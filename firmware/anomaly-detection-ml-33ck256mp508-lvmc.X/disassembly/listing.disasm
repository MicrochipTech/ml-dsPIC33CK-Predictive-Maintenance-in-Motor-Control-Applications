Disassembly Listing for anomaly-detection-ml-33ck256mp508-lvmc
Generated From:
D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/dist/default/debug/anomaly-detection-ml-33ck256mp508-lvmc.X.debug.elf
Oct 20, 2023 10:33:49 AM

---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/sensiml/ssi_comms.c  ----------
1:                 /** @file ssi_comms.c */
2:                 
3:                 /*==========================================================
4:                  * Copyright 2021 QuickLogic Corporation
5:                  *
6:                  * Licensed under the Apache License, Version 2.0 (the "License");
7:                  * you may not use this file except in compliance with the License.
8:                  * You may obtain a copy of the License at
9:                  *
10:                 *    http://www.apache.org/licenses/LICENSE-2.0
11:                 *
12:                 * Unless required by applicable law or agreed to in writing, software
13:                 * distributed under the License is distributed on an "AS IS" BASIS,
14:                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
15:                 * See the License for the specific language governing permissions and
16:                 * limitations under the License.
17:                 *==========================================================*/
18:                #include "../app_config.h"
19:                #include "ssi_comms.h"
20:                #include <stdbool.h>
21:                #include <stddef.h>
22:                #include <stdint.h>
23:                #include <string.h>
24:                
25:                /*
26:                 * Some functions in here will be unused, depending on SSI version
27:                 */
28:                //#pragma GCC diagnostic push
29:                //#pragma GCC diagnostic ignored "-Wunused-function"
30:                
31:                volatile unsigned int myData[2]                         = { 3, 4 };
32:                static uint32_t       ssi_conn_seqnum[SSI_MAX_CHANNELS] = { 0 };
33:                
34:                static char connection_buf[TOTAL_CHARS];
35:                
36:                static ssi_io_funcs_t* p_ssi_interface;
37:                
38:                void ssi_init(ssi_io_funcs_t* p_interface)
39:                {
40:                    p_ssi_interface = p_interface;
000000  040200     GOTO __resetPRI, __reset
41:                    p_interface->initialized = true;
000002  000000     NOP
42:                }
000006  000B2E     NOP
43:                
44:                bool ssi_connected(void) { return p_ssi_interface->initialized && p_ssi_interface->connected; }
000000  040200     GOTO __resetPRI, __reset
000010  000B66     NOP
45:                
46:                void ssi_try_connect(void)
47:                {
48:                    int read = 0;
49:                    memset(connection_buf, 0, TOTAL_CHARS);
000000  040200     GOTO __resetPRI, __reset
50:                    read = p_ssi_interface->ssi_read((uint8_t*) connection_buf, CONNECT_CHARS);
000008  000B4A     NOP
51:                    if (read == CONNECT_CHARS)
000010  000B66     NOP
52:                    {
53:                        if (strncmp(connection_buf, CONNECT_STRING, CONNECT_CHARS + 1) == 0)
000014  000920     NOP
54:                        {
55:                            p_ssi_interface->connected = true;
000020  000920     NOP
56:                        }
57:                    }
58:                }
000026  000920     NOP
000028  000920     NOP
59:                
60:                void ssi_try_disconnect(void)
61:                {
62:                    int read = 0;
63:                    memset(connection_buf, 0, TOTAL_CHARS);
000000  040200     GOTO __resetPRI, __reset
64:                
65:                    read = p_ssi_interface->ssi_read((uint8_t*) connection_buf, DISCONNECT_CHARS);
000008  000B4A     NOP
66:                    if (read == DISCONNECT_CHARS)
000010  000B66     NOP
67:                    {
68:                        if (strncmp(connection_buf, DISCONNECT_STRING, TOTAL_CHARS) == 0)
000014  000920     NOP
69:                        {
70:                            p_ssi_interface->connected = false;
000020  000920     NOP
71:                        }
72:                    }
73:                }
000026  000920     NOP
000028  000920     NOP
74:                
75:                void ssi_seqnum_init(uint8_t channel)
76:                {
77:                    if (channel >= SSI_MAX_CHANNELS)
000000  040200     GOTO __resetPRI, __reset
78:                        return;
79:                    ssi_conn_seqnum[channel] = 0;
000004  000B9A     NOP
80:                }
000010  000B66     NOP
000012  00091A     NOP
81:                
82:                void ssi_seqnum_reset(uint8_t channel)
83:                {
84:                    if (channel >= SSI_MAX_CHANNELS)
000000  040200     GOTO __resetPRI, __reset
85:                        return;
86:                    ssi_conn_seqnum[channel] = 0;
000004  000B9A     NOP
87:                }
000010  000B66     NOP
000012  00091A     NOP
88:                
89:                uint32_t ssi_seqnum_update(uint8_t channel)
90:                {
000000  040200     GOTO __resetPRI, __reset
91:                    if (channel >= SSI_MAX_CHANNELS)
000004  000B9A     NOP
92:                        return 0;
000002  000000     NOP
93:                    ssi_conn_seqnum[channel]++;
000008  000B4A     NOP
94:                    return ssi_conn_seqnum[channel];
95:                }
00001A  000920     NOP
00001C  000920     NOP
96:                
97:                uint32_t ssi_seqnum_get(uint8_t channel)
98:                {
000000  040200     GOTO __resetPRI, __reset
99:                    if (channel >= SSI_MAX_CHANNELS)
000004  000B9A     NOP
100:                       return 0;
000002  000000     NOP
101:                   return ssi_conn_seqnum[channel];
000008  000B4A     NOP
102:               }
000012  00091A     NOP
000014  000920     NOP
103:               
104:               uint8_t ssi_payload_checksum_get(uint8_t* p_data, uint16_t len)
105:               {
106:                   uint8_t crc8 = p_data[0];
000000  040200     GOTO __resetPRI, __reset
107:                   int k;
108:                   for ( k = 1; k < len; k++)
000002  000000     NOP
00000E  000920     NOP
109:                   {
110:                       crc8 ^= p_data[k];
00000A  000BD2     NOP
111:                   }
112:                   return crc8;
113:               }
000016  000920     NOP
00001A  000920     NOP
114:               
115:               void ssiv2_publish_sensor_data(uint8_t channel, uint8_t* buffer, int size)
116:               {
000000  040200     GOTO __resetPRI, __reset
117:                   if (p_ssi_interface->initialized == false)
00000E  000920     NOP
118:                   {
119:                       return;
120:                   }
121:                   uint8_t ssiv2header[SSI_HEADER_SIZE];
122:                   memset(ssiv2header, 0, SSI_HEADER_SIZE);
000016  000920     NOP
123:                   uint8_t  sync   = SSI_SYNC_DATA;
124:                   uint8_t  rsvd   = 0;
125:                   uint16_t u16len = (size + 6);
00001E  000920     NOP
126:                   uint32_t seqnum = ssi_seqnum_update(channel);
000020  000920     NOP
127:                   uint8_t  crc8   = 0;
000024  000920     NOP
128:               
129:                   ssiv2header[0] = sync;
000028  000920     NOP
130:                   ssiv2header[1] = (u16len >> 0) & 0xff;
00002C  000920     NOP
131:                   ssiv2header[2] = (u16len >> 8) & 0xff;
00002E  000920     NOP
132:                   ssiv2header[3] = rsvd;
000032  000920     NOP
133:                   ssiv2header[4] = channel;
000034  000920     NOP
134:                   ssiv2header[5] = (seqnum >> 0) & 0xff;
000036  000920     NOP
135:                   ssiv2header[6] = (seqnum >> 8) & 0xff;
000038  000920     NOP
136:                   ssiv2header[7] = (seqnum >> 16) & 0xff;
000042  000920     NOP
137:                   ssiv2header[8] = (seqnum >> 24) & 0xff;
000048  000920     NOP
138:               
139:                   // compute 8-bit checksum
140:                   crc8 = crc8 ^ ssi_payload_checksum_get(ssiv2header + 3, SSI_HEADER_SIZE - 3);
00004C  000920     NOP
141:                   crc8 = crc8 ^ ssi_payload_checksum_get(buffer, size);
000056  000920     NOP
142:               
143:                   // Send SSI v2 header information
144:                   p_ssi_interface->ssi_write(ssiv2header, SSI_HEADER_SIZE);
000060  000920     NOP
145:               
146:                   // Send sensor data
147:                   p_ssi_interface->ssi_write(buffer, size);
000068  000920     NOP
148:               
149:                   // Add 8-bit checksum
150:                   p_ssi_interface->ssi_write(&crc8, 1);
000072  000920     NOP
151:               }
00007C  000920     NOP
000086  000920     NOP
152:               
153:               
154:               void ssiv1_publish_sensor_data(uint8_t* buffer, int size)
155:               {
156:                   if (p_ssi_interface->initialized == false)
000000  040200     GOTO __resetPRI, __reset
157:                   {
158:                       return;
159:                   }
160:                   p_ssi_interface->ssi_write(buffer, size);
000008  000B4A     NOP
161:               }
00000C  000BB6     NOP
00000E  000920     NOP
162:               //#pragma GCC diagnostic pop
163:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/ringbuffer.c  -----------------
1:                 /*******************************************************************************
2:                   Buffering Interface Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     ringbuffer.c
9:                 
10:                  Summary:
11:                    This file contains the ring buffer API used for generic buffering
12:                
13:                  Notes:
14:                    - The API provided here is strictly designed for a single reader thread and
15:                      single writer thread; other uses will cause race conditions.
16:                 *******************************************************************************/
17:                /*******************************************************************************
18:                * Copyright (C) 2020 Microchip Technology Inc. and its subsidiaries.
19:                *
20:                * Subject to your compliance with these terms, you may use Microchip software
21:                * and any derivatives exclusively with Microchip products. It is your
22:                * responsibility to comply with third party license terms applicable to your
23:                * use of third party software (including open source software) that may
24:                * accompany Microchip software.
25:                *
26:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
27:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
28:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
29:                * PARTICULAR PURPOSE.
30:                *
31:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:                 *******************************************************************************/
39:                #include <stdint.h>
40:                #include <string.h>
41:                #include "ringbuffer.h"
42:                
43:                /* Return non-zero on error */
44:                int8_t ringbuffer_init(ringbuffer_t *ringbuffer, void *buffer, ringbuffer_size_t len, size_t itemsize) {
45:                    /* Check for power of 2 */
46:                    if ( (((len - 1) & len) != 0) || (len > RINGBUFFER_MAX_SIZE) || (buffer == NULL) )
00935A  E90282     DEC W2, W5
00935C  628282     AND W5, W2, W5
009360  3A000F     BRA NZ, .L2
009362  280005     MOV #0x8000, W5
009364  510F85     SUB W2, W5, [W15]
009366  3E000C     BRA GTU, .L2
009368  E00001     CP0 W1
00936A  32000A     BRA Z, .L2
47:                        return 1;
00935E  B3C014     MOV.B #0x1, W4
48:                
49:                    memset(ringbuffer, 0, sizeof(ringbuffer_t));
00936C  090005     REPEAT #0x5
00936E  EB1800     CLR [W0++]
009370  B100C0     SUB #0xC, W0
50:                    ringbuffer->len = len;
009372  980022     MOV W2, [W0+4]
51:                    ringbuffer->itemsize = itemsize;
009374  980033     MOV W3, [W0+6]
52:                    ringbuffer->data = buffer;
009376  980051     MOV W1, [W0+10]
53:                    ringbuffer->_mask = 2*len - 1;
009378  410102     ADD W2, W2, W2
00937A  E90102     DEC W2, W2
00937C  980042     MOV W2, [W0+8]
54:                
55:                    return 0;
00937E  EB4200     CLR.B W4
56:                }
009380  784004     MOV.B W4, W0
009382  060000     RETURN
57:                
58:                /* 
59:                * This function is not thread safe.
60:                * It should only be called when the program is in a state where the caller
61:                * thread cannot be interrupted by any other thread that could access the ring
62:                * buffer.
63:                */
64:                void ringbuffer_reset(ringbuffer_t *ringbuffer) {
65:                    ringbuffer->readIdx = 0;
009E82  EB0080     CLR W1
66:                    ringbuffer->writeIdx = 0;
009E86  780801     MOV W1, [W0]
67:                }
009E88  060000     RETURN
009E8A  980821     MOV W1, [W0+20]
68:                
69:                ringbuffer_size_t ringbuffer_read(ringbuffer_t *ringbuffer, void *dst, ringbuffer_size_t itemcount) {
000000  040200     GOTO __resetPRI, __reset
70:                    ringbuffer_size_t availitems = ringbuffer_get_read_items(ringbuffer);
00000C  000BB6     NOP
71:                    ringbuffer_size_t buflen;
72:                    const void *src = ringbuffer_get_read_buffer(ringbuffer, &buflen);
000012  00091A     NOP
73:                
74:                    if (itemcount > availitems)
75:                        itemcount = availitems;
76:                
77:                    if (buflen >= itemcount) {
00001E  000920     NOP
78:                        memcpy(dst, src, itemcount * ringbuffer->itemsize);
000024  000920     NOP
79:                    }
80:                    else {
81:                        memcpy(dst, src, buflen * ringbuffer->itemsize);
000030  000920     NOP
82:                        src = ringbuffer->data; /* wrap around buffer */
83:                        memcpy((uint8_t *) dst + buflen * ringbuffer->itemsize, src, (itemcount - buflen) * ringbuffer->itemsize);
00003A  000920     NOP
84:                    }
85:                
86:                    ringbuffer_advance_read_index(ringbuffer, itemcount);
000048  000920     NOP
87:                    return itemcount;
88:                }
00004C  000920     NOP
000056  000920     NOP
89:                
90:                ringbuffer_size_t ringbuffer_write(ringbuffer_t *ringbuffer, const void *src, ringbuffer_size_t itemcount) {
000000  040200     GOTO __resetPRI, __reset
91:                    ringbuffer_size_t availitems = ringbuffer_get_write_items(ringbuffer);
00000C  000BB6     NOP
92:                    ringbuffer_size_t buflen;
93:                    void *dst = ringbuffer_get_write_buffer(ringbuffer, &buflen);
000012  00091A     NOP
94:                
95:                    if (itemcount > availitems)
96:                        itemcount = availitems;
97:                    
98:                    if (buflen >= itemcount) {
00001E  000920     NOP
99:                        memcpy(dst, src, itemcount * ringbuffer->itemsize);
000024  000920     NOP
100:                   }
101:                   else {
102:                       memcpy(dst, src, buflen * ringbuffer->itemsize);
00002E  000920     NOP
103:                       dst = ringbuffer->data; /* wrap around buffer */
104:                       memcpy(dst, (uint8_t *) src + buflen * ringbuffer->itemsize, (itemcount - buflen) * ringbuffer->itemsize);
000036  000920     NOP
105:                   }
106:               
107:                   ringbuffer_advance_write_index(ringbuffer, itemcount);
000046  000920     NOP
108:                   return itemcount;
109:               }
00004A  000920     NOP
000054  000920     NOP
110:               
111:               ringbuffer_size_t ringbuffer_get_read_items(ringbuffer_t *ringbuffer) {
112:                   return (ringbuffer->writeIdx - ringbuffer->readIdx) & ringbuffer->_mask;
009D6C  780110     MOV [W0], W2
009D6E  900090     MOV [W0+2], W1
009D70  510101     SUB W2, W1, W2
009D72  9000C0     MOV [W0+8], W1
009D74  610001     AND W2, W1, W0
113:               }
009D76  060000     RETURN
009D78  780101     MOV W1, W2
114:               
115:               ringbuffer_size_t ringbuffer_get_write_items(ringbuffer_t *ringbuffer) {
116:                   return ringbuffer->len - ((ringbuffer->writeIdx - ringbuffer->readIdx) & ringbuffer->_mask);
000000  040200     GOTO __resetPRI, __reset
117:               }
00000E  000920     NOP
000010  000B66     NOP
118:               
119:               const void * ringbuffer_get_read_buffer(ringbuffer_t *ringbuffer, ringbuffer_size_t *itemcount) {
120:                   ringbuffer_size_t writeIdx = ringbuffer->writeIdx;
009558  780210     MOV [W0], W4
121:                   ringbuffer_size_t readIdx = ringbuffer->readIdx;
00955A  900110     MOV [W0+2], W2
122:                   ringbuffer_size_t availitems = (writeIdx - readIdx) & ringbuffer->_mask;
00955C  520202     SUB W4, W2, W4
00955E  9001C0     MOV [W0+8], W3
009560  620203     AND W4, W3, W4
123:               
124:                   readIdx &= ringbuffer->len - 1; /* Shift readIdx to inside the buffer */
009562  9001A0     MOV [W0+4], W3
009564  E90283     DEC W3, W5
009566  628102     AND W5, W2, W2
125:                   if (readIdx + availitems > ringbuffer->len) {
009568  410284     ADD W2, W4, W5
00956A  518F85     SUB W3, W5, [W15]
00956C  310002     BRA C, .L10
126:                       *itemcount = ringbuffer->len - readIdx;
00956E  518882     SUB W3, W2, [W1]
009570  370001     BRA .L11
127:                   }
128:                   else {
129:                       *itemcount = availitems;
009572  780884     MOV W4, [W1]
130:                   }
131:                   
132:                   return (const void *) (ringbuffer->data + readIdx * ringbuffer->itemsize);
009574  9000B0     MOV [W0+6], W1
009576  B99181     MULW.SS W2, W1, W2
009578  900050     MOV [W0+10], W0
00957A  400002     ADD W0, W2, W0
133:               }
00957C  060000     RETURN
00957E  781F88     MOV W8, [W15++]
009580  780400     MOV W0, W8
009582  780001     MOV W1, W0
134:               
135:               void * ringbuffer_get_write_buffer(ringbuffer_t *ringbuffer, ringbuffer_size_t *itemcount) {
136:                   ringbuffer_size_t readIdx = ringbuffer->readIdx;
009426  900210     MOV [W0+2], W4
137:                   ringbuffer_size_t writeIdx = ringbuffer->writeIdx;
009428  780190     MOV [W0], W3
138:                   ringbuffer_size_t availitems = ringbuffer->len - ((writeIdx - readIdx) & ringbuffer->_mask);
00942A  900120     MOV [W0+4], W2
00942C  518204     SUB W3, W4, W4
00942E  9002C0     MOV [W0+8], W5
009430  620205     AND W4, W5, W4
009432  510204     SUB W2, W4, W4
139:               
140:                   writeIdx &= ringbuffer->len - 1; /* Shift writeIdx to inside the buffer */
009434  E90282     DEC W2, W5
009436  628183     AND W5, W3, W3
141:                   if (writeIdx + availitems > ringbuffer->len) {
009438  420283     ADD W4, W3, W5
00943A  510F85     SUB W2, W5, [W15]
00943C  310002     BRA C, .L13
142:                       *itemcount = ringbuffer->len - writeIdx;
00943E  510883     SUB W2, W3, [W1]
009440  370001     BRA .L14
143:                   }
144:                   else {
145:                       *itemcount = availitems;
009442  780884     MOV W4, [W1]
146:                   }
147:                   
148:                   return (void *) (ringbuffer->data + writeIdx * ringbuffer->itemsize);
009444  900130     MOV [W0+6], W2
009446  B99982     MULW.SS W3, W2, W2
009448  900050     MOV [W0+10], W0
00944A  400002     ADD W0, W2, W0
149:               }
00944C  060000     RETURN
00944E  781F88     MOV W8, [W15++]
150:               
151:               ringbuffer_size_t ringbuffer_advance_read_index(ringbuffer_t *ringbuffer, ringbuffer_size_t itemcount) {
152:                   ringbuffer_size_t readIdx = ringbuffer->readIdx;
009A70  900190     MOV [W0+2], W3
153:                   ringbuffer_size_t availitems = (ringbuffer->writeIdx - readIdx) & ringbuffer->_mask;
009A72  900140     MOV [W0+8], W2
009A74  118210     SUBR W3, [W0], W4
009A76  620202     AND W4, W2, W4
009A78  508F84     SUB W1, W4, [W15]
009A7A  360001     BRA LEU, .L16
009A7C  780084     MOV W4, W1
154:                   ringbuffer_size_t newIdx;
155:                   
156:                   if (itemcount > availitems)
157:                       itemcount = availitems;
158:               
159:                   newIdx = (readIdx + itemcount) & ringbuffer->_mask;
009A7E  408183     ADD W1, W3, W3
009A80  618102     AND W3, W2, W2
160:               
161:                   __ringbuffer_sync();
162:                   ringbuffer->readIdx = newIdx;
009A82  980012     MOV W2, [W0+2]
163:                   
164:                   return itemcount;
165:               }
009A84  780001     MOV W1, W0
009A86  060000     RETURN
009A88  A9E8C3     BCLR 0x8C3, #7
009A8A  000000     NOP
009A8C  000000     NOP
166:               
167:               ringbuffer_size_t ringbuffer_advance_write_index(ringbuffer_t *ringbuffer, ringbuffer_size_t itemcount) {
168:                   ringbuffer_size_t writeIdx = ringbuffer->writeIdx;
009776  780190     MOV [W0], W3
169:                   ringbuffer_size_t availitems = ringbuffer->len - ((writeIdx - ringbuffer->readIdx) & ringbuffer->_mask);
009778  900210     MOV [W0+2], W4
00977A  900140     MOV [W0+8], W2
00977C  518204     SUB W3, W4, W4
00977E  620202     AND W4, W2, W4
009780  9002A0     MOV [W0+4], W5
009782  528204     SUB W5, W4, W4
009784  508F84     SUB W1, W4, [W15]
009786  360001     BRA LEU, .L22
009788  780084     MOV W4, W1
170:                   ringbuffer_size_t newIdx;
171:               
172:                   if (itemcount > availitems)
173:                       itemcount = availitems;
174:                   
175:                   newIdx = (writeIdx + itemcount) & ringbuffer->_mask;
00978A  408183     ADD W1, W3, W3
00978C  618102     AND W3, W2, W2
176:               
177:                   __ringbuffer_sync();
178:                   ringbuffer->writeIdx = newIdx;
00978E  780802     MOV W2, [W0]
179:               
180:                   return itemcount;
181:               }
009790  780001     MOV W1, W0
009792  060000     RETURN
009794  A9EC81     BCLR 0xC81, #7
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/uart/src/uart1.c
1:                 /**
2:                  * UART1 Generated Driver Source File
3:                  * 
4:                  * @file      uart1.c
5:                  *            
6:                  * @ingroup   uartdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for the UART1 driver.
9:                  *            
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.4.0
13:                 *            
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                #include <stdint.h>
40:                #include <stddef.h>
41:                #include <xc.h>
42:                #include <stddef.h>
43:                #include "../uart1.h"
44:                
45:                // Section: Macro Definitions
46:                #define UART1_CLOCK 100000000U
47:                #define UART1_BAUD_TO_BRG_WITH_FRACTIONAL(x) (UART1_CLOCK/(x))
48:                #define UART1_BAUD_TO_BRG_WITH_BRGH_1(x) (UART1_CLOCK/(4U*(x))-1U)
49:                #define UART1_BAUD_TO_BRG_WITH_BRGH_0(x) (UART1_CLOCK/(16U*(x))-1U)
50:                #define UART1_BRG_TO_BAUD_WITH_FRACTIONAL(x) (UART1_CLOCK/(x))
51:                #define UART1_BRG_TO_BAUD_WITH_BRGH_1(x) (UART1_CLOCK/(4U*((x)+1U)))
52:                #define UART1_BRG_TO_BAUD_WITH_BRGH_0(x) (UART1_CLOCK/(16U*((x)+1U)))
53:                
54:                #define UART1_MIN_ACHIEVABLE_BAUD_WITH_FRACTIONAL 95U
55:                #define UART1_MIN_ACHIEVABLE_BAUD_WITH_BRGH_1 24U
56:                
57:                // Section: Driver Interface
58:                
59:                const struct UART_INTERFACE MCC_UART = {
60:                    .Initialize = &UART1_Initialize,
61:                    .Deinitialize = &UART1_Deinitialize,
62:                    .Read = &UART1_Read,
63:                    .Write = &UART1_Write,
64:                    .IsRxReady = &UART1_IsRxReady,
65:                    .IsTxReady = &UART1_IsTxReady,
66:                    .IsTxDone = &UART1_IsTxDone,
67:                    .TransmitEnable = &UART1_TransmitEnable,
68:                    .TransmitDisable = &UART1_TransmitDisable,
69:                    .AutoBaudSet = &UART1_AutoBaudSet,
70:                    .AutoBaudQuery = &UART1_AutoBaudQuery,
71:                    .AutoBaudEventEnableGet = &UART1_AutoBaudEventEnableGet,
72:                    .BRGCountSet = &UART1_BRGCountSet,
73:                    .BRGCountGet = &UART1_BRGCountGet,
74:                    .BaudRateSet = &UART1_BaudRateSet,
75:                    .BaudRateGet = &UART1_BaudRateGet,
76:                    .ErrorGet = &UART1_ErrorGet,
77:                    .RxCompleteCallbackRegister = NULL,
78:                    .TxCompleteCallbackRegister = NULL,
79:                    .TxCollisionCallbackRegister = NULL,
80:                    .FramingErrorCallbackRegister = NULL,
81:                    .OverrunErrorCallbackRegister = NULL,
82:                    .ParityErrorCallbackRegister = NULL,
83:                };
84:                
85:                // Section: Private Variable Definitions
86:                static union
87:                {
88:                    struct
89:                    {
90:                        uint16_t frammingError :1;
91:                        uint16_t parityError :1;
92:                        uint16_t overrunError :1;
93:                        uint16_t txCollisionError :1;
94:                        uint16_t autoBaudOverflow :1;
95:                        uint16_t reserved :11;
96:                    };
97:                    size_t status;
98:                } uartError;
99:                
100:               // Section: UART1 APIs
101:               
102:               void UART1_Initialize(void)
103:               {
104:               /*    
105:                    Set the UART1 module to the options selected in the user interface.
106:                    Make sure to set LAT bit corresponding to TxPin as high before UART initialization
107:               */
108:                   // URXEN ; RXBIMD ; UARTEN disabled; MOD Asynchronous 8-bit UART; UTXBRK ; BRKOVR ; UTXEN ; USIDL ; WAKE ; ABAUD ; BRGH ; 
109:                   U1MODE = 0x0;
00983C  EF2238     CLR U1MODE
110:                   // STSEL 1 Stop bit sent, 1 checked at RX; BCLKMOD enabled; SLPEN ; FLO ; BCLKSEL FOSC/2; C0EN ; RUNOVF ; UTXINV ; URXINV ; HALFDPLX ; 
111:                   U1MODEH = 0x800;
00983E  208000     MOV #0x800, W0
009840  8811D0     MOV W0, U1MODEH
112:                   // OERIE ; RXBKIF ; RXBKIE ; ABDOVF ; OERR ; TXCIE ; TXCIF ; FERIE ; TXMTIE ; ABDOVE ; CERIE ; CERIF ; PERIE ; 
113:                   U1STA = 0x80;
009842  200800     MOV #0x80, W0
009844  8811E0     MOV W0, U1STA
114:                   // URXISEL ; UTXBE ; UTXISEL ; URXBE ; STPMD ; TXWRE ; 
115:                   U1STAH = 0x2E;
009846  2002E0     MOV #0x2E, W0
009848  8811F0     MOV W0, U1STAH
116:                   // BaudRate 115207.37; Frequency 100000000 Hz; BRG 868; 
117:                   U1BRG = 0x364;
00984A  203640     MOV #0x364, W0
00984C  881200     MOV W0, U1BRG
118:                   // BRG 0; 
119:                   U1BRGH = 0x0;
00984E  EF2242     CLR U1BRGH
120:                   
121:                   U1MODEbits.UARTEN = 1;   // enabling UART ON bit
009850  A8E239     BSET 0x239, #7
122:                   U1MODEbits.UTXEN = 1;
009852  A8A238     BSET U1MODE, #5
123:                   U1MODEbits.URXEN = 1;
009854  A88238     BSET U1MODE, #4
124:               }
009856  060000     RETURN
125:               
126:               void UART1_Deinitialize(void)
127:               {
128:                   U1MODE = 0x0;
009BAA  EF2238     CLR U1MODE
129:                   U1MODEH = 0x0;
009BAC  EF223A     CLR U1MODEH
130:                   U1STA = 0x80;
009BAE  200800     MOV #0x80, W0
009BB0  8811E0     MOV W0, U1STA
131:                   U1STAH = 0x2E;
009BB2  2002E0     MOV #0x2E, W0
009BB4  8811F0     MOV W0, U1STAH
132:                   U1BRG = 0x0;
009BB6  EF2240     CLR U1BRG
133:                   U1BRGH = 0x0;
009BB8  EF2242     CLR U1BRGH
134:               }
009BBA  060000     RETURN
009BBC  801210     MOV U1BRGH, W0
135:               
136:               uint8_t UART1_Read(void)
137:               {
138:                   while((U1STAHbits.URXBE == 1))
009D22  AB223E     BTST U1STAH, #1
009D24  3AFFFE     BRA NZ, UART1_Read
139:                   {
140:                       
141:                   }
142:               
143:                   if ((U1STAbits.OERR == 1))
009D26  AB223C     BTST U1STA, #1
009D28  320001     BRA Z, .L5
144:                   {
145:                       U1STAbits.OERR = 0;
009D2A  A9223C     BCLR U1STA, #1
146:                   }
147:                   
148:                   return U1RXREG;
009D2C  801220     MOV U1RXREG, W0
149:               }
009D2E  060000     RETURN
009D30  901080     MOV [W0+32], W1
150:               
151:               void UART1_Write(uint8_t txData)
152:               {
153:                   while(U1STAHbits.UTXBF == 1)
009DB6  AB823E     BTST U1STAH, #4
009DB8  3AFFFE     BRA NZ, UART1_Write
154:                   {
155:                       
156:                   }
157:               
158:                   U1TXREG = txData;    // Write the data byte to the USART.
009DBA  FB8000     ZE W0, W0
009DBC  881240     MOV W0, U1TXREG
159:               }
009DBE  060000     RETURN
160:               
161:               bool UART1_IsRxReady(void)
162:               {
163:                   return (U1STAHbits.URXBE == 0);
009DC0  8011F0     MOV U1STAH, W0
009DC2  A21000     BTG W0, #1
009DC4  0A8011     BFEXT #0x1, #0x1, W0, W0
009DC6  000000     NOP
164:               }
009DC8  060000     RETURN
009DCA  E00000     CP0 W0
165:               
166:               bool UART1_IsTxReady(void)
009CB4  200200     MOV #0x20, W0
009CB6  B60238     AND U1MODE, WREG
009CB8  EA0000     NEG W0, W0
167:               {
168:                   return ((!U1STAHbits.UTXBF) && U1MODEbits.UTXEN);
009CAE  EB0000     CLR W0
009CB0  AB823E     BTST U1STAH, #4
009CB2  3A0004     BRA NZ, .L12
009CBA  DE004F     LSR W0, #15, W0
169:               }
009CBC  060000     RETURN
009CBE  EB0000     CLR W0
170:               
171:               bool UART1_IsTxDone(void)
009CC4  200200     MOV #0x20, W0
009CC6  B6023E     AND U1STAH, WREG
009CC8  EA0000     NEG W0, W0
172:               {
173:                   return (bool)(U1STAbits.TRMT && U1STAHbits.UTXBE);
009CBE  EB0000     CLR W0
009CC0  ABE23C     BTST U1STA, #7
009CC2  320004     BRA Z, .L15
009CCA  DE004F     LSR W0, #15, W0
174:               }
009CCC  060000     RETURN
009CCE  A8EC00     BSET ADCON5L, #7
175:               
176:               void UART1_TransmitEnable(void)
177:               {
178:                   U1MODEbits.UTXEN = 1;
009FAA  A8A238     BSET U1MODE, #5
179:               }
009FAC  060000     RETURN
180:               
181:               void UART1_TransmitDisable(void)
182:               {
183:                   U1MODEbits.UTXEN = 0;
009FAE  A9A238     BCLR U1MODE, #5
184:               }
009FB0  060000     RETURN
009FB2  060000     RETURN
185:               
186:               void UART1_AutoBaudSet(bool enable)
187:               {
188:                   U1INTbits.ABDIF = 0U;
00988E  A9C25C     BCLR U1INT, #6
189:                   U1INTbits.ABDIE = enable;
009890  600061     AND W0, #0x1, W0
009892  DD00C2     SL W0, #2, W1
009894  8012E2     MOV U1INT, W2
009896  A12002     BCLR W2, #2
009898  708102     IOR W1, W2, W2
00989A  8812E2     MOV W2, U1INT
190:                   U1MODEbits.ABAUD = enable;
00989C  DD0046     SL W0, #6, W0
00989E  8011C1     MOV U1MODE, W1
0098A0  A16001     BCLR W1, #6
0098A2  700081     IOR W0, W1, W1
0098A4  8811C1     MOV W1, U1MODE
191:               }
0098A6  060000     RETURN
0098A8  900220     MOV [W0+4], W4
192:               
193:               bool UART1_AutoBaudQuery(void)
194:               {
195:                   return U1MODEbits.ABAUD;
009EFE  0AA066     BFEXT #0x6, #0x1, U1MODE, W0
009F00  000238     NOP
196:               }
009F02  060000     RETURN
197:               
198:               bool UART1_AutoBaudEventEnableGet(void)
199:               { 
200:                   return U1INTbits.ABDIE; 
009F04  0AA022     BFEXT #0x2, #0x1, U1INT, W0
009F06  00025C     NOP
201:               }
009F08  060000     RETURN
009F0A  07E5E3     RCALL f_stat_moment
202:               
203:               size_t UART1_ErrorGet(void)
204:               {
205:                   uartError.status = 0;
008BB0  EF3268     CLR uartError
206:                   if(U1STAbits.FERR == 1U)
008BB2  AB623C     BTST U1STA, #3
008BB4  320001     BRA Z, .L23
207:                   {
208:                       uartError.frammingError = uartError.status|UART_ERROR_FRAMING_MASK;
008BB6  A81268     BSET uartError, #0
209:                   }
210:                   if(U1STAbits.PERR== 1U)
008BB8  ABC23C     BTST U1STA, #6
008BBA  320006     BRA Z, .L24
211:                   {
212:                       uartError.parityError = uartError.status|UART_ERROR_PARITY_MASK;
008BBC  809340     MOV uartError, W0
008BBE  6000E1     AND W0, #0x1, W1
008BC0  408081     ADD W1, W1, W1
008BC2  A11000     BCLR W0, #1
008BC4  708000     IOR W1, W0, W0
008BC6  889340     MOV W0, uartError
213:                   }
214:                   if(U1STAbits.OERR== 1U)
008BC8  AB223C     BTST U1STA, #1
008BCA  320007     BRA Z, .L25
215:                   {
216:                       uartError.overrunError = uartError.status|UART_ERROR_RX_OVERRUN_MASK;
008BCC  809340     MOV uartError, W0
008BCE  6000E1     AND W0, #0x1, W1
008BD0  DD08C2     SL W1, #2, W1
008BD2  A12000     BCLR W0, #2
008BD4  708000     IOR W1, W0, W0
008BD6  889340     MOV W0, uartError
217:                       U1STAbits.OERR = 0;
008BD8  A9223C     BCLR U1STA, #1
218:                   }
219:                   if(U1STAbits.TXCIF== 1U)
008BDA  AB023C     BTST U1STA, #0
008BDC  320007     BRA Z, .L26
220:                   {
221:                       uartError.txCollisionError = uartError.status|UART_ERROR_TX_COLLISION_MASK;
008BDE  809340     MOV uartError, W0
008BE0  6000E1     AND W0, #0x1, W1
008BE2  DD08C3     SL W1, #3, W1
008BE4  A13000     BCLR W0, #3
008BE6  708000     IOR W1, W0, W0
008BE8  889340     MOV W0, uartError
222:                       U1STAbits.TXCIF = 0;
008BEA  A9023C     BCLR U1STA, #0
223:                   }
224:                   if(U1STAbits.ABDOVF== 1U)
008BEC  ABA23C     BTST U1STA, #5
008BEE  320007     BRA Z, .L27
225:                   {
226:                       uartError.autoBaudOverflow = uartError.status|UART_ERROR_AUTOBAUD_OVERFLOW_MASK;
008BF0  809340     MOV uartError, W0
008BF2  6000E1     AND W0, #0x1, W1
008BF4  DD08C4     SL W1, #4, W1
008BF6  A14000     BCLR W0, #4
008BF8  708000     IOR W1, W0, W0
008BFA  889340     MOV W0, uartError
227:                       U1STAbits.ABDOVF = 0;
008BFC  A9A23C     BCLR U1STA, #5
228:                   }
229:                   
230:                   return uartError.status;
231:               }
008BFE  809340     MOV uartError, W0
008C00  060000     RETURN
008C02  2005E2     MOV #0x5E, W2
232:               
233:               void UART1_BRGCountSet(uint32_t brgValue)
234:               {
235:                   U1BRG = brgValue & 0xFFFFU;
009E7A  881200     MOV W0, U1BRG
236:                   U1BRGH = (brgValue >>16U) & 0x000FU;
009E7C  60806F     AND W1, #0xF, W0
009E7E  881210     MOV W0, U1BRGH
237:               }
009E80  060000     RETURN
009E82  EB0080     CLR W1
009E84  980011     MOV W1, [W0+2]
238:               
239:               uint32_t UART1_BRGCountGet(void)
240:               {
241:                   uint32_t brgValue;
242:                   
243:                   brgValue = U1BRGH;
009BBC  801210     MOV U1BRGH, W0
009BBE  EB0080     CLR W1
244:                   brgValue = (brgValue << 16U) | U1BRG;
009BC0  DD00C0     SL W0, #0, W1
009BC2  200000     MOV #0x0, W0
009BC4  801202     MOV U1BRG, W2
009BC6  EB0180     CLR W3
009BC8  700002     IOR W0, W2, W0
009BCA  708083     IOR W1, W3, W1
245:                   
246:                   return brgValue;
247:               }
009BCC  060000     RETURN
009BCE  600067     AND W0, #0x7, W0
248:               
249:               void UART1_BaudRateSet(uint32_t baudRate)
250:               {
251:                   uint32_t brgValue;
252:                   
253:                   if((baudRate >= UART1_MIN_ACHIEVABLE_BAUD_WITH_FRACTIONAL) && (baudRate != 0))
008C02  2005E2     MOV #0x5E, W2
008C04  500F82     SUB W0, W2, [W15]
008C06  588FE0     SUBB W1, #0x0, [W15]
008C08  360007     BRA LEU, .L31
254:                   {
255:                       U1MODEHbits.BCLKMOD = 1;
008C0A  A8623B     BSET 0x23B, #3
256:                       U1MODEbits.BRGH = 0;
008C0C  A9E238     BCLR U1MODE, #7
257:                       brgValue = UART1_BAUD_TO_BRG_WITH_FRACTIONAL(baudRate);
008C0E  BE0100     MOV.D W0, W2
008C10  2E1000     MOV #0xE100, W0
008C12  205F51     MOV #0x5F5, W1
008C14  07C128     RCALL ___udivsi3
008C16  37001A     BRA .L32
258:                   }
259:                   else if(baudRate >= UART1_MIN_ACHIEVABLE_BAUD_WITH_BRGH_1)
008C18  500FF7     SUB W0, #0x17, [W15]
008C1A  588FE0     SUBB W1, #0x0, [W15]
008C1C  36000C     BRA LEU, .L33
260:                   {
261:                       U1MODEHbits.BCLKMOD = 0;
008C1E  A9623B     BCLR 0x23B, #3
262:                       U1MODEbits.BRGH = 1;
008C20  A8E238     BSET U1MODE, #7
263:                       brgValue = UART1_BAUD_TO_BRG_WITH_BRGH_1(baudRate);
008C22  DD0942     SL W1, #2, W2
008C24  DE01CE     LSR W0, #14, W3
008C26  710183     IOR W2, W3, W3
008C28  DD0142     SL W0, #2, W2
008C2A  2E1000     MOV #0xE100, W0
008C2C  205F51     MOV #0x5F5, W1
008C2E  07C11B     RCALL ___udivsi3
008C30  500061     SUB W0, #0x1, W0
008C32  5880E0     SUBB W1, #0x0, W1
008C34  37000B     BRA .L32
264:                   }
265:                   else
266:                   {
267:                       U1MODEHbits.BCLKMOD = 0;
008C36  A9623B     BCLR 0x23B, #3
268:                       U1MODEbits.BRGH = 0;
008C38  A9E238     BCLR U1MODE, #7
269:                       brgValue = UART1_BAUD_TO_BRG_WITH_BRGH_0(baudRate);
008C3A  DD0944     SL W1, #4, W2
008C3C  DE01CC     LSR W0, #12, W3
008C3E  710183     IOR W2, W3, W3
008C40  DD0144     SL W0, #4, W2
008C42  2E1000     MOV #0xE100, W0
008C44  205F51     MOV #0x5F5, W1
008C46  07C10F     RCALL ___udivsi3
008C48  500061     SUB W0, #0x1, W0
008C4A  5880E0     SUBB W1, #0x0, W1
270:                   }
271:                   U1BRG = brgValue & 0xFFFFU;
008C4C  881200     MOV W0, U1BRG
272:                   U1BRGH = (brgValue >>16U) & 0x000FU;
008C4E  60806F     AND W1, #0xF, W0
008C50  881210     MOV W0, U1BRGH
273:               }
008C52  060000     RETURN
008C54  500FE2     SUB W0, #0x2, [W15]
274:               
275:               uint32_t UART1_BaudRateGet(void)
276:               {
277:                   uint32_t brgValue;
278:                   uint32_t baudRate;
279:                   
280:                   brgValue = UART1_BRGCountGet();
008E48  0706B9     RCALL UART1_BRGCountGet
281:                   if((U1MODEHbits.BCLKMOD == 1) && (brgValue != 0))
008E4A  AB623B     BTST 0x23B, #3
008E4C  320008     BRA Z, .L35
008E4E  500FE0     SUB W0, #0x0, [W15]
008E50  588FE0     SUBB W1, #0x0, [W15]
008E52  320005     BRA Z, .L35
282:                   {
283:                       baudRate = UART1_BRG_TO_BAUD_WITH_FRACTIONAL(brgValue);
008E54  BE0100     MOV.D W0, W2
008E56  2E1000     MOV #0xE100, W0
008E58  205F51     MOV #0x5F5, W1
008E5A  07C005     RCALL ___udivsi3
008E5C  370015     BRA .L36
284:                   }
285:                   else if(U1MODEbits.BRGH == 1)
008E5E  ABE238     BTST U1MODE, #7
008E60  32000A     BRA Z, .L37
286:                   {
287:                       baudRate = UART1_BRG_TO_BAUD_WITH_BRGH_1(brgValue);
008E62  400061     ADD W0, #0x1, W0
008E64  4880E0     ADDC W1, #0x0, W1
008E66  DD0942     SL W1, #2, W2
008E68  DE01CE     LSR W0, #14, W3
008E6A  710183     IOR W2, W3, W3
008E6C  DD0142     SL W0, #2, W2
008E6E  2E1000     MOV #0xE100, W0
008E70  205F51     MOV #0x5F5, W1
008E72  07BFF9     RCALL ___udivsi3
008E74  370009     BRA .L36
288:                   }
289:                   else
290:                   {
291:                       baudRate = UART1_BRG_TO_BAUD_WITH_BRGH_0(brgValue);
008E76  400061     ADD W0, #0x1, W0
008E78  4880E0     ADDC W1, #0x0, W1
008E7A  DD0944     SL W1, #4, W2
008E7C  DE01CC     LSR W0, #12, W3
008E7E  710183     IOR W2, W3, W3
008E80  DD0144     SL W0, #4, W2
008E82  2E1000     MOV #0xE100, W0
008E84  205F51     MOV #0x5F5, W1
008E86  07BFEF     RCALL ___udivsi3
292:                   }
293:                   return baudRate;
294:               }
008E88  060000     RETURN
008E8A  216A61     MOV #0x16A6, W1
008E8C  980871     MOV W1, [W0+30]
295:               
296:               int __attribute__((__section__(".libc.write"))) write(int handle, void *buffer, unsigned int len) {
000C86  BE9F88     MOV.D W8, [W15++]
000C88  781F8A     MOV W10, [W15++]
000C8A  780481     MOV W1, W9
000C8C  780502     MOV W2, W10
297:                   unsigned int numBytesWritten = 0 ;
298:                   while(!UART1_IsTxDone());
000C8E  074817     RCALL UART1_IsTxDone
000C90  E00400     CP0.B W0
000C92  32FFFD     BRA Z, .L39
299:                   while(numBytesWritten<len)
000C94  EB0000     CLR W0
000C96  E0000A     CP0 W10
000C98  32000A     BRA Z, .L40
000C9A  780400     MOV W0, W8
000CA8  550F88     SUB W10, W8, [W15]
000CAA  3EFFF8     BRA GTU, .L47
300:                   {
301:                       while(!UART1_IsTxReady());
000C9C  074808     RCALL UART1_IsTxReady
000C9E  E00400     CP0.B W0
000CA0  32FFFD     BRA Z, .L47
302:                       UART1_Write(*((uint8_t *)buffer + numBytesWritten++));
000CA2  784039     MOV.B [W9++], W0
000CA4  E80408     INC W8, W8
000CA6  074887     RCALL UART1_Write
000CAC  78000A     MOV W10, W0
303:                   }
304:                   return numBytesWritten;
305:               }
000CAE  78054F     MOV [--W15], W10
000CB0  BE044F     MOV.D [--W15], W8
000CB2  060000     RETURN
000CB4  050000     RETLW #0x0, W0
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/tmr1.h
1:                 /**
2:                  * TMR1 Generated Driver Header File 
3:                  * 
4:                  * @file      tmr1.h
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the TMR1 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.4.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef TMR1_H
39:                #define TMR1_H
40:                
41:                // Section: Included Files
42:                
43:                #include <stddef.h>
44:                #include <stdint.h>
45:                #include <xc.h>
46:                #include "timer_interface.h"
47:                // Section: Data Type Definitions
48:                
49:                
50:                /**
51:                 * @ingroup  timerdriver
52:                 * @brief    Structure object of type TIMER_INTERFACE with the custom name given by 
53:                 *           the user in the Melody Driver User interface. The default name 
54:                 *           e.g. Timer1 can be changed by the user in the TIMER user interface. 
55:                 *           This allows defining a structure with application specific name using 
56:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
57:                */
58:                extern const struct TIMER_INTERFACE MCC_TMR_PROFILE;
59:                
60:                /**
61:                 * @ingroup  timerdriver
62:                 * @brief    This macro defines the Custom Name for \ref TMR1_Initialize API
63:                 */
64:                #define MCC_TMR_PROFILE_Initialize TMR1_Initialize
65:                /**
66:                 * @ingroup  timerdriver
67:                 * @brief    This macro defines the Custom Name for \ref TMR1_Deinitialize API
68:                 */
69:                #define MCC_TMR_PROFILE_Deinitialize TMR1_Deinitialize
70:                /**
71:                 * @ingroup  timerdriver
72:                 * @brief    This macro defines the Custom Name for \ref TMR1_Tasks API
73:                 */
74:                #define MCC_TMR_PROFILE_Tasks TMR1_Tasks
75:                /**
76:                 * @ingroup  timerdriver
77:                 * @brief    This macro defines the Custom Name for \ref TMR1_Start API
78:                 */
79:                #define MCC_TMR_PROFILE_Start TMR1_Start
80:                /**
81:                 * @ingroup  timerdriver
82:                 * @brief    This macro defines the Custom Name for \ref TMR1_Stop API
83:                 */
84:                #define MCC_TMR_PROFILE_Stop TMR1_Stop
85:                
86:                #if TIMER_PERIODCOUNTSET_API_SUPPORT
87:                /**
88:                 * @ingroup  timerdriver
89:                 * @brief    This macro defines the Custom Name for \ref TMR1_PeriodCountSet API
90:                 */
91:                #define MCC_TMR_PROFILE_PeriodCountSet TMR1_PeriodCountSet
92:                #endif
93:                
94:                /**
95:                 * @ingroup  timerdriver
96:                 * @brief    This macro defines the Custom Name for \ref TMR1_PeriodSet API
97:                 */
98:                #define MCC_TMR_PROFILE_PeriodSet TMR1_PeriodSet
99:                /**
100:                * @ingroup  timerdriver
101:                * @brief    This macro defines the Custom Name for \ref TMR1_PeriodGet API
102:                */
103:               #define MCC_TMR_PROFILE_PeriodGet TMR1_PeriodGet
104:               /**
105:                * @ingroup  timerdriver
106:                * @brief    This macro defines the Custom Name for \ref TMR1_CounterGet API
107:                */
108:               #define MCC_TMR_PROFILE_CounterGet TMR1_CounterGet
109:               /**
110:                * @ingroup  timerdriver
111:                * @brief    This macro defines the Custom Name for \ref TMR1_Counter16BitGet API
112:                */
113:               #define MCC_TMR_PROFILE_Counter16BitGet TMR1_Counter16BitGet
114:               /**
115:                * @ingroup  timerdriver
116:                * @brief    This macro defines the Custom Name for \ref TMR1_InterruptPrioritySet API
117:                */
118:               #define MCC_TMR_PROFILE_InterruptPrioritySet TMR1_InterruptPrioritySet
119:               /**
120:                * @ingroup  timerdriver
121:                * @brief    This macro defines the Custom Name for \ref TMR1_TimeoutCallbackRegister API
122:                */
123:               #define MCC_TMR_PROFILE_TimeoutCallbackRegister TMR1_TimeoutCallbackRegister
124:               
125:               // Section: TMR1 Module APIs
126:               /**
127:                * @ingroup  timerdriver
128:                * @brief    Initializes the TMR1 module
129:                * @return   none
130:                */
131:               void TMR1_Initialize ( void );
132:               
133:               /**
134:                * @ingroup  timerdriver
135:                * @brief    Deinitializes the TMR1 to POR values
136:                * @return   none
137:                */
138:               void TMR1_Deinitialize(void);
139:               
140:               /**
141:                * @ingroup  timerdriver
142:                * @brief    This function is used to implement the tasks for polled implementations
143:                * @pre      \ref TMR1_Initialize must be called and Timer must be ON
144:                * @return   none
145:                */
146:               void TMR1_Tasks( void );
147:               
148:               /**
149:                * @ingroup  timerdriver
150:                * @brief    Starts the timer
151:                * @pre      \ref TMR1_Initialize must be called
152:                * @return   none
153:                */
154:               void TMR1_Start( void );
155:               
156:               /**
157:                * @ingroup  timerdriver
158:                * @brief    Stops the timer
159:                * @pre      \ref TMR1_Initialize must be called
160:                * @return   none
161:                */
162:               void TMR1_Stop( void );
163:               
164:               /**
165:                * @ingroup    timerdriver
166:                * @brief      Sets the TMR1 period count value
167:                * @param[in]  count - number of clock counts
168:                * @return     none
169:                */
170:               void TMR1_PeriodSet( uint32_t count );
171:               
172:               /**
173:                * @ingroup    timerdriver
174:                * @brief      This inline function gets the TMR1 period count value
175:                * @return     Number of clock counts
176:                */
177:               inline static uint32_t TMR1_PeriodGet( void )
178:               {
179:               	return (uint32_t) PR1;
009EEC  800840     MOV PR1, W0
009EEE  EB0080     CLR W1
180:               }
009EF0  060000     RETURN
181:               
182:               /**
183:                * @ingroup    timerdriver
184:                * @brief      This inline function gets the TMR1 elapsed time value
185:                * @return     Elapsed count value of the timer
186:                */
187:               inline static uint32_t TMR1_CounterGet( void )
188:               {
189:                   return (uint32_t)TMR1;
009EF2  800820     MOV TMR1, W0
009EF4  EB0080     CLR W1
190:               }
009EF6  060000     RETURN
009EF8  0A2020     BFINS #0x0, #0x3, W0, IPC6
191:               
192:               /**
193:                * @ingroup    timerdriver
194:                * @brief      This inline function gets the 16 bit TMR1 elapsed time value
195:                * @return     16 bit elapsed count value of the timer
196:                */
197:               inline static uint16_t TMR1_Counter16BitGet( void )
198:               {
199:                   return TMR1;
000AE6  800821     MOV TMR1, W1
000AF0  800821     MOV TMR1, W1
004998  800821     MOV TMR1, W1
0049B0  800821     MOV TMR1, W1
004B32  800821     MOV TMR1, W1
004EEA  800821     MOV TMR1, W1
004F3C  800821     MOV TMR1, W1
200:               }
201:               
202:               /**
203:                * @ingroup    timerdriver
204:                * @brief      Sets the TMR1 interrupt priority value
205:                * @param[in]  priority - value of interrupt priority
206:                * @return     none
207:                */
208:               void TMR1_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority);
209:               
210:               /**
211:                * @ingroup    timerdriver
212:                * @brief      This function can be used to override default callback and to define 
213:                *             custom callback for TMR1 Timeout event.
214:                * @param[in]  handler - Address of the callback function.  
215:                * @return     none
216:                */
217:               void TMR1_TimeoutCallbackRegister(void (*handler)(void));
218:               
219:               /**
220:                * @ingroup  timerdriver
221:                * @brief    This is the default callback with weak attribute. The user can 
222:                *           override and implement the default callback without weak attribute 
223:                *           or can register a custom callback function using  \ref TMR1_TimeoutCallbackRegister.
224:                * @return   none  
225:                */
226:               void TMR1_TimeoutCallback(void);
227:               
228:               
229:               #if TIMER_PERIODCOUNTSET_API_SUPPORT
230:               /**
231:                * @ingroup    timerdriver
232:                * @brief      Sets the TMR1 period count value
233:                * @param[in]  count - number of clock counts
234:                * @return     none
235:                */
236:               void TMR1_PeriodCountSet(size_t count) __attribute__((deprecated ("\nThis will be removed in future MCC releases. \nUse TMR1_PeriodSet instead. ")));
237:               #endif
238:               
239:               #endif //TMR1_H
240:               
241:               /**
242:                End of File
243:               */
244:               
245:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/src/tmr1.c
1:                 /**
2:                  * TMR1 Generated Driver Source File 
3:                  * 
4:                  * @file      tmr1.c
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver source file for TMR1 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.4.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                #include "../tmr1.h"
40:                #include "../timer_interface.h"
41:                
42:                // Section: Data Type Definitions
43:                
44:                #define MASK_32_BIT_LOW 0x0000FFFFU
45:                #define MASK_32_BIT_HIGH 0xFFFF0000U
46:                
47:                // Section: File specific functions
48:                
49:                static void (*TMR1_TimeoutHandler)(void) = NULL;
50:                
51:                // Section: Driver Interface
52:                
53:                const struct TIMER_INTERFACE MCC_TMR_PROFILE = {
54:                    .Initialize            = &TMR1_Initialize,
55:                    .Deinitialize          = &TMR1_Deinitialize,
56:                    .Start                 = &TMR1_Start,
57:                    .Stop                  = &TMR1_Stop,
58:                    #if TIMER_PERIODCOUNTSET_API_SUPPORT
59:                    .PeriodCountSet        = &TMR1_PeriodCountSet,
60:                    #endif
61:                    .PeriodSet             = &TMR1_PeriodSet,
62:                    .PeriodGet             = &TMR1_PeriodGet,
63:                    .CounterGet            = &TMR1_CounterGet,
64:                    .InterruptPrioritySet  = &TMR1_InterruptPrioritySet,
65:                    .TimeoutCallbackRegister = &TMR1_TimeoutCallbackRegister,
66:                    .Tasks          = &TMR1_Tasks
67:                };
68:                
69:                // Section: TMR1 Module APIs
70:                
71:                void TMR1_Initialize (void)
72:                {
73:                    //TCS External; TSYNC disabled; TCKPS 1:1; TGATE disabled; TECS FCY; PRWIP Write complete; TMWIP Write complete; TMWDIS disabled; TSIDL disabled; TON disabled; 
74:                    T1CON = 0x102;
009C9E  201020     MOV #0x102, W0
009CA0  880800     MOV W0, T1CON
75:                    //TMR 0x0; 
76:                    TMR1 = 0x0;
009CA2  EF2104     CLR TMR1
77:                    //Period 0 ms; Frequency 100,000,000 Hz; PR 65535; 
78:                    PR1 = 0xFFFF;
009CA4  EFA108     SETM PR1
79:                    
80:                    TMR1_TimeoutCallbackRegister(&TMR1_TimeoutCallback);
009CA6  29FCA0     MOV #0x9FCA, W0
009CA8  0700D4     RCALL TMR1_TimeoutCallbackRegister
81:                
82:                    TMR1_Start();
009CAA  070179     RCALL TMR1_Start
83:                }
009CAC  060000     RETURN
009CAE  EB0000     CLR W0
84:                
85:                void TMR1_Deinitialize (void)
86:                {
87:                    TMR1_Stop();
009DAC  0700FA     RCALL TMR1_Stop
88:                    
89:                    T1CON = 0x0;
009DAE  EF2100     CLR T1CON
90:                    TMR1 = 0x0;
009DB0  EF2104     CLR TMR1
91:                    PR1 = 0x0;
009DB2  EF2108     CLR PR1
92:                }
009DB4  060000     RETURN
009DB6  AB823E     BTST U1STAH, #4
93:                
94:                void TMR1_Start( void )
95:                {
96:                    // Start the Timer 
97:                    T1CONbits.TON = 1;
009F9E  A8E101     BSET 0x101, #7
98:                }
009FA0  060000     RETURN
99:                
100:               void TMR1_Stop( void )
101:               {
102:                   // Stop the Timer 
103:                   T1CONbits.TON = 0;
009FA2  A9E101     BCLR 0x101, #7
104:               }
009FA4  060000     RETURN
105:               
106:               void TMR1_PeriodSet(uint32_t count)
107:               {
108:                   PR1 = (uint16_t)(count & MASK_32_BIT_LOW);
009FA6  880840     MOV W0, PR1
109:               }
009FA8  060000     RETURN
009FAA  A8A238     BSET U1MODE, #5
110:               
111:               void TMR1_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority)
112:               {
113:                   IPC0bits.T1IP = priority;
009C8E  600067     AND W0, #0x7, W0
009C90  DD0044     SL W0, #4, W0
009C92  2FF8F1     MOV #0xFF8F, W1
009C94  804202     MOV IPC0, W2
009C96  608082     AND W1, W2, W1
009C98  700081     IOR W0, W1, W1
009C9A  884201     MOV W1, IPC0
114:               }
009C9C  060000     RETURN
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
009C9E  201020     MOV #0x102, W0
115:               
116:               void TMR1_TimeoutCallbackRegister(void (*handler)(void))
117:               {
118:                   if(NULL != handler)
009E52  E00000     CP0 W0
009E54  320001     BRA Z, .L8
119:                   {
120:                       TMR1_TimeoutHandler = handler;
009E56  889320     MOV W0, TMR1_TimeoutHandler
121:                   }
122:               }
009E58  060000     RETURN
009E5A  A90803     BCLR 0x803, #0
123:               
124:               void __attribute__ ((weak)) TMR1_TimeoutCallback( void )
125:               { 
126:               
127:               } 
009FCA  060000     RETURN
009FCC  060000     RETURN
128:               
129:               void TMR1_Tasks( void )    
130:               {
131:                   if(IFS0bits.T1IF == 1)
009D60  AB2800     BTST IFS0, #1
009D62  320003     BRA Z, .L12
132:                   {
133:                       (*TMR1_TimeoutHandler)();
009D64  809320     MOV TMR1_TimeoutHandler, W0
009D66  010000     CALL W0
134:                       IFS0bits.T1IF = 0;
009D68  A92800     BCLR IFS0, #1
135:                   }
136:               }
009D6A  060000     RETURN
009D6C  780110     MOV [W0], W2
137:               
138:               void TMR1_PeriodCountSet(size_t count)
139:               {
140:                   PR1 = count & MASK_32_BIT_LOW;
000000  040200     GOTO __resetPRI, __reset
141:               }
000002  000000     NOP
000004  000B9A     NOP
142:               
143:               /**
144:                End of File
145:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/src/sccp2.c
1:                 /**
2:                  * SCCP2-TIMER Generated Driver Source File
3:                  * 
4:                  * @file      sccp2.c
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver source file for SCCP2-TIMER driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.5.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                #include <stddef.h> 
41:                #include "../sccp2.h"
42:                #include "../timer_interface.h"
43:                
44:                // Section: Data Type Definitions
45:                
46:                #define MASK_32_BIT_LOW 0x0000FFFFU
47:                #define MASK_32_BIT_HIGH 0xFFFF0000U
48:                
49:                // Section: File specific functions
50:                
51:                static void (*SCCP2_TimeoutHandler)(void) = NULL;
52:                
53:                // Section: Driver Interface
54:                
55:                // Defines an object for TIMER_INTERFACE
56:                
57:                const struct TIMER_INTERFACE Timer2 = {
58:                    .Initialize     = &SCCP2_Timer_Initialize,
59:                    .Deinitialize   = &SCCP2_Timer_Deinitialize,
60:                    .Start          = &SCCP2_Timer_Start,
61:                    .Stop           = &SCCP2_Timer_Stop,
62:                    #if TIMER_PERIODCOUNTSET_API_SUPPORT
63:                    .PeriodCountSet = &SCCP2_Timer_PeriodCountSet,
64:                    #endif
65:                    .PeriodSet      = &SCCP2_Timer_PeriodSet,
66:                    .CounterGet     = &SCCP2_Timer_CounterGet,
67:                    .PeriodGet	    = &SCCP2_Timer_PeriodGet,
68:                    .InterruptPrioritySet = &SCCP2_Timer_InterruptPrioritySet,
69:                    .TimeoutCallbackRegister = &SCCP2_Timer_TimeoutCallbackRegister,
70:                    .Tasks          = NULL,
71:                };
72:                
73:                // Section: Driver Interface Function Definitions
74:                
75:                void SCCP2_Timer_Initialize(void)
76:                {
77:                    // MOD ; CCSEL disabled; TMR32 16 Bit; TMRPS 1:1; CLKSEL FOSC/2; TMRSYNC disabled; CCPSLP disabled; CCPSIDL disabled; CCPON disabled; 
78:                    CCP2CON1L = 0x0; //The module is disabled, till other settings are configured
009304  EF2974     CLR CCP2CON1L
79:                    //SYNC None; ALTSYNC disabled; ONESHOT disabled; TRIGEN disabled; IOPS Each Time Base Period Match; RTRGEN disabled; OPSRC Timer Interrupt Event; 
80:                    CCP2CON1H = 0x0;
009306  EF2976     CLR CCP2CON1H
81:                    //ASDG 0x0; SSDG disabled; ASDGM disabled; PWMRSEN disabled; 
82:                    CCP2CON2L = 0x0;
009308  EF2978     CLR CCP2CON2L
83:                    //ICSEL ; AUXOUT Disabled; ICGSM Level-Sensitive mode; OCAEN disabled; OENSYNC disabled; 
84:                    CCP2CON2H = 0x0;
00930A  EF297A     CLR CCP2CON2H
85:                    //PSSACE Tri-state; POLACE disabled; OSCNT None; OETRIG disabled; 
86:                    CCP2CON3H = 0x0;
00930C  EF297E     CLR CCP2CON3H
87:                    //ICOV disabled; ICDIS disabled; SCEVT disabled; ASEVT disabled; TRCLR disabled; TRSET disabled; ICGARM disabled; 
88:                    CCP2STATL = 0x0;
00930E  EF2980     CLR CCP2STATL
89:                    //TMRL 0x0000; 
90:                    CCP2TMRL = 0x0;
009310  EF2984     CLR CCP2TMRL
91:                    //TMRH 0x0000; 
92:                    CCP2TMRH = 0x0;
009312  EF2986     CLR CCP2TMRH
93:                    //PRL 34463; 
94:                    CCP2PRL = 0x869F;
009314  2869F0     MOV #0x869F, W0
009316  884C40     MOV W0, CCP2PRL
95:                    //PRH 1; 
96:                    CCP2PRH = 0x1;
009318  200010     MOV #0x1, W0
00931A  884C50     MOV W0, CCP2PRH
97:                    //CMPA 0; 
98:                    CCP2RA = 0x0;
00931C  EF298C     CLR CCP2RAL
99:                    //CMPB 0; 
100:                   CCP2RB = 0x0;
00931E  EF2990     CLR CCP2RBL
101:                   //BUFL 0x0000; 
102:                   CCP2BUFL = 0x0;
009320  EF2994     CLR CCP2BUFL
103:                   //BUFH 0x0000; 
104:                   CCP2BUFH = 0x0;
009322  EF2996     CLR CCP2BUFH
105:                   
106:                   SCCP2_Timer_TimeoutCallbackRegister(&SCCP2_TimeoutCallback);
009324  29FCC0     MOV #0x9FCC, W0
009326  0705A1     RCALL SCCP2_Timer_TimeoutCallbackRegister
107:               
108:                   IFS1bits.CCT2IF = 0;
009328  A90803     BCLR 0x803, #0
109:                   // Enabling SCCP2 interrupt
110:                   IEC1bits.CCT2IE = 1;
00932A  A80823     BSET 0x823, #0
111:               
112:                   CCP2CON1Lbits.CCPON = 1; //Enable Module
00932C  A8E975     BSET 0x975, #7
113:               }
00932E  060000     RETURN
009330  EB4100     CLR.B W2
114:               
115:               void SCCP2_Timer_Deinitialize(void)
116:               {
117:                   CCP2CON1Lbits.CCPON = 0;
0093FE  A9E975     BCLR 0x975, #7
118:                   
119:                   IFS1bits.CCT2IF = 0;
009400  A90803     BCLR 0x803, #0
120:                   IEC1bits.CCT2IE = 0;
009402  A90823     BCLR 0x823, #0
121:                   
122:                   CCP2CON1L = 0x0; 
009404  EF2974     CLR CCP2CON1L
123:                   CCP2CON1H = 0x0; 
009406  EF2976     CLR CCP2CON1H
124:                   CCP2CON2L = 0x0; 
009408  EF2978     CLR CCP2CON2L
125:                   CCP2CON2H = 0x100; 
00940A  201000     MOV #0x100, W0
00940C  884BD0     MOV W0, CCP2CON2H
126:                   CCP2CON3H = 0x0; 
00940E  EF297E     CLR CCP2CON3H
127:                   CCP2STATL = 0x0; 
009410  EF2980     CLR CCP2STATL
128:                   CCP2TMRL = 0x0; 
009412  EF2984     CLR CCP2TMRL
129:                   CCP2TMRH = 0x0; 
009414  EF2986     CLR CCP2TMRH
130:                   CCP2PRL = 0xFFFF; 
009416  EB8000     SETM W0
009418  884C40     MOV W0, CCP2PRL
131:                   CCP2PRH = 0xFFFF; 
00941A  884C50     MOV W0, CCP2PRH
132:                   CCP2RA = 0x0; 
00941C  EF298C     CLR CCP2RAL
133:                   CCP2RB = 0x0; 
00941E  EF2990     CLR CCP2RBL
134:                   CCP2BUFL = 0x0; 
009420  EF2994     CLR CCP2BUFL
135:                   CCP2BUFH = 0x0; 
009422  EF2996     CLR CCP2BUFH
136:               }
009424  060000     RETURN
009426  900210     MOV [W0+2], W4
137:               
138:               void SCCP2_Timer_Start(void)
139:               {
140:                   IFS1bits.CCT2IF = 0;
009E5A  A90803     BCLR 0x803, #0
141:                   // Enable SCCP2 interrupt
142:                   IEC1bits.CCT2IE = 1;
009E5C  A80823     BSET 0x823, #0
143:                   
144:                   CCP2CON1Lbits.CCPON = 1;
009E5E  A8E975     BSET 0x975, #7
145:               }
009E60  060000     RETURN
146:               
147:               void SCCP2_Timer_Stop(void)
148:               {
149:                   CCP2CON1Lbits.CCPON = 0;
009E62  A9E975     BCLR 0x975, #7
150:                   
151:                   IFS1bits.CCT2IF = 0;
009E64  A90803     BCLR 0x803, #0
152:                   // Disable SCCP2 interrupt
153:                   IEC1bits.CCT2IE = 0;
009E66  A90823     BCLR 0x823, #0
154:               }
009E68  060000     RETURN
009E6A  E00000     CP0 W0
155:               
156:               void SCCP2_Timer_PeriodSet(uint32_t count)
157:               {
158:                   if(count > 0xFFFFU)
009B02  400FE1     ADD W0, #0x1, [W15]
159:                   {
160:                       CCP2PRL = (uint16_t)(count & MASK_32_BIT_LOW);
009B08  884C40     MOV W0, CCP2PRL
161:                       CCP2PRH = (uint16_t)((count & MASK_32_BIT_HIGH) >> 16);
009B0A  884C51     MOV W1, CCP2PRH
162:                       CCP2CON1Lbits.T32 = 1;
009B0C  A8A974     BSET CCP2CON1L, #5
009B0E  370002     BRA .L10
163:                   }
164:                   else
165:                   {
166:                       CCP2PRL = (uint16_t)(count & MASK_32_BIT_LOW);
009B10  884C40     MOV W0, CCP2PRL
167:                       CCP2CON1Lbits.T32 = 0;
009B12  A9A974     BCLR CCP2CON1L, #5
168:                   }
169:               }
009B14  060000     RETURN
009B16  781F88     MOV W8, [W15++]
170:               
171:               void SCCP2_Timer_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority)
172:               {
173:                   IPC6bits.CCT2IP = priority;
009EF8  0A2020     BFINS #0x0, #0x3, W0, IPC6
009EFA  00084C     NOP
174:               }
009EFC  060000     RETURN
009EFE  0AA066     BFEXT #0x6, #0x1, U1MODE, W0
175:               
176:               void SCCP2_Timer_TimeoutCallbackRegister(void (*handler)(void))
177:               {
178:                   if(NULL != handler)
009E6A  E00000     CP0 W0
009E6C  320001     BRA Z, .L14
179:                   {
180:                       SCCP2_TimeoutHandler = handler;
009E6E  889330     MOV W0, SCCP2_TimeoutHandler
181:                   }
182:               }
009E70  060000     RETURN
183:               
184:               void SCCP2_TimeoutCallbackRegister(void* handler)
185:               {
186:                   if(NULL != handler)
009E72  E00000     CP0 W0
009E74  320001     BRA Z, .L18
187:                   {
188:                       SCCP2_TimeoutHandler = handler;
009E76  889330     MOV W0, SCCP2_TimeoutHandler
189:                   }
190:               }
009E78  060000     RETURN
009E7A  881200     MOV W0, U1BRG
191:               
192:               void __attribute__ ((weak)) SCCP2_TimeoutCallback (void)
193:               { 
194:               
195:               } 
009FCC  060000     RETURN
009FCE  FFFFFF     NOPR
196:               
197:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _CCT2Interrupt (void)
198:               {
000C16  F80036     PUSH RCOUNT
000C18  BE9F80     MOV.D W0, [W15++]
000C1A  BE9F82     MOV.D W2, [W15++]
000C1C  BE9F84     MOV.D W4, [W15++]
000C1E  BE9F86     MOV.D W6, [W15++]
199:                   if(NULL != SCCP2_TimeoutHandler)
000C20  809330     MOV SCCP2_TimeoutHandler, W0
000C22  E00000     CP0 W0
000C24  320001     BRA Z, .L21
200:                   {
201:                       (*SCCP2_TimeoutHandler)();
000C26  010000     CALL W0
202:                   }
203:                   IFS1bits.CCT2IF = 0;
000C28  A90803     BCLR 0x803, #0
204:               }
000C2A  BE034F     MOV.D [--W15], W6
000C2C  BE024F     MOV.D [--W15], W4
000C2E  BE014F     MOV.D [--W15], W2
000C30  BE004F     MOV.D [--W15], W0
000C32  F90036     POP RCOUNT
000C34  064000     RETFIE
000C36  F80036     PUSH RCOUNT
205:               
206:               void SCCP2_Timer_PeriodCountSet(size_t count)
207:               {
208:                   CCP2PRL = (uint16_t)(count & MASK_32_BIT_LOW);
000000  040200     GOTO __resetPRI, __reset
209:                   CCP2CON1Lbits.T32 = 0;
000002  000000     NOP
210:               }
000004  000B9A     NOP
000006  000B2E     NOP
211:               
212:               /**
213:                End of File
214:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/src/sccp1.c
1:                 /**
2:                  * SCCP1-TIMER Generated Driver Source File
3:                  * 
4:                  * @file      sccp1.c
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver source file for SCCP1-TIMER driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.5.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                #include <stddef.h> 
41:                #include "../sccp1.h"
42:                #include "../timer_interface.h"
43:                
44:                // Section: Data Type Definitions
45:                
46:                #define MASK_32_BIT_LOW 0x0000FFFFU
47:                #define MASK_32_BIT_HIGH 0xFFFF0000U
48:                
49:                // Section: File specific functions
50:                
51:                static void (*SCCP1_TimeoutHandler)(void) = NULL;
52:                
53:                // Section: Driver Interface
54:                
55:                // Defines an object for TIMER_INTERFACE
56:                
57:                const struct TIMER_INTERFACE MCC_TMR_TICK = {
58:                    .Initialize     = &SCCP1_Timer_Initialize,
59:                    .Deinitialize   = &SCCP1_Timer_Deinitialize,
60:                    .Start          = &SCCP1_Timer_Start,
61:                    .Stop           = &SCCP1_Timer_Stop,
62:                    #if TIMER_PERIODCOUNTSET_API_SUPPORT
63:                    .PeriodCountSet = &SCCP1_Timer_PeriodCountSet,
64:                    #endif
65:                    .PeriodSet      = &SCCP1_Timer_PeriodSet,
66:                    .CounterGet     = &SCCP1_Timer_CounterGet,
67:                    .PeriodGet	    = &SCCP1_Timer_PeriodGet,
68:                    .InterruptPrioritySet = &SCCP1_Timer_InterruptPrioritySet,
69:                    .TimeoutCallbackRegister = &SCCP1_Timer_TimeoutCallbackRegister,
70:                    .Tasks          = NULL,
71:                };
72:                
73:                // Section: Driver Interface Function Definitions
74:                
75:                void SCCP1_Timer_Initialize(void)
76:                {
77:                    // MOD ; CCSEL disabled; TMR32 16 Bit; TMRPS 1:1; CLKSEL FOSC/2; TMRSYNC disabled; CCPSLP disabled; CCPSIDL disabled; CCPON disabled; 
78:                    CCP1CON1L = 0x0; //The module is disabled, till other settings are configured
0092D8  EF2950     CLR CCP1CON1L
79:                    //SYNC None; ALTSYNC disabled; ONESHOT disabled; TRIGEN disabled; IOPS Each Time Base Period Match; RTRGEN disabled; OPSRC Timer Interrupt Event; 
80:                    CCP1CON1H = 0x0;
0092DA  EF2952     CLR CCP1CON1H
81:                    //ASDG 0x0; SSDG disabled; ASDGM disabled; PWMRSEN disabled; 
82:                    CCP1CON2L = 0x0;
0092DC  EF2954     CLR CCP1CON2L
83:                    //ICSEL ; AUXOUT Disabled; ICGSM Level-Sensitive mode; OCAEN disabled; OENSYNC disabled; 
84:                    CCP1CON2H = 0x0;
0092DE  EF2956     CLR CCP1CON2H
85:                    //PSSACE Tri-state; POLACE disabled; OSCNT None; OETRIG disabled; 
86:                    CCP1CON3H = 0x0;
0092E0  EF295A     CLR CCP1CON3H
87:                    //ICOV disabled; ICDIS disabled; SCEVT disabled; ASEVT disabled; TRCLR disabled; TRSET disabled; ICGARM disabled; 
88:                    CCP1STATL = 0x0;
0092E2  EF295C     CLR CCP1STATL
89:                    //TMRL 0x0000; 
90:                    CCP1TMRL = 0x0;
0092E4  EF2960     CLR CCP1TMRL
91:                    //TMRH 0x0000; 
92:                    CCP1TMRH = 0x0;
0092E6  EF2962     CLR CCP1TMRH
93:                    //PRL 34463; 
94:                    CCP1PRL = 0x869F;
0092E8  2869F0     MOV #0x869F, W0
0092EA  884B20     MOV W0, CCP1PRL
95:                    //PRH 1; 
96:                    CCP1PRH = 0x1;
0092EC  200010     MOV #0x1, W0
0092EE  884B30     MOV W0, CCP1PRH
97:                    //CMPA 0; 
98:                    CCP1RA = 0x0;
0092F0  EF2968     CLR CCP1RAL
99:                    //CMPB 0; 
100:                   CCP1RB = 0x0;
0092F2  EF296C     CLR CCP1RBL
101:                   //BUFL 0x0000; 
102:                   CCP1BUFL = 0x0;
0092F4  EF2970     CLR CCP1BUFL
103:                   //BUFH 0x0000; 
104:                   CCP1BUFH = 0x0;
0092F6  EF2972     CLR CCP1BUFH
105:                   
106:                   SCCP1_Timer_TimeoutCallbackRegister(&SCCP1_TimeoutCallback);
0092F8  29FC80     MOV #0x9FC8, W0
0092FA  0705A7     RCALL SCCP1_Timer_TimeoutCallbackRegister
107:               
108:                   IFS0bits.CCT1IF = 0;
0092FC  A9E800     BCLR IFS0, #7
109:                   // Enabling SCCP1 interrupt
110:                   IEC0bits.CCT1IE = 1;
0092FE  A8E820     BSET IEC0, #7
111:               
112:                   CCP1CON1Lbits.CCPON = 1; //Enable Module
009300  A8E951     BSET 0x951, #7
113:               }
009302  060000     RETURN
009304  EF2974     CLR CCP2CON1L
114:               
115:               void SCCP1_Timer_Deinitialize(void)
116:               {
117:                   CCP1CON1Lbits.CCPON = 0;
0093D6  A9E951     BCLR 0x951, #7
118:                   
119:                   IFS0bits.CCT1IF = 0;
0093D8  A9E800     BCLR IFS0, #7
120:                   IEC0bits.CCT1IE = 0;
0093DA  A9E820     BCLR IEC0, #7
121:                   
122:                   CCP1CON1L = 0x0; 
0093DC  EF2950     CLR CCP1CON1L
123:                   CCP1CON1H = 0x0; 
0093DE  EF2952     CLR CCP1CON1H
124:                   CCP1CON2L = 0x0; 
0093E0  EF2954     CLR CCP1CON2L
125:                   CCP1CON2H = 0x100; 
0093E2  201000     MOV #0x100, W0
0093E4  884AB0     MOV W0, CCP1CON2H
126:                   CCP1CON3H = 0x0; 
0093E6  EF295A     CLR CCP1CON3H
127:                   CCP1STATL = 0x0; 
0093E8  EF295C     CLR CCP1STATL
128:                   CCP1TMRL = 0x0; 
0093EA  EF2960     CLR CCP1TMRL
129:                   CCP1TMRH = 0x0; 
0093EC  EF2962     CLR CCP1TMRH
130:                   CCP1PRL = 0xFFFF; 
0093EE  EB8000     SETM W0
0093F0  884B20     MOV W0, CCP1PRL
131:                   CCP1PRH = 0xFFFF; 
0093F2  884B30     MOV W0, CCP1PRH
132:                   CCP1RA = 0x0; 
0093F4  EF2968     CLR CCP1RAL
133:                   CCP1RB = 0x0; 
0093F6  EF296C     CLR CCP1RBL
134:                   CCP1BUFL = 0x0; 
0093F8  EF2970     CLR CCP1BUFL
135:                   CCP1BUFH = 0x0; 
0093FA  EF2972     CLR CCP1BUFH
136:               }
0093FC  060000     RETURN
0093FE  A9E975     BCLR 0x975, #7
137:               
138:               void SCCP1_Timer_Start(void)
139:               {
140:                   IFS0bits.CCT1IF = 0;
009E3A  A9E800     BCLR IFS0, #7
141:                   // Enable SCCP1 interrupt
142:                   IEC0bits.CCT1IE = 1;
009E3C  A8E820     BSET IEC0, #7
143:                   
144:                   CCP1CON1Lbits.CCPON = 1;
009E3E  A8E951     BSET 0x951, #7
145:               }
009E40  060000     RETURN
146:               
147:               void SCCP1_Timer_Stop(void)
148:               {
149:                   CCP1CON1Lbits.CCPON = 0;
009E42  A9E951     BCLR 0x951, #7
150:                   
151:                   IFS0bits.CCT1IF = 0;
009E44  A9E800     BCLR IFS0, #7
152:                   // Disable SCCP1 interrupt
153:                   IEC0bits.CCT1IE = 0;
009E46  A9E820     BCLR IEC0, #7
154:               }
009E48  060000     RETURN
009E4A  E00000     CP0 W0
155:               
156:               void SCCP1_Timer_PeriodSet(uint32_t count)
157:               {
158:                   if(count > 0xFFFFU)
009AEE  400FE1     ADD W0, #0x1, [W15]
009AF0  588FE0     SUBB W1, #0x0, [W15]
009AF2  360004     BRA LEU, .L11
159:                   {
160:                       CCP1PRL = (uint16_t)(count & MASK_32_BIT_LOW);
009AF4  884B20     MOV W0, CCP1PRL
161:                       CCP1PRH = (uint16_t)((count & MASK_32_BIT_HIGH) >> 16);
009AF6  884B31     MOV W1, CCP1PRH
162:                       CCP1CON1Lbits.T32 = 1;
009AF8  A8A950     BSET CCP1CON1L, #5
009AFA  370002     BRA .L10
163:                   }
164:                   else
165:                   {
166:                       CCP1PRL = (uint16_t)(count & MASK_32_BIT_LOW);
009AFC  884B20     MOV W0, CCP1PRL
167:                       CCP1CON1Lbits.T32 = 0;
009AFE  A9A950     BCLR CCP1CON1L, #5
168:                   }
169:               }
009B00  060000     RETURN
009B02  400FE1     ADD W0, #0x1, [W15]
009B04  588FE0     SUBB W1, #0x0, [W15]
009B06  360004     BRA LEU, .L11
170:               
171:               void SCCP1_Timer_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority)
172:               {
173:                   IPC1bits.CCT1IP = priority;
009C7E  600067     AND W0, #0x7, W0
009C80  DD004C     SL W0, #12, W0
009C82  28FFF1     MOV #0x8FFF, W1
009C84  804212     MOV IPC1, W2
009C86  608082     AND W1, W2, W1
009C88  700081     IOR W0, W1, W1
009C8A  884211     MOV W1, IPC1
174:               }
009C8C  060000     RETURN
009C8E  600067     AND W0, #0x7, W0
175:               
176:               void SCCP1_Timer_TimeoutCallbackRegister(void (*handler)(void))
177:               {
178:                   if(NULL != handler)
009E4A  E00000     CP0 W0
009E4C  320001     BRA Z, .L14
179:                   {
180:                       SCCP1_TimeoutHandler = handler;
009E4E  889310     MOV W0, SCCP1_TimeoutHandler
181:                   }
182:               }
009E50  060000     RETURN
009E52  E00000     CP0 W0
183:               
184:               void SCCP1_TimeoutCallbackRegister(void* handler)
185:               {
186:                   if(NULL != handler)
000000  040200     GOTO __resetPRI, __reset
187:                   {
188:                       SCCP1_TimeoutHandler = handler;
000004  000B9A     NOP
189:                   }
190:               }
000006  000B2E     NOP
000008  000B4A     NOP
191:               
192:               void __attribute__ ((weak)) SCCP1_TimeoutCallback (void)
193:               { 
194:               
195:               } 
009FC8  060000     RETURN
009FCA  060000     RETURN
196:               
197:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _CCT1Interrupt (void)
198:               {
000BF6  F80036     PUSH RCOUNT
199:                   if(NULL != SCCP1_TimeoutHandler)
000C00  809310     MOV SCCP1_TimeoutHandler, W0
000C02  E00000     CP0 W0
000C04  320001     BRA Z, .L21
200:                   {
201:                       (*SCCP1_TimeoutHandler)();
000C06  010000     CALL W0
202:                   }
203:                   IFS0bits.CCT1IF = 0;
000C08  A9E800     BCLR IFS0, #7
204:               }
000C0A  BE034F     MOV.D [--W15], W6
000C0C  BE024F     MOV.D [--W15], W4
000C0E  BE014F     MOV.D [--W15], W2
000C10  BE004F     MOV.D [--W15], W0
000C12  F90036     POP RCOUNT
000C14  064000     RETFIE
000C16  F80036     PUSH RCOUNT
205:               
206:               void SCCP1_Timer_PeriodCountSet(size_t count)
207:               {
208:                   CCP1PRL = (uint16_t)(count & MASK_32_BIT_LOW);
000000  040200     GOTO __resetPRI, __reset
209:                   CCP1CON1Lbits.T32 = 0;
000002  000000     NOP
210:               }
000004  000B9A     NOP
000006  000B2E     NOP
211:               
212:               /**
213:                End of File
214:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/sccp2.h
1:                 /**
2:                  * SCCP2-TIMER Generated Driver Header File 
3:                  * 
4:                  * @file      sccp2.h
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the SCCP2-TIMER driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.5.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef SCCP2_H
39:                #define SCCP2_H
40:                
41:                // Section: Included Files
42:                
43:                #include <stddef.h>
44:                #include <stdint.h>
45:                #include <xc.h>
46:                #include "timer_interface.h"
47:                
48:                // Section: Data Type Definitions
49:                
50:                
51:                /**
52:                 * @ingroup  timerdriver
53:                 * @brief    Structure object of type TIMER_INTERFACE with the custom name given by 
54:                 *           the user in the Melody Driver User interface. The default name 
55:                 *           e.g. Timer1 can be changed by the user in the TIMER user interface. 
56:                 *           This allows defining a structure with application specific name using 
57:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
58:                */
59:                extern const struct TIMER_INTERFACE Timer2;
60:                
61:                /**
62:                 * @ingroup  timerdriver
63:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Initialize API
64:                 */
65:                #define Timer2_Initialize SCCP2_Timer_Initialize
66:                /**
67:                 * @ingroup  timerdriver
68:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Deinitialize API
69:                 */
70:                #define Timer2_Deinitialize SCCP2_Timer_Deinitialize
71:                /**
72:                 * @ingroup  timerdriver
73:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Tasks API
74:                 */
75:                #define Timer2_Tasks SCCP2_Timer_Tasks
76:                /**
77:                 * @ingroup  timerdriver
78:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Start API
79:                 */
80:                #define Timer2_Start SCCP2_Timer_Start
81:                /**
82:                 * @ingroup  timerdriver
83:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Stop API
84:                 */
85:                #define Timer2_Stop SCCP2_Timer_Stop
86:                
87:                #if TIMER_PERIODCOUNTSET_API_SUPPORT
88:                /**
89:                 * @ingroup  timerdriver
90:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_PeriodCountSet API
91:                 */
92:                #define Timer2_PeriodCountSet SCCP2_Timer_PeriodCountSet
93:                #endif
94:                
95:                /**
96:                 * @ingroup  timerdriver
97:                 * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_PeriodSet API
98:                 */
99:                #define Timer2_PeriodSet SCCP2_Timer_PeriodSet
100:               /**
101:                * @ingroup  timerdriver
102:                * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_PeriodGet API
103:                */
104:               #define Timer2_PeriodGet SCCP2_Timer_PeriodGet
105:               /**
106:                * @ingroup  timerdriver
107:                * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_CounterGet API
108:                */
109:               #define Timer2_CounterGet SCCP2_Timer_CounterGet
110:               /**
111:                * @ingroup  timerdriver
112:                * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_Counter16BitGet API
113:                */
114:               #define Timer2_Counter16BitGet SCCP2_Timer_Counter16BitGet
115:               /**
116:                * @ingroup  timerdriver
117:                * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_InterruptPrioritySet API
118:                */
119:               #define Timer2_InterruptPrioritySet SCCP2_Timer_InterruptPrioritySet
120:               
121:               /**
122:                * @ingroup  timerdriver
123:                * @brief    This macro defines the Custom Name for \ref SCCP2_Timer_TimeoutCallbackRegister API
124:                */
125:               #define Timer2_TimeoutCallbackRegister SCCP2_Timer_TimeoutCallbackRegister
126:               
127:               // Section: Driver Interface Functions
128:               
129:               /**
130:                * @ingroup  timerdriver
131:                * @brief    Initializes the SCCP2 module 
132:                * @return   none  
133:                */
134:               void SCCP2_Timer_Initialize (void);
135:               
136:               /**
137:                * @ingroup  timerdriver
138:                * @brief    Deinitializes the SCCP2 to POR values
139:                * @return   none  
140:                */
141:               void SCCP2_Timer_Deinitialize(void);
142:               
143:               /**
144:                * @ingroup  timerdriver
145:                * @brief    Starts the timer
146:                * @pre      \ref SCCP2_Timer_Initialize must be called
147:                * @return   none  
148:                */
149:               void SCCP2_Timer_Start(void);
150:               
151:               /**
152:                * @ingroup  timerdriver
153:                * @brief    Stops the timer
154:                * @pre      \ref SCCP2_Timer_Initialize must be called
155:                * @return   none  
156:                */
157:               void SCCP2_Timer_Stop(void);
158:               
159:               /**
160:                * @ingroup  timerdriver
161:                * @brief    Sets the SCCP2-Timer period count value
162:                * @pre      \ref SCCP2_Timer_Initialize must be called
163:                * @param[in]  count - period value
164:                * @return   none  
165:                */
166:               void SCCP2_Timer_PeriodSet(uint32_t count);
167:               
168:               /**
169:                * @ingroup  timerdriver
170:                * @brief    This inline function gets the SCCP2-Timer period count value
171:                * @pre      \ref SCCP2_Timer_Initialize must be called
172:                * @return   Period count value  
173:                */
174:               inline static uint32_t SCCP2_Timer_PeriodGet(void)
175:               {
176:                   if(CCP2CON1Lbits.T32 == 1)
009804  ABA974     BTST CCP2CON1L, #5
009806  320009     BRA Z, .L2
177:                   {
178:                       return (((uint32_t)CCP2PRH << 16U) | (CCP2PRL) );
009808  804C50     MOV CCP2PRH, W0
00980A  804C42     MOV CCP2PRL, W2
00980C  EB0080     CLR W1
00980E  DD00C0     SL W0, #0, W1
009810  200000     MOV #0x0, W0
009812  EB0180     CLR W3
009814  700002     IOR W0, W2, W0
009816  708083     IOR W1, W3, W1
009818  370002     BRA .L3
179:                   }
180:                   else
181:                   {
182:                       return (uint32_t) CCP2PRL;
00981A  804C40     MOV CCP2PRL, W0
00981C  EB0080     CLR W1
183:                   }
184:               }
00981E  060000     RETURN
185:               
186:               /**
187:                * @ingroup  timerdriver
188:                * @brief    This inline function gets the SCCP2-Timer elapsed count value
189:                * @return   Elapsed count value of the timer  
190:                */
191:               inline static uint32_t SCCP2_Timer_CounterGet(void)
192:               {
193:                   if(CCP2CON1Lbits.T32 == 1)
009820  ABA974     BTST CCP2CON1L, #5
009822  320009     BRA Z, .L5
194:                   {
195:                       return (((uint32_t)CCP2TMRH << 16U) | CCP2TMRL);
009824  804C30     MOV CCP2TMRH, W0
009826  804C22     MOV CCP2TMRL, W2
009828  EB0080     CLR W1
00982A  DD00C0     SL W0, #0, W1
00982C  200000     MOV #0x0, W0
00982E  EB0180     CLR W3
009830  700002     IOR W0, W2, W0
009832  708083     IOR W1, W3, W1
009834  370002     BRA .L6
196:                   }
197:                   else
198:                   {
199:                       return (uint32_t)CCP2TMRL;
009836  804C20     MOV CCP2TMRL, W0
009838  EB0080     CLR W1
200:                   }
201:               }
00983A  060000     RETURN
00983C  EF2238     CLR U1MODE
202:               
203:               /**
204:                * @ingroup  timerdriver
205:                * @brief    This inline function gets the SCCP2-Timer least significant 16 bit elapsed count value
206:                * @return   Least significant 16 bit elapsed count value of the timer  
207:                */
208:               inline static uint16_t SCCP2_Timer_Counter16BitGet(void)
209:               {
210:                   return CCP2TMRL;
211:               }
212:               
213:               /**
214:                * @ingroup  timerdriver
215:                * @brief    Sets the Interrupt Priority Value 
216:                * @return   none  
217:                */
218:               void SCCP2_Timer_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority);
219:               
220:               
221:               /**
222:                * @ingroup    timerdriver
223:                * @brief      This function can be used to override default callback and to define 
224:                *             custom callback for SCCP2 Timeout event.
225:                * @param[in]  handler - Address of the callback function.  
226:                * @return     none 
227:                */
228:               void SCCP2_Timer_TimeoutCallbackRegister(void (*handler)(void));
229:               
230:               /**
231:                * @ingroup    timerdriver
232:                * @brief      This function can be used to override default callback and to define 
233:                *             custom callback for SCCP2 Timeout event.
234:                * @param[in]  handler - Address of the callback function.  
235:                * @return     none 
236:                */
237:               void SCCP2_TimeoutCallbackRegister(void* handler)__attribute__((deprecated("\nThis will be removed in future MCC releases. \nUse SCCP2_Timer_TimeoutCallbackRegister instead. ")));
238:               
239:               /**
240:                * @ingroup  timerdriver
241:                * @brief    This is the default callback with weak attribute. The user can 
242:                *           override and implement the default callback without weak attribute 
243:                *           or can register a custom callback function using  \ref SCCP2_Timer_TimeoutCallbackRegister.
244:                * @return   none  
245:                */
246:               void SCCP2_TimeoutCallback(void);
247:               
248:               
249:               #if TIMER_PERIODCOUNTSET_API_SUPPORT
250:               /**
251:                * @ingroup  timerdriver
252:                * @brief    Sets the SCCP2-Timer period count value
253:                * @pre      \ref SCCP2_Timer_Initialize must be called
254:                * @param[in]  count - period value
255:                * @return   none  
256:                */
257:               void SCCP2_Timer_PeriodCountSet(size_t count)__attribute__((deprecated ("\nThis will be removed in future MCC releases. \nUse SCCP2_Timer_PeriodSet instead. ")));
258:               #endif
259:               #endif //SCCP2_H
260:               
261:               /**
262:                End of File
263:               */
264:               
265:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/timer/sccp1.h
1:                 /**
2:                  * SCCP1-TIMER Generated Driver Header File 
3:                  * 
4:                  * @file      sccp1.h
5:                  * 
6:                  * @ingroup   timerdriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the SCCP1-TIMER driver
9:                  *
10:                 * @version   Firmware Driver Version 1.5.0
11:                 *
12:                 * @version   PLIB Version 1.5.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef SCCP1_H
39:                #define SCCP1_H
40:                
41:                // Section: Included Files
42:                
43:                #include <stddef.h>
44:                #include <stdint.h>
45:                #include <xc.h>
46:                #include "timer_interface.h"
47:                
48:                // Section: Data Type Definitions
49:                
50:                
51:                /**
52:                 * @ingroup  timerdriver
53:                 * @brief    Structure object of type TIMER_INTERFACE with the custom name given by 
54:                 *           the user in the Melody Driver User interface. The default name 
55:                 *           e.g. Timer1 can be changed by the user in the TIMER user interface. 
56:                 *           This allows defining a structure with application specific name using 
57:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
58:                */
59:                extern const struct TIMER_INTERFACE MCC_TMR_TICK;
60:                
61:                /**
62:                 * @ingroup  timerdriver
63:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Initialize API
64:                 */
65:                #define MCC_TMR_TICK_Initialize SCCP1_Timer_Initialize
66:                /**
67:                 * @ingroup  timerdriver
68:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Deinitialize API
69:                 */
70:                #define MCC_TMR_TICK_Deinitialize SCCP1_Timer_Deinitialize
71:                /**
72:                 * @ingroup  timerdriver
73:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Tasks API
74:                 */
75:                #define MCC_TMR_TICK_Tasks SCCP1_Timer_Tasks
76:                /**
77:                 * @ingroup  timerdriver
78:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Start API
79:                 */
80:                #define MCC_TMR_TICK_Start SCCP1_Timer_Start
81:                /**
82:                 * @ingroup  timerdriver
83:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Stop API
84:                 */
85:                #define MCC_TMR_TICK_Stop SCCP1_Timer_Stop
86:                
87:                #if TIMER_PERIODCOUNTSET_API_SUPPORT
88:                /**
89:                 * @ingroup  timerdriver
90:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_PeriodCountSet API
91:                 */
92:                #define MCC_TMR_TICK_PeriodCountSet SCCP1_Timer_PeriodCountSet
93:                #endif
94:                
95:                /**
96:                 * @ingroup  timerdriver
97:                 * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_PeriodSet API
98:                 */
99:                #define MCC_TMR_TICK_PeriodSet SCCP1_Timer_PeriodSet
100:               /**
101:                * @ingroup  timerdriver
102:                * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_PeriodGet API
103:                */
104:               #define MCC_TMR_TICK_PeriodGet SCCP1_Timer_PeriodGet
105:               /**
106:                * @ingroup  timerdriver
107:                * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_CounterGet API
108:                */
109:               #define MCC_TMR_TICK_CounterGet SCCP1_Timer_CounterGet
110:               /**
111:                * @ingroup  timerdriver
112:                * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_Counter16BitGet API
113:                */
114:               #define MCC_TMR_TICK_Counter16BitGet SCCP1_Timer_Counter16BitGet
115:               /**
116:                * @ingroup  timerdriver
117:                * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_InterruptPrioritySet API
118:                */
119:               #define MCC_TMR_TICK_InterruptPrioritySet SCCP1_Timer_InterruptPrioritySet
120:               
121:               /**
122:                * @ingroup  timerdriver
123:                * @brief    This macro defines the Custom Name for \ref SCCP1_Timer_TimeoutCallbackRegister API
124:                */
125:               #define MCC_TMR_TICK_TimeoutCallbackRegister SCCP1_Timer_TimeoutCallbackRegister
126:               
127:               // Section: Driver Interface Functions
128:               
129:               /**
130:                * @ingroup  timerdriver
131:                * @brief    Initializes the SCCP1 module 
132:                * @return   none  
133:                */
134:               void SCCP1_Timer_Initialize (void);
135:               
136:               /**
137:                * @ingroup  timerdriver
138:                * @brief    Deinitializes the SCCP1 to POR values
139:                * @return   none  
140:                */
141:               void SCCP1_Timer_Deinitialize(void);
142:               
143:               /**
144:                * @ingroup  timerdriver
145:                * @brief    Starts the timer
146:                * @pre      \ref SCCP1_Timer_Initialize must be called
147:                * @return   none  
148:                */
149:               void SCCP1_Timer_Start(void);
150:               
151:               /**
152:                * @ingroup  timerdriver
153:                * @brief    Stops the timer
154:                * @pre      \ref SCCP1_Timer_Initialize must be called
155:                * @return   none  
156:                */
157:               void SCCP1_Timer_Stop(void);
158:               
159:               /**
160:                * @ingroup  timerdriver
161:                * @brief    Sets the SCCP1-Timer period count value
162:                * @pre      \ref SCCP1_Timer_Initialize must be called
163:                * @param[in]  count - period value
164:                * @return   none  
165:                */
166:               void SCCP1_Timer_PeriodSet(uint32_t count);
167:               
168:               /**
169:                * @ingroup  timerdriver
170:                * @brief    This inline function gets the SCCP1-Timer period count value
171:                * @pre      \ref SCCP1_Timer_Initialize must be called
172:                * @return   Period count value  
173:                */
174:               inline static uint32_t SCCP1_Timer_PeriodGet(void)
175:               {
176:                   if(CCP1CON1Lbits.T32 == 1)
0097CC  ABA950     BTST CCP1CON1L, #5
0097CE  320009     BRA Z, .L2
177:                   {
178:                       return (((uint32_t)CCP1PRH << 16U) | (CCP1PRL) );
0097D0  804B30     MOV CCP1PRH, W0
0097D2  804B22     MOV CCP1PRL, W2
0097D4  EB0080     CLR W1
0097D6  DD00C0     SL W0, #0, W1
0097D8  200000     MOV #0x0, W0
0097DA  EB0180     CLR W3
0097DC  700002     IOR W0, W2, W0
0097DE  708083     IOR W1, W3, W1
0097E0  370002     BRA .L3
179:                   }
180:                   else
181:                   {
182:                       return (uint32_t) CCP1PRL;
0097E2  804B20     MOV CCP1PRL, W0
0097E4  EB0080     CLR W1
183:                   }
184:               }
0097E6  060000     RETURN
185:               
186:               /**
187:                * @ingroup  timerdriver
188:                * @brief    This inline function gets the SCCP1-Timer elapsed count value
189:                * @return   Elapsed count value of the timer  
190:                */
191:               inline static uint32_t SCCP1_Timer_CounterGet(void)
192:               {
193:                   if(CCP1CON1Lbits.T32 == 1)
0097E8  ABA950     BTST CCP1CON1L, #5
0097EA  320009     BRA Z, .L5
194:                   {
195:                       return (((uint32_t)CCP1TMRH << 16U) | CCP1TMRL);
0097EC  804B10     MOV CCP1TMRH, W0
0097EE  804B02     MOV CCP1TMRL, W2
0097F0  EB0080     CLR W1
0097F2  DD00C0     SL W0, #0, W1
0097F4  200000     MOV #0x0, W0
0097F6  EB0180     CLR W3
0097F8  700002     IOR W0, W2, W0
0097FA  708083     IOR W1, W3, W1
0097FC  370002     BRA .L6
196:                   }
197:                   else
198:                   {
199:                       return (uint32_t)CCP1TMRL;
0097FE  804B00     MOV CCP1TMRL, W0
009800  EB0080     CLR W1
200:                   }
201:               }
009802  060000     RETURN
009804  ABA974     BTST CCP2CON1L, #5
202:               
203:               /**
204:                * @ingroup  timerdriver
205:                * @brief    This inline function gets the SCCP1-Timer least significant 16 bit elapsed count value
206:                * @return   Least significant 16 bit elapsed count value of the timer  
207:                */
208:               inline static uint16_t SCCP1_Timer_Counter16BitGet(void)
209:               {
210:                   return CCP1TMRL;
211:               }
212:               
213:               /**
214:                * @ingroup  timerdriver
215:                * @brief    Sets the Interrupt Priority Value 
216:                * @return   none  
217:                */
218:               void SCCP1_Timer_InterruptPrioritySet(enum INTERRUPT_PRIORITY priority);
219:               
220:               
221:               /**
222:                * @ingroup    timerdriver
223:                * @brief      This function can be used to override default callback and to define 
224:                *             custom callback for SCCP1 Timeout event.
225:                * @param[in]  handler - Address of the callback function.  
226:                * @return     none 
227:                */
228:               void SCCP1_Timer_TimeoutCallbackRegister(void (*handler)(void));
229:               
230:               /**
231:                * @ingroup    timerdriver
232:                * @brief      This function can be used to override default callback and to define 
233:                *             custom callback for SCCP1 Timeout event.
234:                * @param[in]  handler - Address of the callback function.  
235:                * @return     none 
236:                */
237:               void SCCP1_TimeoutCallbackRegister(void* handler)__attribute__((deprecated("\nThis will be removed in future MCC releases. \nUse SCCP1_Timer_TimeoutCallbackRegister instead. ")));
238:               
239:               /**
240:                * @ingroup  timerdriver
241:                * @brief    This is the default callback with weak attribute. The user can 
242:                *           override and implement the default callback without weak attribute 
243:                *           or can register a custom callback function using  \ref SCCP1_Timer_TimeoutCallbackRegister.
244:                * @return   none  
245:                */
246:               void SCCP1_TimeoutCallback(void);
247:               
248:               
249:               #if TIMER_PERIODCOUNTSET_API_SUPPORT
250:               /**
251:                * @ingroup  timerdriver
252:                * @brief    Sets the SCCP1-Timer period count value
253:                * @pre      \ref SCCP1_Timer_Initialize must be called
254:                * @param[in]  count - period value
255:                * @return   none  
256:                */
257:               void SCCP1_Timer_PeriodCountSet(size_t count)__attribute__((deprecated ("\nThis will be removed in future MCC releases. \nUse SCCP1_Timer_PeriodSet instead. ")));
258:               #endif
259:               #endif //SCCP1_H
260:               
261:               /**
262:                End of File
263:               */
264:               
265:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/watchdog.h
1:                 /**
2:                  * WATCHDOG Generated Driver Header File
3:                  * 
4:                  * @file      watchdog.h
5:                  * 
6:                  * @defgroup  watchdogdriver WDT Driver
7:                  * 
8:                  * @brief     Watchdog Timer Driver using dsPIC MCUs.
9:                  *
10:                 * @version   Firmware Driver Version 1.0.1
11:                 *
12:                 * @version   PLIB Version 1.1.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                /*
17:                © [2023] Microchip Technology Inc. and its subsidiaries.
18:                
19:                    Subject to your compliance with these terms, you may use Microchip 
20:                    software and any derivatives exclusively with Microchip products. 
21:                    You are responsible for complying with 3rd party license terms  
22:                    applicable to your use of 3rd party software (including open source  
23:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
24:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
25:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
26:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
27:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
28:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
29:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
30:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
31:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
32:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
33:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
34:                    THIS SOFTWARE.
35:                */
36:                
37:                #ifndef WATCHDOG_H
38:                #define WATCHDOG_H
39:                
40:                #include <xc.h>
41:                
42:                // Section: Type defines
43:                 
44:                /**
45:                 * @ingroup  watchdogdriver
46:                 * @brief    This macro holds the key value to clear Watchdog Timer (WDT)
47:                */
48:                #define WATCHDOG_CLR_KEY 0x5743
49:                
50:                /**
51:                 * @ingroup  watchdogdriver
52:                 * @brief    This inline function is used to enable the Watchdog Timer (WDT) using the software bit
53:                 * @return   none  
54:                 */
55:                inline static void WATCHDOG_TimerSoftwareEnable(void)
56:                {
57:                    WDTCONLbits.ON = 1;
008088  A8EFB5     BSET 0xFB5, #7
58:                }
59:                
60:                /**
61:                 * @ingroup  watchdogdriver
62:                 * @brief    This inline function is used to disable the Watchdog Timer (WDT) using the software bit
63:                 * @return   none  
64:                 */
65:                inline static void WATCHDOG_TimerSoftwareDisable(void)
66:                {
67:                    WDTCONLbits.ON = 0;
68:                }
69:                
70:                /**
71:                 * @ingroup  watchdogdriver
72:                 * @brief    This inline function is used to clear the Watchdog Timer (WDT)
73:                 * @return   none  
74:                 */
75:                inline static void WATCHDOG_TimerClear(void)
76:                {
77:                    WDTCONH = WATCHDOG_CLR_KEY;
000960  257430     MOV #0x5743, W0
000962  887DB0     MOV W0, WDTCONH
008882  257430     MOV #0x5743, W0
008884  887DB0     MOV W0, WDTCONH
008886  780480     MOV W0, W9
0088A6  887DB9     MOV W9, WDTCONH
78:                }
79:                
80:                #endif /* WATCHDOG_H */
81:                /**
82:                 End of File
83:                */
84:                
85:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/system.h
1:                 /**
2:                  * MAIN Generated Driver Header File
3:                  * 
4:                  * @file      system.h
5:                  * 
6:                  * @defgroup  systemdriver System Driver
7:                  * 
8:                  * @brief     System driver using dsPIC MCUs.
9:                  *
10:                 * @version   Driver Version 1.0.1
11:                 *
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                /*
15:                © [2023] Microchip Technology Inc. and its subsidiaries.
16:                
17:                    Subject to your compliance with these terms, you may use Microchip 
18:                    software and any derivatives exclusively with Microchip products. 
19:                    You are responsible for complying with 3rd party license terms  
20:                    applicable to your use of 3rd party software (including open source  
21:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
22:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
23:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
24:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
25:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
26:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
27:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
28:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
29:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
30:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
31:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
32:                    THIS SOFTWARE.
33:                */
34:                
35:                #include "xc.h"
36:                #include "stdint.h"
37:                #include "system_types.h"
38:                
39:                #ifndef SYSTEM_H
40:                #define	SYSTEM_H
41:                
42:                /**
43:                 * @ingroup systemdriver
44:                 * @brief   Initializes the System module
45:                 * @return  none 
46:                 */
47:                void SYSTEM_Initialize(void);
48:                
49:                /**
50:                 * @ingroup systemdriver
51:                 * @brief   Initializes the CPU core control register
52:                 * @return  none 
53:                 */
54:                inline static void SYSTEM_CORCONInitialize()
55:                {
56:                    CORCON = (CORCON & 0x00F2) | CORCON_MODE_PORVALUES;
57:                }
58:                
59:                /**
60:                 * @ingroup   systemdriver
61:                 * @brief     This inline function sets the CPU core control register operating mode 
62:                 *            to a value that is decided by the SYSTEM_CORCON_MODES argument.
63:                 * @param[in] modeValue - SYSTEM_CORCON_MODES initialization mode specifier
64:                 * @return    none 
65:                 */
66:                inline static void SYSTEM_CORCONModeOperatingSet(SYSTEM_CORCON_MODES modeValue)
67:                {
68:                    CORCON = (CORCON & 0x00F2) | modeValue;
0080E6  200F27     MOV #0xF2, W7
0080E8  800226     MOV CORCON, W6
0080EA  638386     AND W7, W6, W7
0080EC  B30E27     IOR #0xE2, W7
0080EE  880227     MOV W7, CORCON
69:                }
70:                
71:                /**
72:                 * @ingroup    systemdriver
73:                 * @brief      This inline function sets the value of CPU core control register
74:                 * @param[in]  value - value that needs to be written to the CPU core control register
75:                 * @return     none 
76:                 */
77:                inline static void SYSTEM_CORCONRegisterValueSet(uint16_t value)
78:                {
79:                    CORCON = value;
00815A  88022B     MOV W11, CORCON
80:                }
81:                
82:                /**
83:                 * @ingroup systemdriver
84:                 * @brief   This inline function gets the value of CPU core control register
85:                 * @return  value of the CPU core control register 
86:                 */
87:                inline static uint16_t SYSTEM_CORCONRegisterValueGet(void)
88:                {    
89:                    return CORCON;
0080E4  80022B     MOV CORCON, W11
90:                }
91:                
92:                /**
93:                 * @ingroup systemdriver
94:                 * @brief   This inline function gets the base address of the DEVID register 
95:                 *          for the currently selected device
96:                 * @return  base address of the DEVID register 
97:                 */
98:                inline static uint32_t SYSTEM_DeviceIdRegisterAddressGet(void)
99:                {
100:                   return __DEVID_BASE;
101:               }
102:               
103:               #endif	/* SYSTEM_H */
104:               /**
105:                End of File
106:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/traps.c
1:                 /**
2:                  * TRAPS Generated Driver Source File 
3:                  * 
4:                  * @file      traps.c
5:                  *            
6:                  * @ingroup   trapsdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for TRAPS driver
9:                  *            
10:                 * @version   Driver Version 1.0.1
11:                 *            
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                
15:                /*
16:                © [2023] Microchip Technology Inc. and its subsidiaries.
17:                
18:                    Subject to your compliance with these terms, you may use Microchip 
19:                    software and any derivatives exclusively with Microchip products. 
20:                    You are responsible for complying with 3rd party license terms  
21:                    applicable to your use of 3rd party software (including open source  
22:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
23:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
24:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
25:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
26:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
27:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
28:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
29:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
30:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
31:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
32:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
33:                    THIS SOFTWARE.
34:                */
35:                
36:                // Section: Included Files
37:                #include <xc.h>
38:                #include "../traps.h"
39:                
40:                #define ERROR_HANDLER __attribute__((interrupt,no_auto_psv))
41:                #define FAILSAFE_STACK_GUARDSIZE 8
42:                
43:                // A private place to store the error code if we run into a severe error
44:                
45:                static uint16_t TRAPS_error_code = -1;
46:                
47:                // Section: Driver Interface Function Definitions
48:                
49:                //@brief Halts 
50:                void __attribute__((weak)) TRAPS_halt_on_error(uint16_t code)
51:                {
52:                    TRAPS_error_code = code;
000000  040200     GOTO __resetPRI, __reset
53:                #ifdef __DEBUG    
54:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
55:                    __builtin_software_breakpoint();
000004  000B9A     NOP
56:                    while(1)
57:                    {
58:                    
59:                    }
60:                #else
61:                    // Trigger software reset
62:                    __asm__ volatile ("reset");
63:                #endif
64:                }
65:                
66:                // @brief Sets the stack pointer to a backup area of memory, in case we run into
67:                //   a stack error (in which case we can't really trust the stack pointer)
68:                
69:                inline static void use_failsafe_stack(void)
70:                {
71:                    static uint8_t failsafe_stack[32];
72:                    asm volatile (
000BDC  234AE0     MOV #0x34AE, W0
000BDE  780780     MOV W0, W15
73:                        "   mov    %[pstack], W15\n"
74:                        :
75:                        : [pstack]"r"(failsafe_stack)
76:                    );
77:                    
78:                    /* Controls where the stack pointer limit is, relative to the end of the
79:                     * failsafe stack
80:                     */ 
81:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) - (uint16_t) FAILSAFE_STACK_GUARDSIZE);
000BE0  234C60     MOV #0x34C6, W0
000BE2  880100     MOV W0, SPLIM
82:                }
83:                
84:                /** Address error Trap vector**/
85:                void ERROR_HANDLER _AddressError(void)
86:                {
000B2E  F80036     PUSH RCOUNT
000B30  BE9F80     MOV.D W0, [W15++]
000B32  BE9F82     MOV.D W2, [W15++]
000B34  BE9F84     MOV.D W4, [W15++]
000B36  BE9F86     MOV.D W6, [W15++]
87:                    INTCON1bits.ADDRERR = 0;  //Clear the trap flag
000B38  A968C0     BCLR INTCON1, #3
88:                    TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
000B3A  200020     MOV #0x2, W0
000B3C  07425B     RCALL TRAPS_halt_on_error
89:                }
000B3E  BE034F     MOV.D [--W15], W6
000B40  BE024F     MOV.D [--W15], W4
000B42  BE014F     MOV.D [--W15], W2
000B44  BE004F     MOV.D [--W15], W0
000B46  F90036     POP RCOUNT
000B48  064000     RETFIE
90:                
91:                /** Generic Hard Trap vector**/
92:                void ERROR_HANDLER _HardTrapError(void)
93:                {
000B4A  F80036     PUSH RCOUNT
000B4C  BE9F80     MOV.D W0, [W15++]
000B4E  BE9F82     MOV.D W2, [W15++]
000B50  BE9F84     MOV.D W4, [W15++]
000B52  BE9F86     MOV.D W6, [W15++]
94:                    INTCON4bits.SGHT = 0;  //Clear the trap flag
000B54  A908C6     BCLR INTCON4, #0
95:                    TRAPS_halt_on_error(TRAPS_HARD_ERR);
000B56  200070     MOV #0x7, W0
000B58  07424D     RCALL TRAPS_halt_on_error
96:                }
000B5A  BE034F     MOV.D [--W15], W6
000B5C  BE024F     MOV.D [--W15], W4
000B5E  BE014F     MOV.D [--W15], W2
000B60  BE004F     MOV.D [--W15], W0
000B62  F90036     POP RCOUNT
000B64  064000     RETFIE
97:                
98:                /** Generic Soft Trap vector**/
99:                void ERROR_HANDLER _SoftTrapError(void)
100:               {
000B66  F80036     PUSH RCOUNT
000B68  BE9F80     MOV.D W0, [W15++]
000B6A  BE9F82     MOV.D W2, [W15++]
000B6C  BE9F84     MOV.D W4, [W15++]
000B6E  BE9F86     MOV.D W6, [W15++]
101:                   if(INTCON3bits.DOOVR == 1)
000B70  AB88C4     BTST INTCON3, #4
000B72  320003     BRA Z, .L6
102:                   {
103:                     INTCON3bits.DOOVR = 0;  //Clear the trap flag
000B74  A988C4     BCLR INTCON3, #4
104:                     TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
000B76  2000A0     MOV #0xA, W0
000B78  07423D     RCALL TRAPS_halt_on_error
105:                   }
106:               
107:                   if(INTCON3bits.NAE == 1)
000B7A  AB08C5     BTST 0x8C5, #0
000B7C  320003     BRA Z, .L7
108:                   {
109:                     INTCON3bits.NAE = 0;  //Clear the trap flag
000B7E  A908C5     BCLR 0x8C5, #0
110:                     TRAPS_halt_on_error(TRAPS_NVM_ERR);
000B80  2000C0     MOV #0xC, W0
000B82  074238     RCALL TRAPS_halt_on_error
111:                   }
112:               
113:               #ifdef _CAN
114:                   if(INTCON3bits.CAN == 1)
000B84  AB28C5     BTST 0x8C5, #1
000B86  320003     BRA Z, .L8
115:                   {
116:                     INTCON3bits.CAN = 0;  //Clear the trap flag
000B88  A928C5     BCLR 0x8C5, #1
117:                     TRAPS_halt_on_error(TRAPS_CAN_ERR);
000B8A  2000D0     MOV #0xD, W0
000B8C  074233     RCALL TRAPS_halt_on_error
118:                   }
119:               
120:               #endif
121:                   if(INTCON3bits.APLL == 1)
000B8E  AB08C4     BTST INTCON3, #0
000B90  320003     BRA Z, .L9, .L10
122:                   {
123:                     INTCON3bits.APLL = 0;  //Clear the trap flag
000B92  A908C4     BCLR INTCON3, #0
124:                     TRAPS_halt_on_error(TRAPS_APLL_ERR);
000B94  2000B0     MOV #0xB, W0
000B96  07422E     RCALL TRAPS_halt_on_error
000B98  37FFFF     BRA .L9, .L10
125:                   }
126:               
127:                   while(1)
128:                   {
129:                   }
130:               }
131:               
132:               /** Oscillator Fail Trap vector**/
133:               void ERROR_HANDLER _OscillatorFail(void)
134:               {
000B9A  F80036     PUSH RCOUNT
000B9C  BE9F80     MOV.D W0, [W15++]
000B9E  BE9F82     MOV.D W2, [W15++]
000BA0  BE9F84     MOV.D W4, [W15++]
000BA2  BE9F86     MOV.D W6, [W15++]
135:                   INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
000BA4  A928C0     BCLR INTCON1, #1
136:                   TRAPS_halt_on_error(TRAPS_OSC_FAIL);
000BA6  EB0000     CLR W0
000BA8  074225     RCALL TRAPS_halt_on_error
137:               }
000BAA  BE034F     MOV.D [--W15], W6
000BAC  BE024F     MOV.D [--W15], W4
000BAE  BE014F     MOV.D [--W15], W2
000BB0  BE004F     MOV.D [--W15], W0
000BB2  F90036     POP RCOUNT
000BB4  064000     RETFIE
138:               
139:               /** Math Error Trap vector**/
140:               void ERROR_HANDLER _MathError(void)
141:               {
000BB6  F80036     PUSH RCOUNT
000BB8  BE9F80     MOV.D W0, [W15++]
000BBA  BE9F82     MOV.D W2, [W15++]
000BBC  BE9F84     MOV.D W4, [W15++]
000BBE  BE9F86     MOV.D W6, [W15++]
142:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
000BC0  A988C0     BCLR INTCON1, #4
143:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
000BC2  200030     MOV #0x3, W0
000BC4  074217     RCALL TRAPS_halt_on_error
144:               }
000BC6  BE034F     MOV.D [--W15], W6
000BC8  BE024F     MOV.D [--W15], W4
000BCA  BE014F     MOV.D [--W15], W2
000BCC  BE004F     MOV.D [--W15], W0
000BCE  F90036     POP RCOUNT
000BD0  064000     RETFIE
145:               
146:               /** Stack Error Trap Vector**/
147:               void ERROR_HANDLER _StackError(void)
148:               {
000BD2  F80036     PUSH RCOUNT
000BD4  BE9F80     MOV.D W0, [W15++]
000BD6  BE9F82     MOV.D W2, [W15++]
000BD8  BE9F84     MOV.D W4, [W15++]
000BDA  BE9F86     MOV.D W6, [W15++]
149:                   /* We use a failsafe stack: the presence of a stack-pointer error
150:                    * means that we cannot trust the stack to operate correctly unless
151:                    * we set the stack pointer to a safe place.
152:                    */
153:                   use_failsafe_stack(); 
154:                   
155:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
000BE4  A948C0     BCLR INTCON1, #2
156:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
000BE6  200010     MOV #0x1, W0
000BE8  074205     RCALL TRAPS_halt_on_error
157:               }
000BEA  BE034F     MOV.D [--W15], W6
000BEC  BE024F     MOV.D [--W15], W4
000BEE  BE014F     MOV.D [--W15], W2
000BF0  BE004F     MOV.D [--W15], W0
000BF2  F90036     POP RCOUNT
000BF4  064000     RETFIE
000BF6  F80036     PUSH RCOUNT
000BF8  BE9F80     MOV.D W0, [W15++]
000BFA  BE9F82     MOV.D W2, [W15++]
000BFC  BE9F84     MOV.D W4, [W15++]
000BFE  BE9F86     MOV.D W6, [W15++]
158:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/system.c
1:                 /**
2:                  * MAIN Generated Driver Header File
3:                  * 
4:                  * @file      system.c
5:                  *            
6:                  * @ingroup   systemdriver
7:                  *            
8:                  * @brief     This is the generated driver header file for the System driver
9:                  *            
10:                 * @version   Driver Version 1.0.1
11:                 *            
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                /*
15:                © [2023] Microchip Technology Inc. and its subsidiaries.
16:                
17:                    Subject to your compliance with these terms, you may use Microchip 
18:                    software and any derivatives exclusively with Microchip products. 
19:                    You are responsible for complying with 3rd party license terms  
20:                    applicable to your use of 3rd party software (including open source  
21:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
22:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
23:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
24:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
25:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
26:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
27:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
28:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
29:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
30:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
31:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
32:                    THIS SOFTWARE.
33:                */
34:                
35:                #include "../system.h"
36:                #include "../system_types.h"
37:                #include "../clock.h"
38:                #include "../pins.h"
39:                #include "../../adc/adc1.h"
40:                #include "../../cmp/cmp1.h"
41:                #include "../dmt.h"
42:                #include "../../opa/opa1.h"
43:                #include "../../opa/opa2.h"
44:                #include "../../opa/opa3.h"
45:                #include "../../pwm_hs/pwm.h"
46:                #include "../../qei/qei1.h"
47:                #include "../../timer/sccp1.h"
48:                #include "../../timer/sccp2.h"
49:                #include "../../timer/tmr1.h"
50:                #include "../../uart/uart1.h"
51:                #include "../interrupt.h"
52:                
53:                
54:                void SYSTEM_Initialize(void)
55:                {
56:                    CLOCK_Initialize();
009532  07F962     RCALL CLOCK_Initialize
57:                    PINS_Initialize();
009534  07F616     RCALL PINS_Initialize
58:                    ADC1_Initialize();
009536  07ED01     RCALL ADC1_Initialize
59:                    CMP1_Initialize();
009538  070046     RCALL CMP1_Initialize
60:                    DMT_Initialize();
00953A  0702A6     RCALL DMT_Initialize
61:                    OPA1_Initialize();
00953C  07046A     RCALL OPA1_Initialize
62:                    OPA2_Initialize();
00953E  070465     RCALL OPA2_Initialize
63:                    OPA3_Initialize();
009540  070460     RCALL OPA3_Initialize
64:                    PWM_Initialize();
009542  07ED6F     RCALL PWM_Initialize
65:                    QEI1_Initialize();
009544  07FDDC     RCALL QEI1_Initialize
66:                    SCCP1_Timer_Initialize();
009546  07FEC8     RCALL SCCP1_Timer_Initialize
67:                    SCCP2_Timer_Initialize();
009548  07FEDD     RCALL SCCP2_Timer_Initialize
68:                    TMR1_Initialize();
00954A  0703A9     RCALL TMR1_Initialize
69:                    UART1_Initialize();
00954C  070177     RCALL UART1_Initialize
70:                    INTERRUPT_GlobalEnable();
71:                    INTERRUPT_Initialize();
009554  07018F     RCALL INTERRUPT_Initialize
72:                }
009556  060000     RETURN
73:                
74:                /**
75:                 End of File
76:                */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/reset.c
1:                 /**
2:                  * RESET Generated Driver Source File
3:                  * 
4:                  * @file      reset.c
5:                  *            
6:                  * @ingroup   resetdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for RESET driver
9:                  *            
10:                 * @version   Driver Version 1.0.0
11:                 *            
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                
15:                /*
16:                © [2023] Microchip Technology Inc. and its subsidiaries.
17:                
18:                    Subject to your compliance with these terms, you may use Microchip 
19:                    software and any derivatives exclusively with Microchip products. 
20:                    You are responsible for complying with 3rd party license terms  
21:                    applicable to your use of 3rd party software (including open source  
22:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
23:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
24:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
25:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
26:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
27:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
28:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
29:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
30:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
31:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
32:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
33:                    THIS SOFTWARE.
34:                */
35:                
36:                #include <stdbool.h>
37:                #include <stdint.h>
38:                #include <xc.h>
39:                #include "../reset.h"
40:                
41:                // Section: File specific functions
42:                
43:                
44:                /**
45:                 @ingroup  resetdriver
46:                 @static   RESET cause from trap
47:                 @brief    RESET cause from trap
48:                */
49:                static bool RESET_CauseFromTrap(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
50:                {
51:                    bool resetStatus = false;
52:                    
53:                    if((uint16_t)(resetCause & (uint16_t) RESET_MASK_TRAPR) == (uint16_t) RESET_MASK_TRAPR)
54:                    { 
55:                        resetStatus = true; 
56:                    }
57:                    
58:                    return resetStatus;
59:                }
000002  000000     NOP
60:                
61:                /**
62:                 @ingroup  resetdriver
63:                 @static   RESET cause from Illegal Opcode
64:                 @brief    RESET cause from Illegal Opcode   
65:                */
66:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
67:                {
68:                    bool resetStatus = false;
69:                    
70:                    if((uint16_t)(resetCause & (uint16_t) RESET_MASK_IOPUWR) == (uint16_t) RESET_MASK_IOPUWR)
71:                    { 
72:                        resetStatus = true; 
73:                    }
74:                    
75:                    return resetStatus;
76:                }
000008  000B4A     NOP
00000A  000BD2     NOP
77:                
78:                /**
79:                 @ingroup  resetdriver
80:                 @static   RESET cause from Configuration Mismatch
81:                 @brief    RESET cause from Configuration Mismatch  
82:                */
83:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
84:                {
85:                    bool resetStatus = false;
86:                    
87:                    if((uint16_t)(resetCause & (uint16_t) RESET_MASK_CM) == (uint16_t) RESET_MASK_CM)
88:                    { 
89:                        resetStatus = true; 
90:                    }
91:                    
92:                    return resetStatus;
93:                }
000004  000B9A     NOP
000006  000B2E     NOP
94:                
95:                /**
96:                 @ingroup  resetdriver
97:                 @static   RESET cause from External
98:                 @brief    RESET cause from External  
99:                */
100:               static bool RESET_CauseFromExternal(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
101:               {
102:                   bool resetStatus = false;
103:                   
104:                   if((uint16_t)(resetCause & (uint16_t) RESET_MASK_EXTR) == (uint16_t) RESET_MASK_EXTR)
105:                   { 
106:                       resetStatus = true; 
107:                   }
108:                   
109:                   return resetStatus;
110:               }
000004  000B9A     NOP
000006  000B2E     NOP
111:               
112:               /**
113:                @ingroup  resetdriver
114:                @static   RESET cause from Software
115:                @brief    RESET cause from Software     
116:               */
117:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
118:               {
119:                   bool resetStatus = false;
120:                   
121:                   if((uint16_t)(resetCause & (uint16_t) RESET_MASK_SWR) == (uint16_t) RESET_MASK_SWR)
122:                   { 
123:                       resetStatus = true; 
124:                   }
125:                   
126:                   return resetStatus;
127:               }
000004  000B9A     NOP
000006  000B2E     NOP
128:               
129:               /**
130:                @ingroup  resetdriver
131:                @static   RESET cause from Watchdog Time
132:                @brief    RESET cause from Watchdog Time  
133:               */
134:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
000000  040200     GOTO __resetPRI, __reset
135:               {
136:                   bool resetStatus = false;
137:                   
138:                   if((uint16_t)(resetCause & (uint16_t) RESET_MASK_WDTO) == (uint16_t) RESET_MASK_WDTO)
139:                   { 
140:                     resetStatus = true;
141:                   }
142:                   
143:                   return resetStatus;
144:               }
000004  000B9A     NOP
000006  000B2E     NOP
145:               
146:               /**
147:                @ingroup  resetdriver
148:                @static   RESET cause from Clear
149:                @brief    RESET cause from Clear    
150:               */
151:               static void RESET_CauseClear(enum RESET_MASKS resetFlagMask)
152:               { 
153:                    RCON = RCON & (~resetFlagMask); 
000000  040200     GOTO __resetPRI, __reset
154:               } 
000006  000B2E     NOP
000008  000B4A     NOP
155:               
156:               uint16_t RESET_CauseGet(void)
157:               {
158:                   return RCON;
000000  040200     GOTO __resetPRI, __reset
159:               }
000002  000000     NOP
000004  000B9A     NOP
160:               
161:               void __attribute__ ((weak)) RESET_CauseHandler(void)
162:               {
000000  040200     GOTO __resetPRI, __reset
163:                   uint16_t resetCause = RESET_CauseGet();
000002  000000     NOP
164:                   
165:                   if(RESET_CauseFromTrap(resetCause))
000006  000B2E     NOP
166:                   { 
167:                       RESET_CauseClear(RESET_MASK_TRAPR);
00000E  000920     NOP
168:                   }
169:                   
170:                   if(RESET_CauseFromIllegalOpcode(resetCause))
000012  00091A     NOP
171:                   { 
172:                       RESET_CauseClear(RESET_MASK_IOPUWR); 
00001A  000920     NOP
173:                   }
174:                   
175:                   if(RESET_CauseFromConfigurationMismatch(resetCause))
00001E  000920     NOP
176:                   { 
177:                       RESET_CauseClear(RESET_MASK_CM); 
000026  000920     NOP
178:                   }
179:                   
180:                   if(RESET_CauseFromExternal(resetCause))
00002A  000C36     NOP
181:                   { 
182:                       RESET_CauseClear(RESET_MASK_EXTR); 
000032  000920     NOP
183:                   }
184:                   
185:                   if(RESET_CauseFromSoftware(resetCause))
000036  000920     NOP
186:                   { 
187:                       RESET_CauseClear(RESET_MASK_SWR); 
00003E  000920     NOP
188:                   }
189:                   
190:                   if(RESET_CauseFromWatchdogTimer(resetCause))
000042  000920     NOP
191:                   { 
192:                       RESET_CauseClear(RESET_MASK_WDTO); 
00004A  000920     NOP
193:                   }
194:               }
00004E  000920     NOP
000050  000920     NOP
000052  000920     NOP
000054  000920     NOP
195:               
196:               void RESET_CauseClearAll()
197:               { 
198:                   RCON = 0x00; 
000000  040200     GOTO __resetPRI, __reset
199:               }
000002  000000     NOP
000004  000B9A     NOP
200:               /**
201:                End of File
202:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/pins.c
1:                 /**
2:                  * PINS Generated Driver Source File 
3:                  * 
4:                  * @file      pins.c
5:                  *            
6:                  * @ingroup   pinsdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for PINS driver.
9:                  *
10:                 * @version   Firmware Driver Version 1.0.1
11:                 *
12:                 * @version   PLIB Version 1.1.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Includes
39:                #include <xc.h>
40:                #include <stddef.h>
41:                #include "../pins.h"
42:                
43:                // Section: File specific functions
44:                
45:                // Section: Driver Interface Function Definitions
46:                void PINS_Initialize(void)
47:                {
48:                    /****************************************************************************
49:                     * Setting the Output Latch SFR(s)
50:                     ***************************************************************************/
51:                    LATA = 0x0000;
008162  EF2E06     CLR LATA
52:                    LATB = 0x0000;
008164  EF2E22     CLR LATB
53:                    LATC = 0x0000;
008166  EF2E3E     CLR LATC
54:                    LATD = 0x0000;
008168  EF2E5A     CLR LATD
55:                    LATE = 0x0000;
00816A  EF2E76     CLR LATE
56:                
57:                    /****************************************************************************
58:                     * Setting the GPIO Direction SFR(s)
59:                     ***************************************************************************/
60:                    TRISA = 0x000E;
00816C  2000E0     MOV #0xE, W0
00816E  887010     MOV W0, TRISA
61:                    TRISB = 0x0FFB;
008170  20FFB0     MOV #0xFFB, W0
008172  8870F0     MOV W0, TRISB
62:                    TRISC = 0xFFFF;
008174  EFAE3A     SETM TRISC
63:                    TRISD = 0xDFFC;
008176  2DFFC0     MOV #0xDFFC, W0
008178  8872B0     MOV W0, TRISD
64:                    TRISE = 0xFF2F;
00817A  2FF2F0     MOV #0xFF2F, W0
00817C  887390     MOV W0, TRISE
65:                
66:                
67:                    /****************************************************************************
68:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
69:                     ***************************************************************************/
70:                    CNPUA = 0x0000;
00817E  EF2E0A     CLR CNPUA
71:                    CNPUB = 0x0000;
008180  EF2E26     CLR CNPUB
72:                    CNPUC = 0x0000;
008182  EF2E42     CLR CNPUC
73:                    CNPUD = 0x0000;
008184  EF2E5E     CLR CNPUD
74:                    CNPUE = 0x0000;
008186  EF2E7A     CLR CNPUE
75:                    CNPDA = 0x0000;
008188  EF2E0C     CLR CNPDA
76:                    CNPDB = 0x0000;
00818A  EF2E28     CLR CNPDB
77:                    CNPDC = 0x0000;
00818C  EF2E44     CLR CNPDC
78:                    CNPDD = 0x0000;
00818E  EF2E60     CLR CNPDD
79:                    CNPDE = 0x0000;
008190  EF2E7C     CLR CNPDE
80:                
81:                
82:                    /****************************************************************************
83:                     * Setting the Open Drain SFR(s)
84:                     ***************************************************************************/
85:                    ODCA = 0x0000;
008192  EF2E08     CLR ODCA
86:                    ODCB = 0x0000;
008194  EF2E24     CLR ODCB
87:                    ODCC = 0x0000;
008196  EF2E40     CLR ODCC
88:                    ODCD = 0x0000;
008198  EF2E5C     CLR ODCD
89:                    ODCE = 0x0000;
00819A  EF2E78     CLR ODCE
90:                
91:                
92:                    /****************************************************************************
93:                     * Setting the Analog/Digital Configuration SFR(s)
94:                     ***************************************************************************/
95:                    ANSELA = 0x001F;
00819C  2001F0     MOV #0x1F, W0
00819E  887000     MOV W0, ANSELA
96:                    ANSELB = 0x039F;
0081A0  2039F0     MOV #0x39F, W0
0081A2  8870E0     MOV W0, ANSELB
97:                    ANSELC = 0x00CF;
0081A4  200CF0     MOV #0xCF, W0
0081A6  8871C0     MOV W0, ANSELC
98:                    ANSELD = 0x0C00;
0081A8  20C000     MOV #0xC00, W0
0081AA  8872A0     MOV W0, ANSELD
99:                    ANSELE = 0x000F;
0081AC  2000F0     MOV #0xF, W0
0081AE  887380     MOV W0, ANSELE
100:               
101:                   /****************************************************************************
102:                    * Set the PPS
103:                    ***************************************************************************/
104:                    __builtin_write_RPCON(0x0000); // unlock PPS
0081B0  EB0000     CLR W0
0081B2  200551     MOV #0x55, W1
0081B4  8846B1     MOV W1, NVMKEY
0081B6  200AA1     MOV #0xAA, W1
0081B8  8846B1     MOV W1, NVMKEY
0081BA  886800     MOV W0, RPCON
105:               
106:                       RPINR15bits.QEINDX1R = 0x003E; //RC14->QEI1:INDX1;
0081BC  B3C3E0     MOV.B #0x3E, W0
0081BE  B7ED22     MOV.B WREG, RPINR15
107:                       RPINR14bits.QEIA1R = 0x003C; //RC12->QEI1:QEA1;
0081C0  B3C3C0     MOV.B #0x3C, W0
0081C2  B7ED20     MOV.B WREG, RPINR14
108:                       RPINR14bits.QEIB1R = 0x003D; //RC13->QEI1:QEB1;
0081C4  B3C3D0     MOV.B #0x3D, W0
0081C6  B7ED21     MOV.B WREG, 0xD21
109:                       RPINR18bits.U1RXR = 0x004E; //RD14->UART1:U1RX;
0081C8  B3C4E0     MOV.B #0x4E, W0
0081CA  B7ED28     MOV.B WREG, RPINR18
110:                       RPOR22bits.RP77R = 0x0001;  //RD13->UART1:U1TX;
0081CC  2C0FF0     MOV #0xC0FF, W0
0081CE  B60DAC     AND RPOR22, WREG
0081D0  A08000     BSET W0, #8
0081D2  886D60     MOV W0, RPOR22
111:               
112:                    __builtin_write_RPCON(0x0800); // lock PPS
0081D4  208000     MOV #0x800, W0
0081D6  200551     MOV #0x55, W1
0081D8  8846B1     MOV W1, NVMKEY
0081DA  200AA1     MOV #0xAA, W1
0081DC  8846B1     MOV W1, NVMKEY
0081DE  886800     MOV W0, RPCON
113:               
114:               
115:               }
0081E0  060000     RETURN
116:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/interrupt.c
1:                 /**
2:                  * INTERRUPT Generated Driver Source File 
3:                  * 
4:                  * @file      interrupt.c
5:                  *            
6:                  * @ingroup   interruptdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for INTERRUPT driver
9:                  *            
10:                 * @version   Driver Version 1.1.0
11:                 *            
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                
15:                /*
16:                © [2023] Microchip Technology Inc. and its subsidiaries.
17:                
18:                    Subject to your compliance with these terms, you may use Microchip 
19:                    software and any derivatives exclusively with Microchip products. 
20:                    You are responsible for complying with 3rd party license terms  
21:                    applicable to your use of 3rd party software (including open source  
22:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
23:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
24:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
25:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
26:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
27:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
28:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
29:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
30:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
31:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
32:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
33:                    THIS SOFTWARE.
34:                */
35:                
36:                // Section: Includes
37:                #include <xc.h>
38:                #include "../interrupt.h"
39:                
40:                // Section: Driver Interface Function Definitions
41:                
42:                void INTERRUPT_Initialize(void)
43:                {
44:                    // DMT: Dead Man Timer
45:                    // Priority: 1
46:                    IPC11bits.DMTIP = 1;
009874  2FF8F0     MOV #0xFF8F, W0
009876  B60856     AND IPC11, WREG
009878  A04000     BSET W0, #4
00987A  8842B0     MOV W0, IPC11
47:                    
48:                    // CCT1: CCP1 Timer Event
49:                    // Priority: 1
50:                    IPC1bits.CCT1IP = 1;
00987C  28FFF0     MOV #0x8FFF, W0
00987E  B60842     AND IPC1, WREG
009880  A0C000     BSET W0, #12
009882  884210     MOV W0, IPC1
51:                    
52:                    // CCT2: CCP2 Timer Event
53:                    // Priority: 1
54:                    IPC6bits.CCT2IP = 1;
009884  2FFF80     MOV #0xFFF8, W0
009886  B6084C     AND IPC6, WREG
009888  A00000     BSET W0, #0
00988A  884260     MOV W0, IPC6
55:                    
56:                }
00988C  060000     RETURN
57:                
58:                void INTERRUPT_Deinitialize(void)
59:                {
60:                    //POR default value of priority
61:                    IPC11bits.DMTIP = 4;
000000  040200     GOTO __resetPRI, __reset
62:                    IPC1bits.CCT1IP = 4;
000008  000B4A     NOP
63:                    IPC6bits.CCT2IP = 4;
000010  000B66     NOP
64:                }
000018  000920     NOP
00001A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/dmt_asm.s
                                                  1:     ;/*******************************************************************************
                                                  2:     ;
                                                  3:     ;DMT Generated Driver Header File
                                                  4:     ; 
                                                  5:     ; @file      dmt_asm.s
                                                  6:     ; 
                                                  7:     ; @defgroup  dmtdriver DMT Driver
                                                  8:     ; 
                                                  9:     ; @brief     Assembly language optimized helper routines required for calibration
                                                  10:    ;
                                                  11:    ; @version   Driver Version 1.1.0
                                                  12:    ;
                                                  13:    ; @skipline  Device : dsPIC33CK256MP508
                                                  14:    ;
                                                  15:    ;*******************************************************************************/
                                                  16:    ;
                                                  17:    ;// DOM-IGNORE-BEGIN
                                                  18:    ;/*******************************************************************************
                                                  19:    ;  Copyright (C) 2016 Microchip Technology Inc.
                                                  20:    ;
                                                  21:    ;  MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any
                                                  22:    ;  derivatives created by any person or entity by or on your behalf, exclusively
                                                  23:    ;  with Microchip's products.  Microchip and its licensors retain all ownership
                                                  24:    ;  and intellectual property rights in the accompanying software and in all
                                                  25:    ;  derivatives here to.
                                                  26:    ;
                                                  27:    ;  This software and any accompanying information is for suggestion only.  It
                                                  28:    ;  does not modify Microchip's standard warranty for its products.  You agree
                                                  29:    ;  that you are solely responsible for testing the software and determining its
                                                  30:    ;  suitability.  Microchip has no obligation to modify, test, certify, or
                                                  31:    ;  support the software.
                                                  32:    ;
                                                  33:    ;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
                                                  34:    ;  EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
                                                  35:    ;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
                                                  36:    ;  PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S PRODUCTS,
                                                  37:    ;  COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
                                                  38:    ;
                                                  39:    ;  IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
                                                  40:    ;  (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
                                                  41:    ;  INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
                                                  42:    ;  EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
                                                  43:    ;  ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
                                                  44:    ;  MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
                                                  45:    ;  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
                                                  46:    ;  CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
                                                  47:    ;  FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
                                                  48:    ;
                                                  49:    ;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
                                                  50:    ;  TERMS.
                                                  51:    ;*******************************************************************************/
                                                  52:    
                                                  53:    
                                                  54:    /**
                                                  55:     * ;uint32_t  DMT_CalibratedCounterGet(void);
                                                  56:     * Gets the count of DMT counter just before calling CalibratedCounterGet function
                                                  57:     *
                                                  58:     * @return   32-bit (unsigned long) caliberated count
                                                  59:     *                      
                                                  60:     *   Registers used:  w0 w1 w2
                                                  61:     *
                                                  62:     */
                                                  63:    
                                                  64:        .global         _DMT_CounterGet
                                                  65:        .global         _DMT_CalibratedCounterGet
                                                  66:        .global	        _calibOffset
                                                  67:        .type           _DMT_CalibratedCounterGet, @function
0091C6  FE0000     RESET                          68:        reset
                                                  69:        
                                                  70:     _DMT_CalibratedCounterGet:
0091C8  0704E7     RCALL 0x9B98                   71:            rcall _DMT_CounterGet
0091CA  781F82     MOV W2, [W15++]                72:            push w2
0091CC  809212     MOV 0x1242, W2                 73:            mov _calibOffset, w2
0091CE  110000     SUBR W2, W0, W0                74:            SUBR w2, w0, w0
0091D0  200002     MOV #0x0, W2                   75:            mov #0x0, w2
0091D2  190081     SUBBR W2, W1, W1               76:            SUBBR w2, w1, w1
0091D4  78014F     MOV [--W15], W2                77:            pop w2
0091D6  060000     RETURN                         78:            return
                                                  79:        
                                                  80:    /**
                                                  81:     * ;void  DMT_Calibrate(void);
                                                  82:     * Calculates and stores offset value during DMT_CounterGet function call
                                                  83:     *                      
                                                  84:     *   Registers used:  w0 w1 w2
                                                  85:     *
                                                  86:     */    
                                                  87:        
                                                  88:        .global         _DMT_CounterGet
                                                  89:        .global         _DMT_Calibrate
                                                  90:        .global	        _calibOffset
                                                  91:        .type           _DMT_Calibrate, @function
                                                  92:        .extern         DMTCNTL
0091D8  FE0000     RESET                          93:        reset
                                                  94:        
                                                  95:     _DMT_Calibrate:
0091DA  781F80     MOV W0, [W15++]                96:    		push w0
0091DC  781F81     MOV W1, [W15++]                97:    		push w1
0091DE  781F82     MOV W2, [W15++]                98:    		push w2
0091E0  800360     MOV DMTCNTL, W0                99:    		mov DMTCNTL, w0
0091E2  781F80     MOV W0, [W15++]                100:   		push w0
0091E4  0704D9     RCALL 0x9B98                   101:   		rcall _DMT_CounterGet
0091E6  78014F     MOV [--W15], W2                102:   		pop w2
0091E8  500102     SUB W0, W2, W2                 103:   		sub w0, w2, w2
0091EA  E90102     DEC W2, W2                     104:   		dec w2, w2
0091EC  889212     MOV W2, 0x1242                 105:   		mov w2, _calibOffset
0091EE  78014F     MOV [--W15], W2                106:   		pop w2
0091F0  7800CF     MOV [--W15], W1                107:   		pop w1
0091F2  78004F     MOV [--W15], W0                108:   		pop w0
0091F4  060000     RETURN                         109:   		return;
                                                  110:   
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/dmt.c
1:                 /**
2:                  * DMT Generated Driver Source File
3:                  * 
4:                  * @file      dmt.c
5:                  * 
6:                  * @ingroup   dmtdriver
7:                  * 
8:                  * @brief     This is the generated driver source file for DMT driver
9:                  *
10:                 * @version   Driver Version 1.1.1
11:                 *
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                
15:                /*
16:                © [2023] Microchip Technology Inc. and its subsidiaries.
17:                
18:                    Subject to your compliance with these terms, you may use Microchip 
19:                    software and any derivatives exclusively with Microchip products. 
20:                    You are responsible for complying with 3rd party license terms  
21:                    applicable to your use of 3rd party software (including open source  
22:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
23:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
24:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
25:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
26:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
27:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
28:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
29:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
30:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
31:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
32:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
33:                    THIS SOFTWARE.
34:                */
35:                
36:                // Section: Included Files
37:                #include <xc.h>
38:                #include <stddef.h>
39:                #include "../dmt.h"
40:                #include "../interrupt.h"
41:                
42:                // Section: Private Variable Definitions
43:                static bool bPreCleared = false;
44:                uint32_t calibOffset = 0;
45:                void (*DMT_EventHandler)(void) = NULL;
46:                
47:                // Section: File specific functions
48:                
49:                void DMT_Calibrate(void);
50:                
51:                // Section: DMT Module APIs
52:                void DMT_Initialize(void)
53:                {  
54:                    INTERRUPT_GlobalDisable();
55:                    DMT_Calibrate();
009A8E  07FBA5     RCALL _DMT_Calibrate
56:                    INTERRUPT_GlobalEnable();
57:                    
58:                    DMT_EventCallbackRegister(&DMT_EventCallback);
009A96  29FC60     MOV #0x9FC6, W0
009A98  0701CC     RCALL DMT_EventCallbackRegister
59:                
60:                    IEC2bits.DMTIE = 1U;
009A9A  A8A825     BSET 0x825, #5
61:                }
009A9C  060000     RETURN
009A9E  781F88     MOV W8, [W15++]
62:                
63:                void DMT_Enable(void)
64:                {   
65:                    // Set the Bit ON = 1
66:                    DMTCON = 0x8000;
000000  040200     GOTO __resetPRI, __reset
67:                }
000004  000B9A     NOP
000006  000B2E     NOP
68:                
69:                void DMT_PreClear(void)
70:                {
71:                    DMTPRECLR =  0x4000;  
000000  040200     GOTO __resetPRI, __reset
72:                  
73:                    // To keep track of Preclear operation is performed
74:                    bPreCleared = true;
000004  000B9A     NOP
75:                }
000008  000B4A     NOP
00000A  000BD2     NOP
76:                
77:                void DMT_Clear(void)
78:                {
79:                    bPreCleared = false;
000000  040200     GOTO __resetPRI, __reset
80:                    while((DMTSTAT & 0x0001) != 0x0001)
000002  000000     NOP
81:                    {
82:                    }
83:                    
84:                    DMTCLR = 0x0008;
000006  000B2E     NOP
85:                }
00000A  000BD2     NOP
00000C  000BB6     NOP
86:                
87:                bool DMT_IsWindowOpen(void)
000002  000000     NOP
88:                {
89:                    bool status = false;
90:                    
91:                    if((DMTSTAT & 0x0001) == 0x0001)
000000  040200     GOTO __resetPRI, __reset
92:                    {
93:                        status = true;
94:                    }
95:                    
96:                    return status;    
97:                }
000004  000B9A     NOP
000006  000B2E     NOP
98:                
99:                bool DMT_IsPreCleared(void)
100:               {
101:                   return bPreCleared;
102:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
103:               
104:               uint32_t DMT_TimeoutCounterGet(void)
105:               {
106:                   uint32_t counter = 0;    
107:                   counter = (uint32_t)(DMTPSCNTH & 0x0000FFFF) << 16;    
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
108:                   return (counter | DMTPSCNTL);
000002  000000     NOP
00000A  000BD2     NOP
109:               }
000010  000B66     NOP
000012  00091A     NOP
110:               
111:               uint32_t DMT_WindowTimeoutCounterGet(void) 
112:               {    
113:                   uint32_t winTimeoutCounter = 0;    
114:                   winTimeoutCounter = (uint32_t)(DMTPSINTVH & 0x0000FFFF) << 16;    
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
115:                   return (winTimeoutCounter | DMTPSINTVL);
000002  000000     NOP
000004  000B9A     NOP
00000A  000BD2     NOP
116:               }
000010  000B66     NOP
000012  00091A     NOP
117:               
118:               uint16_t DMT_StatusGet(void) 
119:               {   
120:                   uint16_t status = 0;
121:                   status = (uint16_t)(DMTSTAT & 0xE1);
000000  040200     GOTO __resetPRI, __reset
122:                   return status;
123:               }
000004  000B9A     NOP
000006  000B2E     NOP
124:               
125:               uint32_t DMT_CounterGet(void)
126:               {   
127:                   uint32_t counter = 0;    
128:                   counter = (uint32_t)(DMTCNTH & 0x0000FFFF) << 16;
009B98  800370     MOV DMTCNTH, W0
009B9C  EB0080     CLR W1
009B9E  DD00C0     SL W0, #0, W1
009BA0  200000     MOV #0x0, W0
129:                   return (counter | DMTCNTL);
009B9A  800362     MOV DMTCNTL, W2
009BA2  EB0180     CLR W3
009BA4  700002     IOR W0, W2, W0
009BA6  708083     IOR W1, W3, W1
130:               }
009BA8  060000     RETURN
009BAA  EF2238     CLR U1MODE
131:               
132:               void DMT_EventCallbackRegister(void* handler)
133:               {
134:                   if(NULL != handler)
009E32  E00000     CP0 W0
009E34  320001     BRA Z, .L13
135:                   {
136:                       DMT_EventHandler = handler;
009E36  889230     MOV W0, DMT_EventHandler
137:                   }
138:               }
009E38  060000     RETURN
009E3A  A9E800     BCLR IFS0, #7
139:               
140:               void __attribute__ ((weak)) DMT_EventCallback( void )
141:               { 
142:               
143:               } 
009FC6  060000     RETURN
144:               
145:               
146:               void __attribute__ ((interrupt, no_auto_psv)) _DMTInterrupt(void)
147:               {
000B0E  F80036     PUSH RCOUNT
000B10  BE9F80     MOV.D W0, [W15++]
000B12  BE9F82     MOV.D W2, [W15++]
000B14  BE9F84     MOV.D W4, [W15++]
000B16  BE9F86     MOV.D W6, [W15++]
148:                   if(NULL != DMT_EventHandler)
000B18  809230     MOV DMT_EventHandler, W0
000B1A  E00000     CP0 W0
000B1C  320001     BRA Z, .L17
149:                   {
150:                       (*DMT_EventHandler)();
000B1E  010000     CALL W0
151:                   }
152:                   IFS2bits.DMTIF = 0U;
000B20  A9A805     BCLR 0x805, #5
153:               }
000B22  BE034F     MOV.D [--W15], W6
000B24  BE024F     MOV.D [--W15], W4
000B26  BE014F     MOV.D [--W15], W2
000B28  BE004F     MOV.D [--W15], W0
000B2A  F90036     POP RCOUNT
000B2C  064000     RETFIE
000B2E  F80036     PUSH RCOUNT
154:               
155:               /**
156:                End of File
157:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/src/clock.c
1:                 /**
2:                  * CLOCK Generated Driver Source File 
3:                  * 
4:                  * @file      clock.c
5:                  *            
6:                  * @ingroup   clockdriver
7:                  *            
8:                  * @brief     This is the generated source file for CLOCK driver
9:                  *
10:                 * @version   Firmware Driver Version 1.0.2
11:                 *
12:                 * @version   PLIB Version 1.4.0-dev.1
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Includes
39:                #include <xc.h>
40:                #include <stdint.h>
41:                #include "../clock.h"
42:                
43:                void CLOCK_Initialize(void)
44:                {
45:                    /*  
46:                       Input frequency                               :  8.00 MHz
47:                       Clock source                                  :  FRC Oscillator with PLL
48:                       System frequency (Fosc)                       :  200.00 MHz [(8.00 MHz / 1) * 50 / 1 / 2 = 200.00 MHz]
49:                       PLL VCO frequency (Fvco)                      :  400.00 MHz [(8.00 MHz / 1) * 50 = 400.00 MHz]
50:                       PLL output frequency (Fpllo)                  :  400.00 MHz [(8.00 MHz / 1) * 50 / 1 = 400.00 MHz]
51:                       PLL VCO divider frequency (Fvcodiv)           :  100.00 MHz [400.00 MHz / 4 = 100.00 MHz]
52:                       Clock switching enabled                       :  true
53:                       Clock source when device boots                :  FRC Oscillator
54:                       Auxiliary clock source                        :  FRC Oscillator
55:                       Auxiliary clock input frequency               :  8.00 MHz
56:                       Auxiliary clock PLL output frequency (AFpllo) :  8.00 MHz
57:                    */
58:                    // RCDIV FRC/1; PLLPRE 1:1; DOZE 1:8; DOZEN disabled; ROI disabled; 
59:                    CLKDIV = 0x3001;
0087F8  230010     MOV #0x3001, W0
60:                    // PLLDIV 50; 
61:                    PLLFBD = 0x32;
0087FC  200320     MOV #0x32, W0
0087FE  887C40     MOV W0, PLLFBD
62:                    // TUN Center frequency; 
63:                    OSCTUN = 0x0;
008800  EF2F8C     CLR OSCTUN
64:                    // PLLPOST 1:1; VCODIV FVCO/4; POST2DIV 1:1; 
65:                    PLLDIV = 0x11;
008802  200110     MOV #0x11, W0
008804  887C50     MOV W0, PLLDIV
66:                    // ENAPLL disabled; FRCSEL FRC Oscillator; APLLPRE 1:1; 
67:                    ACLKCON1 = 0x101;
008806  201010     MOV #0x101, W0
008808  887C70     MOV W0, ACLKCON1
68:                    // APLLFBDIV 150; 
69:                    APLLFBD1 = 0x96;
00880A  200960     MOV #0x96, W0
00880C  887C80     MOV W0, APLLFBD1
70:                    // APSTSCLR 1:4; APOST2DIV 1:1; AVCODIV FVCO/4; 
71:                    APLLDIV1 = 0x41;
00880E  200410     MOV #0x41, W0
008810  887C90     MOV W0, APLLDIV1
72:                    // CANCLKEN disabled; CANCLKSEL FVCO/4; CANCLKDIV Divide by 1; 
73:                    CANCLKCON = 0x500;
008812  205000     MOV #0x500, W0
008814  887CD0     MOV W0, CANCLKCON
74:                    // ROEN disabled; DIVSWEN disabled; ROSLP disabled; ROSEL ; OE disabled; ROSIDL disabled; 
75:                    REFOCONL = 0x0;
008816  EF2FB8     CLR REFOCONL
76:                    // RODIV 0; 
77:                    REFOCONH = 0x0;
008818  EF2FBA     CLR REFOCONH
78:                    // ROTRIM 0; 
79:                    REFOTRIMH = 0x0;
00881A  EF2FBE     CLR REFOTRIMH
80:                    // IOLOCK disabled; 
81:                    RPCON = 0x0;
00881C  EF2D00     CLR RPCON
82:                    // PMDLOCK disabled; 
83:                    PMDCON = 0x0;
00881E  EF2FA0     CLR PMDCON
84:                    // ADC1MD enabled; T1MD enabled; U2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; QEIMD enabled; PWMMD enabled; I2C1MD enabled; C1MD enabled; 
85:                    PMD1 = 0x0;
008820  EF2FA4     CLR PMD1
86:                    // CCP2MD enabled; CCP1MD enabled; CCP4MD enabled; CCP3MD enabled; CCP7MD enabled; CCP8MD enabled; CCP5MD enabled; CCP6MD enabled; CCP9MD enabled; 
87:                    PMD2 = 0x0;
008822  EF2FA6     CLR PMD2
88:                    // U3MD enabled; CRCMD enabled; I2C2MD enabled; I2C3MD enabled; QEI2MD enabled; PMPMD enabled; 
89:                    PMD3 = 0x0;
008824  EF2FA8     CLR PMD3
90:                    // REFOMD enabled; 
91:                    PMD4 = 0x0;
008826  EF2FAA     CLR PMD4
92:                    // DMA1MD enabled; DMA2MD enabled; DMA3MD enabled; DMA0MD enabled; SPI3MD enabled; 
93:                    PMD6 = 0x0;
008828  EF2FAE     CLR PMD6
94:                    // PTGMD enabled; CMP1MD enabled; CMP3MD enabled; CMP2MD enabled; 
95:                    PMD7 = 0x0;
00882A  EF2FB0     CLR PMD7
96:                    // DMTMD enabled; CLC3MD enabled; OPAMPMD enabled; BIASMD enabled; CLC4MD enabled; SENT1MD enabled; CLC1MD enabled; CLC2MD enabled; SENT2MD enabled; 
97:                    PMD8 = 0x0;
00882C  EF2FB2     CLR PMD8
98:                    // CF no clock failure; NOSC FRCPLL; CLKLOCK unlocked; OSWEN Switch is Complete; 
99:                    __builtin_write_OSCCONH((uint8_t) (0x01));
00882E  200010     MOV #0x1, W0
008830  2009A2     MOV #0x9A, W2
008832  200781     MOV #0x78, W1
008834  20F853     MOV #0xF85, W3
008836  784981     MOV.B W1, [W3]
008838  784982     MOV.B W2, [W3]
00883A  784980     MOV.B W0, [W3]
100:                   __builtin_write_OSCCONL((uint8_t) (0x01));
00883C  200572     MOV #0x57, W2
00883E  200461     MOV #0x46, W1
008840  20F843     MOV #0xF84, W3
008842  784981     MOV.B W1, [W3]
008844  784982     MOV.B W2, [W3]
008846  784980     MOV.B W0, [W3]
101:                   // Wait for Clock switch to occur
102:                   while (OSCCONbits.OSWEN != 0);
008848  AB0F84     BTST OSCCON, #0
00884A  3AFFFE     BRA NZ, .L2
103:                   while (OSCCONbits.LOCK != 1);
00884C  200201     MOV #0x20, W1
00884E  807C22     MOV OSCCON, W2
008850  608002     AND W1, W2, W0
008852  32FFFD     BRA Z, .L4
104:               }
008854  060000     RETURN
105:               
106:               bool CLOCK_AuxPllLockStatusGet(void)
107:               {
108:                   return ACLKCON1bits.APLLCK;
000000  040200     GOTO __resetPRI, __reset
109:               }
000004  000B9A     NOP
000006  000B2E     NOP
110:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/system/interrupt.h
1:                 /**
2:                  * INTERRUPT Generated Driver Header File 
3:                  * 
4:                  * @file      interrupt.h
5:                  *            
6:                  * @defgroup  interruptdriver Interrupt Driver
7:                  *            
8:                  * @brief     Interrupt Priority configuration driver using dsPIC MCUs.
9:                  *            
10:                 * @version   Driver Version 1.1.0
11:                 *            
12:                 * @skipline  Device : dsPIC33CK256MP508
13:                */
14:                
15:                /*
16:                © [2023] Microchip Technology Inc. and its subsidiaries.
17:                
18:                    Subject to your compliance with these terms, you may use Microchip 
19:                    software and any derivatives exclusively with Microchip products. 
20:                    You are responsible for complying with 3rd party license terms  
21:                    applicable to your use of 3rd party software (including open source  
22:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
23:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
24:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
25:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
26:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
27:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
28:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
29:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
30:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
31:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
32:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
33:                    THIS SOFTWARE.
34:                */
35:                
36:                #ifndef INTERRUPT_H
37:                #define INTERRUPT_H
38:                
39:                // Section: Driver Interface Function
40:                
41:                /**
42:                 * @ingroup  interruptdriver
43:                 * @brief    Initializes the interrupt priorities of the modules that have been configured
44:                 * @return   none  
45:                 */
46:                void INTERRUPT_Initialize(void);
47:                
48:                /**
49:                 * @ingroup  interruptdriver
50:                 * @brief    Deinitializes the INTERRUPT to POR values
51:                 * @return   none  
52:                 */
53:                void INTERRUPT_Deinitialize(void);
54:                
55:                /**
56:                 * @ingroup  interruptdriver
57:                 * @brief    Enables the global interrupt bit
58:                 * @return   none  
59:                 */
60:                inline static void INTERRUPT_GlobalEnable(void)
61:                {
62:                    __builtin_enable_interrupts();
00954E  A8E8C3     BSET 0x8C3, #7
009550  000000     NOP
009552  000000     NOP
009A90  A8E8C3     BSET 0x8C3, #7
009A92  000000     NOP
009A94  000000     NOP
63:                }
64:                
65:                /**
66:                 * @ingroup  interruptdriver
67:                 * @brief    Disables the global interrupt bit
68:                 * @return   none  
69:                 */
70:                inline static void INTERRUPT_GlobalDisable(void)
71:                {
72:                    __builtin_disable_interrupts();
009A88  A9E8C3     BCLR 0x8C3, #7
73:                }
74:                
75:                /**
76:                 * @ingroup  interruptdriver
77:                 * @brief    Returns the pending Interrupt Vector number
78:                 * @return   Returns the pending Interrupt Vector number  
79:                 */
80:                inline static uint16_t INTERRUPT_VectorNumberGet(void)
81:                {
82:                    return _VECNUM; 
83:                }
84:                
85:                #endif
86:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/qei/src/qei1.c
1:                 /**
2:                  * QEI1 Generated Driver Source File 
3:                  * 
4:                  * @file      qei1.c
5:                  *            
6:                  * @ingroup   qeidriver
7:                  *            
8:                  * @brief     This is the generated driver source file for QEI1 driver
9:                  *            
10:                 * @version   Firmware Driver Version 1.2.2
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *            
14:                 * @skipline  Device : PIC24/dspIC/PIC32MM
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #include "../qei1.h"
39:                
40:                
41:                // Section: Driver Interface
42:                
43:                const struct QEI_INTERFACE MCC_QEI = {
44:                    .Initialize = &QEI1_Initialize,
45:                    .Deinitialize = &QEI1_Deinitialize,
46:                    .Enable = &QEI1_Enable,
47:                    .Disable = &QEI1_Disable,
48:                    .PositionCountRead = &QEI1_PositionCountRead,
49:                    .PositionCount16bitRead = &QEI1_PositionCount16bitRead,
50:                    .PositionCountWrite = &QEI1_PositionCountWrite,
51:                    .ModuloRangeSet = &QEI1_ModuloRangeSet,
52:                    .PhaseInputSwappedGet = &QEI1_PhaseInputSwappedGet,
53:                    .PhaseInputSwappedSet = &QEI1_PhaseInputSwappedSet,
54:                    .PositionCaptureEnable = &QEI1_PositionCaptureEnable,
55:                    .PositionCaptureDisable = &QEI1_PositionCaptureDisable,
56:                    .PositionCaptureGet = &QEI1_PositionCaptureGet,
57:                    .PositionCapture16bitGet = &QEI1_PositionCapture16bitGet,
58:                    .PositionCaptureSet = &QEI1_PositionCaptureSet,
59:                    .CounterModeSet = &QEI1_CounterModeSet,
60:                    .IMVGatedValueSet = &QEI1_IMVGatedValueSet
61:                };
62:                
63:                // Section: QEI1 Module APIs
64:                
65:                void QEI1_Initialize(void)
66:                {
67:                    /* CCM Quadrature Encoder mode; GATEN disabled; CNTPOL Positive; INTDIV 1:1; IMV Index match occurs when QEBx = 0 and QEAx = 0; PIMOD Modulo Count mode; QEISIDL disabled; QEIEN disabled; */
68:                    QEI1CON = 0x1800;
0090FE  218000     MOV #0x1800, W0
009100  880A00     MOV W0, QEI1CON
69:                    /* QEAPOL disabled; QEBPOL disabled; IDXPOL disabled; HOMPOL disabled; SWPAB disabled; OUTFNC disabled; QFDIV 1:; FLTREN enabled; QCAPEN ; */
70:                    QEI1IOC = 0x4000;
009102  240000     MOV #0x4000, W0
009104  880A20     MOV W0, QEI1IOC
71:                    /* HCAPEN ; */
72:                    QEI1IOCH = 0x0;
009106  EF2146     CLR QEI1IOCH
73:                    /* IDXIEN disabled; IDXIRQ No index event has occured; HOMIEN disabled; HOMIRQ No home event has occured; VELOVIEN disabled; VELOVIRQ No overflow has occured; PCIIEN disabled; PCIIRQ POSxCNT was not reinitialized; POSOVIEN disabled; POSOVIRQ No overflow has occured; PCLEQIEN disabled; PCLEQIRQ POSxCNT less than QEIxLEC; PCHEQIEN disabled; PCHEQIRQ POSxCNT less than QEIxGEC; */
74:                    QEI1STAT = 0x0;
009108  EF2148     CLR QEI1STAT
75:                    /* POSCNTL 0x0; */
76:                    POS1CNTL = 0x0;
00910A  EF214C     CLR POS1CNTL
77:                    /* POSCNTH 0x0; */
78:                    POS1CNTH = 0x0;
00910C  EF214E     CLR POS1CNTH
79:                    /* POSHLDH 0x0; */
80:                    POS1HLD = 0x0;
00910E  EF2152     CLR POS1HLD
81:                    /* VELCNTL 0x0; */
82:                    VEL1CNT = 0x0;
009110  EF2154     CLR VEL1CNT
83:                    /* VELCNTH 0x0; */
84:                    VEL1CNTH = 0x0;
009112  EF2156     CLR VEL1CNTH
85:                    /* VELHLDH 0x0; */
86:                    VEL1HLD = 0x0;
009114  EF215A     CLR VEL1HLD
87:                    /* INTTMRL 0x0; */
88:                    INT1TMRL = 0x0;
009116  EF215C     CLR INT1TMRL
89:                    /* INTTMRH 0x0; */
90:                    INT1TMRH = 0x0;
009118  EF215E     CLR INT1TMRH
91:                    /* INTHLDL 0x0; */
92:                    INT1HLDL = 0x0;
00911A  EF2160     CLR INT1HLDL
93:                    /* INTHLDH 0x0; */
94:                    INT1HLDH = 0x0;
00911C  EF2162     CLR INT1HLDH
95:                    /* INDXCNTL 0x0; */
96:                    INDX1CNTL = 0x0;
00911E  EF2164     CLR INDX1CNTL
97:                    /* INDXCNTH 0x0; */
98:                    INDX1CNTH = 0x0;
009120  EF2166     CLR INDX1CNTH
99:                    /* INDXHLDH 0x0; */
100:                   INDX1HLD = 0x0;
009122  EF216A     CLR INDX1HLD
101:                   /* QEIGECL 0x0; */
102:                   QEI1GECL = 0x0;
009124  EF216C     CLR QEI1GECL
103:                   /* QEIGECH 0x0; */
104:                   QEI1GECH = 0x0;
009126  EF216E     CLR QEI1GECH
105:                   /* QEIGECL 0x0; */
106:                   QEI1ICL = 0x0;
009128  EF216C     CLR QEI1GECL
107:                   /* QEIGECH 0x0; */
108:                   QEI1ICH = 0x0;
00912A  EF216E     CLR QEI1GECH
109:                   /* QEILECL 0x0; */
110:                   QEI1LECL = 0x0;
00912C  EF2170     CLR QEI1LECL
111:                   /* QEILECH 0x0; */
112:                   QEI1LECH = 0x0;
00912E  EF2172     CLR QEI1LECH
113:               }
009130  060000     RETURN
009132  781F88     MOV W8, [W15++]
114:               
115:               void QEI1_Deinitialize(void)
116:               {
117:                   QEI1CON = 0x0;
009196  EF2140     CLR QEI1CON
118:                   QEI1IOC = 0x0;
009198  EF2144     CLR QEI1IOC
119:                   QEI1IOCH = 0x0;
00919A  EF2146     CLR QEI1IOCH
120:                   QEI1STAT = 0x0;
00919C  EF2148     CLR QEI1STAT
121:                   POS1CNTL = 0x0;
00919E  EF214C     CLR POS1CNTL
122:                   POS1CNTH = 0x0;
0091A0  EF214E     CLR POS1CNTH
123:                   POS1HLD = 0x0;
0091A2  EF2152     CLR POS1HLD
124:                   VEL1CNT = 0x0;
0091A4  EF2154     CLR VEL1CNT
125:                   VEL1CNTH = 0x0;
0091A6  EF2156     CLR VEL1CNTH
126:                   VEL1HLD = 0x0;
0091A8  EF215A     CLR VEL1HLD
127:                   INT1TMRL = 0x0;
0091AA  EF215C     CLR INT1TMRL
128:                   INT1TMRH = 0x0;
0091AC  EF215E     CLR INT1TMRH
129:                   INT1HLDL = 0x0;
0091AE  EF2160     CLR INT1HLDL
130:                   INT1HLDH = 0x0;
0091B0  EF2162     CLR INT1HLDH
131:                   INDX1CNTL = 0x0;
0091B2  EF2164     CLR INDX1CNTL
132:                   INDX1CNTH = 0x0;
0091B4  EF2166     CLR INDX1CNTH
133:                   INDX1HLD = 0x0;
0091B6  EF216A     CLR INDX1HLD
134:                   QEI1GECL = 0x0;
0091B8  EF216C     CLR QEI1GECL
135:                   QEI1GECH = 0x0;
0091BA  EF216E     CLR QEI1GECH
136:                   QEI1ICL = 0x0;
0091BC  EF216C     CLR QEI1GECL
137:                   QEI1ICH = 0x0;
0091BE  EF216E     CLR QEI1GECH
138:                   QEI1LECL = 0x0;
0091C0  EF2170     CLR QEI1LECL
139:                   QEI1LECH = 0x0;
0091C2  EF2172     CLR QEI1LECH
140:               }
0091C4  060000     RETURN
0091C6  FE0000     RESET
141:               
142:               
143:               
144:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/qei/qei1.h  
1:                 /**
2:                  * QEI1 Generated Driver Header File 
3:                  * 
4:                  * @file      qei1.h
5:                  *            
6:                  * @ingroup   qeidriver
7:                  *            
8:                  * @brief     This is the generated driver header file for the QEI1 driver
9:                  *            
10:                 * @version   Firmware Driver Version 1.2.2
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *            
14:                 * @skipline  Device : PIC24/dspIC/PIC32MM
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef QEI1_H
39:                #define QEI1_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdbool.h>
45:                #include <stdint.h>
46:                #include "qei_types.h"
47:                #include "qei_interface.h"
48:                
49:                // Section: Data Type Definitions
50:                
51:                /**
52:                 * @ingroup  qeidriver
53:                 * @brief    Structure object of type QEI_INTERFACE with the custom name
54:                 *           given by the user in the Melody Driver User interface. The default name 
55:                 *           e.g. QEI1 can be changed by the user in the QEI user interface. 
56:                 *           This allows defining a structure with application specific name using 
57:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
58:                */
59:                extern const struct QEI_INTERFACE MCC_QEI;
60:                /**
61:                 * @ingroup  qeidriver
62:                 * @brief    This macro defines the Custom Name for \ref QEI1_Disable API
63:                 */
64:                #define MCC_QEI_Disable QEI1_Disable
65:                /**
66:                 * @ingroup  qeidriver
67:                 * @brief    This macro defines the Custom Name for \ref QEI1_Enable API
68:                 */
69:                #define MCC_QEI_Enable QEI1_Enable
70:                /**
71:                 * @ingroup  qeidriver
72:                 * @brief    This macro defines the Custom Name for \ref QEI1_PositionCountRead API
73:                 */
74:                #define MCC_QEI_PositionCountRead QEI1_PositionCountRead
75:                /**
76:                 * @ingroup  qeidriver
77:                 * @brief    This macro defines the Custom Name for \ref QEI1_PositionCount16bitRead API
78:                 */
79:                #define MCC_QEI_PositionCount16bitRead QEI1_PositionCount16bitRead
80:                /**
81:                 * @ingroup  qeidriver
82:                 * @brief    This macro defines the Custom Name for \ref QEI1_PositionCountWrite API
83:                 */
84:                #define MCC_QEI_PositionCountWrite QEI1_PositionCountWrite
85:                /**
86:                 * @ingroup  qeidriver
87:                 * @brief    This macro defines the Custom Name for \ref QEI1_ModuloRangeSet API
88:                 */
89:                #define MCC_QEI_ModuloRangeSet QEI1_ModuloRangeSet
90:                /**
91:                 * @ingroup  qeidriver
92:                 * @brief    This macro defines the Custom Name for \ref QEI1_PhaseInputSwappedGet API
93:                 */
94:                #define MCC_QEI_PhaseInputSwappedGet QEI1_PhaseInputSwappedGet
95:                /**
96:                 * @ingroup  qeidriver
97:                 * @brief    This macro defines the Custom Name for \ref QEI1_PhaseInputSwappedSet API
98:                 */
99:                #define MCC_QEI_PhaseInputSwappedSet QEI1_PhaseInputSwappedSet
100:               /**
101:                * @ingroup  qeidriver
102:                * @brief    This macro defines the Custom Name for \ref QEI1_PositionCaptureEnable API
103:                */
104:               #define MCC_QEI_PositionCaptureEnable QEI1_PositionCaptureEnable
105:               /**
106:                * @ingroup  qeidriver
107:                * @brief    This macro defines the Custom Name for \ref QEI1_PositionCaptureDisable API
108:                */
109:               #define MCC_QEI_PositionCaptureDisable QEI1_PositionCaptureDisable
110:               /**
111:                * @ingroup  qeidriver
112:                * @brief    This macro defines the Custom Name for \ref QEI1_PositionCaptureGet API
113:                */
114:               #define MCC_QEI_PositionCaptureGet QEI1_PositionCaptureGet
115:               /**
116:                * @ingroup  qeidriver
117:                * @brief    This macro defines the Custom Name for \ref QEI1_PositionCapture16bitGet API
118:                */
119:               #define MCC_QEI_PositionCapture16bitGet QEI1_PositionCapture16bitGet
120:               /**
121:                * @ingroup  qeidriver
122:                * @brief    This macro defines the Custom Name for \ref QEI1_PositionCaptureSet API
123:                */
124:               #define MCC_QEI_PositionCaptureSet QEI1_PositionCaptureSet
125:               /**
126:                * @ingroup  qeidriver
127:                * @brief    This macro defines the Custom Name for \ref QEI1_CounterModeSet API
128:                */
129:               #define MCC_QEI_CounterModeSet QEI1_CounterModeSet
130:               /**
131:                * @ingroup  qeidriver
132:                * @brief    This macro defines the Custom Name for \ref QEI1_IMVGatedValueSet API
133:                */
134:               #define MCC_QEI_IMVGatedValueSet QEI1_IMVGatedValueSet
135:               /**
136:                * @ingroup  qeidriver
137:                * @brief    This macro defines the Custom Name for \ref QEI1_Initialize API
138:                */
139:               #define MCC_QEI_Initialize QEI1_Initialize
140:               /**
141:                * @ingroup  qeidriver
142:                * @brief    This macro defines the Custom Name for \ref QEI1_Deinitialize API
143:                */
144:               #define MCC_QEI_Deinitialize QEI1_Deinitialize
145:               // Section: QEI1 Module APIs
146:               
147:               /**
148:                * @ingroup  qeidriver
149:                * @brief    This inline function disables the QEI1 module
150:                * @return   none  
151:                */
152:               inline static void QEI1_Disable(void)
153:               {
154:                   QEI1CONbits.QEIEN = 0;        
009F86  A9E141     BCLR 0x141, #7
155:               }
009F88  060000     RETURN
156:                   
157:               /**
158:                * @ingroup  qeidriver
159:                * @brief    This inline function enables the QEI1 module
160:                * @return   none
161:                */
162:               inline static void  QEI1_Enable(void)
163:               {
164:                   QEI1CONbits.QEIEN = 1;        
009F8A  A8E141     BSET 0x141, #7
165:               }
009F8C  060000     RETURN
009F8E  800A60     MOV POS1CNTL, W0
166:               
167:               /**
168:                * @ingroup  qeidriver
169:                * @brief    This inline function returns the 32-bit position count value 
170:                * @return   Returns the 32-bit position count register value
171:                */
172:               inline static uint32_t QEI1_PositionCountRead(void)
173:               {
174:                /* Note:  A read to the LSW of the position count in POSCNTL must happen first.  
175:                *         This will latch the MSW synchronously to the POSHLD register,
176:                *         to ensure a correct 32 bit readout.
177:                */
178:                   return ( POS1CNTL | ((uint32_t)POS1HLD << 16U) );
009B74  800A62     MOV POS1CNTL, W2
009B76  800A90     MOV POS1HLD, W0
009B78  EB0080     CLR W1
009B7A  DD00C0     SL W0, #0, W1
009B7C  200000     MOV #0x0, W0
009B7E  EB0180     CLR W3
009B80  700002     IOR W0, W2, W0
009B82  708083     IOR W1, W3, W1
179:               }
009B84  060000     RETURN
009B86  800B70     MOV QEI1GECH, W0
180:               
181:               /**
182:                * @ingroup  qeidriver
183:                * @brief    This inline function returns the 16-bit position count value from the 
184:                *           QEI1 position count register.
185:                * @return   Returns the LSB 16 bits of the QEI1 position 
186:                *           count register.
187:                */
188:               inline static uint16_t QEI1_PositionCount16bitRead(void)
189:               {
190:                   return POS1CNTL;
009F8E  800A60     MOV POS1CNTL, W0
191:               }
009F90  060000     RETURN
009F92  A8E145     BSET 0x145, #7
192:               
193:               /**
194:                * @ingroup    qeidriver
195:                * @brief      This inline function sets the QEI1 position count value
196:                * @param[in]  positionCount - 32-bit position count value 
197:                * @return     none  
198:                */
199:               inline static void QEI1_PositionCountWrite(uint32_t positionCount)
200:               {
201:                /* Note the MSW is written first to POSHLD register followed by the LSW to the lower 16 bits of
202:                   the actual position count register. This sequence is important for a successful write operation.*/
203:                   POS1HLD = (uint16_t)(positionCount >> 16U);
009EDA  880A91     MOV W1, POS1HLD
204:                   POS1CNTL = (uint16_t)positionCount;
009EDC  880A60     MOV W0, POS1CNTL
205:               }
009EDE  060000     RETURN
009EE0  0AA088     BFEXT #0x8, #0x1, QEI1IOC, W0
206:               
207:               /**
208:                * @ingroup    qeidriver
209:                * @brief      This inline function sets the 32bit modulo count value when QEI is configured to
210:                *             operate in 'Modulo Count' mode. The lower bound controlled by the QEILEC register is set to 0.
211:                * @param[in]  countsPerRevolution - Modulus number of counts per wraparound  
212:                * @return     none  
213:                */
214:               inline static void QEI1_ModuloRangeSet(uint32_t countsPerRevolution)
215:               {
216:                   uint32_t maxCount = countsPerRevolution - (uint32_t)1;
009D14  500161     SUB W0, #0x1, W2
009D16  5881E0     SUBB W1, #0x0, W3
217:                   QEI1LECL = 0;
009D18  EF2170     CLR QEI1LECL
218:                   QEI1LECH = 0;
009D1A  EF2172     CLR QEI1LECH
219:                   QEI1GECL = (uint16_t) maxCount;
009D1C  880B62     MOV W2, QEI1GECL
220:                   QEI1GECH = (uint16_t)(maxCount >> 16U);
009D1E  880B73     MOV W3, QEI1GECH
221:               }
009D20  060000     RETURN
009D22  AB223E     BTST U1STAH, #1
222:               
223:               /**
224:                * @ingroup  qeidriver
225:                * @brief    This inline function gets the status of QEI input phase swap configuration  
226:                * @return   true   - Phase inputs are swapped
227:                * @return   false  - Phase inputs are not swapped
228:                */
229:               inline static bool QEI1_PhaseInputSwappedGet(void)
230:               {
231:                   return QEI1IOCbits.SWPAB;
009EE0  0AA088     BFEXT #0x8, #0x1, QEI1IOC, W0
009EE2  000144     NOP
232:               }
009EE4  060000     RETURN
009EE6  880B60     MOV W0, QEI1GECL
233:               
234:               /**
235:                * @ingroup    qeidriver
236:                * @brief      This inline function sets whether the QEA and QEB pins are 
237:                *             swapped prior to quadrature decoder logic.
238:                * @param[in]  swapEnabled - specifies whether QEA and QEB pins need 
239:                *             to be swapped prior to quadrature decoder logic  
240:                * @return     none   
241:                */
242:               inline static void QEI1_PhaseInputSwappedSet(bool swapEnabled)
243:               {
244:               
245:                   if (swapEnabled)
009D54  E00400     CP0.B W0
009D56  320002     BRA Z, .L9
246:                   {
247:                       QEI1IOCbits.SWPAB = 1;
009D58  A80145     BSET 0x145, #0
009D5A  370001     BRA .L8
248:                   }
249:                   else
250:                   {
251:                       QEI1IOCbits.SWPAB = 0;   
009D5C  A90145     BCLR 0x145, #0
252:                   }  
253:               }
009D5E  060000     RETURN
009D60  AB2800     BTST IFS0, #1
254:               
255:               /**
256:                * @ingroup  qeidriver
257:                * @brief    This inline function enables the QEI position count capture on an index event
258:                * @return   none  
259:                */
260:               inline static void QEI1_PositionCaptureEnable(void)
261:               {
262:                   QEI1IOCbits.QCAPEN = 1;
009F92  A8E145     BSET 0x145, #7
263:               }
009F94  060000     RETURN
264:               
265:               /**
266:                * @ingroup  qeidriver
267:                * @brief    This inline function disables the QEI position count capture on an index event
268:                * @return   none  
269:                */
270:               inline static void QEI1_PositionCaptureDisable(void)
271:               {
272:                   QEI1IOCbits.QCAPEN = 0;
009F96  A9E145     BCLR 0x145, #7
273:               }
009F98  060000     RETURN
009F9A  800B60     MOV QEI1GECL, W0
274:               
275:               /**
276:                * @ingroup  qeidriver
277:                * @brief    This inline function reads the 32-bit position capture value from the
278:                *           QEIICx 32 bit register.
279:                * @return   Returns position capture value
280:                */
281:               inline static uint32_t QEI1_PositionCaptureGet(void)
282:               {
283:                   return (((uint32_t) QEI1ICH << 16U) | QEI1ICL );
009B86  800B70     MOV QEI1GECH, W0
009B88  800B62     MOV QEI1GECL, W2
009B8A  EB0080     CLR W1
009B8C  DD00C0     SL W0, #0, W1
009B8E  200000     MOV #0x0, W0
009B90  EB0180     CLR W3
009B92  700002     IOR W0, W2, W0
009B94  708083     IOR W1, W3, W1
284:               }
009B96  060000     RETURN
009B98  800370     MOV DMTCNTH, W0
285:               
286:               /**
287:                * @ingroup  qeidriver
288:                * @brief    This inline function returns the 16-bit position capture value from 
289:                *           QEIICL position count capture register
290:                * @return   Returns the LSB 16 bits of position capture value
291:                */
292:               inline static uint16_t QEI1_PositionCapture16bitGet(void)
293:               {
294:                   return QEI1ICL;
009F9A  800B60     MOV QEI1GECL, W0
295:               }
009F9C  060000     RETURN
009F9E  A8E101     BSET 0x101, #7
296:               
297:               /**
298:                * @ingroup    qeidriver
299:                * @brief      This inline function initializes the 32 bit position capture register value
300:                * @param[in]  initValue - 32 bit position capture register value  
301:                * @return     none  
302:                */
303:               inline static void QEI1_PositionCaptureSet(uint32_t initValue)
304:               {
305:                   QEI1ICL = (uint16_t) initValue;
009EE6  880B60     MOV W0, QEI1GECL
306:                   QEI1ICH = (uint16_t)(initValue >> 16U);
009EE8  880B71     MOV W1, QEI1GECH
307:               }
009EEA  060000     RETURN
009EEC  800840     MOV PR1, W0
308:               
309:               /**
310:                * @ingroup    qeidriver
311:                * @brief      This inline function sets the QEI Counter mode
312:                * @param[in]  mode - Sets the QEI counter mode 
313:                * @return     none  
314:                */
315:               inline static void QEI1_CounterModeSet(enum QEI_MODE mode)
316:               {
317:                   QEI1CONbits.PIMOD = mode;
009C5E  600067     AND W0, #0x7, W0
009C60  DD004A     SL W0, #10, W0
009C62  2E3FF1     MOV #0xE3FF, W1
009C64  800A02     MOV QEI1CON, W2
009C66  608082     AND W1, W2, W1
009C68  700081     IOR W0, W1, W1
009C6A  880A01     MOV W1, QEI1CON
318:               }
009C6C  060000     RETURN
319:               
320:               /**
321:                * @ingroup    qeidriver
322:                * @brief      This inline function sets the QEI Index Match Value 
323:                * @param[in]  mode - Sets the QEI Index Match Value
324:                * @return     none  
325:                */
326:               inline static void QEI1_IMVGatedValueSet(enum QEI_IMV_STATE state)
327:               {
328:                   QEI1CONbits.IMV = state;
009C6E  600063     AND W0, #0x3, W0
009C70  DD0048     SL W0, #8, W0
009C72  2FCFF1     MOV #0xFCFF, W1
009C74  800A02     MOV QEI1CON, W2
009C76  608082     AND W1, W2, W1
009C78  700081     IOR W0, W1, W1
009C7A  880A01     MOV W1, QEI1CON
329:               }
009C7C  060000     RETURN
009C7E  600067     AND W0, #0x7, W0
330:               
331:               /**
332:                * @ingroup  qeidriver
333:                * @brief    Initializes the QEI module
334:                * @return   none 
335:                */
336:               void QEI1_Initialize(void);
337:               
338:               /**
339:                * @ingroup  qeidriver
340:                * @brief    Deinitializes the QEI1 to POR values
341:                * @return   none  
342:                */
343:               void QEI1_Deinitialize(void);
344:               
345:               #endif // QEI1.H
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/pwm_hs/src/pwm.c
1:                 /**
2:                  * PWM Generated Driver Source File
3:                  * 
4:                  * @file      pwm.c
5:                  * 
6:                  * @ingroup   pwmhsdriver
7:                  * 
8:                  * @brief     This is the generated driver source file for PWM driver
9:                  *
10:                 * @version   Firmware Driver Version 1.1.5
11:                 *
12:                 * @version   PLIB Version 2.2.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                
41:                #include "../pwm.h"
42:                
43:                // Section: File specific functions
44:                
45:                static void (*PWM_GeneratorEOCEventHandler)(enum PWM_GENERATOR genNum) = NULL;
46:                
47:                
48:                // Section: Driver Interface
49:                
50:                const struct PWM_HS_INTERFACE MCC_PWM = {
51:                    .Initialize                     = &PWM_Initialize,
52:                    .Deinitialize                   = &PWM_Deinitialize,
53:                    .Disable                        = &PWM_Disable,
54:                    .Enable                         = &PWM_Enable,
55:                    .ModeSet                        = &PWM_ModeSet,
56:                    .MasterPeriodSet                = &PWM_MasterPeriodSet,
57:                    .MasterDutyCycleSet             = &PWM_MasterDutyCycleSet,
58:                    .PeriodSet                      = &PWM_PeriodSet,
59:                    .DutyCycleSet                   = &PWM_DutyCycleSet,
60:                    .PhaseSelect                    = &PWM_PhaseSelect,
61:                    .PhaseSet                       = &PWM_PhaseSet,
62:                    .OverrideDataSet                = &PWM_OverrideDataSet,
63:                    .OverrideDataHighSet            = &PWM_OverrideDataHighSet,
64:                    .OverrideDataLowSet             = &PWM_OverrideDataLowSet,
65:                    .OverrideDataGet                = &PWM_OverrideDataGet,
66:                    .OverrideHighEnable             = &PWM_OverrideHighEnable,
67:                    .OverrideLowEnable              = &PWM_OverrideLowEnable,
68:                    .OverrideHighDisable            = &PWM_OverrideHighDisable,
69:                    .OverrideLowDisable             = &PWM_OverrideLowDisable,
70:                    .DeadTimeLowSet                 = &PWM_DeadTimeLowSet,
71:                    .DeadTimeHighSet                = &PWM_DeadTimeHighSet,
72:                    .DeadTimeSet                    = &PWM_DeadTimeSet,
73:                    .TriggerCompareValueSet         = &PWM_TriggerCompareValueSet,
74:                    .GeneratorInterruptEnable       = &PWM_GeneratorInterruptEnable,
75:                    .GeneratorInterruptDisable      = &PWM_GeneratorInterruptDisable,
76:                    .GeneratorEventStatusGet        = &PWM_GeneratorEventStatusGet,
77:                    .GeneratorEventStatusClear      = &PWM_GeneratorEventStatusClear,
78:                
79:                    .SpecialEventPrimaryCompareValueSet     = NULL,    
80:                    .SpecialEventTriggerInterruptFlagClear  = NULL,
81:                    .SpecialEventPrimaryInterruptEnable     = NULL,
82:                    .SpecialEventPrimaryInterruptDisable    = NULL,
83:                    .FaultModeLatchDisable                  = NULL,
84:                    .FaultModeLatchEnable                   = NULL,
85:                    .MasterPhaseSet                         = &PWM_MasterPhaseSet,
86:                    .GeneratorDisable                       = &PWM_GeneratorDisable,
87:                    .GeneratorEnable                        = &PWM_GeneratorEnable,
88:                    .TriggerACompareValueSet                = &PWM_TriggerACompareValueSet,
89:                    .TriggerBCompareValueSet                = &PWM_TriggerBCompareValueSet,
90:                    .TriggerCCompareValueSet                = &PWM_TriggerCCompareValueSet,
91:                    .SoftwareUpdateRequest                  = &PWM_SoftwareUpdateRequest,
92:                    .SoftwareUpdatePending                  = &PWM_SoftwareUpdatePending,
93:                    .FaultModeLatchClear                    = &PWM_FaultModeLatchClear,
94:                    .Trigger1Enable                         = &PWM_Trigger1Enable,
95:                    .Trigger1Disable                        = &PWM_Trigger1Disable,
96:                    .Trigger2Enable                         = &PWM_Trigger2Enable,
97:                    .Trigger2Disable                        = &PWM_Trigger2Disable,
98:                    
99:                    .GeneratorEOCEventCallbackRegister = &PWM_GeneratorEOCEventCallbackRegister,
100:                   
101:                   
102:                   .GeneratorTasks         = &PWM_GeneratorTasks,
103:                   .CommonEventTasks       = NULL,
104:               };
105:               
106:               // Section: PWM Module APIs
107:               
108:               void PWM_Initialize (void)
109:               {
110:                   // MODSEL Center-Aligned; TRGCNT 1; CLKSEL Master clock; ON disabled; HREN disabled; 
111:                   PG1CONL = 0xc;
007022  2000C0     MOV #0xC, W0
112:                   // MODSEL Center-Aligned; TRGCNT 1; CLKSEL Master clock; ON disabled; HREN disabled; 
113:                   PG2CONL = 0xc;
007026  881B00     MOV W0, PG2CONL
114:                   // MODSEL Center-Aligned; TRGCNT 1; CLKSEL Master clock; ON disabled; HREN disabled; 
115:                   PG4CONL = 0xc;
007028  881E60     MOV W0, PG4CONL
116:                   // 
117:                   PG1CAP = 0x0;
00702A  EF235E     CLR PG1CAP
118:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
119:                   PG1CLPCIH = 0x0;
00702C  EF233E     CLR PG1CLPCIH
120:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
121:                   PG1CLPCIL = 0x0;
00702E  EF233C     CLR PG1CLPCIL
122:                   // MSTEN disabled; TRIGMOD Single trigger mode; SOCS Self-trigger; UPDMOD SOC update; MPHSEL disabled; MPERSEL enabled; MDCSEL disabled; 
123:                   PG1CONH = 0x4000;
007030  240001     MOV #0x4000, W1
007032  881961     MOV W1, PG1CONH
124:                   // DC1 0x0; 
125:                   PG1DC = 0x0;
007034  EF234E     CLR PG1DC
126:                   // DCA1 0x0; 
127:                   PG1DCA = 0x0;
007036  EF2350     CLR PG1DCA
128:                   // DTH1 200; 
129:                   PG1DTH = 0xC8;
007038  200C82     MOV #0xC8, W2
00703A  881AE2     MOV W2, PG1DTH
130:                   // DTL1 200; 
131:                   PG1DTL = 0xC8;
00703C  881AD2     MOV W2, PG1DTL
132:                   // ADTR2EN1 disabled; IEVTSEL Time based interrupts disabled; SIEN disabled; FFIEN disabled; ADTR1OFS None; CLIEN disabled; FLTIEN disabled; ADTR2EN2 disabled; ADTR2EN3 disabled; 
133:                   PG1EVTH = 0x300;
00703E  203001     MOV #0x300, W1
007040  8819B1     MOV W1, PG1EVTH
134:                   // UPDTRG Duty Cycle; ADTR1PS 1:1; PGTRGSEL EOC event; ADTR1EN3 disabled; ADTR1EN1 disabled; ADTR1EN2 disabled; 
135:                   PG1EVTL = 0x8;
007042  200085     MOV #0x8, W5
007044  8819A5     MOV W5, PG1EVTL
136:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
137:                   PG1FFPCIH = 0x0;
007046  EF2342     CLR PG1FFPCIH
138:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
139:                   PG1FFPCIL = 0x0;
007048  EF2340     CLR PG1FFPCIL
140:                   // TQPS Not inverted; LATMOD disabled; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Latched; 
141:                   PG1FPCIH = 0x300;
00704A  8819D1     MOV W1, PG1FPCIH
142:                   // PSS Comparator 1 output; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
143:                   PG1FPCIL = 0x1B;
00704C  2001B4     MOV #0x1B, W4
00704E  8819C4     MOV W4, PG1FPCIL
144:                   // PENL enabled; DTCMPSEL PCI Sync Logic; PMOD Complementary; POLL Active-high; PENH enabled; CAPSRC Software; POLH Active-high; 
145:                   PG1IOCONH = 0xC;
007050  881990     MOV W0, PG1IOCONH
146:                   // FLTDAT 0; DBDAT 0x0; SWAP disabled; OVRENH disabled; OVRENL disabled; OSYNC User output overrides occur when specified by UPDMOD bits; CLMOD disabled; FFDAT 0x0; CLDAT 0x0; OVRDAT 0; 
147:                   PG1IOCONL = 0x200;
007052  202003     MOV #0x200, W3
007054  881983     MOV W3, PG1IOCONL
148:                   // PWMPCI PWM1; PLR disabled; PLF disabled; PHR disabled; PHF disabled; 
149:                   PG1LEBH = 0x0;
007056  EF234A     CLR PG1LEBH
150:                   // LEB 0x0; 
151:                   PG1LEBL = 0x0;
007058  EF2348     CLR PG1LEBL
152:                   // PER1 0x0; 
153:                   PG1PER = 0x0;
00705A  EF2352     CLR PG1PER
154:                   // PHASE1 0x0; 
155:                   PG1PHASE = 0x0;
00705C  EF234C     CLR PG1PHASE
156:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
157:                   PG1SPCIH = 0x0;
00705E  EF2346     CLR PG1SPCIH
158:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
159:                   PG1SPCIL = 0x0;
007060  EF2344     CLR PG1SPCIL
160:                   // TRSET disabled; UPDREQ disabled; CLEVT disabled; TRCLR disabled; CAP disabled; SEVT disabled; FFEVT disabled; UPDATE disabled; FLTEVT disabled; 
161:                   PG1STAT = 0x0;
007062  EF232E     CLR PG1STAT
162:                   // TRIGA1 0; 
163:                   PG1TRIGA = 0x0;
007064  EF2354     CLR PG1TRIGA
164:                   // TRIGB1 0x0; 
165:                   PG1TRIGB = 0x0;
007066  EF2356     CLR PG1TRIGB
166:                   // TRIGC1 0x0; 
167:                   PG1TRIGC = 0x0;
007068  EF2358     CLR PG1TRIGC
168:                   // 
169:                   PG2CAP = 0x0;
00706A  EF2394     CLR PG2CAP
170:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
171:                   PG2CLPCIH = 0x0;
00706C  EF2374     CLR PG2CLPCIH
172:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
173:                   PG2CLPCIL = 0x0;
00706E  EF2372     CLR PG2CLPCIL
174:                   // MSTEN disabled; TRIGMOD Single trigger mode; SOCS Trigger output selected by PG1 or PG5; UPDMOD SOC update; MPHSEL disabled; MPERSEL enabled; MDCSEL disabled; 
175:                   PG2CONH = 0x4001;
007070  240016     MOV #0x4001, W6
007072  881B16     MOV W6, PG2CONH
176:                   // DC2 0x0; 
177:                   PG2DC = 0x0;
007074  EF2384     CLR PG2DC
178:                   // DCA2 0x0; 
179:                   PG2DCA = 0x0;
007076  EF2386     CLR PG2DCA
180:                   // DTH2 200; 
181:                   PG2DTH = 0xC8;
007078  881C92     MOV W2, PG2DTH
182:                   // DTL2 200; 
183:                   PG2DTL = 0xC8;
00707A  881C82     MOV W2, PG2DTL
184:                   // ADTR2EN1 disabled; IEVTSEL Time based interrupts disabled; SIEN disabled; FFIEN disabled; ADTR1OFS None; CLIEN disabled; FLTIEN disabled; ADTR2EN2 disabled; ADTR2EN3 disabled; 
185:                   PG2EVTH = 0x300;
00707C  881B61     MOV W1, PG2EVTH
186:                   // UPDTRG Duty Cycle; ADTR1PS 1:1; PGTRGSEL EOC event; ADTR1EN3 disabled; ADTR1EN1 disabled; ADTR1EN2 disabled; 
187:                   PG2EVTL = 0x8;
00707E  881B55     MOV W5, PG2EVTL
188:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
189:                   PG2FFPCIH = 0x0;
007080  EF2378     CLR PG2FFPCIH
190:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
191:                   PG2FFPCIL = 0x0;
007082  EF2376     CLR PG2FFPCIL
192:                   // TQPS Not inverted; LATMOD disabled; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Latched; 
193:                   PG2FPCIH = 0x300;
007084  881B81     MOV W1, PG2FPCIH
194:                   // PSS Comparator 1 output; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
195:                   PG2FPCIL = 0x1B;
007086  881B74     MOV W4, PG2FPCIL
196:                   // PENL enabled; DTCMPSEL PCI Sync Logic; PMOD Complementary; POLL Active-high; PENH enabled; CAPSRC Software; POLH Active-high; 
197:                   PG2IOCONH = 0xC;
007088  881B40     MOV W0, PG2IOCONH
198:                   // FLTDAT 0; DBDAT 0x0; SWAP disabled; OVRENH disabled; OVRENL disabled; OSYNC User output overrides occur when specified by UPDMOD bits; CLMOD disabled; FFDAT 0x0; CLDAT 0x0; OVRDAT 0; 
199:                   PG2IOCONL = 0x200;
00708A  881B33     MOV W3, PG2IOCONL
200:                   // PWMPCI PWM1; PLR disabled; PLF disabled; PHR disabled; PHF disabled; 
201:                   PG2LEBH = 0x0;
00708C  EF2380     CLR PG2LEBH
202:                   // LEB 0x0; 
203:                   PG2LEBL = 0x0;
00708E  EF237E     CLR PG2LEBL
204:                   // PER2 0x0; 
205:                   PG2PER = 0x0;
007090  EF2388     CLR PG2PER
206:                   // PHASE2 0x0; 
207:                   PG2PHASE = 0x0;
007092  EF2382     CLR PG2PHASE
208:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
209:                   PG2SPCIH = 0x0;
007094  EF237C     CLR PG2SPCIH
210:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
211:                   PG2SPCIL = 0x0;
007096  EF237A     CLR PG2SPCIL
212:                   // TRSET disabled; UPDREQ disabled; CLEVT disabled; TRCLR disabled; CAP disabled; SEVT disabled; FFEVT disabled; UPDATE disabled; FLTEVT disabled; 
213:                   PG2STAT = 0x0;
007098  EF2364     CLR PG2STAT
214:                   // TRIGA2 0; 
215:                   PG2TRIGA = 0x0;
00709A  EF238A     CLR PG2TRIGA
216:                   // TRIGB2 0x0; 
217:                   PG2TRIGB = 0x0;
00709C  EF238C     CLR PG2TRIGB
218:                   // TRIGC2 0x0; 
219:                   PG2TRIGC = 0x0;
00709E  EF238E     CLR PG2TRIGC
220:                   // 
221:                   PG4CAP = 0x0;
0070A0  EF2400     CLR PG4CAP
222:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
223:                   PG4CLPCIH = 0x0;
0070A2  EF23E0     CLR PG4CLPCIH
224:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
225:                   PG4CLPCIL = 0x0;
0070A4  EF23DE     CLR PG4CLPCIL
226:                   // MSTEN disabled; TRIGMOD Single trigger mode; SOCS Trigger output selected by PG1 or PG5; UPDMOD SOC update; MPHSEL disabled; MPERSEL enabled; MDCSEL disabled; 
227:                   PG4CONH = 0x4001;
0070A6  881E76     MOV W6, PG4CONH
228:                   // DC4 0x0; 
229:                   PG4DC = 0x0;
0070A8  EF23F0     CLR PG4DC
230:                   // DCA4 0x0; 
231:                   PG4DCA = 0x0;
0070AA  EF23F2     CLR PG4DCA
232:                   // DTH4 200; 
233:                   PG4DTH = 0xC8;
0070AC  881FF2     MOV W2, PG4DTH
234:                   // DTL4 200; 
235:                   PG4DTL = 0xC8;
0070AE  881FE2     MOV W2, PG4DTL
236:                   // ADTR2EN1 disabled; IEVTSEL Time based interrupts disabled; SIEN disabled; FFIEN disabled; ADTR1OFS None; CLIEN disabled; FLTIEN disabled; ADTR2EN2 disabled; ADTR2EN3 disabled; 
237:                   PG4EVTH = 0x300;
0070B0  881EC1     MOV W1, PG4EVTH
238:                   // UPDTRG Duty Cycle; ADTR1PS 1:1; PGTRGSEL EOC event; ADTR1EN3 disabled; ADTR1EN1 disabled; ADTR1EN2 disabled; 
239:                   PG4EVTL = 0x8;
0070B2  881EB5     MOV W5, PG4EVTL
240:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
241:                   PG4FFPCIH = 0x0;
0070B4  EF23E4     CLR PG4FFPCIH
242:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
243:                   PG4FFPCIL = 0x0;
0070B6  EF23E2     CLR PG4FFPCIL
244:                   // TQPS Not inverted; LATMOD disabled; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Latched; 
245:                   PG4FPCIH = 0x300;
0070B8  881EE1     MOV W1, PG4FPCIH
246:                   // PSS Comparator 1 output; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
247:                   PG4FPCIL = 0x1B;
0070BA  881ED4     MOV W4, PG4FPCIL
248:                   // PENL enabled; DTCMPSEL PCI Sync Logic; PMOD Complementary; POLL Active-high; PENH enabled; CAPSRC Software; POLH Active-high; 
249:                   PG4IOCONH = 0xC;
0070BC  881EA0     MOV W0, PG4IOCONH
250:                   // FLTDAT 0; DBDAT 0x0; SWAP disabled; OVRENH disabled; OVRENL disabled; OSYNC User output overrides occur when specified by UPDMOD bits; CLMOD disabled; FFDAT 0x0; CLDAT 0x0; OVRDAT 0; 
251:                   PG4IOCONL = 0x200;
0070BE  881E93     MOV W3, PG4IOCONL
252:                   // PWMPCI PWM1; PLR disabled; PLF disabled; PHR disabled; PHF disabled; 
253:                   PG4LEBH = 0x0;
0070C0  EF23EC     CLR PG4LEBH
254:                   // LEB 0x0; 
255:                   PG4LEBL = 0x0;
0070C2  EF23EA     CLR PG4LEBL
256:                   // PER4 0x0; 
257:                   PG4PER = 0x0;
0070C4  EF23F4     CLR PG4PER
258:                   // PHASE4 0x0; 
259:                   PG4PHASE = 0x0;
0070C6  EF23EE     CLR PG4PHASE
260:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
261:                   PG4SPCIH = 0x0;
0070C8  EF23E8     CLR PG4SPCIH
262:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
263:                   PG4SPCIL = 0x0;
0070CA  EF23E6     CLR PG4SPCIL
264:                   // TRSET disabled; UPDREQ disabled; CLEVT disabled; TRCLR disabled; CAP disabled; SEVT disabled; FFEVT disabled; UPDATE disabled; FLTEVT disabled; 
265:                   PG4STAT = 0x0;
0070CC  EF23D0     CLR PG4STAT
266:                   // TRIGA4 0; 
267:                   PG4TRIGA = 0x0;
0070CE  EF23F6     CLR PG4TRIGA
268:                   // TRIGB4 0x0; 
269:                   PG4TRIGB = 0x0;
0070D0  EF23F8     CLR PG4TRIGB
270:                   // TRIGC4 0x0; 
271:                   PG4TRIGC = 0x0;
0070D2  EF23FA     CLR PG4TRIGC
272:                   // CTB3EN disabled; CTB2EN disabled; CTB1EN disabled; CTB4EN disabled; CTB8EN disabled; CTB7EN disabled; CTB6EN disabled; CTB5EN disabled; 
273:                   CMBTRIGH = 0x0;
0070D4  EF2310     CLR CMBTRIGH
274:                   // CTA1EN disabled; CTA2EN disabled; CTA3EN disabled; CTA4EN disabled; CTA7EN disabled; CTA8EN disabled; CTA5EN disabled; CTA6EN disabled; 
275:                   CMBTRIGL = 0x0;
0070D6  EF230E     CLR CMBTRIGL
276:                   // FSCL 0x0; 
277:                   FSCL = 0x0;
0070D8  EF2302     CLR FSCL
278:                   // FSMINPER 0x0; 
279:                   FSMINPER = 0x0;
0070DA  EF2304     CLR FSMINPER
280:                   // LFSR 0x0; 
281:                   LFSR = 0x0;
0070DC  EF230C     CLR LFSR
282:                   // PWMLFA PWMS1 or PWMS2;; S1APOL Positive logic; S2APOL Positive logic; PWMLFAD No Assignment; PWMS1A PWM1H; PWMS2A PWM1H; 
283:                   LOGCONA = 0x0;
0070DE  EF2312     CLR LOGCONA
284:                   // PWMLFB PWMS1 | PWMS2; S2BPOL Positive logic; PWMLFBD No Assignment; S1BPOL Positive logic; PWMS2B PWM1H; PWMS1B PWM1H; 
285:                   LOGCONB = 0x0;
0070E0  EF2314     CLR LOGCONB
286:                   // PWMLFC PWMS1 | PWMS2; PWMLFCD No Assignment; S2CPOL Positive logic; S1CPOL Positive logic; PWMS1C PWM1H; PWMS2C PWM1H; 
287:                   LOGCONC = 0x0;
0070E2  EF2316     CLR LOGCONC
288:                   // PWMS1D PWM1H; S1DPOL Positive logic; PWMLFD PWMS1 | PWMS2; PWMLFDD No Assignment; S2DPOL Positive logic; PWMS2D PWM1H; 
289:                   LOGCOND = 0x0;
0070E4  EF2318     CLR LOGCOND
290:                   // PWMS1E PWM1H; PWMS2E PWM1H; S1EPOL Positive logic; PWMLFE PWMS1 | PWMS2; S2EPOL Positive logic; PWMLFED No Assignment; 
291:                   LOGCONE = 0x0;
0070E6  EF231A     CLR LOGCONE
292:                   // S1FPOL Positive logic; PWMS2F PWM1H; PWMS1F PWM1H; S2FPOL Positive logic; PWMLFFD No Assignment; PWMLFF PWMS1 | PWMS2; 
293:                   LOGCONF = 0x0;
0070E8  EF231C     CLR LOGCONF
294:                   // MDC 0x0; 
295:                   MDC = 0x0;
0070EA  EF2308     CLR MDC
296:                   // MPER 4999; 
297:                   MPER = 0x1387;
0070EC  213870     MOV #0x1387, W0
0070EE  881850     MOV W0, MPER
298:                   // MPHASE 0x0; 
299:                   MPHASE = 0x0;
0070F0  EF2306     CLR MPHASE
300:                   // MCLKSEL FOSC; LOCK disabled; DIVSEL 1:2; HRERR disabled; 
301:                   PCLKCON = 0x0;
0070F2  EF2300     CLR PCLKCON
302:                   // EVTASEL PGTRGSEL bits; EVTASYNC Not synchronized; EVTAPOL Active-high; EVTAPGS PG1; EVTASTRD Stretched to 8 PWM clock cycles minimum; EVT1OEN disabled; 
303:                   PWMEVTA = 0x0;
0070F4  EF231E     CLR PWMEVTA
304:                   // EVTBPGS PG1; EVTBSYNC Not synchronized; EVTBPOL Active-high; EVTBSEL PGTRGSEL bits; EVTBSTRD Stretched to 8 PWM clock cycles minimum; EVT2OEN disabled; 
305:                   PWMEVTB = 0x0;
0070F6  EF2320     CLR PWMEVTB
306:                   // EVTCPGS PG1; EVTCPOL Active-high; EVTCSEL PGTRGSEL bits; EVTCSTRD Stretched to 8 PWM clock cycles minimum; EVTCSYNC Not synchronized; EVT3OEN disabled; 
307:                   PWMEVTC = 0x0;
0070F8  EF2322     CLR PWMEVTC
308:                   // EVT4OEN disabled; EVTDSTRD Stretched to 8 PWM clock cycles minimum; EVTDPOL Active-high; EVTDPGS PG1; EVTDSEL PGTRGSEL bits; EVTDSYNC Not synchronized; 
309:                   PWMEVTD = 0x0;
0070FA  EF2324     CLR PWMEVTD
310:                   // EVT5OEN disabled; EVTEPOL Active-high; EVTEPGS PG1; EVTESTRD Stretched to 8 PWM clock cycles minimum; EVTESEL PGTRGSEL bits; EVTESYNC Not synchronized; 
311:                   PWMEVTE = 0x0;
0070FC  EF2326     CLR PWMEVTE
312:                   // EVTFPOL Active-high; EVTFPGS PG1; EVTFSTRD Stretched to 8 PWM clock cycles minimum; EVTFSEL PGTRGSEL bits; EVT6OEN disabled; EVTFSYNC Not synchronized; 
313:                   PWMEVTF = 0x0;
0070FE  EF2328     CLR PWMEVTF
314:                   
315:                   PWM_GeneratorEOCEventCallbackRegister(&PWM_GeneratorEOCEventCallback);
007100  29FC40     MOV #0x9FC4, W0
007102  071693     RCALL PWM_GeneratorEOCEventCallbackRegister
316:                   
317:                   
318:               
319:               }
007104  060000     RETURN
007106  060000     RETURN
320:               
321:               void PWM_Deinitialize (void)
322:               {
323:                   PWM_Disable();
324:                   
325:                   PG1CONL = 0x0;
007486  EF232A     CLR PG1CONL
326:                   PG2CONL = 0x0;
007488  EF2360     CLR PG2CONL
327:                   PG4CONL = 0x0;
00748A  EF23CC     CLR PG4CONL
328:                   
329:                   PG1CAP = 0x0;
00748C  EF235E     CLR PG1CAP
330:                   PG1CLPCIH = 0x0;
00748E  EF233E     CLR PG1CLPCIH
331:                   PG1CLPCIL = 0x0;
007490  EF233C     CLR PG1CLPCIL
332:                   PG1CONH = 0x0;
007492  EF232C     CLR PG1CONH
333:                   PG1DC = 0x0;
007494  EF234E     CLR PG1DC
334:                   PG1DCA = 0x0;
007496  EF2350     CLR PG1DCA
335:                   PG1DTH = 0x0;
007498  EF235C     CLR PG1DTH
336:                   PG1DTL = 0x0;
00749A  EF235A     CLR PG1DTL
337:                   PG1EVTH = 0x0;
00749C  EF2336     CLR PG1EVTH
338:                   PG1EVTL = 0x0;
00749E  EF2334     CLR PG1EVTL
339:                   PG1FFPCIH = 0x0;
0074A0  EF2342     CLR PG1FFPCIH
340:                   PG1FFPCIL = 0x0;
0074A2  EF2340     CLR PG1FFPCIL
341:                   PG1FPCIH = 0x0;
0074A4  EF233A     CLR PG1FPCIH
342:                   PG1FPCIL = 0x0;
0074A6  EF2338     CLR PG1FPCIL
343:                   PG1IOCONH = 0x0;
0074A8  EF2332     CLR PG1IOCONH
344:                   PG1IOCONL = 0x0;
0074AA  EF2330     CLR PG1IOCONL
345:                   PG1LEBH = 0x0;
0074AC  EF234A     CLR PG1LEBH
346:                   PG1LEBL = 0x0;
0074AE  EF2348     CLR PG1LEBL
347:                   PG1PER = 0x0;
0074B0  EF2352     CLR PG1PER
348:                   PG1PHASE = 0x0;
0074B2  EF234C     CLR PG1PHASE
349:                   PG1SPCIH = 0x0;
0074B4  EF2346     CLR PG1SPCIH
350:                   PG1SPCIL = 0x0;
0074B6  EF2344     CLR PG1SPCIL
351:                   PG1STAT = 0x0;
0074B8  EF232E     CLR PG1STAT
352:                   PG1TRIGA = 0x0;
0074BA  EF2354     CLR PG1TRIGA
353:                   PG1TRIGB = 0x0;
0074BC  EF2356     CLR PG1TRIGB
354:                   PG1TRIGC = 0x0;
0074BE  EF2358     CLR PG1TRIGC
355:                   PG2CAP = 0x0;
0074C0  EF2394     CLR PG2CAP
356:                   PG2CLPCIH = 0x0;
0074C2  EF2374     CLR PG2CLPCIH
357:                   PG2CLPCIL = 0x0;
0074C4  EF2372     CLR PG2CLPCIL
358:                   PG2CONH = 0x0;
0074C6  EF2362     CLR PG2CONH
359:                   PG2DC = 0x0;
0074C8  EF2384     CLR PG2DC
360:                   PG2DCA = 0x0;
0074CA  EF2386     CLR PG2DCA
361:                   PG2DTH = 0x0;
0074CC  EF2392     CLR PG2DTH
362:                   PG2DTL = 0x0;
0074CE  EF2390     CLR PG2DTL
363:                   PG2EVTH = 0x0;
0074D0  EF236C     CLR PG2EVTH
364:                   PG2EVTL = 0x0;
0074D2  EF236A     CLR PG2EVTL
365:                   PG2FFPCIH = 0x0;
0074D4  EF2378     CLR PG2FFPCIH
366:                   PG2FFPCIL = 0x0;
0074D6  EF2376     CLR PG2FFPCIL
367:                   PG2FPCIH = 0x0;
0074D8  EF2370     CLR PG2FPCIH
368:                   PG2FPCIL = 0x0;
0074DA  EF236E     CLR PG2FPCIL
369:                   PG2IOCONH = 0x0;
0074DC  EF2368     CLR PG2IOCONH
370:                   PG2IOCONL = 0x0;
0074DE  EF2366     CLR PG2IOCONL
371:                   PG2LEBH = 0x0;
0074E0  EF2380     CLR PG2LEBH
372:                   PG2LEBL = 0x0;
0074E2  EF237E     CLR PG2LEBL
373:                   PG2PER = 0x0;
0074E4  EF2388     CLR PG2PER
374:                   PG2PHASE = 0x0;
0074E6  EF2382     CLR PG2PHASE
375:                   PG2SPCIH = 0x0;
0074E8  EF237C     CLR PG2SPCIH
376:                   PG2SPCIL = 0x0;
0074EA  EF237A     CLR PG2SPCIL
377:                   PG2STAT = 0x0;
0074EC  EF2364     CLR PG2STAT
378:                   PG2TRIGA = 0x0;
0074EE  EF238A     CLR PG2TRIGA
379:                   PG2TRIGB = 0x0;
0074F0  EF238C     CLR PG2TRIGB
380:                   PG2TRIGC = 0x0;
0074F2  EF238E     CLR PG2TRIGC
381:                   PG4CAP = 0x0;
0074F4  EF2400     CLR PG4CAP
382:                   PG4CLPCIH = 0x0;
0074F6  EF23E0     CLR PG4CLPCIH
383:                   PG4CLPCIL = 0x0;
0074F8  EF23DE     CLR PG4CLPCIL
384:                   PG4CONH = 0x0;
0074FA  EF23CE     CLR PG4CONH
385:                   PG4DC = 0x0;
0074FC  EF23F0     CLR PG4DC
386:                   PG4DCA = 0x0;
0074FE  EF23F2     CLR PG4DCA
387:                   PG4DTH = 0x0;
007500  EF23FE     CLR PG4DTH
388:                   PG4DTL = 0x0;
007502  EF23FC     CLR PG4DTL
389:                   PG4EVTH = 0x0;
007504  EF23D8     CLR PG4EVTH
390:                   PG4EVTL = 0x0;
007506  EF23D6     CLR PG4EVTL
391:                   PG4FFPCIH = 0x0;
007508  EF23E4     CLR PG4FFPCIH
392:                   PG4FFPCIL = 0x0;
00750A  EF23E2     CLR PG4FFPCIL
393:                   PG4FPCIH = 0x0;
00750C  EF23DC     CLR PG4FPCIH
394:                   PG4FPCIL = 0x0;
00750E  EF23DA     CLR PG4FPCIL
395:                   PG4IOCONH = 0x0;
007510  EF23D4     CLR PG4IOCONH
396:                   PG4IOCONL = 0x0;
007512  EF23D2     CLR PG4IOCONL
397:                   PG4LEBH = 0x0;
007514  EF23EC     CLR PG4LEBH
398:                   PG4LEBL = 0x0;
007516  EF23EA     CLR PG4LEBL
399:                   PG4PER = 0x0;
007518  EF23F4     CLR PG4PER
400:                   PG4PHASE = 0x0;
00751A  EF23EE     CLR PG4PHASE
401:                   PG4SPCIH = 0x0;
00751C  EF23E8     CLR PG4SPCIH
402:                   PG4SPCIL = 0x0;
00751E  EF23E6     CLR PG4SPCIL
403:                   PG4STAT = 0x0;
007520  EF23D0     CLR PG4STAT
404:                   PG4TRIGA = 0x0;
007522  EF23F6     CLR PG4TRIGA
405:                   PG4TRIGB = 0x0;
007524  EF23F8     CLR PG4TRIGB
406:                   PG4TRIGC = 0x0;
007526  EF23FA     CLR PG4TRIGC
407:                   CMBTRIGH = 0x0;
007528  EF2310     CLR CMBTRIGH
408:                   CMBTRIGL = 0x0;
00752A  EF230E     CLR CMBTRIGL
409:                   FSCL = 0x0;
00752C  EF2302     CLR FSCL
410:                   FSMINPER = 0x0;
00752E  EF2304     CLR FSMINPER
411:                   LFSR = 0x0;
007530  EF230C     CLR LFSR
412:                   LOGCONA = 0x0;
007532  EF2312     CLR LOGCONA
413:                   LOGCONB = 0x0;
007534  EF2314     CLR LOGCONB
414:                   LOGCONC = 0x0;
007536  EF2316     CLR LOGCONC
415:                   LOGCOND = 0x0;
007538  EF2318     CLR LOGCOND
416:                   LOGCONE = 0x0;
00753A  EF231A     CLR LOGCONE
417:                   LOGCONF = 0x0;
00753C  EF231C     CLR LOGCONF
418:                   MDC = 0x0;
00753E  EF2308     CLR MDC
419:                   MPER = 0x0;
007540  EF230A     CLR MPER
420:                   MPHASE = 0x0;
007542  EF2306     CLR MPHASE
421:                   PCLKCON = 0x0;
007544  EF2300     CLR PCLKCON
422:                   PWMEVTA = 0x0;
007546  EF231E     CLR PWMEVTA
423:                   PWMEVTB = 0x0;
007548  EF2320     CLR PWMEVTB
424:                   PWMEVTC = 0x0;
00754A  EF2322     CLR PWMEVTC
425:                   PWMEVTD = 0x0;
00754C  EF2324     CLR PWMEVTD
426:                   PWMEVTE = 0x0;
00754E  EF2326     CLR PWMEVTE
427:                   PWMEVTF = 0x0;
007550  EF2328     CLR PWMEVTF
428:               }
007552  060000     RETURN
007554  EB0080     CLR W1
429:               
430:               void PWM_GeneratorEOCEventCallbackRegister(void (*callback)(enum PWM_GENERATOR genNum))
431:               {
432:                   if(NULL != callback)
009E2A  E00000     CP0 W0
009E2C  320001     BRA Z, .L304
433:                   {
434:                       PWM_GeneratorEOCEventHandler = callback;
009E2E  889300     MOV W0, PWM_GeneratorEOCEventHandler
435:                   }
436:               }
009E30  060000     RETURN
009E32  E00000     CP0 W0
437:               
438:               void __attribute__ ((weak)) PWM_GeneratorEOCEventCallback ( enum PWM_GENERATOR genNum )
439:               { 
440:               
441:               } 
009FC4  060000     RETURN
009FC6  060000     RETURN
442:               
443:               
444:               void PWM_GeneratorTasks (enum PWM_GENERATOR intGen)
445:               {
446:                   switch(intGen)
008E06  500FE2     SUB W0, #0x2, [W15]
008E08  32000D     BRA Z, .L311
008E0A  500FE4     SUB W0, #0x4, [W15]
008E0C  320014     BRA Z, .L312
008E0E  500FE1     SUB W0, #0x1, [W15]
008E10  3A001A     BRA NZ, .L308
447:                   {
448:                       case MOTOR1_PHASE_A:
449:                           if(IFS4bits.PWM1IF == 1)
008E12  AB6808     BTST IFS4, #3
008E14  320018     BRA Z, .L308
450:                           {
451:                               if(NULL != PWM_GeneratorEOCEventHandler)
008E16  809301     MOV PWM_GeneratorEOCEventHandler, W1
008E18  E00001     CP0 W1
008E1A  320002     BRA Z, .L313
452:                               {
453:                                   (*PWM_GeneratorEOCEventHandler)(intGen);
008E1C  200010     MOV #0x1, W0
008E1E  010001     CALL W1
454:                               }
455:                               IFS4bits.PWM1IF = 0;
008E20  A96808     BCLR IFS4, #3
008E22  370011     BRA .L308
456:                           }
457:                           break;
458:                       case MOTOR1_PHASE_B:
459:                           if(IFS4bits.PWM2IF == 1)
008E24  AB8808     BTST IFS4, #4
008E26  32000F     BRA Z, .L308
460:                           {
461:                               if(NULL != PWM_GeneratorEOCEventHandler)
008E28  809301     MOV PWM_GeneratorEOCEventHandler, W1
008E2A  E00001     CP0 W1
008E2C  320002     BRA Z, .L314
462:                               {
463:                                   (*PWM_GeneratorEOCEventHandler)(intGen);
008E2E  200020     MOV #0x2, W0
008E30  010001     CALL W1
464:                               }
465:                               IFS4bits.PWM2IF = 0;
008E32  A98808     BCLR IFS4, #4
008E34  370008     BRA .L308
466:                           }
467:                           break;
468:                       case MOTOR1_PHASE_C:
469:                           if(IFS4bits.PWM4IF == 1)
008E36  ABC808     BTST IFS4, #6
008E38  320006     BRA Z, .L308
470:                           {
471:                               if(NULL != PWM_GeneratorEOCEventHandler)
008E3A  809301     MOV PWM_GeneratorEOCEventHandler, W1
008E3C  E00001     CP0 W1
008E3E  320002     BRA Z, .L315
472:                               {
473:                                   (*PWM_GeneratorEOCEventHandler)(intGen);
008E40  200040     MOV #0x4, W0
008E42  010001     CALL W1
474:                               }
475:                               IFS4bits.PWM4IF = 0;
008E44  A9C808     BCLR IFS4, #6
476:                           }
477:                           break;
478:                       default:
479:                           break;
480:                   }
481:               }
008E46  060000     RETURN
008E48  0706B9     RCALL UART1_BRGCountGet
482:               
483:               /**
484:                End of File
485:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/pwm_hs/pwm.h
1:                 /**
2:                  * PWM Generated Driver Header File 
3:                  * 
4:                  * @file      pwm.h
5:                  * 
6:                  * @ingroup   pwmhsdriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the PWM driver
9:                  *
10:                 * @version   Firmware Driver Version 1.1.5
11:                 *
12:                 * @version   PLIB Version 2.2.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef PWM_H
39:                #define PWM_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdint.h>
45:                #include <stdbool.h>
46:                #include <stdlib.h>
47:                #include "pwm_hs_types.h"
48:                #include "pwm_hs_interface.h"
49:                
50:                // Section: Data Type Definitions
51:                
52:                
53:                /**
54:                 @ingroup  pwmhsdriver
55:                 @brief    Structure object of type PWM_HS_INTERFACE with the 
56:                           custom name given by the user in the Melody Driver User interface. 
57:                           The default name e.g. PWM_HS can be changed by the 
58:                           user in the PWM user interface. 
59:                           This allows defining a structure with application specific name 
60:                           using the 'Custom Name' field. Application specific name allows the 
61:                           API Portability.
62:                */
63:                extern const struct PWM_HS_INTERFACE MCC_PWM;
64:                
65:                /**
66:                 * @ingroup  pwmdriver
67:                 * @brief    This macro defines the Custom Name for \ref PWM_Initialize API
68:                 */
69:                #define MCC_PWM_Initialize PWM_Initialize
70:                /**
71:                 * @ingroup  pwmdriver
72:                 * @brief    This macro defines the Custom Name for \ref PWM_Deinitialize API
73:                 */
74:                #define MCC_PWM_Deinitialize PWM_Deinitialize
75:                /**
76:                 * @ingroup  pwmdriver
77:                 * @brief    This macro defines the Custom Name for \ref PWM_Disable API
78:                 */
79:                #define MCC_PWM_Disable PWM_Disable
80:                /**
81:                 * @ingroup  pwmdriver
82:                 * @brief    This macro defines the Custom Name for \ref PWM_Enable API
83:                 */
84:                #define MCC_PWM_Enable PWM_Enable
85:                /**
86:                 * @ingroup  pwmdriver
87:                 * @brief    This macro defines the Custom Name for \ref PWM_MasterPeriodSet API
88:                 */
89:                #define MCC_PWM_MasterPeriodSet PWM_MasterPeriodSet
90:                /**
91:                 * @ingroup  pwmdriver
92:                 * @brief    This macro defines the Custom Name for \ref PWM_MasterDutyCycleSet API
93:                 */
94:                #define MCC_PWM_MasterDutyCycleSet PWM_MasterDutyCycleSet
95:                /**
96:                 * @ingroup  pwmdriver
97:                 * @brief    This macro defines the Custom Name for \ref PWM_MasterPhaseSet API
98:                 */
99:                #define MCC_PWM_MasterPhaseSet PWM_MasterPhaseSet
100:               /**
101:                * @ingroup  pwmdriver
102:                * @brief    This macro defines the Custom Name for \ref PWM_PeriodSet API
103:                */
104:               #define MCC_PWM_PeriodSet PWM_PeriodSet
105:               /**
106:                * @ingroup  pwmdriver
107:                * @brief    This macro defines the Custom Name for \ref PWM_ModeSet API
108:                */
109:               #define MCC_PWM_ModeSet PWM_ModeSet
110:               /**
111:                * @ingroup  pwmdriver
112:                * @brief    This macro defines the Custom Name for \ref PWM_DutyCycleSet API
113:                */
114:               #define MCC_PWM_DutyCycleSet PWM_DutyCycleSet
115:               /**
116:                * @ingroup  pwmdriver
117:                * @brief    This macro defines the Custom Name for \ref PWM_PhaseSelect API
118:                */
119:               #define MCC_PWM_PhaseSelect PWM_PhaseSelect
120:               /**
121:                * @ingroup  pwmdriver
122:                * @brief    This macro defines the Custom Name for \ref PWM_PhaseSet API
123:                */
124:               #define MCC_PWM_PhaseSet PWM_PhaseSet
125:               /**
126:                * @ingroup  pwmdriver
127:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideDataSet API
128:                */
129:               #define MCC_PWM_OverrideDataSet PWM_OverrideDataSet
130:               /**
131:                * @ingroup  pwmdriver
132:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideDataHighSet API
133:                */
134:               #define MCC_PWM_OverrideDataHighSet PWM_OverrideDataHighSet
135:               /**
136:                * @ingroup  pwmdriver
137:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideDataLowSet API
138:                */
139:               #define MCC_PWM_OverrideDataLowSet PWM_OverrideDataLowSet
140:               /**
141:                * @ingroup  pwmdriver
142:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideDataGet API
143:                */
144:               #define MCC_PWM_OverrideDataGet PWM_OverrideDataGet
145:               /**
146:                * @ingroup  pwmdriver
147:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideHighEnable API
148:                */
149:               #define MCC_PWM_OverrideHighEnable PWM_OverrideHighEnable
150:               /**
151:                * @ingroup  pwmdriver
152:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideLowEnable API
153:                */
154:               #define MCC_PWM_OverrideLowEnable PWM_OverrideLowEnable
155:               /**
156:                * @ingroup  pwmdriver
157:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideHighDisable API
158:                */
159:               #define MCC_PWM_OverrideHighDisable PWM_OverrideHighDisable
160:               /**
161:                * @ingroup  pwmdriver
162:                * @brief    This macro defines the Custom Name for \ref PWM_OverrideLowDisable API
163:                */
164:               #define MCC_PWM_OverrideLowDisable PWM_OverrideLowDisable
165:               /**
166:                * @ingroup  pwmdriver
167:                * @brief    This macro defines the Custom Name for \ref PWM_DeadTimeLowSet API
168:                */
169:               #define MCC_PWM_DeadTimeLowSet PWM_DeadTimeLowSet
170:               /**
171:                * @ingroup  pwmdriver
172:                * @brief    This macro defines the Custom Name for \ref PWM_DeadTimeHighSet API
173:                */
174:               #define MCC_PWM_DeadTimeHighSet PWM_DeadTimeHighSet
175:               /**
176:                * @ingroup  pwmdriver
177:                * @brief    This macro defines the Custom Name for \ref PWM_DeadTimeSet API
178:                */
179:               #define MCC_PWM_DeadTimeSet PWM_DeadTimeSet
180:               /**
181:                * @ingroup  pwmdriver
182:                * @brief    This macro defines the Custom Name for \ref PWM_TriggerCompareValueSet API
183:                */
184:               #define MCC_PWM_TriggerCompareValueSet PWM_TriggerCompareValueSet
185:               /**
186:                * @ingroup  pwmdriver
187:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorInterruptEnable API
188:                */
189:               #define MCC_PWM_GeneratorInterruptEnable PWM_GeneratorInterruptEnable
190:               /**
191:                * @ingroup  pwmdriver
192:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorInterruptDisable API
193:                */
194:               #define MCC_PWM_GeneratorInterruptDisable PWM_GeneratorInterruptDisable
195:               /**
196:                * @ingroup  pwmdriver
197:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorEventStatusGet API
198:                */
199:               #define MCC_PWM_GeneratorEventStatusGet PWM_GeneratorEventStatusGet
200:               /**
201:                * @ingroup  pwmdriver
202:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorEventStatusClear API
203:                */
204:               #define MCC_PWM_GeneratorEventStatusClear PWM_GeneratorEventStatusClear
205:               /**
206:                * @ingroup  pwmdriver
207:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorDisable API
208:                */
209:               #define MCC_PWM_GeneratorDisable PWM_GeneratorDisable
210:               /**
211:                * @ingroup  pwmdriver
212:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorEnable API
213:                */
214:               #define MCC_PWM_GeneratorEnable PWM_GeneratorEnable
215:               /**
216:                * @ingroup  pwmdriver
217:                * @brief    This macro defines the Custom Name for \ref PWM_TriggerACompareValueSet API
218:                */
219:               #define MCC_PWM_TriggerACompareValueSet PWM_TriggerACompareValueSet
220:               /**
221:                * @ingroup  pwmdriver
222:                * @brief    This macro defines the Custom Name for \ref PWM_TriggerBCompareValueSet API
223:                */
224:               #define MCC_PWM_TriggerBCompareValueSet PWM_TriggerBCompareValueSet
225:               /**
226:                * @ingroup  pwmdriver
227:                * @brief    This macro defines the Custom Name for \ref PWM_TriggerCCompareValueSet API
228:                */
229:               #define MCC_PWM_TriggerCCompareValueSet PWM_TriggerCCompareValueSet
230:               /**
231:                * @ingroup  pwmdriver
232:                * @brief    This macro defines the Custom Name for \ref PWM_SoftwareUpdateRequest API
233:                */
234:               #define MCC_PWM_SoftwareUpdateRequest PWM_SoftwareUpdateRequest
235:               /**
236:                * @ingroup  pwmdriver
237:                * @brief    This macro defines the Custom Name for \ref PWM_SoftwareUpdatePending API
238:                */
239:               #define MCC_PWM_SoftwareUpdatePending PWM_SoftwareUpdatePending
240:               /**
241:                * @ingroup  pwmdriver
242:                * @brief    This macro defines the Custom Name for \ref PWM_FaultModeLatchClear API
243:                */
244:               #define MCC_PWM_FaultModeLatchClear PWM_FaultModeLatchClear
245:               /**
246:                * @ingroup  pwmdriver
247:                * @brief    This macro defines the Custom Name for \ref PWM_Trigger1Enable API
248:                */
249:                #define MCC_PWM_Trigger1Enable PWM_Trigger1Enable
250:               /**
251:                * @ingroup  pwmdriver
252:                * @brief    This macro defines the Custom Name for \ref PWM_Trigger1Disable API
253:                */
254:               #define MCC_PWM_Trigger1Disable PWM_Trigger1Disable
255:               /**
256:                * @ingroup  pwmdriver
257:                * @brief    This macro defines the Custom Name for \ref PWM_Trigger2Enable API
258:                */
259:                #define MCC_PWM_Trigger2Enable PWM_Trigger2Enable
260:               /**
261:                * @ingroup  pwmdriver
262:                * @brief    This macro defines the Custom Name for \ref PWM_Trigger2Disable API
263:                */
264:               #define MCC_PWM_Trigger2Disable PWM_Trigger2Disable
265:               /**
266:                * @ingroup  pwmdriver
267:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorEOCEventCallbackRegister API
268:                */
269:               #define MCC_PWM_GeneratorEOCEventCallbackRegister PWM_GeneratorEOCEventCallbackRegister
270:               
271:               /**
272:                * @ingroup  pwmdriver
273:                * @brief    This macro defines the Custom Name for \ref PWM_GeneratorTasks API
274:                */
275:               #define MCC_PWM_GeneratorTasks PWM_GeneratorTasks
276:               
277:               // Section: PWM Module APIs
278:               
279:               /**
280:                * @ingroup  pwmhsdriver
281:                * @brief    Initializes PWM module, using the given initialization data
282:                * @return   none  
283:                */
284:               void PWM_Initialize(void);
285:               
286:               /**
287:                * @ingroup  pwmhsdriver
288:                * @brief    Deinitializes the PWM to POR values
289:                * @return   none  
290:                */
291:               void PWM_Deinitialize(void);
292:               
293:               /**
294:                * @ingroup    pwmhsdriver
295:                * @brief      This inline function enables the specific PWM generator selected by the argument 
296:                *             PWM_GENERATOR.
297:                * @param[in]  genNum - PWM generator number  
298:                * @return     none  
299:                */
300:               inline static void PWM_GeneratorEnable(enum PWM_GENERATOR genNum)
301:               {
302:                   switch(genNum) { 
0098C0  500FE2     SUB W0, #0x2, [W15]
0098C2  320006     BRA Z, .L4
0098C4  500FE4     SUB W0, #0x4, [W15]
0098C6  320006     BRA Z, .L5
0098C8  500FE1     SUB W0, #0x1, [W15]
0098CA  3A0005     BRA NZ, .L1
303:                       case MOTOR1_PHASE_A:
304:                               PG1CONLbits.ON = 1;              
0098CC  A8E32B     BSET 0x32B, #7
305:                               break;       
0098CE  370003     BRA .L1
306:                       case MOTOR1_PHASE_B:
307:                               PG2CONLbits.ON = 1;              
0098D0  A8E361     BSET 0x361, #7
308:                               break;       
0098D2  370001     BRA .L1
309:                       case MOTOR1_PHASE_C:
310:                               PG4CONLbits.ON = 1;              
0098D4  A8E3CD     BSET 0x3CD, #7
311:                               break;       
312:                       default:break;    
313:                   }     
314:               }
0098D6  060000     RETURN
315:               
316:               /**
317:                * @ingroup    pwmhsdriver
318:                * @brief      This inline function disables the specific PWM generator selected by the argument 
319:                *             PWM_GENERATOR.
320:                * @param[in]  genNum - PWM generator number
321:                * @return     none  
322:                */
323:               inline static void PWM_GeneratorDisable(enum PWM_GENERATOR genNum)
324:               {
325:                   switch(genNum) { 
0098D8  500FE2     SUB W0, #0x2, [W15]
0098DA  320006     BRA Z, .L9
0098DC  500FE4     SUB W0, #0x4, [W15]
0098DE  320006     BRA Z, .L10
0098E0  500FE1     SUB W0, #0x1, [W15]
0098E2  3A0005     BRA NZ, .L6
326:                       case MOTOR1_PHASE_A:
327:                               PG1CONLbits.ON = 0;              
0098E4  A9E32B     BCLR 0x32B, #7
328:                               break;       
0098E6  370003     BRA .L6
329:                       case MOTOR1_PHASE_B:
330:                               PG2CONLbits.ON = 0;              
0098E8  A9E361     BCLR 0x361, #7
331:                               break;       
0098EA  370001     BRA .L6
332:                       case MOTOR1_PHASE_C:
333:                               PG4CONLbits.ON = 0;              
0098EC  A9E3CD     BCLR 0x3CD, #7
334:                               break;       
335:                       default:break;    
336:                   }    
337:               }
0098EE  060000     RETURN
0098F0  500FE2     SUB W0, #0x2, [W15]
338:               
339:               /**
340:                * @ingroup    pwmhsdriver
341:                * @brief      This inline function sets the operating mode of specific PWM generator selected                  
342:                *             by the argument PWM_GENERATOR.
343:                * @param[in]  genNum - PWM generator number
344:                * @param[in]  mode - PWM operating mode
345:                * @return     none  
346:                */
347:               inline static void PWM_ModeSet(enum PWM_GENERATOR genNum, enum PWM_MODES mode)
348:               {
349:                   switch(genNum) { 
008966  500FE2     SUB W0, #0x2, [W15]
350:                       case MOTOR1_PHASE_A:
351:                               PG1CONLbits.MODSEL = mode; 
008972  0A2120     BFINS #0x0, #0x3, W1, PG1CONL
008974  00032A     NOP
008DD4  2FFF81     MOV #0xFFF8, W1
008DD6  801952     MOV PG1CONL, W2
008DD8  608002     AND W1, W2, W0
008DDA  B30050     IOR #0x5, W0
008DDC  881950     MOV W0, PG1CONL
352:                               if(mode == PWM_MODE_INDEPENDENT_EDGE_DUAL_OUTPUT)      
008976  508FE2     SUB W1, #0x2, [W15]
008978  3A0005     BRA NZ, .L16
353:                               {
354:                                  PG1IOCONHbits.PMOD = 0x1;
00897A  2FFCF0     MOV #0xFFCF, W0
00897C  B60332     AND PG1IOCONH, WREG
00897E  A04000     BSET W0, #4
008980  881990     MOV W0, PG1IOCONH
008982  37001A     BRA .L11
355:                               }       
356:                               else
357:                               {
358:                                  PG1IOCONHbits.PMOD = 0x0;
008984  2FFCF0     MOV #0xFFCF, W0
008986  B62332     AND PG1IOCONH
008988  370017     BRA .L11
008DDE  2FFCF0     MOV #0xFFCF, W0
008DE0  B62332     AND PG1IOCONH
359:                               }
360:                               break;       
361:                       case MOTOR1_PHASE_B:
362:                               PG2CONLbits.MODSEL = mode; 
00898A  0A2120     BFINS #0x0, #0x3, W1, PG2CONL
00898C  000360     NOP
008DE2  801B03     MOV PG2CONL, W3
008DE4  608103     AND W1, W3, W2
008DE6  B30052     IOR #0x5, W2
008DE8  881B02     MOV W2, PG2CONL
363:                               if(mode == PWM_MODE_INDEPENDENT_EDGE_DUAL_OUTPUT)      
00898E  508FE2     SUB W1, #0x2, [W15]
008990  3A0005     BRA NZ, .L17
364:                               {
365:                                  PG2IOCONHbits.PMOD = 0x1;
008992  2FFCF0     MOV #0xFFCF, W0
008994  B60368     AND PG2IOCONH, WREG
008996  A04000     BSET W0, #4
008998  881B40     MOV W0, PG2IOCONH
00899A  37000E     BRA .L11
366:                               }       
367:                               else
368:                               {
369:                                  PG2IOCONHbits.PMOD = 0x0;
00899C  2FFCF0     MOV #0xFFCF, W0
00899E  B62368     AND PG2IOCONH
0089A0  37000B     BRA .L11
008DEA  B62368     AND PG2IOCONH
370:                               }
371:                               break;       
372:                       case MOTOR1_PHASE_C:
373:                               PG4CONLbits.MODSEL = mode; 
0089A2  0A2120     BFINS #0x0, #0x3, W1, PG4CONL
0089A4  0003CC     NOP
008DEC  801E62     MOV PG4CONL, W2
008DEE  608082     AND W1, W2, W1
008DF0  B30051     IOR #0x5, W1
008DF2  881E61     MOV W1, PG4CONL
374:                               if(mode == PWM_MODE_INDEPENDENT_EDGE_DUAL_OUTPUT)      
0089A6  508FE2     SUB W1, #0x2, [W15]
0089A8  3A0005     BRA NZ, .L18
375:                               {
376:                                  PG4IOCONHbits.PMOD = 0x1;
0089AA  2FFCF0     MOV #0xFFCF, W0
0089AC  B603D4     AND PG4IOCONH, WREG
0089AE  A04000     BSET W0, #4
0089B0  881EA0     MOV W0, PG4IOCONH
0089B2  370002     BRA .L11
377:                               }       
378:                               else
379:                               {
380:                                  PG4IOCONHbits.PMOD = 0x0;
0089B4  2FFCF0     MOV #0xFFCF, W0
0089B6  B623D4     AND PG4IOCONH
008DF4  B623D4     AND PG4IOCONH
381:                               }
382:                               break;       
383:                       default:break;    
384:                   }    
385:               }
0089B8  060000     RETURN
0089BA  500FE2     SUB W0, #0x2, [W15]
386:               
387:               /**
388:                * @ingroup  pwmhsdriver
389:                * @brief    This inline function will enable all the generators of PWM module
390:                * @return   none  
391:                */
392:               inline static void PWM_Enable(void)
393:               {
394:                   PG1CONLbits.ON = 1;              
008DF6  A8E32B     BSET 0x32B, #7
009E1A  A8E32B     BSET 0x32B, #7
395:                   PG2CONLbits.ON = 1;              
008DF8  A8E361     BSET 0x361, #7
009E1C  A8E361     BSET 0x361, #7
396:                   PG4CONLbits.ON = 1;              
008DFA  A8E3CD     BSET 0x3CD, #7
009E1E  A8E3CD     BSET 0x3CD, #7
397:               }
009E20  060000     RETURN
009E22  A9E32B     BCLR 0x32B, #7
398:               
399:               /**
400:                * @ingroup  pwmhsdriver
401:                * @brief    This inline function will disable all the generators of PWM module
402:                * @return   none  
403:                */
404:               inline static void PWM_Disable(void)
405:               {
406:                   PG1CONLbits.ON = 0;              
007480  A9E32B     BCLR 0x32B, #7
009E22  A9E32B     BCLR 0x32B, #7
407:                   PG2CONLbits.ON = 0;              
007482  A9E361     BCLR 0x361, #7
009E24  A9E361     BCLR 0x361, #7
408:                   PG4CONLbits.ON = 0;              
007484  A9E3CD     BCLR 0x3CD, #7
009E26  A9E3CD     BCLR 0x3CD, #7
409:               }
009E28  060000     RETURN
009E2A  E00000     CP0 W0
410:               
411:               /**
412:                * @ingroup    pwmhsdriver
413:                * @brief      This inline function sets the period value in count for the Master Time Base generator
414:                * @param[in]  masterPeriod - Period value in count
415:                * @return     none  
416:                */
417:               inline static void PWM_MasterPeriodSet(uint16_t masterPeriod)
418:               {
419:                   MPER = masterPeriod;
0081EE  213870     MOV #0x1387, W0
0081F0  881850     MOV W0, MPER
009F7A  881850     MOV W0, MPER
420:               }
009F7C  060000     RETURN
421:               
422:               /**
423:                * @ingroup    pwmhsdriver
424:                * @brief      This inline function sets the PWM master duty cycle register
425:                * @param[in]  masterDutyCycle - Master Duty Cycle value
426:                * @return     none
427:                */
428:               inline static void PWM_MasterDutyCycleSet(uint16_t masterDutyCycle)
429:               {
430:                   MDC = masterDutyCycle;
009F7E  881840     MOV W0, MDC
431:               }
009F80  060000     RETURN
432:               
433:               /**
434:                * @ingroup    pwmhsdriver
435:                * @brief      This inline function sets the phase value in count for the Master Time Base generator
436:                * @param[in]  masterPhase - Phase value in count
437:                * @return     none  
438:                */
439:               inline static void PWM_MasterPhaseSet(uint16_t masterPhase)
440:               {
441:                   MPHASE = masterPhase;
009F82  881830     MOV W0, MPHASE
442:               }
009F84  060000     RETURN
009F86  A9E141     BCLR 0x141, #7
443:               
444:               /**
445:                * @ingroup    pwmhsdriver
446:                * @brief      This inline function sets the period value in count for the PWM generator specific Time Base.
447:                * @param[in]  genNum - PWM generator number
448:                * @param[in]  period - PWM generator period value in count
449:                * @return     none  
450:                */
451:               inline static void PWM_PeriodSet(enum PWM_GENERATOR genNum,uint16_t period)
452:               {
453:                   switch(genNum) { 
0098F0  500FE2     SUB W0, #0x2, [W15]
0098F2  320006     BRA Z, .L27
0098F4  500FE4     SUB W0, #0x4, [W15]
0098F6  320006     BRA Z, .L28
0098F8  500FE1     SUB W0, #0x1, [W15]
0098FA  3A0005     BRA NZ, .L24
454:                       case MOTOR1_PHASE_A:
455:                               PG1PER = period;              
0098FC  881A91     MOV W1, PG1PER
456:                               break;       
0098FE  370003     BRA .L24
457:                       case MOTOR1_PHASE_B:
458:                               PG2PER = period;              
009900  881C41     MOV W1, PG2PER
459:                               break;       
009902  370001     BRA .L24
460:                       case MOTOR1_PHASE_C:
461:                               PG4PER = period;              
009904  881FA1     MOV W1, PG4PER
462:                               break;       
463:                       default:break;    
464:                   }   
465:               }
009906  060000     RETURN
466:               
467:               /**
468:                * @ingroup    pwmhsdriver
469:                * @brief      This inline function sets the PWM generator specific duty cycle register
470:                * @param[in]  genNum      - PWM generator number
471:                * @param[in]  dutyCycle   - PWM generator duty cycle
472:                * @return     none  
473:                */
474:               inline static void PWM_DutyCycleSet(enum PWM_GENERATOR genNum,uint16_t dutyCycle)
475:               {
476:                   switch(genNum) { 
009908  500FE2     SUB W0, #0x2, [W15]
00990A  320006     BRA Z, .L32
00990C  500FE4     SUB W0, #0x4, [W15]
00990E  320006     BRA Z, .L33
009910  500FE1     SUB W0, #0x1, [W15]
009912  3A0005     BRA NZ, .L29
477:                       case MOTOR1_PHASE_A:
478:                               PG1DC = dutyCycle;              
004C7E  212A70     MOV #0x12A7, W0
004C80  881A70     MOV W0, PG1DC
004CD6  200910     MOV #0x91, W0
004CD8  881A70     MOV W0, PG1DC
004D0C  881A72     MOV W2, PG1DC
004D56  881A72     MOV W2, PG1DC
004D74  212A70     MOV #0x12A7, W0
004D76  881A70     MOV W0, PG1DC
004DBC  212A70     MOV #0x12A7, W0
004DBE  881A70     MOV W0, PG1DC
004DDC  212A70     MOV #0x12A7, W0
004DDE  881A70     MOV W0, PG1DC
004EB4  200910     MOV #0x91, W0
004EB6  881A70     MOV W0, PG1DC
004EE4  881A72     MOV W2, PG1DC
006F20  9000C0     MOV [W0+8], W1
006F22  881A71     MOV W1, PG1DC
008204  200910     MOV #0x91, W0
008206  881A70     MOV W0, PG1DC
009914  881A71     MOV W1, PG1DC
479:                               break;       
009916  370003     BRA .L29
480:                       case MOTOR1_PHASE_B:
481:                               PG2DC = dutyCycle;              
004C82  881C20     MOV W0, PG2DC
004CDA  881C20     MOV W0, PG2DC
004D0E  881C21     MOV W1, PG2DC
004D58  881C21     MOV W1, PG2DC
004D78  881C20     MOV W0, PG2DC
004DC0  881C20     MOV W0, PG2DC
004DE0  881C20     MOV W0, PG2DC
004EB8  881C20     MOV W0, PG2DC
004EE6  881C21     MOV W1, PG2DC
006F24  9000D0     MOV [W0+10], W1
006F26  881C21     MOV W1, PG2DC
008208  881C20     MOV W0, PG2DC
009918  881C21     MOV W1, PG2DC
482:                               break;       
00991A  370001     BRA .L29
483:                       case MOTOR1_PHASE_C:
484:                               PG4DC = dutyCycle;              
004C84  881F80     MOV W0, PG4DC
004CDC  881F80     MOV W0, PG4DC
004D10  881F80     MOV W0, PG4DC
004D12  3700EB     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004D5A  881F80     MOV W0, PG4DC
004D5C  3700C6     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004D7A  881F80     MOV W0, PG4DC
004DC2  881F80     MOV W0, PG4DC
004DE2  881F80     MOV W0, PG4DC
004DE4  370082     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004EBA  881F80     MOV W0, PG4DC
004EE8  881F80     MOV W0, PG4DC
006F28  9000E0     MOV [W0+12], W1
006F2A  881F81     MOV W1, PG4DC
00820A  881F80     MOV W0, PG4DC
00991C  881F81     MOV W1, PG4DC
485:                               break;       
486:                       default:break;    
487:                   }  
488:               }
00991E  060000     RETURN
009920  500FE2     SUB W0, #0x2, [W15]
489:               
490:               /**
491:                * @ingroup    pwmhsdriver
492:                * @brief      This inline function selects the PWM generator source for Phase
493:                * @param[in]  genNum - PWM generator number
494:                * @param[in]  source - PWM generator source select
495:                * @return     none  
496:                */
497:               inline static void PWM_PhaseSelect(enum PWM_GENERATOR genNum,enum PWM_SOURCE_SELECT source)
498:               {
499:                   switch(genNum) { 
00902A  500FE2     SUB W0, #0x2, [W15]
500:                       case MOTOR1_PHASE_A:
501:                               PG1CONHbits.MPHSEL = source;              
008DCE  A8A32D     BSET 0x32D, #5
009036  6080E1     AND W1, #0x1, W1
009038  DD08CD     SL W1, #13, W1
00903A  801960     MOV PG1CONH, W0
00903C  A1D000     BCLR W0, #13
00903E  708000     IOR W1, W0, W0
009040  881960     MOV W0, PG1CONH
502:                               break;       
009042  37000D     BRA .L34
503:                       case MOTOR1_PHASE_B:
504:                               PG2CONHbits.MPHSEL = source;              
008DD0  A8A363     BSET 0x363, #5
009044  6080E1     AND W1, #0x1, W1
009046  DD08CD     SL W1, #13, W1
009048  801B10     MOV PG2CONH, W0
00904A  A1D000     BCLR W0, #13
00904C  708000     IOR W1, W0, W0
00904E  881B10     MOV W0, PG2CONH
505:                               break;       
009050  370006     BRA .L34
506:                       case MOTOR1_PHASE_C:
507:                               PG4CONHbits.MPHSEL = source;              
008DD2  A8A3CF     BSET 0x3CF, #5
009052  6080E1     AND W1, #0x1, W1
009054  DD08CD     SL W1, #13, W1
009056  801E70     MOV PG4CONH, W0
009058  A1D000     BCLR W0, #13
00905A  708000     IOR W1, W0, W0
00905C  881E70     MOV W0, PG4CONH
508:                               break;       
509:                       default:break;    
510:                   } 
511:               }
00905E  060000     RETURN
009060  500FE2     SUB W0, #0x2, [W15]
512:               
513:               /**
514:                * @ingroup    pwmhsdriver
515:                * @brief      This inline function sets the phase value in count for the PWM generator specific Time Base
516:                * @param[in]  genNum - PWM generator number
517:                * @param[in]  phase - PWM generator phase value in count
518:                * @return     none  
519:                */
520:               inline static void PWM_PhaseSet(enum PWM_GENERATOR genNum,uint16_t phase)
521:               {
522:                   switch(genNum) { 
009920  500FE2     SUB W0, #0x2, [W15]
009922  320006     BRA Z, .L42
009924  500FE4     SUB W0, #0x4, [W15]
009926  320006     BRA Z, .L43
009928  500FE1     SUB W0, #0x1, [W15]
00992A  3A0005     BRA NZ, .L39
523:                       case MOTOR1_PHASE_A:
524:                               PG1PHASE = phase;              
00992C  881A61     MOV W1, PG1PHASE
525:                               break;       
00992E  370003     BRA .L39
526:                       case MOTOR1_PHASE_B:
527:                               PG2PHASE = phase;              
009930  881C11     MOV W1, PG2PHASE
528:                               break;       
009932  370001     BRA .L39
529:                       case MOTOR1_PHASE_C:
530:                               PG4PHASE = phase;              
009934  881F71     MOV W1, PG4PHASE
531:                               break;       
532:                       default:break;    
533:                   } 
534:               }
009936  060000     RETURN
009938  500FE2     SUB W0, #0x2, [W15]
535:               
536:               /**
537:                * @ingroup    pwmhsdriver
538:                * @brief      This inline function updates PWM override data bits with the requested value for a 
539:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR.
540:                * @param[in]  genNum          -   PWM generator number
541:                * @param[in]  overrideData    -   Override data  
542:                * @return     none  
543:                */
544:               inline static void PWM_OverrideDataSet(enum PWM_GENERATOR genNum,uint16_t overrideData)
545:               {
546:                   switch(genNum) { 
009060  500FE2     SUB W0, #0x2, [W15]
009062  32000B     BRA Z, .L47
009064  500FE4     SUB W0, #0x4, [W15]
009066  320010     BRA Z, .L48
009068  500FE1     SUB W0, #0x1, [W15]
00906A  3A0014     BRA NZ, .L44
547:                       case MOTOR1_PHASE_A:
548:                               PG1IOCONLbits.OVRDAT = overrideData;              
004C70  2F3FF0     MOV #0xF3FF, W0
004C72  B62330     AND PG1IOCONL
004D66  2F3FF0     MOV #0xF3FF, W0
004D68  B62330     AND PG1IOCONL
004DAE  2F3FF0     MOV #0xF3FF, W0
004DB0  B62330     AND PG1IOCONL
004DCE  2F3FF0     MOV #0xF3FF, W0
004DD0  B62330     AND PG1IOCONL
006E76  2F3FF1     MOV #0xF3FF, W1
006E78  203302     MOV #0x330, W2
006E7A  608912     AND W1, [W2], [W2]
006E98  203302     MOV #0x330, W2
006E9A  608912     AND W1, [W2], [W2]
00820C  2F3FF0     MOV #0xF3FF, W0
00820E  B62330     AND PG1IOCONL
00886E  2F3FF0     MOV #0xF3FF, W0
008870  B62330     AND PG1IOCONL
00906C  6080E3     AND W1, #0x3, W1
00906E  DD08CA     SL W1, #10, W1
009070  2F3FF0     MOV #0xF3FF, W0
009072  B60330     AND PG1IOCONL, WREG
009074  708000     IOR W1, W0, W0
009076  881980     MOV W0, PG1IOCONL
549:                               break;       
009078  37000D     BRA .L44
550:                       case MOTOR1_PHASE_B:
551:                               PG2IOCONLbits.OVRDAT = overrideData;              
004C74  B62366     AND PG2IOCONL
004D6A  B62366     AND PG2IOCONL
004DB2  B62366     AND PG2IOCONL
004DD2  B62366     AND PG2IOCONL
006E7C  203662     MOV #0x366, W2
006E7E  608912     AND W1, [W2], [W2]
006E9C  203662     MOV #0x366, W2
006E9E  608912     AND W1, [W2], [W2]
008210  B62366     AND PG2IOCONL
008872  B62366     AND PG2IOCONL
00907A  6080E3     AND W1, #0x3, W1
00907C  DD08CA     SL W1, #10, W1
00907E  2F3FF0     MOV #0xF3FF, W0
009080  B60366     AND PG2IOCONL, WREG
009082  708000     IOR W1, W0, W0
009084  881B30     MOV W0, PG2IOCONL
552:                               break;       
009086  370006     BRA .L44
553:                       case MOTOR1_PHASE_C:
554:                               PG4IOCONLbits.OVRDAT = overrideData;              
004C76  B623D2     AND PG4IOCONL
004D6C  B623D2     AND PG4IOCONL
004DB4  B623D2     AND PG4IOCONL
004DD4  B623D2     AND PG4IOCONL
006E80  203D22     MOV #0x3D2, W2
006E82  608912     AND W1, [W2], [W2]
006EA0  203D22     MOV #0x3D2, W2
006EA2  608912     AND W1, [W2], [W2]
008212  B623D2     AND PG4IOCONL
008874  B623D2     AND PG4IOCONL
009088  6080E3     AND W1, #0x3, W1
00908A  DD08CA     SL W1, #10, W1
00908C  2F3FF0     MOV #0xF3FF, W0
00908E  B603D2     AND PG4IOCONL, WREG
009090  708000     IOR W1, W0, W0
009092  881E90     MOV W0, PG4IOCONL
555:                               break;       
556:                       default:break;    
557:                   }
558:               }
009094  060000     RETURN
009096  781F88     MOV W8, [W15++]
559:               
560:               /**
561:                * @ingroup    pwmhsdriver
562:                * @brief      This inline function updates PWM override high data bit with the requested value for a 
563:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR.
564:                * @param[in]  genNum              - PWM generator number
565:                * @param[in]  overrideDataHigh    - Override data  
566:                * @return     none  
567:                */
568:               inline static void PWM_OverrideDataHighSet(enum PWM_GENERATOR genNum,bool overrideDataHigh)
569:               {
570:                   switch(genNum) { 
0089BA  500FE2     SUB W0, #0x2, [W15]
0089BC  320010     BRA Z, .L52
0089BE  500FE4     SUB W0, #0x4, [W15]
0089C0  32001A     BRA Z, .L53
0089C2  500FE1     SUB W0, #0x1, [W15]
0089C4  3A0023     BRA NZ, .L49
571:                       case MOTOR1_PHASE_A:
572:                               PG1IOCONLbits.OVRDAT = (PG1IOCONLbits.OVRDAT & 0x1) | ((uint8_t)overrideDataHigh << 0x1);
0089C6  40C081     ADD.B W1, W1, W1
0089C8  0AA0AA     BFEXT #0xa, #0x1, PG1IOCONL, W0
0089CA  000330     NOP
0089CC  70C000     IOR.B W1, W0, W0
0089CE  600063     AND W0, #0x3, W0
0089D0  DD004A     SL W0, #10, W0
0089D2  2F3FF1     MOV #0xF3FF, W1
0089D4  801982     MOV PG1IOCONL, W2
0089D6  608082     AND W1, W2, W1
0089D8  700081     IOR W0, W1, W1
0089DA  881981     MOV W1, PG1IOCONL
573:                               break;
0089DC  370017     BRA .L49
574:                       case MOTOR1_PHASE_B:
575:                               PG2IOCONLbits.OVRDAT = (PG2IOCONLbits.OVRDAT & 0x1) | ((uint8_t)overrideDataHigh << 0x1);
0089DE  40C081     ADD.B W1, W1, W1
0089E0  0AA0AA     BFEXT #0xa, #0x1, PG2IOCONL, W0
0089E2  000366     NOP
0089E4  70C000     IOR.B W1, W0, W0
0089E6  600063     AND W0, #0x3, W0
0089E8  DD004A     SL W0, #10, W0
0089EA  2F3FF1     MOV #0xF3FF, W1
0089EC  801B32     MOV PG2IOCONL, W2
0089EE  608082     AND W1, W2, W1
0089F0  700081     IOR W0, W1, W1
0089F2  881B31     MOV W1, PG2IOCONL
576:                               break;
0089F4  37000B     BRA .L49
577:                       case MOTOR1_PHASE_C:
578:                               PG4IOCONLbits.OVRDAT = (PG4IOCONLbits.OVRDAT & 0x1) | ((uint8_t)overrideDataHigh << 0x1);
0089F6  40C081     ADD.B W1, W1, W1
0089F8  0AA0AA     BFEXT #0xa, #0x1, PG4IOCONL, W0
0089FA  0003D2     NOP
0089FC  70C000     IOR.B W1, W0, W0
0089FE  600063     AND W0, #0x3, W0
008A00  DD004A     SL W0, #10, W0
008A02  2F3FF1     MOV #0xF3FF, W1
008A04  801E92     MOV PG4IOCONL, W2
008A06  608082     AND W1, W2, W1
008A08  700081     IOR W0, W1, W1
008A0A  881E91     MOV W1, PG4IOCONL
579:                               break;
580:                       default:break;    
581:                   }
582:               }
008A0C  060000     RETURN
008A0E  500FE2     SUB W0, #0x2, [W15]
583:               
584:               /**
585:                * @ingroup    pwmhsdriver
586:                * @brief      This inline function updates PWM override low data bit with the requested value for a 
587:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR. 
588:                * @param[in]  genNum             - PWM generator number
589:                * @param[in]  overrideDataLow    - Override data  
590:                * @return     none  
591:                */
592:               inline static void PWM_OverrideDataLowSet(enum PWM_GENERATOR genNum,bool overrideDataLow)
593:               {
594:                   switch(genNum) { 
008C54  500FE2     SUB W0, #0x2, [W15]
008C56  32000F     BRA Z, .L57
008C58  500FE4     SUB W0, #0x4, [W15]
008C5A  320018     BRA Z, .L58
008C5C  500FE1     SUB W0, #0x1, [W15]
008C5E  3A0020     BRA NZ, .L54
595:                       case MOTOR1_PHASE_A:
596:                               PG1IOCONLbits.OVRDAT = (PG1IOCONLbits.OVRDAT & 0x2) | overrideDataLow;
008C60  0AA0BA     BFEXT #0xa, #0x2, PG1IOCONL, W0
008C62  000330     NOP
008C64  604062     AND.B W0, #0x2, W0
008C66  70C080     IOR.B W1, W0, W1
008C68  6080E3     AND W1, #0x3, W1
008C6A  DD08CA     SL W1, #10, W1
008C6C  2F3FF0     MOV #0xF3FF, W0
008C6E  B60330     AND PG1IOCONL, WREG
008C70  708000     IOR W1, W0, W0
008C72  881980     MOV W0, PG1IOCONL
597:                               break;  
008C74  370015     BRA .L54
598:                       case MOTOR1_PHASE_B:
599:                               PG2IOCONLbits.OVRDAT = (PG2IOCONLbits.OVRDAT & 0x2) | overrideDataLow;
008C76  0AA0BA     BFEXT #0xa, #0x2, PG2IOCONL, W0
008C78  000366     NOP
008C7A  604062     AND.B W0, #0x2, W0
008C7C  70C080     IOR.B W1, W0, W1
008C7E  6080E3     AND W1, #0x3, W1
008C80  DD08CA     SL W1, #10, W1
008C82  2F3FF0     MOV #0xF3FF, W0
008C84  B60366     AND PG2IOCONL, WREG
008C86  708000     IOR W1, W0, W0
008C88  881B30     MOV W0, PG2IOCONL
600:                               break;  
008C8A  37000A     BRA .L54
601:                       case MOTOR1_PHASE_C:
602:                               PG4IOCONLbits.OVRDAT = (PG4IOCONLbits.OVRDAT & 0x2) | overrideDataLow;
008C8C  0AA0BA     BFEXT #0xa, #0x2, PG4IOCONL, W0
008C8E  0003D2     NOP
008C90  604062     AND.B W0, #0x2, W0
008C92  70C080     IOR.B W1, W0, W1
008C94  6080E3     AND W1, #0x3, W1
008C96  DD08CA     SL W1, #10, W1
008C98  2F3FF0     MOV #0xF3FF, W0
008C9A  B603D2     AND PG4IOCONL, WREG
008C9C  708000     IOR W1, W0, W0
008C9E  881E90     MOV W0, PG4IOCONL
603:                               break;  
604:                       default:break;    
605:                   }
606:               }
008CA0  060000     RETURN
008CA2  780100     MOV W0, W2
607:               
608:               /**
609:                * @ingroup    pwmhsdriver
610:                * @brief      This inline function gets PWM override value for the PWM Generator selected by the 
611:                *             argument \ref PWM_GENERATOR. 
612:                * @param[in]  genNum  -  PWM generator number
613:                * @return     Override data for the PWM Generator selected by the argument 
614:                *             PWM_GENERATOR.  
615:                */
616:               inline static uint16_t PWM_OverrideDataGet(enum PWM_GENERATOR genNum)
617:               {
618:                   uint16_t overrideData = 0x0U;
0096BA  EB0000     CLR W0
619:                   switch(genNum) { 
00969C  500FE2     SUB W0, #0x2, [W15]
00969E  320007     BRA Z, .L62
0096A0  500FE4     SUB W0, #0x4, [W15]
0096A2  320008     BRA Z, .L63
0096A4  500FE1     SUB W0, #0x1, [W15]
0096A6  3A0009     BRA NZ, .L65
620:                       case MOTOR1_PHASE_A:
621:                               overrideData = PG1IOCONLbits.OVRDAT;             
0096A8  0AA0BA     BFEXT #0xa, #0x2, PG1IOCONL, W0
0096AA  000330     NOP
622:                               break;
0096AC  370007     BRA .L60
623:                       case MOTOR1_PHASE_B:
624:                               overrideData = PG2IOCONLbits.OVRDAT;             
0096AE  0AA0BA     BFEXT #0xa, #0x2, PG2IOCONL, W0
0096B0  000366     NOP
625:                               break;
0096B2  370004     BRA .L60
626:                       case MOTOR1_PHASE_C:
627:                               overrideData = PG4IOCONLbits.OVRDAT;             
0096B4  0AA0BA     BFEXT #0xa, #0x2, PG4IOCONL, W0
0096B6  0003D2     NOP
628:                               break;
0096B8  370001     BRA .L60
629:                       default:break;    
630:                   }
631:                   return overrideData;
632:               }
0096BC  060000     RETURN
0096BE  500FE2     SUB W0, #0x2, [W15]
633:               
634:               /**
635:                * @ingroup  pwmhsdriver
636:                * @brief    This inline function enables PWM override on PWMH output for specific PWM generator selected 
637:                *           by the argument \ref PWM_GENERATOR.
638:                * @param[in]  genNum - PWM generator number  
639:                * @return   none  
640:                */
641:               inline static void PWM_OverrideHighEnable(enum PWM_GENERATOR genNum)
642:               {
643:                   switch(genNum) { 
009938  500FE2     SUB W0, #0x2, [W15]
00993A  320006     BRA Z, .L69
00993C  500FE4     SUB W0, #0x4, [W15]
00993E  320006     BRA Z, .L70
009940  500FE1     SUB W0, #0x1, [W15]
009942  3A0005     BRA NZ, .L66
644:                       case MOTOR1_PHASE_A:
645:                               PG1IOCONLbits.OVRENH = 1;              
004C78  A8A331     BSET 0x331, #5
004D6E  A8A331     BSET 0x331, #5
004DB6  A8A331     BSET 0x331, #5
004DD6  A8A331     BSET 0x331, #5
006E84  A8A331     BSET 0x331, #5
006EA4  A8A331     BSET 0x331, #5
008214  A8A331     BSET 0x331, #5
008876  A8A331     BSET 0x331, #5
009944  A8A331     BSET 0x331, #5
646:                               break;
009946  370003     BRA .L66
647:                       case MOTOR1_PHASE_B:
648:                               PG2IOCONLbits.OVRENH = 1;              
004C7A  A8A367     BSET 0x367, #5
004D70  A8A367     BSET 0x367, #5
004DB8  A8A367     BSET 0x367, #5
004DD8  A8A367     BSET 0x367, #5
006E88  A8A367     BSET 0x367, #5
006EA6  A8A367     BSET 0x367, #5
008218  A8A367     BSET 0x367, #5
00887A  A8A367     BSET 0x367, #5
009948  A8A367     BSET 0x367, #5
649:                               break;
00994A  370001     BRA .L66
650:                       case MOTOR1_PHASE_C:
651:                               PG4IOCONLbits.OVRENH = 1;              
004C7C  A8A3D3     BSET 0x3D3, #5
004D72  A8A3D3     BSET 0x3D3, #5
004DBA  A8A3D3     BSET 0x3D3, #5
004DDA  A8A3D3     BSET 0x3D3, #5
006E8C  A8A3D3     BSET 0x3D3, #5
006EA8  A8A3D3     BSET 0x3D3, #5
00821C  A8A3D3     BSET 0x3D3, #5
00887E  A8A3D3     BSET 0x3D3, #5
00994C  A8A3D3     BSET 0x3D3, #5
652:                               break;
653:                       default:break;    
654:                   }
655:               }
00994E  060000     RETURN
656:               
657:               /**
658:                * @ingroup    pwmhsdriver
659:                * @brief      This inline function enables PWM override on PWML output for specific PWM generator selected 
660:                *             by the argument \ref PWM_GENERATOR.
661:                * @param[in]  genNum - PWM generator number
662:                * @return     none  
663:                */
664:               inline static void PWM_OverrideLowEnable(enum PWM_GENERATOR genNum)
665:               {
666:                   switch(genNum) { 
009950  500FE2     SUB W0, #0x2, [W15]
009952  320006     BRA Z, .L74
009954  500FE4     SUB W0, #0x4, [W15]
009956  320006     BRA Z, .L75
009958  500FE1     SUB W0, #0x1, [W15]
00995A  3A0005     BRA NZ, .L71
667:                       case MOTOR1_PHASE_A:
668:                               PG1IOCONLbits.OVRENL = 1;              
006E86  A88331     BSET 0x331, #4
008216  A88331     BSET 0x331, #4
008878  A88331     BSET 0x331, #4
00995C  A88331     BSET 0x331, #4
669:                               break; 
00995E  370003     BRA .L71
670:                       case MOTOR1_PHASE_B:
671:                               PG2IOCONLbits.OVRENL = 1;              
006E8A  A88367     BSET 0x367, #4
00821A  A88367     BSET 0x367, #4
00887C  A88367     BSET 0x367, #4
009960  A88367     BSET 0x367, #4
672:                               break; 
009962  370001     BRA .L71
673:                       case MOTOR1_PHASE_C:
674:                               PG4IOCONLbits.OVRENL = 1;              
006E8E  A883D3     BSET 0x3D3, #4
00821E  A883D3     BSET 0x3D3, #4
008880  A883D3     BSET 0x3D3, #4
009964  A883D3     BSET 0x3D3, #4
675:                               break; 
676:                       default:break;    
677:                   }
678:               }
009966  060000     RETURN
679:               
680:               /**
681:                * @ingroup    pwmhsdriver
682:                * @brief      This inline function disables PWM override on PWMH output for specific PWM generator selected 
683:                *             by the argument \ref PWM_GENERATOR.    
684:                * @param[in]  genNum - PWM generator number
685:                * @return     none  
686:                */
687:               inline static void PWM_OverrideHighDisable(enum PWM_GENERATOR genNum)
688:               {
689:                   switch(genNum) { 
009968  500FE2     SUB W0, #0x2, [W15]
00996A  320006     BRA Z, .L79
00996C  500FE4     SUB W0, #0x4, [W15]
00996E  320006     BRA Z, .L80
009970  500FE1     SUB W0, #0x1, [W15]
009972  3A0005     BRA NZ, .L76
690:                       case MOTOR1_PHASE_A:
691:                               PG1IOCONLbits.OVRENH = 0;              
004CDE  A9A331     BCLR 0x331, #5
004EBC  A9A331     BCLR 0x331, #5
009974  A9A331     BCLR 0x331, #5
692:                               break;
009976  370003     BRA .L76
693:                       case MOTOR1_PHASE_B:
694:                               PG2IOCONLbits.OVRENH = 0;              
004CE0  A9A367     BCLR 0x367, #5
004EBE  A9A367     BCLR 0x367, #5
009978  A9A367     BCLR 0x367, #5
695:                               break;
00997A  370001     BRA .L76
696:                       case MOTOR1_PHASE_C:
697:                               PG4IOCONLbits.OVRENH = 0;              
004CE2  A9A3D3     BCLR 0x3D3, #5
004EC0  A9A3D3     BCLR 0x3D3, #5
00997C  A9A3D3     BCLR 0x3D3, #5
698:                               break;
699:                       default:break;    
700:                   }
701:               }
00997E  060000     RETURN
702:               
703:               /**
704:                * @ingroup    pwmhsdriver
705:                * @brief      This inline function disables PWM override on PWML output for specific PWM generator selected 
706:                *             by the argument \ref PWM_GENERATOR.    
707:                * @param[in]  genNum - PWM generator number 
708:                * @return     none  
709:                */
710:               inline static void PWM_OverrideLowDisable(enum PWM_GENERATOR genNum)
711:               {
712:                   switch(genNum) { 
009980  500FE2     SUB W0, #0x2, [W15]
009982  320006     BRA Z, .L84
009984  500FE4     SUB W0, #0x4, [W15]
009986  320006     BRA Z, .L85
009988  500FE1     SUB W0, #0x1, [W15]
00998A  3A0005     BRA NZ, .L81
713:                       case MOTOR1_PHASE_A:
714:                               PG1IOCONLbits.OVRENL = 0;              
006EAA  A98331     BCLR 0x331, #4
00998C  A98331     BCLR 0x331, #4
715:                               break;   
00998E  370003     BRA .L81
716:                       case MOTOR1_PHASE_B:
717:                               PG2IOCONLbits.OVRENL = 0;              
006EAC  A98367     BCLR 0x367, #4
009990  A98367     BCLR 0x367, #4
718:                               break;   
009992  370001     BRA .L81
719:                       case MOTOR1_PHASE_C:
720:                               PG4IOCONLbits.OVRENL = 0;              
006EAE  A983D3     BCLR 0x3D3, #4
009994  A983D3     BCLR 0x3D3, #4
721:                               break;   
722:                       default:break;    
723:                   }
724:               }
009996  060000     RETURN
725:               
726:               /**
727:                * @ingroup    pwmhsdriver
728:                * @brief      This inline function updates PWM Deadtime low register with the requested value for a 
729:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR.
730:                * @param[in]  genNum      - PWM generator number
731:                * @param[in]  deadtimeLow - Deadtime low value
732:                * @return     none  
733:                */
734:               inline static void PWM_DeadTimeLowSet(enum PWM_GENERATOR genNum,uint16_t deadtimeLow)
735:               {
736:                   switch(genNum) { 
009998  500FE2     SUB W0, #0x2, [W15]
00999A  320006     BRA Z, .L89
00999C  500FE4     SUB W0, #0x4, [W15]
00999E  320006     BRA Z, .L90
0099A0  500FE1     SUB W0, #0x1, [W15]
0099A2  3A0005     BRA NZ, .L86
737:                       case MOTOR1_PHASE_A:
738:                               PG1DTL = deadtimeLow;              
0099A4  881AD1     MOV W1, PG1DTL
739:                               break;       
0099A6  370003     BRA .L86
740:                       case MOTOR1_PHASE_B:
741:                               PG2DTL = deadtimeLow;              
0099A8  881C81     MOV W1, PG2DTL
742:                               break;       
0099AA  370001     BRA .L86
743:                       case MOTOR1_PHASE_C:
744:                               PG4DTL = deadtimeLow;              
0099AC  881FE1     MOV W1, PG4DTL
745:                               break;       
746:                       default:break;    
747:                   }
748:               }
0099AE  060000     RETURN
749:               
750:               /**
751:                * @ingroup    pwmhsdriver
752:                * @brief      This inline function updates PWM Deadtime high register with the requested value for a 
753:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR.
754:                * @param[in]  genNum          - PWM generator number
755:                * @param[in]  deadtimeHigh    - Deadtime high value
756:                * @return     none  
757:                */
758:               inline static void PWM_DeadTimeHighSet(enum PWM_GENERATOR genNum,uint16_t deadtimeHigh)
759:               {
760:                   switch(genNum) { 
0099B0  500FE2     SUB W0, #0x2, [W15]
0099B2  320006     BRA Z, .L94
0099B4  500FE4     SUB W0, #0x4, [W15]
0099B6  320006     BRA Z, .L95
0099B8  500FE1     SUB W0, #0x1, [W15]
0099BA  3A0005     BRA NZ, .L91
761:                       case MOTOR1_PHASE_A:
762:                               PG1DTH = deadtimeHigh;              
0099BC  881AE1     MOV W1, PG1DTH
763:                               break;       
0099BE  370003     BRA .L91
764:                       case MOTOR1_PHASE_B:
765:                               PG2DTH = deadtimeHigh;              
0099C0  881C91     MOV W1, PG2DTH
766:                               break;       
0099C2  370001     BRA .L91
767:                       case MOTOR1_PHASE_C:
768:                               PG4DTH = deadtimeHigh;              
0099C4  881FF1     MOV W1, PG4DTH
769:                               break;       
770:                       default:break;    
771:                   }
772:               }
0099C6  060000     RETURN
0099C8  500FE2     SUB W0, #0x2, [W15]
773:               
774:               /**
775:                * @ingroup    pwmhsdriver
776:                * @brief      This inline function updates PWM Deadtime low and high register with the requested value for a 
777:                *             specific PWM generator selected by the argument \ref PWM_GENERATOR.
778:                * @param[in]  genNum          - PWM generator number
779:                * @param[in]  deadtimeHigh    - Deadtime value
780:                * @return     none  
781:                */
782:               inline static void PWM_DeadTimeSet(enum PWM_GENERATOR genNum,uint16_t deadtime)
783:               {
784:                   switch(genNum) { 
009758  500FE2     SUB W0, #0x2, [W15]
00975A  320007     BRA Z, .L99
00975C  500FE4     SUB W0, #0x4, [W15]
00975E  320008     BRA Z, .L100
009760  500FE1     SUB W0, #0x1, [W15]
009762  3A0008     BRA NZ, .L96
785:                       case MOTOR1_PHASE_A:
786:                               PG1DTL = deadtime;
0081F2  200C80     MOV #0xC8, W0
0081F4  881AD0     MOV W0, PG1DTL
009764  881AD1     MOV W1, PG1DTL
787:                               PG1DTH = deadtime;                 
0081F6  881AE0     MOV W0, PG1DTH
009766  881AE1     MOV W1, PG1DTH
788:                               break;       
009768  370005     BRA .L96
789:                       case MOTOR1_PHASE_B:
790:                               PG2DTL = deadtime;
0081F8  881C80     MOV W0, PG2DTL
00976A  881C81     MOV W1, PG2DTL
791:                               PG2DTH = deadtime;                 
0081FA  881C90     MOV W0, PG2DTH
00976C  881C91     MOV W1, PG2DTH
792:                               break;       
00976E  370002     BRA .L96
793:                       case MOTOR1_PHASE_C:
794:                               PG4DTL = deadtime;
0081FC  881FE0     MOV W0, PG4DTL
009770  881FE1     MOV W1, PG4DTL
795:                               PG4DTH = deadtime;                 
0081FE  881FF0     MOV W0, PG4DTH
009772  881FF1     MOV W1, PG4DTH
796:                               break;       
797:                       default:break;    
798:                   }
799:               }
009774  060000     RETURN
009776  780190     MOV [W0], W3
800:               
801:               /**
802:                * @ingroup    pwmhsdriver
803:                * @brief      This inline function sets the PWM trigger compare value in count for the PWM Generator 
804:                *             selected by the argument \ref PWM_GENERATOR.
805:                * @param[in]  genNum          - PWM generator number
806:                * @param[in]  trigCompValue   - Trigger compare value in count
807:                * @return     none  
808:                */
809:               inline static void PWM_TriggerCompareValueSet(enum PWM_GENERATOR genNum,uint16_t trigCompValue)
810:               {
811:                   switch(genNum) { 
0099C8  500FE2     SUB W0, #0x2, [W15]
0099CA  320006     BRA Z, .L104
0099CC  500FE4     SUB W0, #0x4, [W15]
0099CE  320006     BRA Z, .L105
0099D0  500FE1     SUB W0, #0x1, [W15]
0099D2  3A0005     BRA NZ, .L101
812:                       case MOTOR1_PHASE_A:
813:                               PG1TRIGA = trigCompValue;              
0099D4  881AA1     MOV W1, PG1TRIGA
814:                               break;      
0099D6  370003     BRA .L101
815:                       case MOTOR1_PHASE_B:
816:                               PG2TRIGA = trigCompValue;              
0099D8  881C51     MOV W1, PG2TRIGA
817:                               break;      
0099DA  370001     BRA .L101
818:                       case MOTOR1_PHASE_C:
819:                               PG4TRIGA = trigCompValue;              
0099DC  881FB1     MOV W1, PG4TRIGA
820:                               break;      
821:                       default:break;    
822:                   }
823:               }
0099DE  060000     RETURN
0099E0  500FE2     SUB W0, #0x2, [W15]
824:               
825:               /**
826:                * @ingroup    pwmhsdriver
827:                * @brief      This inline function enables interrupt requests for the PWM Generator selected by the 
828:                *             argument \ref PWM_GENERATOR.   
829:                * @param[in]  genNum - PWM generator number
830:                * @param[in]  interrupt - PWM generator interrupt source
831:                * @return     none  
832:                */
833:               inline static void PWM_GeneratorInterruptEnable(enum PWM_GENERATOR genNum, enum PWM_GENERATOR_INTERRUPT interrupt)
834:               {
835:                   switch(genNum) { 
008260  500FE2     SUB W0, #0x2, [W15]
008262  320017     BRA Z, .L109
008264  500FE4     SUB W0, #0x4, [W15]
008266  320028     BRA Z, .L110
008268  500FE1     SUB W0, #0x1, [W15]
00826A  3A0038     BRA NZ, .L106
836:                       case MOTOR1_PHASE_A:
837:                               switch(interrupt) { 
00826C  508FE2     SUB W1, #0x2, [W15]
00826E  32000B     BRA Z, .L112
008270  3E0003     BRA GTU, .L115
008272  508FE1     SUB W1, #0x1, [W15]
008274  3A0033     BRA NZ, .L106
008276  370005     BRA .L126
008278  508FE3     SUB W1, #0x3, [W15]
00827A  320007     BRA Z, .L113
00827C  508FE4     SUB W1, #0x4, [W15]
00827E  3A002E     BRA NZ, .L106
008280  370006     BRA .L127
838:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
839:                                                       PG1EVTHbits.FLTIEN = true;               
008282  A8E337     BSET 0x337, #7
840:                                                       break;       
008284  37002B     BRA .L106
841:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
842:                                                       PG1EVTHbits.CLIEN = true;
008286  A8C337     BSET 0x337, #6
843:                                                       break;
008288  370029     BRA .L106
844:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
845:                                                       PG1EVTHbits.FFIEN = true;
00828A  A8A337     BSET 0x337, #5
846:                                                       break;
00828C  370027     BRA .L106
847:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
848:                                                       PG1EVTHbits.SIEN = true;
00828E  A88337     BSET 0x337, #4
849:                                                       break;                                                        
008290  370025     BRA .L106
850:                                       default:break;  
851:                               }              
852:                               break;   
853:                       case MOTOR1_PHASE_B:
854:                               switch(interrupt) { 
008292  508FE2     SUB W1, #0x2, [W15]
008294  32000B     BRA Z, .L117
008296  3E0003     BRA GTU, .L120
008298  508FE1     SUB W1, #0x1, [W15]
00829A  3A0020     BRA NZ, .L106
00829C  370005     BRA .L128
00829E  508FE3     SUB W1, #0x3, [W15]
0082A0  320007     BRA Z, .L118
0082A2  508FE4     SUB W1, #0x4, [W15]
0082A4  3A001B     BRA NZ, .L106
0082A6  370006     BRA .L129
855:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
856:                                                       PG2EVTHbits.FLTIEN = true;               
0082A8  A8E36D     BSET 0x36D, #7
857:                                                       break;       
0082AA  370018     BRA .L106
858:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
859:                                                       PG2EVTHbits.CLIEN = true;
0082AC  A8C36D     BSET 0x36D, #6
860:                                                       break;
0082AE  370016     BRA .L106
861:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
862:                                                       PG2EVTHbits.FFIEN = true;
0082B0  A8A36D     BSET 0x36D, #5
863:                                                       break;
0082B2  370014     BRA .L106
864:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
865:                                                       PG2EVTHbits.SIEN = true;
0082B4  A8836D     BSET 0x36D, #4
866:                                                       break;                                                        
0082B6  370012     BRA .L106
867:                                       default:break;  
868:                               }              
869:                               break;   
870:                       case MOTOR1_PHASE_C:
871:                               switch(interrupt) { 
0082B8  508FE2     SUB W1, #0x2, [W15]
0082BA  32000B     BRA Z, .L122
0082BC  3E0003     BRA GTU, .L125
0082BE  508FE1     SUB W1, #0x1, [W15]
0082C0  3A000D     BRA NZ, .L106
0082C2  370005     BRA .L130
0082C4  508FE3     SUB W1, #0x3, [W15]
0082C6  320007     BRA Z, .L123
0082C8  508FE4     SUB W1, #0x4, [W15]
0082CA  3A0008     BRA NZ, .L106
0082CC  370006     BRA .L131
872:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
873:                                                       PG4EVTHbits.FLTIEN = true;               
0082CE  A8E3D9     BSET 0x3D9, #7
874:                                                       break;       
0082D0  370005     BRA .L106
875:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
876:                                                       PG4EVTHbits.CLIEN = true;
0082D2  A8C3D9     BSET 0x3D9, #6
877:                                                       break;
0082D4  370003     BRA .L106
878:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
879:                                                       PG4EVTHbits.FFIEN = true;
0082D6  A8A3D9     BSET 0x3D9, #5
880:                                                       break;
0082D8  370001     BRA .L106
881:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
882:                                                       PG4EVTHbits.SIEN = true;
0082DA  A883D9     BSET 0x3D9, #4
883:                                                       break;                                                        
884:                                       default:break;  
885:                               }              
886:                               break;   
887:                       default:break;  
888:                   }
889:               }
0082DC  060000     RETURN
890:               
891:               /**
892:                * @ingroup    pwmhsdriver
893:                * @brief      This inline function disables interrupt requests for the PWM Generator selected by the 
894:                *             argument \ref PWM_GENERATOR.
895:                * @param[in]  genNum 	 - PWM generator number
896:                * @param[in]  interrupt - PWM generator interrupt source
897:                * @return     none  
898:                */
899:               inline static void PWM_GeneratorInterruptDisable(enum PWM_GENERATOR genNum, enum PWM_GENERATOR_INTERRUPT interrupt)
900:               {
901:                   switch(genNum) { 
0082DE  500FE2     SUB W0, #0x2, [W15]
0082E0  320017     BRA Z, .L135
0082E2  500FE4     SUB W0, #0x4, [W15]
0082E4  320028     BRA Z, .L136
0082E6  500FE1     SUB W0, #0x1, [W15]
0082E8  3A0038     BRA NZ, .L132
902:                       case MOTOR1_PHASE_A:
903:                               switch(interrupt) { 
0082EA  508FE2     SUB W1, #0x2, [W15]
0082EC  32000B     BRA Z, .L138
0082EE  3E0003     BRA GTU, .L141
0082F0  508FE1     SUB W1, #0x1, [W15]
0082F2  3A0033     BRA NZ, .L132
0082F4  370005     BRA .L152
0082F6  508FE3     SUB W1, #0x3, [W15]
0082F8  320007     BRA Z, .L139
0082FA  508FE4     SUB W1, #0x4, [W15]
0082FC  3A002E     BRA NZ, .L132
0082FE  370006     BRA .L153
904:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
905:                                                       PG1EVTHbits.FLTIEN = false;               
008300  A9E337     BCLR 0x337, #7
906:                                                       break;       
008302  37002B     BRA .L132
907:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
908:                                                       PG1EVTHbits.CLIEN = false;
008304  A9C337     BCLR 0x337, #6
909:                                                       break;
008306  370029     BRA .L132
910:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
911:                                                       PG1EVTHbits.FFIEN = false;
008308  A9A337     BCLR 0x337, #5
912:                                                       break;
00830A  370027     BRA .L132
913:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
914:                                                       PG1EVTHbits.SIEN = false;
00830C  A98337     BCLR 0x337, #4
915:                                                       break;                                
00830E  370025     BRA .L132
916:                                       default:break;  
917:                               }              
918:                               break;  
919:                       case MOTOR1_PHASE_B:
920:                               switch(interrupt) { 
008310  508FE2     SUB W1, #0x2, [W15]
008312  32000B     BRA Z, .L143
008314  3E0003     BRA GTU, .L146
008316  508FE1     SUB W1, #0x1, [W15]
008318  3A0020     BRA NZ, .L132
00831A  370005     BRA .L154
00831C  508FE3     SUB W1, #0x3, [W15]
00831E  320007     BRA Z, .L144
008320  508FE4     SUB W1, #0x4, [W15]
008322  3A001B     BRA NZ, .L132
008324  370006     BRA .L155
921:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
922:                                                       PG2EVTHbits.FLTIEN = false;               
008326  A9E36D     BCLR 0x36D, #7
923:                                                       break;       
008328  370018     BRA .L132
924:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
925:                                                       PG2EVTHbits.CLIEN = false;
00832A  A9C36D     BCLR 0x36D, #6
926:                                                       break;
00832C  370016     BRA .L132
927:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
928:                                                       PG2EVTHbits.FFIEN = false;
00832E  A9A36D     BCLR 0x36D, #5
929:                                                       break;
008330  370014     BRA .L132
930:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
931:                                                       PG2EVTHbits.SIEN = false;
008332  A9836D     BCLR 0x36D, #4
932:                                                       break;                                
008334  370012     BRA .L132
933:                                       default:break;  
934:                               }              
935:                               break;  
936:                       case MOTOR1_PHASE_C:
937:                               switch(interrupt) { 
008336  508FE2     SUB W1, #0x2, [W15]
008338  32000B     BRA Z, .L148
00833A  3E0003     BRA GTU, .L151
00833C  508FE1     SUB W1, #0x1, [W15]
00833E  3A000D     BRA NZ, .L132
008340  370005     BRA .L156
008342  508FE3     SUB W1, #0x3, [W15]
008344  320007     BRA Z, .L149
008346  508FE4     SUB W1, #0x4, [W15]
008348  3A0008     BRA NZ, .L132
00834A  370006     BRA .L157
938:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
939:                                                       PG4EVTHbits.FLTIEN = false;               
00834C  A9E3D9     BCLR 0x3D9, #7
940:                                                       break;       
00834E  370005     BRA .L132
941:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
942:                                                       PG4EVTHbits.CLIEN = false;
008350  A9C3D9     BCLR 0x3D9, #6
943:                                                       break;
008352  370003     BRA .L132
944:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
945:                                                       PG4EVTHbits.FFIEN = false;
008354  A9A3D9     BCLR 0x3D9, #5
946:                                                       break;
008356  370001     BRA .L132
947:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
948:                                                       PG4EVTHbits.SIEN = false;
008358  A983D9     BCLR 0x3D9, #4
949:                                                       break;                                
950:                                       default:break;  
951:                               }              
952:                               break;  
953:                       default:break;  
954:                   }
955:               }
00835A  060000     RETURN
956:               
957:               /**
958:                * @ingroup    pwmhsdriver
959:                * @brief      This inline function clears the PWM interrupt status for the PWM Generator selected by the 
960:                *             argument \ref PWM_GENERATOR.   
961:                * @param[in]  genNum 	- PWM generator number
962:                * @param[in]  interrupt - PWM generator interrupt source
963:                * @return     none  
964:                */
965:               inline static void PWM_GeneratorEventStatusClear(enum PWM_GENERATOR genNum, enum PWM_GENERATOR_INTERRUPT interrupt)
966:               {
967:                   switch(genNum) { 
00835C  500FE2     SUB W0, #0x2, [W15]
00835E  320017     BRA Z, .L161
008360  500FE4     SUB W0, #0x4, [W15]
008362  320028     BRA Z, .L162
008364  500FE1     SUB W0, #0x1, [W15]
008366  3A0038     BRA NZ, .L158
968:                       case MOTOR1_PHASE_A:
969:                               switch(interrupt) { 
008368  508FE2     SUB W1, #0x2, [W15]
00836A  32000B     BRA Z, .L164
00836C  3E0003     BRA GTU, .L167
00836E  508FE1     SUB W1, #0x1, [W15]
008370  3A0033     BRA NZ, .L158
008372  370005     BRA .L178
008374  508FE3     SUB W1, #0x3, [W15]
008376  320007     BRA Z, .L165
008378  508FE4     SUB W1, #0x4, [W15]
00837A  3A002E     BRA NZ, .L158
00837C  370006     BRA .L179
970:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
971:                                                       PG1STATbits.FLTEVT = 0;                            
004BF8  A9C32F     BCLR 0x32F, #6
004E2C  A9C32F     BCLR 0x32F, #6
00837E  A9C32F     BCLR 0x32F, #6
972:                                                       break;       
008380  37002B     BRA .L158
973:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
974:                                                       PG1STATbits.CLEVT = 0;
008382  A9A32F     BCLR 0x32F, #5
975:                                                       break;
008384  370029     BRA .L158
976:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
977:                                                       PG1STATbits.FFEVT = 0;
008386  A9832F     BCLR 0x32F, #4
978:                                                       break;    
008388  370027     BRA .L158
979:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
980:                                                       PG1STATbits.SEVT = 0;
00838A  A9E32F     BCLR 0x32F, #7
981:                                                       break;                            
00838C  370025     BRA .L158
982:                                       default:break;  
983:                               }              
984:                               break; 
985:                       case MOTOR1_PHASE_B:
986:                               switch(interrupt) { 
00838E  508FE2     SUB W1, #0x2, [W15]
008390  32000B     BRA Z, .L169
008392  3E0003     BRA GTU, .L172
008394  508FE1     SUB W1, #0x1, [W15]
008396  3A0020     BRA NZ, .L158
008398  370005     BRA .L180
00839A  508FE3     SUB W1, #0x3, [W15]
00839C  320007     BRA Z, .L170
00839E  508FE4     SUB W1, #0x4, [W15]
0083A0  3A001B     BRA NZ, .L158
0083A2  370006     BRA .L181
987:                                       case PWM_GENERATOR_INTERRUPT_FAULT:
988:                                                       PG2STATbits.FLTEVT = 0;                            
004BFA  A9C365     BCLR 0x365, #6
004E2E  A9C365     BCLR 0x365, #6
0083A4  A9C365     BCLR 0x365, #6
989:                                                       break;       
0083A6  370018     BRA .L158
990:                                       case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
991:                                                       PG2STATbits.CLEVT = 0;
0083A8  A9A365     BCLR 0x365, #5
992:                                                       break;
0083AA  370016     BRA .L158
993:                                       case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
994:                                                       PG2STATbits.FFEVT = 0;
0083AC  A98365     BCLR 0x365, #4
995:                                                       break;    
0083AE  370014     BRA .L158
996:                                       case PWM_GENERATOR_INTERRUPT_SYNC:
997:                                                       PG2STATbits.SEVT = 0;
0083B0  A9E365     BCLR 0x365, #7
998:                                                       break;                            
0083B2  370012     BRA .L158
999:                                       default:break;  
1000:                              }              
1001:                              break; 
1002:                      case MOTOR1_PHASE_C:
1003:                              switch(interrupt) { 
0083B4  508FE2     SUB W1, #0x2, [W15]
0083B6  32000B     BRA Z, .L174
0083B8  3E0003     BRA GTU, .L177
0083BA  508FE1     SUB W1, #0x1, [W15]
0083BC  3A000D     BRA NZ, .L158
0083BE  370005     BRA .L182
0083C0  508FE3     SUB W1, #0x3, [W15]
0083C2  320007     BRA Z, .L175
0083C4  508FE4     SUB W1, #0x4, [W15]
0083C6  3A0008     BRA NZ, .L158
0083C8  370006     BRA .L183
1004:                                      case PWM_GENERATOR_INTERRUPT_FAULT:
1005:                                                      PG4STATbits.FLTEVT = 0;                            
004BFC  A9C3D1     BCLR 0x3D1, #6
004BFE  370175     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004E30  A9C3D1     BCLR 0x3D1, #6
004E32  37005B     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
0083CA  A9C3D1     BCLR 0x3D1, #6
1006:                                                      break;       
0083CC  370005     BRA .L158
1007:                                      case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
1008:                                                      PG4STATbits.CLEVT = 0;
0083CE  A9A3D1     BCLR 0x3D1, #5
1009:                                                      break;
0083D0  370003     BRA .L158
1010:                                      case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
1011:                                                      PG4STATbits.FFEVT = 0;
0083D2  A983D1     BCLR 0x3D1, #4
1012:                                                      break;    
0083D4  370001     BRA .L158
1013:                                      case PWM_GENERATOR_INTERRUPT_SYNC:
1014:                                                      PG4STATbits.SEVT = 0;
0083D6  A9E3D1     BCLR 0x3D1, #7
1015:                                                      break;                            
1016:                                      default:break;  
1017:                              }              
1018:                              break; 
1019:                      default:break;  
1020:                  }
1021:              }
0083D8  060000     RETURN
0083DA  BE9F88     MOV.D W8, [W15++]
1022:              
1023:              /**
1024:               * @ingroup    pwmhsdriver
1025:               * @brief      This inline function gets the PWM interrupt status for the PWM Generator selected by the 
1026:               *             argument \ref PWM_GENERATOR.   
1027:               * @param[in]  genNum 	- PWM generator number
1028:               * @param[in]  interrupt - PWM generator interrupt source
1029:               * @return     true  - Interrupt is pending
1030:               * @return     false - Interrupt is not pending
1031:               */
1032:              inline static bool PWM_GeneratorEventStatusGet(enum PWM_GENERATOR genNum, enum PWM_GENERATOR_INTERRUPT interrupt)
1033:              {
1034:                  bool status = false;
007AEC  EB4000     CLR.B W0
007AEE  370005     BRA .L185
007AF0  EB4000     CLR.B W0
007AF2  370003     BRA .L185
007AF4  EB4000     CLR.B W0
007AF6  370001     BRA .L185
007AF8  EB4000     CLR.B W0
1035:                  switch(genNum) { 
007A56  500FE2     SUB W0, #0x2, [W15]
007A58  32001B     BRA Z, .L187
007A5A  500FE4     SUB W0, #0x4, [W15]
007A5C  320030     BRA Z, .L188
007A5E  500FE1     SUB W0, #0x1, [W15]
007A60  3A0045     BRA NZ, .L208
1036:                      case MOTOR1_PHASE_A:
1037:                              switch(interrupt) { 
007A62  508FE2     SUB W1, #0x2, [W15]
007A64  32000C     BRA Z, .L190
007A66  3E0003     BRA GTU, .L193
007A68  508FE1     SUB W1, #0x1, [W15]
007A6A  3A0042     BRA NZ, .L205
007A6C  370005     BRA .L209
007A6E  508FE3     SUB W1, #0x3, [W15]
007A70  320009     BRA Z, .L191
007A72  508FE4     SUB W1, #0x4, [W15]
007A74  3A003D     BRA NZ, .L205
007A76  370009     BRA .L210
1038:                                      case PWM_GENERATOR_INTERRUPT_FAULT:
1039:                                                      status = PG1STATbits.FLTEVT;               
007A78  0AA0EE     BFEXT #0xe, #0x1, PG1STAT, W0
007A7A  00032E     NOP
1040:                                                      break;       
007A7C  37003E     BRA .L185
1041:                                      case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
1042:                                                      status = PG1STATbits.CLEVT;
007A7E  0AA0DD     BFEXT #0xd, #0x1, PG1STAT, W0
007A80  00032E     NOP
1043:                                                      break;
007A82  37003B     BRA .L185
1044:                                      case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
1045:                                                      status = PG1STATbits.FFEVT;
007A84  0AA0CC     BFEXT #0xc, #0x1, PG1STAT, W0
007A86  00032E     NOP
1046:                                                      break;    
007A88  370038     BRA .L185
1047:                                      case PWM_GENERATOR_INTERRUPT_SYNC:
1048:                                                      status = PG1STATbits.SEVT;
007A8A  801970     MOV PG1STAT, W0
007A8C  DE004F     LSR W0, #15, W0
1049:                                                      break;                            
007A8E  370035     BRA .L185
1050:                                      default:break;  
1051:                              }              
1052:                              break; 
1053:                      case MOTOR1_PHASE_B:
1054:                              switch(interrupt) { 
007A90  508FE2     SUB W1, #0x2, [W15]
007A92  32000C     BRA Z, .L195
007A94  3E0003     BRA GTU, .L198
007A96  508FE1     SUB W1, #0x1, [W15]
007A98  3A002D     BRA NZ, .L206
007A9A  370005     BRA .L211
007A9C  508FE3     SUB W1, #0x3, [W15]
007A9E  320009     BRA Z, .L196
007AA0  508FE4     SUB W1, #0x4, [W15]
007AA2  3A0028     BRA NZ, .L206
007AA4  370009     BRA .L212
1055:                                      case PWM_GENERATOR_INTERRUPT_FAULT:
1056:                                                      status = PG2STATbits.FLTEVT;               
007AA6  0AA0EE     BFEXT #0xe, #0x1, PG2STAT, W0
007AA8  000364     NOP
1057:                                                      break;       
007AAA  370027     BRA .L185
1058:                                      case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
1059:                                                      status = PG2STATbits.CLEVT;
007AAC  0AA0DD     BFEXT #0xd, #0x1, PG2STAT, W0
007AAE  000364     NOP
1060:                                                      break;
007AB0  370024     BRA .L185
1061:                                      case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
1062:                                                      status = PG2STATbits.FFEVT;
007AB2  0AA0CC     BFEXT #0xc, #0x1, PG2STAT, W0
007AB4  000364     NOP
1063:                                                      break;    
007AB6  370021     BRA .L185
1064:                                      case PWM_GENERATOR_INTERRUPT_SYNC:
1065:                                                      status = PG2STATbits.SEVT;
007AB8  801B20     MOV PG2STAT, W0
007ABA  DE004F     LSR W0, #15, W0
1066:                                                      break;                            
007ABC  37001E     BRA .L185
1067:                                      default:break;  
1068:                              }              
1069:                              break; 
1070:                      case MOTOR1_PHASE_C:
1071:                              switch(interrupt) { 
007ABE  508FE2     SUB W1, #0x2, [W15]
007AC0  32000C     BRA Z, .L200
007AC2  3E0003     BRA GTU, .L203
007AC4  508FE1     SUB W1, #0x1, [W15]
007AC6  3A0018     BRA NZ, .L207
007AC8  370005     BRA .L213
007ACA  508FE3     SUB W1, #0x3, [W15]
007ACC  320009     BRA Z, .L201
007ACE  508FE4     SUB W1, #0x4, [W15]
007AD0  3A0013     BRA NZ, .L207
007AD2  370009     BRA .L214
1072:                                      case PWM_GENERATOR_INTERRUPT_FAULT:
1073:                                                      status = PG4STATbits.FLTEVT;               
007AD4  0AA0EE     BFEXT #0xe, #0x1, PG4STAT, W0
007AD6  0003D0     NOP
1074:                                                      break;       
007AD8  370010     BRA .L185
1075:                                      case PWM_GENERATOR_INTERRUPT_CURRENT_LIMIT:
1076:                                                      status = PG4STATbits.CLEVT;
007ADA  0AA0DD     BFEXT #0xd, #0x1, PG4STAT, W0
007ADC  0003D0     NOP
1077:                                                      break;
007ADE  37000D     BRA .L185
1078:                                      case PWM_GENERATOR_INTERRUPT_FEED_FORWARD:
1079:                                                      status = PG4STATbits.FFEVT;
007AE0  0AA0CC     BFEXT #0xc, #0x1, PG4STAT, W0
007AE2  0003D0     NOP
1080:                                                      break;    
007AE4  37000A     BRA .L185
1081:                                      case PWM_GENERATOR_INTERRUPT_SYNC:
1082:                                                      status = PG4STATbits.SEVT;
007AE6  801E80     MOV PG4STAT, W0
007AE8  DE004F     LSR W0, #15, W0
1083:                                                      break;                            
007AEA  370007     BRA .L185
1084:                                      default:break;  
1085:                              }              
1086:                              break; 
1087:                      default:break;  
1088:                  }
1089:                  return status;
1090:              }
007AFA  060000     RETURN
007AFC  4787F6     ADD W15, #0x16, W15
1091:              
1092:              /**
1093:               * @ingroup    pwmhsdriver
1094:               * @brief      This inline function requests to update the data registers for specific PWM generator 
1095:               *             selected by the argument \ref PWM_GENERATOR.
1096:               * @param[in]  genNum - PWM generator number
1097:               * @return     none  
1098:               */
1099:              inline static void PWM_SoftwareUpdateRequest(enum PWM_GENERATOR genNum)
1100:              {
1101:                  switch(genNum) { 
0099E0  500FE2     SUB W0, #0x2, [W15]
0099E2  320006     BRA Z, .L218
0099E4  500FE4     SUB W0, #0x4, [W15]
0099E6  320006     BRA Z, .L219
0099E8  500FE1     SUB W0, #0x1, [W15]
0099EA  3A0005     BRA NZ, .L215
1102:                      case MOTOR1_PHASE_A:
1103:                              PG1STATbits.UPDREQ = 1;              
0099EC  A8632E     BSET PG1STAT, #3
1104:                              break;       
0099EE  370003     BRA .L215
1105:                      case MOTOR1_PHASE_B:
1106:                              PG2STATbits.UPDREQ = 1;              
0099F0  A86364     BSET PG2STAT, #3
1107:                              break;       
0099F2  370001     BRA .L215
1108:                      case MOTOR1_PHASE_C:
1109:                              PG4STATbits.UPDREQ = 1;              
0099F4  A863D0     BSET PG4STAT, #3
1110:                              break;       
1111:                      default:break;    
1112:                  }
1113:              
1114:              }
0099F6  060000     RETURN
0099F8  500FE2     SUB W0, #0x2, [W15]
1115:              
1116:              /**
1117:               * @ingroup    pwmhsdriver
1118:               * @brief      This inline function gets the status of the update request for specific PWM generator 
1119:               *             selected by the argument \ref PWM_GENERATOR.
1120:               * @param[in]  genNum - PWM generator number
1121:               * @return     true  - Software update is pending
1122:               * @return     false - Software update is not pending 
1123:               */
1124:              inline static bool PWM_SoftwareUpdatePending(enum PWM_GENERATOR genNum)
1125:              {
1126:                  bool status = false;
0096DC  EB4000     CLR.B W0
1127:                  switch(genNum) { 
0096BE  500FE2     SUB W0, #0x2, [W15]
0096C0  320007     BRA Z, .L223
0096C2  500FE4     SUB W0, #0x4, [W15]
0096C4  320008     BRA Z, .L224
0096C6  500FE1     SUB W0, #0x1, [W15]
0096C8  3A0009     BRA NZ, .L226
1128:                      case MOTOR1_PHASE_A:
1129:                              status = PG1STATbits.UPDATE;              
0096CA  0AA044     BFEXT #0x4, #0x1, PG1STAT, W0
0096CC  00032E     NOP
1130:                              break;       
0096CE  370007     BRA .L221
1131:                      case MOTOR1_PHASE_B:
1132:                              status = PG2STATbits.UPDATE;              
0096D0  0AA044     BFEXT #0x4, #0x1, PG2STAT, W0
0096D2  000364     NOP
1133:                              break;       
0096D4  370004     BRA .L221
1134:                      case MOTOR1_PHASE_C:
1135:                              status = PG4STATbits.UPDATE;              
0096D6  0AA044     BFEXT #0x4, #0x1, PG4STAT, W0
0096D8  0003D0     NOP
1136:                              break;       
0096DA  370001     BRA .L221
1137:                      default:break;   
1138:                  }
1139:                  return status;
1140:              }
0096DE  060000     RETURN
0096E0  900110     MOV [W0+2], W2
1141:              
1142:              /**
1143:               * @ingroup    pwmhsdriver
1144:               * @brief      This inline function sets the Trigger A compare value in count for a specific PWM generator 
1145:               *             selected by the argument \ref PWM_GENERATOR.  
1146:               * @param[in]  genNum - PWM generator number
1147:               * @param[in]  trigA  - Trigger A compare value in count
1148:               * @return     none  
1149:               */
1150:              inline static void PWM_TriggerACompareValueSet(enum PWM_GENERATOR genNum,uint16_t trigA)
1151:              { 
1152:                  switch(genNum) { 
0099F8  500FE2     SUB W0, #0x2, [W15]
0099FA  320006     BRA Z, .L230
0099FC  500FE4     SUB W0, #0x4, [W15]
0099FE  320006     BRA Z, .L231
009A00  500FE1     SUB W0, #0x1, [W15]
009A02  3A0005     BRA NZ, .L227
1153:                      case MOTOR1_PHASE_A:
1154:                              PG1TRIGA = trigA;              
008200  200640     MOV #0x64, W0
008202  881AA0     MOV W0, PG1TRIGA
009A04  881AA1     MOV W1, PG1TRIGA
1155:                              break;       
009A06  370003     BRA .L227
1156:                      case MOTOR1_PHASE_B:
1157:                              PG2TRIGA = trigA;              
009A08  881C51     MOV W1, PG2TRIGA
1158:                              break;       
009A0A  370001     BRA .L227
1159:                      case MOTOR1_PHASE_C:
1160:                              PG4TRIGA = trigA;              
009A0C  881FB1     MOV W1, PG4TRIGA
1161:                              break;       
1162:                      default:break;    
1163:                  }
1164:              }
009A0E  060000     RETURN
1165:              
1166:              /**
1167:               * @ingroup    pwmhsdriver
1168:               * @brief      This inline function sets the Trigger B compare value in count for a specific PWM generator 
1169:               *             selected by the argument \ref PWM_GENERATOR.   
1170:               * @param[in]  genNum - PWM generator number
1171:               * @param[in]  trigB  - Trigger B compare value in count
1172:               * @return     none  
1173:               */
1174:              inline static void PWM_TriggerBCompareValueSet(enum PWM_GENERATOR genNum,uint16_t trigB)
1175:              {
1176:                  switch(genNum) { 
009A10  500FE2     SUB W0, #0x2, [W15]
009A12  320006     BRA Z, .L235
009A14  500FE4     SUB W0, #0x4, [W15]
009A16  320006     BRA Z, .L236
009A18  500FE1     SUB W0, #0x1, [W15]
009A1A  3A0005     BRA NZ, .L232
1177:                      case MOTOR1_PHASE_A:
1178:                              PG1TRIGB = trigB;              
009A1C  881AB1     MOV W1, PG1TRIGB
1179:                              break;       
009A1E  370003     BRA .L232
1180:                      case MOTOR1_PHASE_B:
1181:                              PG2TRIGB = trigB;              
009A20  881C61     MOV W1, PG2TRIGB
1182:                              break;       
009A22  370001     BRA .L232
1183:                      case MOTOR1_PHASE_C:
1184:                              PG4TRIGB = trigB;              
009A24  881FC1     MOV W1, PG4TRIGB
1185:                              break;       
1186:                      default:break;    
1187:                  }
1188:              }
009A26  060000     RETURN
1189:              
1190:              /**
1191:               * @ingroup    pwmhsdriver
1192:               * @brief      This inline function sets the Trigger C compare value in count for a specific PWM generator 
1193:               *             selected by the argument \ref PWM_GENERATOR.
1194:               * @param[in]  genNum - PWM generator number
1195:               * @param[in]  trigC  - Trigger C compare value in count
1196:               * @return     none  
1197:               */
1198:              inline static void PWM_TriggerCCompareValueSet(enum PWM_GENERATOR genNum,uint16_t trigC)
1199:              {
1200:                  switch(genNum) { 
009A28  500FE2     SUB W0, #0x2, [W15]
009A2A  320006     BRA Z, .L240
009A2C  500FE4     SUB W0, #0x4, [W15]
009A2E  320006     BRA Z, .L241
009A30  500FE1     SUB W0, #0x1, [W15]
009A32  3A0005     BRA NZ, .L237
1201:                      case MOTOR1_PHASE_A:
1202:                              PG1TRIGC = trigC;              
009A34  881AC1     MOV W1, PG1TRIGC
1203:                              break;       
009A36  370003     BRA .L237
1204:                      case MOTOR1_PHASE_B:
1205:                              PG2TRIGC = trigC;              
009A38  881C71     MOV W1, PG2TRIGC
1206:                              break;       
009A3A  370001     BRA .L237
1207:                      case MOTOR1_PHASE_C:
1208:                              PG4TRIGC = trigC;              
009A3C  881FD1     MOV W1, PG4TRIGC
1209:                              break;       
1210:                      default:break;    
1211:                  }
1212:              }
009A3E  060000     RETURN
009A40  500FE2     SUB W0, #0x2, [W15]
1213:              
1214:              /**
1215:               * @ingroup    pwmhsdriver
1216:               * @brief      This inline function enables ADC trigger 1 for the specific compare register 
1217:               *             selected by the argument \ref PWM_GENERATOR.
1218:               * @pre        Trigger value has to be set using \ref PWM_TriggerACompareValueSet, 
1219:               *             \ref PWM_TriggerBCompareValueSet or \ref PWM_TriggerCCompareValueSet
1220:               *             before calling this function.
1221:               * @param[in]  genNum - PWM generator number
1222:               * @param[in]  compareRegister - PWM generator number
1223:               * @return     none  
1224:               */
1225:              inline static void PWM_Trigger1Enable(enum PWM_GENERATOR genNum, enum PWM_TRIGGER_COMPARE compareRegister)
1226:              {
1227:                  switch(genNum) { 
008A0E  500FE2     SUB W0, #0x2, [W15]
008A10  320010     BRA Z, .L245
008A12  500FE4     SUB W0, #0x4, [W15]
008A14  32001A     BRA Z, .L246
008A16  500FE1     SUB W0, #0x1, [W15]
008A18  3A0023     BRA NZ, .L242
1228:                      case MOTOR1_PHASE_A:
1229:                              switch(compareRegister) { 
008A1A  508FE2     SUB W1, #0x2, [W15]
008A1C  320006     BRA Z, .L248
008A1E  508FE3     SUB W1, #0x3, [W15]
008A20  320006     BRA Z, .L249
008A22  508FE1     SUB W1, #0x1, [W15]
008A24  3A001D     BRA NZ, .L242
1230:                                      case PWM_TRIGGER_COMPARE_A:
1231:                                                      PG1EVTLbits.ADTR1EN1 = 1;               
008A26  A80335     BSET 0x335, #0
008DCC  A80335     BSET 0x335, #0
1232:                                                      break;       
008A28  37001B     BRA .L242
1233:                                      case PWM_TRIGGER_COMPARE_B:
1234:                                                      PG1EVTLbits.ADTR1EN2 = 1;
008A2A  A82335     BSET 0x335, #1
1235:                                                      break;
008A2C  370019     BRA .L242
1236:                                      case PWM_TRIGGER_COMPARE_C:
1237:                                                      PG1EVTLbits.ADTR1EN3 = 1;
008A2E  A84335     BSET 0x335, #2
1238:                                                      break;                           
008A30  370017     BRA .L242
1239:                                      default:break;  
1240:                              }              
1241:                              break;       
1242:                      case MOTOR1_PHASE_B:
1243:                              switch(compareRegister) { 
008A32  508FE2     SUB W1, #0x2, [W15]
008A34  320006     BRA Z, .L251
008A36  508FE3     SUB W1, #0x3, [W15]
008A38  320006     BRA Z, .L252
008A3A  508FE1     SUB W1, #0x1, [W15]
008A3C  3A0011     BRA NZ, .L242
1244:                                      case PWM_TRIGGER_COMPARE_A:
1245:                                                      PG2EVTLbits.ADTR1EN1 = 1;               
008A3E  A8036B     BSET 0x36B, #0
1246:                                                      break;       
008A40  37000F     BRA .L242
1247:                                      case PWM_TRIGGER_COMPARE_B:
1248:                                                      PG2EVTLbits.ADTR1EN2 = 1;
008A42  A8236B     BSET 0x36B, #1
1249:                                                      break;
008A44  37000D     BRA .L242
1250:                                      case PWM_TRIGGER_COMPARE_C:
1251:                                                      PG2EVTLbits.ADTR1EN3 = 1;
008A46  A8436B     BSET 0x36B, #2
1252:                                                      break;                           
008A48  37000B     BRA .L242
1253:                                      default:break;  
1254:                              }              
1255:                              break;       
1256:                      case MOTOR1_PHASE_C:
1257:                              switch(compareRegister) { 
008A4A  508FE2     SUB W1, #0x2, [W15]
008A4C  320006     BRA Z, .L254
008A4E  508FE3     SUB W1, #0x3, [W15]
008A50  320006     BRA Z, .L255
008A52  508FE1     SUB W1, #0x1, [W15]
008A54  3A0005     BRA NZ, .L242
1258:                                      case PWM_TRIGGER_COMPARE_A:
1259:                                                      PG4EVTLbits.ADTR1EN1 = 1;               
008A56  A803D7     BSET 0x3D7, #0
1260:                                                      break;       
008A58  370003     BRA .L242
1261:                                      case PWM_TRIGGER_COMPARE_B:
1262:                                                      PG4EVTLbits.ADTR1EN2 = 1;
008A5A  A823D7     BSET 0x3D7, #1
1263:                                                      break;
008A5C  370001     BRA .L242
1264:                                      case PWM_TRIGGER_COMPARE_C:
1265:                                                      PG4EVTLbits.ADTR1EN3 = 1;
008A5E  A843D7     BSET 0x3D7, #2
1266:                                                      break;                           
1267:                                      default:break;  
1268:                              }              
1269:                              break;       
1270:                      default:break;    
1271:                  }
1272:              
1273:              }  
008A60  060000     RETURN
1274:              
1275:              /**
1276:               * @ingroup    pwmhsdriver
1277:               * @brief      This inline function disables ADC trigger 1 for the specific compare register 
1278:               *             selected by the argument \ref PWM_GENERATOR.
1279:               * @param[in]  genNum - PWM generator number
1280:               * @param[in]  compareRegister - PWM generator number
1281:               * @return     none  
1282:               */
1283:              inline static void PWM_Trigger1Disable(enum PWM_GENERATOR genNum, enum PWM_TRIGGER_COMPARE compareRegister)
1284:              {
1285:                  switch(genNum) { 
008A62  500FE2     SUB W0, #0x2, [W15]
008A64  320010     BRA Z, .L259
008A66  500FE4     SUB W0, #0x4, [W15]
008A68  32001A     BRA Z, .L260
008A6A  500FE1     SUB W0, #0x1, [W15]
008A6C  3A0023     BRA NZ, .L256
1286:                      case MOTOR1_PHASE_A:
1287:                              switch(compareRegister) { 
008A6E  508FE2     SUB W1, #0x2, [W15]
008A70  320006     BRA Z, .L262
008A72  508FE3     SUB W1, #0x3, [W15]
008A74  320006     BRA Z, .L263
008A76  508FE1     SUB W1, #0x1, [W15]
008A78  3A001D     BRA NZ, .L256
1288:                                      case PWM_TRIGGER_COMPARE_A:
1289:                                                      PG1EVTLbits.ADTR1EN1 = 0;               
008A7A  A90335     BCLR 0x335, #0
1290:                                                      break;       
008A7C  37001B     BRA .L256
1291:                                      case PWM_TRIGGER_COMPARE_B:
1292:                                                      PG1EVTLbits.ADTR1EN2 = 0;
008A7E  A92335     BCLR 0x335, #1
1293:                                                      break;
008A80  370019     BRA .L256
1294:                                      case PWM_TRIGGER_COMPARE_C:
1295:                                                      PG1EVTLbits.ADTR1EN3 = 0;
008A82  A94335     BCLR 0x335, #2
1296:                                                      break;                           
008A84  370017     BRA .L256
1297:                                      default:break;  
1298:                              }              
1299:                              break;       
1300:                      case MOTOR1_PHASE_B:
1301:                              switch(compareRegister) { 
008A86  508FE2     SUB W1, #0x2, [W15]
008A88  320006     BRA Z, .L265
008A8A  508FE3     SUB W1, #0x3, [W15]
008A8C  320006     BRA Z, .L266
008A8E  508FE1     SUB W1, #0x1, [W15]
008A90  3A0011     BRA NZ, .L256
1302:                                      case PWM_TRIGGER_COMPARE_A:
1303:                                                      PG2EVTLbits.ADTR1EN1 = 0;               
008A92  A9036B     BCLR 0x36B, #0
1304:                                                      break;       
008A94  37000F     BRA .L256
1305:                                      case PWM_TRIGGER_COMPARE_B:
1306:                                                      PG2EVTLbits.ADTR1EN2 = 0;
008A96  A9236B     BCLR 0x36B, #1
1307:                                                      break;
008A98  37000D     BRA .L256
1308:                                      case PWM_TRIGGER_COMPARE_C:
1309:                                                      PG2EVTLbits.ADTR1EN3 = 0;
008A9A  A9436B     BCLR 0x36B, #2
1310:                                                      break;                           
008A9C  37000B     BRA .L256
1311:                                      default:break;  
1312:                              }              
1313:                              break;       
1314:                      case MOTOR1_PHASE_C:
1315:                              switch(compareRegister) { 
008A9E  508FE2     SUB W1, #0x2, [W15]
008AA0  320006     BRA Z, .L268
008AA2  508FE3     SUB W1, #0x3, [W15]
008AA4  320006     BRA Z, .L269
008AA6  508FE1     SUB W1, #0x1, [W15]
008AA8  3A0005     BRA NZ, .L256
1316:                                      case PWM_TRIGGER_COMPARE_A:
1317:                                                      PG4EVTLbits.ADTR1EN1 = 0;               
008AAA  A903D7     BCLR 0x3D7, #0
1318:                                                      break;       
008AAC  370003     BRA .L256
1319:                                      case PWM_TRIGGER_COMPARE_B:
1320:                                                      PG4EVTLbits.ADTR1EN2 = 0;
008AAE  A923D7     BCLR 0x3D7, #1
1321:                                                      break;
008AB0  370001     BRA .L256
1322:                                      case PWM_TRIGGER_COMPARE_C:
1323:                                                      PG4EVTLbits.ADTR1EN3 = 0;
008AB2  A943D7     BCLR 0x3D7, #2
1324:                                                      break;                           
1325:                                      default:break;  
1326:                              }              
1327:                              break;       
1328:                      default:break;    
1329:                  }
1330:              
1331:              }
008AB4  060000     RETURN
1332:              
1333:              /**
1334:               * @ingroup    pwmhsdriver
1335:               * @brief      This inline function enables ADC trigger 2 for the specific compare register 
1336:               *             selected by the argument \ref PWM_GENERATOR.
1337:               * @pre        Trigger value has to be set using \ref PWM_TriggerACompareValueSet, 
1338:               *             \ref PWM_TriggerBCompareValueSet or \ref PWM_TriggerCCompareValueSet
1339:               *             before calling this function.
1340:               * @param[in]  genNum - PWM generator number
1341:               * @param[in]  compareRegister - PWM generator number
1342:               * @return     none  
1343:               */
1344:              inline static void PWM_Trigger2Enable(enum PWM_GENERATOR genNum, enum PWM_TRIGGER_COMPARE compareRegister)
1345:              {
1346:                  switch(genNum) { 
008AB6  500FE2     SUB W0, #0x2, [W15]
008AB8  320010     BRA Z, .L273
008ABA  500FE4     SUB W0, #0x4, [W15]
008ABC  32001A     BRA Z, .L274
008ABE  500FE1     SUB W0, #0x1, [W15]
008AC0  3A0023     BRA NZ, .L270
1347:                      case MOTOR1_PHASE_A:
1348:                              switch(compareRegister) { 
008AC2  508FE2     SUB W1, #0x2, [W15]
008AC4  320006     BRA Z, .L276
008AC6  508FE3     SUB W1, #0x3, [W15]
008AC8  320006     BRA Z, .L277
008ACA  508FE1     SUB W1, #0x1, [W15]
008ACC  3A001D     BRA NZ, .L270
1349:                                      case PWM_TRIGGER_COMPARE_A:
1350:                                                      PG1EVTHbits.ADTR2EN1 = 1;               
008ACE  A8A336     BSET PG1EVTH, #5
1351:                                                      break;       
008AD0  37001B     BRA .L270
1352:                                      case PWM_TRIGGER_COMPARE_B:
1353:                                                      PG1EVTHbits.ADTR2EN2 = 1;
008AD2  A8C336     BSET PG1EVTH, #6
1354:                                                      break;
008AD4  370019     BRA .L270
1355:                                      case PWM_TRIGGER_COMPARE_C:
1356:                                                      PG1EVTHbits.ADTR2EN3 = 1;
008AD6  A8E336     BSET PG1EVTH, #7
1357:                                                      break;                           
008AD8  370017     BRA .L270
1358:                                      default:break;  
1359:                              }              
1360:                              break;       
1361:                      case MOTOR1_PHASE_B:
1362:                              switch(compareRegister) { 
008ADA  508FE2     SUB W1, #0x2, [W15]
008ADC  320006     BRA Z, .L279
008ADE  508FE3     SUB W1, #0x3, [W15]
008AE0  320006     BRA Z, .L280
008AE2  508FE1     SUB W1, #0x1, [W15]
008AE4  3A0011     BRA NZ, .L270
1363:                                      case PWM_TRIGGER_COMPARE_A:
1364:                                                      PG2EVTHbits.ADTR2EN1 = 1;               
008AE6  A8A36C     BSET PG2EVTH, #5
1365:                                                      break;       
008AE8  37000F     BRA .L270
1366:                                      case PWM_TRIGGER_COMPARE_B:
1367:                                                      PG2EVTHbits.ADTR2EN2 = 1;
008AEA  A8C36C     BSET PG2EVTH, #6
1368:                                                      break;
008AEC  37000D     BRA .L270
1369:                                      case PWM_TRIGGER_COMPARE_C:
1370:                                                      PG2EVTHbits.ADTR2EN3 = 1;
008AEE  A8E36C     BSET PG2EVTH, #7
1371:                                                      break;                           
008AF0  37000B     BRA .L270
1372:                                      default:break;  
1373:                              }              
1374:                              break;       
1375:                      case MOTOR1_PHASE_C:
1376:                              switch(compareRegister) { 
008AF2  508FE2     SUB W1, #0x2, [W15]
008AF4  320006     BRA Z, .L282
008AF6  508FE3     SUB W1, #0x3, [W15]
008AF8  320006     BRA Z, .L283
008AFA  508FE1     SUB W1, #0x1, [W15]
008AFC  3A0005     BRA NZ, .L270
1377:                                      case PWM_TRIGGER_COMPARE_A:
1378:                                                      PG4EVTHbits.ADTR2EN1 = 1;               
008AFE  A8A3D8     BSET PG4EVTH, #5
1379:                                                      break;       
008B00  370003     BRA .L270
1380:                                      case PWM_TRIGGER_COMPARE_B:
1381:                                                      PG4EVTHbits.ADTR2EN2 = 1;
008B02  A8C3D8     BSET PG4EVTH, #6
1382:                                                      break;
008B04  370001     BRA .L270
1383:                                      case PWM_TRIGGER_COMPARE_C:
1384:                                                      PG4EVTHbits.ADTR2EN3 = 1;
008B06  A8E3D8     BSET PG4EVTH, #7
1385:                                                      break;                           
1386:                                      default:break;  
1387:                              }              
1388:                              break;       
1389:                      default:break;    
1390:                  }
1391:              
1392:              }  
008B08  060000     RETURN
1393:              
1394:              /**
1395:               * @ingroup    pwmhsdriver
1396:               * @brief      This inline function disables ADC trigger 2 for the specific compare register 
1397:               *             selected by the argument \ref PWM_GENERATOR.
1398:               * @param[in]  genNum - PWM generator number
1399:               * @param[in]  compareRegister - PWM generator number
1400:               * @return     none  
1401:               */
1402:              inline static void PWM_Trigger2Disable(enum PWM_GENERATOR genNum, enum PWM_TRIGGER_COMPARE compareRegister)
1403:              {
1404:                  switch(genNum) { 
008B0A  500FE2     SUB W0, #0x2, [W15]
008B0C  320010     BRA Z, .L287
008B0E  500FE4     SUB W0, #0x4, [W15]
008B10  32001A     BRA Z, .L288
008B12  500FE1     SUB W0, #0x1, [W15]
008B14  3A0023     BRA NZ, .L284
1405:                      case MOTOR1_PHASE_A:
1406:                              switch(compareRegister) { 
008B16  508FE2     SUB W1, #0x2, [W15]
008B18  320006     BRA Z, .L290
008B1A  508FE3     SUB W1, #0x3, [W15]
008B1C  320006     BRA Z, .L291
008B1E  508FE1     SUB W1, #0x1, [W15]
008B20  3A001D     BRA NZ, .L284
1407:                                      case PWM_TRIGGER_COMPARE_A:
1408:                                                      PG1EVTHbits.ADTR2EN1 = 0;               
008B22  A9A336     BCLR PG1EVTH, #5
1409:                                                      break;       
008B24  37001B     BRA .L284
1410:                                      case PWM_TRIGGER_COMPARE_B:
1411:                                                      PG1EVTHbits.ADTR2EN2 = 0;
008B26  A9C336     BCLR PG1EVTH, #6
1412:                                                      break;
008B28  370019     BRA .L284
1413:                                      case PWM_TRIGGER_COMPARE_C:
1414:                                                      PG1EVTHbits.ADTR2EN3 = 0;
008B2A  A9E336     BCLR PG1EVTH, #7
1415:                                                      break;                           
008B2C  370017     BRA .L284
1416:                                      default:break;  
1417:                              }              
1418:                              break;       
1419:                      case MOTOR1_PHASE_B:
1420:                              switch(compareRegister) { 
008B2E  508FE2     SUB W1, #0x2, [W15]
008B30  320006     BRA Z, .L293
008B32  508FE3     SUB W1, #0x3, [W15]
008B34  320006     BRA Z, .L294
008B36  508FE1     SUB W1, #0x1, [W15]
008B38  3A0011     BRA NZ, .L284
1421:                                      case PWM_TRIGGER_COMPARE_A:
1422:                                                      PG2EVTHbits.ADTR2EN1 = 0;               
008B3A  A9A36C     BCLR PG2EVTH, #5
1423:                                                      break;       
008B3C  37000F     BRA .L284
1424:                                      case PWM_TRIGGER_COMPARE_B:
1425:                                                      PG2EVTHbits.ADTR2EN2 = 0;
008B3E  A9C36C     BCLR PG2EVTH, #6
1426:                                                      break;
008B40  37000D     BRA .L284
1427:                                      case PWM_TRIGGER_COMPARE_C:
1428:                                                      PG2EVTHbits.ADTR2EN3 = 0;
008B42  A9E36C     BCLR PG2EVTH, #7
1429:                                                      break;                           
008B44  37000B     BRA .L284
1430:                                      default:break;  
1431:                              }              
1432:                              break;       
1433:                      case MOTOR1_PHASE_C:
1434:                              switch(compareRegister) { 
008B46  508FE2     SUB W1, #0x2, [W15]
008B48  320006     BRA Z, .L296
008B4A  508FE3     SUB W1, #0x3, [W15]
008B4C  320006     BRA Z, .L297
008B4E  508FE1     SUB W1, #0x1, [W15]
008B50  3A0005     BRA NZ, .L284
1435:                                      case PWM_TRIGGER_COMPARE_A:
1436:                                                      PG4EVTHbits.ADTR2EN1 = 0;               
008B52  A9A3D8     BCLR PG4EVTH, #5
1437:                                                      break;       
008B54  370003     BRA .L284
1438:                                      case PWM_TRIGGER_COMPARE_B:
1439:                                                      PG4EVTHbits.ADTR2EN2 = 0;
008B56  A9C3D8     BCLR PG4EVTH, #6
1440:                                                      break;
008B58  370001     BRA .L284
1441:                                      case PWM_TRIGGER_COMPARE_C:
1442:                                                      PG4EVTHbits.ADTR2EN3 = 0;
008B5A  A9E3D8     BCLR PG4EVTH, #7
1443:                                                      break;                           
1444:                                      default:break;  
1445:                              }              
1446:                              break;       
1447:                      default:break;    
1448:                  }
1449:              
1450:              }
008B5C  060000     RETURN
008B5E  780080     MOV W0, W1
1451:              
1452:              /**
1453:               * @ingroup    pwmhsdriver
1454:               * @brief      This inline function clears the status of PWM latched fault mode for the PWM Generator 
1455:               *             selected by the argument \ref PWM_GENERATOR.   
1456:               * @param[in]  genNum - PWM generator number
1457:               * @return     none  
1458:               */
1459:              inline static void PWM_FaultModeLatchClear(enum PWM_GENERATOR genNum)
1460:              {
1461:                  switch(genNum) { 
009A40  500FE2     SUB W0, #0x2, [W15]
009A42  320006     BRA Z, .L301
009A44  500FE4     SUB W0, #0x4, [W15]
009A46  320006     BRA Z, .L302
009A48  500FE1     SUB W0, #0x1, [W15]
009A4A  3A0005     BRA NZ, .L298
1462:                      case MOTOR1_PHASE_A: 
1463:                              PG1FPCILbits.SWTERM = 1;
004B78  A8E338     BSET PG1FPCIL, #7
004DF0  A8E338     BSET PG1FPCIL, #7
0079D8  A8E338     BSET PG1FPCIL, #7
009A4C  A8E338     BSET PG1FPCIL, #7
1464:                              break;   
009A4E  370003     BRA .L298
1465:                      case MOTOR1_PHASE_B: 
1466:                              PG2FPCILbits.SWTERM = 1;
004B7A  A8E36E     BSET PG2FPCIL, #7
004DF2  A8E36E     BSET PG2FPCIL, #7
0079DA  A8E36E     BSET PG2FPCIL, #7
009A50  A8E36E     BSET PG2FPCIL, #7
1467:                              break;   
009A52  370001     BRA .L298
1468:                      case MOTOR1_PHASE_C: 
1469:                              PG4FPCILbits.SWTERM = 1;
004B7C  A8E3DA     BSET PG4FPCIL, #7
004DF4  A8E3DA     BSET PG4FPCIL, #7
0079DC  A8E3DA     BSET PG4FPCIL, #7
009A54  A8E3DA     BSET PG4FPCIL, #7
1470:                              break;   
1471:                      default:break;   
1472:                  }   
1473:              }
009A56  060000     RETURN
009A58  781F88     MOV W8, [W15++]
1474:              
1475:              /**
1476:               * @ingroup    pwmhsdriver
1477:               * @brief      This function can be used to override default callback 
1478:               *             \ref PWM_GeneratorEOCEventCallback and to define custom callback for 
1479:               *             PWM EOCEvent event.
1480:               * @param[in]  callback - Address of the callback function
1481:               * @return     none  
1482:               */
1483:              void PWM_GeneratorEOCEventCallbackRegister(void (*callback)(enum PWM_GENERATOR genNum));
1484:              
1485:              /**
1486:               * @ingroup    pwmhsdriver
1487:               * @brief      This is the default callback with weak attribute. The user can 
1488:               *             override and implement the default callback without weak attribute 
1489:               *             or can register a custom callback function using PWM_EOCEventCallbackRegister.
1490:               * @param[in]  genNum - PWM generator number
1491:               * @return     none  
1492:               */
1493:              void PWM_GeneratorEOCEventCallback(enum PWM_GENERATOR genNum);
1494:              
1495:              
1496:              /**
1497:               * @ingroup    pwmhsdriver
1498:               * @brief      This is a tasks function for PWM1
1499:               * @param[in]  intGen - PWM generator number
1500:               * @return     none  
1501:               */
1502:              void PWM_GeneratorTasks(enum PWM_GENERATOR intGen);
1503:              
1504:              
1505:              #endif //PWM_H
1506:              
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/src/opa3.c
1:                 /**
2:                  * OPA3 Generated Driver Source File
3:                  * 
4:                  * @file      opa3.c
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver source file for OPA3 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                #include <stdlib.h>
41:                #include "../opa3.h"
42:                
43:                
44:                // Section: File specific functions
45:                // Section: File specific data type definitions
46:                
47:                /**
48:                 * @ingroup  opadriver
49:                 * @brief    Defines an object for OPA_INTERFACE.
50:                 *           For hardware dependent APIs, make sure the API is not NULL before calling it.
51:                 * 
52:                 * @b Example:
53:                 * @code
54:                 *      if(customerName.OPA_GainSet != NULL)
55:                 *            customerName.OPA_GainSet();
56:                 * @endcode
57:                 */
58:                const struct OPA_INTERFACE MCC_OPA_IDC = {
59:                    .Intitialize        	 = &OPA3_Initialize,
60:                    .Deintitialize      	 = &OPA3_Deinitialize,
61:                    .Enable             	 = &OPA3_Enable,
62:                    .Disable            	 = &OPA3_Disable,
63:                    /**< Hardware dependent APIs */
64:                	.InputVoltageRangeSelect = &OPA3_InputVoltageRangeSelect,
65:                    .GainSet            	 = NULL,           
66:                };
67:                // Section: Driver Interface Function Definitions
68:                
69:                void OPA3_Initialize (void)
70:                {
71:                
72:                    AMPCON1Lbits.AMPON = 1; // Enable the OPA module
009E02  A8E8DD     BSET 0x8DD, #7
73:                    OPA3_InputVoltageRangeSelect( OPA_WIDE_INPUT ); // wide input range
74:                    OPA3_Enable();
75:                    
76:                }
009E08  060000     RETURN
009E0A  A8E8DD     BSET 0x8DD, #7
77:                
78:                void OPA3_Deinitialize (void)
79:                {
80:                    AMPCON1Lbits.AMPON = 0; 
009EC2  A9E8DD     BCLR 0x8DD, #7
81:                
82:                    OPA3_Disable(); 
83:                }
009EC6  060000     RETURN
009EC8  A9E8DD     BCLR 0x8DD, #7
84:                
85:                /**
86:                 End of File
87:                */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/src/opa2.c
1:                 /**
2:                  * OPA2 Generated Driver Source File
3:                  * 
4:                  * @file      opa2.c
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver source file for OPA2 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                #include <stdlib.h>
41:                #include "../opa2.h"
42:                
43:                // Section: File specific functions
44:                // Section: File specific data type definitions
45:                
46:                /**
47:                 * @ingroup  opadriver
48:                 * @brief    Defines an object for OPA_INTERFACE.
49:                 *           For hardware dependent APIs, make sure the API is not NULL before calling it.  
50:                 * 
51:                 * @b Example:
52:                 * @code
53:                 *      if(customerName.OPA_GainSet != NULL)
54:                 *            customerName.OPA_GainSet();
55:                 * @endcode
56:                 */
57:                const struct OPA_INTERFACE MCC_OPA_IB = {
58:                    .Intitialize        	 = &OPA2_Initialize,
59:                    .Deintitialize      	 = &OPA2_Deinitialize,
60:                    .Enable           		 = &OPA2_Enable,
61:                    .Disable            	 = &OPA2_Disable,
62:                    /**< Hardware dependent APIs */
63:                	.InputVoltageRangeSelect = &OPA2_InputVoltageRangeSelect,
64:                    .GainSet            	 = NULL,             
65:                };
66:                // Section: Driver Interface Function Definitions
67:                
68:                void OPA2_Initialize (void)
69:                {
70:                
71:                    AMPCON1Lbits.AMPON = 1; // Enable the OPA module
009E0A  A8E8DD     BSET 0x8DD, #7
72:                    OPA2_InputVoltageRangeSelect( OPA_WIDE_INPUT ); // wide input range
73:                    OPA2_Enable();
74:                    
75:                }
009E10  060000     RETURN
009E12  A8E8DD     BSET 0x8DD, #7
76:                
77:                void OPA2_Deinitialize (void)
78:                {
79:                    AMPCON1Lbits.AMPON = 0; 
009EC8  A9E8DD     BCLR 0x8DD, #7
80:                
81:                    OPA2_Disable(); 
82:                }
009ECC  060000     RETURN
009ECE  0A2000     BFINS #0x0, #0x1, W0, AMPCON1H
83:                
84:                /**
85:                 End of File
86:                */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/src/opa1.c
1:                 /**
2:                  * OPA1 Generated Driver Source File
3:                  * 
4:                  * @file      opa1.c
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver source file for OPA1 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                
40:                #include <stdlib.h>
41:                #include "../opa1.h"
42:                
43:                
44:                // Section: File specific functions
45:                // Section: File specific data type definitions
46:                
47:                /**
48:                 * @ingroup  opadriver
49:                 * @brief    Defines an object for OPA_INTERFACE
50:                 *           For hardware dependent APIs, make sure the API is not NULL before calling it. 
51:                 * 
52:                 * @b Example:
53:                 * @code
54:                 *      if(customerName.OPA_GainSet != NULL)
55:                 *            customerName.OPA_GainSet();
56:                 * @endcode
57:                 */
58:                const struct OPA_INTERFACE MCC_OPA_IA = {
59:                    .Intitialize        	 = &OPA1_Initialize,
60:                    .Deintitialize      	 = &OPA1_Deinitialize,
61:                    .Enable            		 = &OPA1_Enable,
62:                    .Disable           	 	 = &OPA1_Disable,
63:                    /**< Hardware dependent APIs */
64:                	.InputVoltageRangeSelect = &OPA1_InputVoltageRangeSelect,
65:                    .GainSet            	 = NULL,             
66:                };
67:                // Section: Driver Interface Function Definitions
68:                
69:                void OPA1_Initialize (void)
70:                {
71:                    AMPCON1Lbits.AMPON = 1; 					// Enable the OPA module
009E12  A8E8DD     BSET 0x8DD, #7
72:                    OPA1_InputVoltageRangeSelect( OPA_WIDE_INPUT ); // wide input range
73:                    OPA1_Enable();
74:                }
009E18  060000     RETURN
009E1A  A8E32B     BSET 0x32B, #7
75:                
76:                void OPA1_Deinitialize (void)
77:                {
78:                    AMPCON1Lbits.AMPON = 0; 
009ED4  A9E8DD     BCLR 0x8DD, #7
79:                    OPA1_Disable(); 
80:                	
81:                }
009ED8  060000     RETURN
009EDA  880A91     MOV W1, POS1HLD
82:                
83:                /**
84:                 End of File
85:                */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/opa3.h  
1:                 /**
2:                  * OPA3 Generated Driver Header File
3:                  * 
4:                  * @file      opa3.h
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the OPA3 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef OPA3_H
39:                #define OPA3_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdint.h>
45:                #include "opa_types.h"
46:                #include "opa_interface.h"
47:                // Section: Data Type Definitions
48:                
49:                /**
50:                 * @ingroup  opadriver
51:                 * @brief    Structure object of type OPA_INTERFACE with the custom name
52:                 *           given by the user in the Melody Driver User interface. The default name 
53:                 *           e.g. OPA3 can be changed by the user in the OPA user interface. 
54:                 *           This allows defining a structure with application specific name using 
55:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
56:                */
57:                extern const struct OPA_INTERFACE MCC_OPA_IDC;
58:                
59:                /**
60:                 * @ingroup  opadriver
61:                 * @brief    This macro defines the Custom Name for \ref OPA3_Initialize API
62:                 */
63:                #define MCC_OPA_IDC_Initialize OPA3_Initialize
64:                /**
65:                 * @ingroup  opadriver
66:                 * @brief    This macro defines the Custom Name for \ref OPA3_Deinitialize API
67:                 */
68:                #define MCC_OPA_IDC_Deinitialize OPA3_Deinitialize
69:                /**
70:                 * @ingroup  opadriver
71:                 * @brief    This macro defines the Custom Name for \ref OPA3_Enable API
72:                 */
73:                #define MCC_OPA_IDC_Enable OPA3_Enable
74:                /**
75:                 * @ingroup  opadriver
76:                 * @brief    This macro defines the Custom Name for \ref OPA3_Disable API
77:                 */
78:                #define MCC_OPA_IDC_Disable OPA3_Disable
79:                /**
80:                 * @ingroup  opadriver
81:                 * @brief    This macro defines the Custom Name for \ref OPA3_InputVoltageRangeSelect API
82:                 */
83:                #define MCC_OPA_IDC_InputVoltageRangeSelect OPA3_InputVoltageRangeSelect
84:                
85:                
86:                // Section: Interface Routines
87:                
88:                /**
89:                 * @ingroup  opadriver
90:                 * @brief    Initializes OPA3 module
91:                 * @return   none  
92:                 */
93:                void OPA3_Initialize (void);
94:                
95:                /**
96:                 * @ingroup  opadriver
97:                 * @brief    Deinitializes the OPA3 to POR values
98:                 * @return   none  
99:                 */
100:               void OPA3_Deinitialize(void);
101:               
102:               /**
103:                * @ingroup  opadriver
104:                * @brief    This inline function enables the OPA3 module
105:                * @pre      The OPA3_Initialize function should be called for the specified 
106:                *           OPA3 driver instance.
107:                * @return   none  
108:                */
109:               inline static void OPA3_Enable( void )
110:               {
111:                    AMPCON1Lbits.AMPEN3 = 1; //Enable opa3;
008224  A848DC     BSET AMPCON1L, #2
009E06  A848DC     BSET AMPCON1L, #2
009F62  A848DC     BSET AMPCON1L, #2
112:               }
009F64  060000     RETURN
113:               
114:               /**
115:                * @ingroup  opadriver
116:                * @brief    This inline function disables the OPA3 module
117:                * @return   none  
118:                */
119:               inline static void OPA3_Disable( void )
120:               {
121:                    AMPCON1Lbits.AMPEN3 = 0; //Disable opa3;
009EC4  A948DC     BCLR AMPCON1L, #2
009F66  A948DC     BCLR AMPCON1L, #2
122:               }
009F68  060000     RETURN
009F6A  A828DC     BSET AMPCON1L, #1
123:               
124:               /**
125:                * @ingroup    opadriver
126:                * @brief      This inline function selects OPA2 Wide Input or Lowered input voltage range
127:                * @param[in]  input - Wide Input or Lowered Input
128:                * @return     none  
129:                */
130:               inline static void OPA3_InputVoltageRangeSelect(enum OPA_INPUT_VOLTAGE_RANGE input)
131:               {
132:               	AMPCON1Hbits.NCHDIS3 = input;
009CF8  600061     AND W0, #0x1, W0
009E04  A948DE     BCLR AMPCON1H, #2
133:               }
009D04  060000     RETURN
009D06  600061     AND W0, #0x1, W0
134:               
135:               #endif //OPA3_H
136:               
137:               /**
138:                End of File
139:               */
140:               
141:               
142:               
143:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/opa2.h  
1:                 /**
2:                  * OPA2 Generated Driver Header File
3:                  * 
4:                  * @file      opa2.h
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the OPA2 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef OPA2_H
39:                #define OPA2_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdint.h>
45:                #include "opa_types.h"
46:                #include "opa_interface.h"
47:                // Section: Data Type Definitions
48:                
49:                /**
50:                 * @ingroup  opadriver
51:                 * @brief    Structure object of type OPA_INTERFACE with the custom name
52:                 *           given by the user in the Melody Driver User interface. The default name 
53:                 *           e.g. OPA2 can be changed by the user in the OPA user interface. 
54:                 *           This allows defining a structure with application specific name using 
55:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
56:                */
57:                extern const struct OPA_INTERFACE MCC_OPA_IB;
58:                
59:                /**
60:                 * @ingroup  opadriver
61:                 * @brief    This macro defines the Custom Name for \ref OPA2_Initialize API
62:                 */
63:                #define MCC_OPA_IB_Initialize OPA2_Initialize
64:                /**
65:                 * @ingroup  opadriver
66:                 * @brief    This macro defines the Custom Name for \ref OPA2_Deinitialize API
67:                 */
68:                #define MCC_OPA_IB_Deinitialize OPA2_Deinitialize
69:                /**
70:                 * @ingroup  opadriver
71:                 * @brief    This macro defines the Custom Name for \ref OPA2_Enable API
72:                 */
73:                #define MCC_OPA_IB_Enable OPA2_Enable
74:                /**
75:                 * @ingroup  opadriver
76:                 * @brief    This macro defines the Custom Name for \ref OPA2_Disable API
77:                 */
78:                #define MCC_OPA_IB_Disable OPA2_Disable
79:                /**
80:                 * @ingroup  opadriver
81:                 * @brief    This macro defines the Custom Name for \ref OPA2_InputVoltageRangeSelect API
82:                 */
83:                #define MCC_OPA_IB_InputVoltageRangeSelect OPA2_InputVoltageRangeSelect
84:                
85:                
86:                // Section: Interface Routines
87:                
88:                /**
89:                 * @ingroup  opadriver
90:                 * @brief    Initializes the OPA2 module
91:                 * @return   none  
92:                 */
93:                void OPA2_Initialize (void);
94:                
95:                /**
96:                 * @ingroup  opadriver
97:                 * @brief    Deinitializes the OPA2 to POR values
98:                 * @return   none  
99:                 */
100:               void OPA2_Deinitialize(void);
101:               
102:               /**
103:                * @ingroup  opadriver
104:                * @brief    This inline function enables the OPA2 module
105:                * @pre      The OPA2_Initialize function should be called for the specified 
106:                *           OPA2 driver instance
107:                * @return   none  
108:                */
109:               inline static void OPA2_Enable( void )
110:               {
111:                    AMPCON1Lbits.AMPEN2 = 1; //Enable opa2;
008222  A828DC     BSET AMPCON1L, #1
009E0E  A828DC     BSET AMPCON1L, #1
009F6A  A828DC     BSET AMPCON1L, #1
112:               }
009F6C  060000     RETURN
113:               
114:               /**
115:                * @ingroup  opadriver
116:                * @brief    This inline function disables the OPA2 module
117:                * @return   none  
118:                */
119:               inline static void OPA2_Disable( void )
120:               {
121:                    AMPCON1Lbits.AMPEN2 = 0; //Disable opa2;
009ECA  A928DC     BCLR AMPCON1L, #1
009F6E  A928DC     BCLR AMPCON1L, #1
122:               }
009F70  060000     RETURN
009F72  A808DC     BSET AMPCON1L, #0
123:               
124:               /**
125:                * @ingroup    opadriver
126:                * @brief      This inline function selects OPA2 Wide Input or Lowered input voltage range
127:                * @param[in]  input - Wide Input or Lowered Input
128:                * @return     none  
129:                */
130:               inline static void OPA2_InputVoltageRangeSelect(enum OPA_INPUT_VOLTAGE_RANGE input)
131:               {
132:               	AMPCON1Hbits.NCHDIS2 = input;
009D06  600061     AND W0, #0x1, W0
009D08  400000     ADD W0, W0, W0
009D0A  8046F1     MOV AMPCON1H, W1
009D0C  A11001     BCLR W1, #1
009D0E  700081     IOR W0, W1, W1
009D10  8846F1     MOV W1, AMPCON1H
009E0C  A928DE     BCLR AMPCON1H, #1
133:               }
009D12  060000     RETURN
009D14  500161     SUB W0, #0x1, W2
134:               
135:               #endif //OPA2_H
136:               
137:               /**
138:                End of File
139:               */
140:               
141:               
142:               
143:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/opa/opa1.h  
1:                 /**
2:                  * OPA1 Generated Driver Header File
3:                  * 
4:                  * @file      opa1.h
5:                  * 
6:                  * @ingroup   opadriver
7:                  * 
8:                  * @brief     This is the generated driver header file for the OPA1 driver
9:                  *
10:                 * @version   Firmware Driver Version 1.2.1
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef OPA1_H
39:                #define OPA1_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdint.h>
45:                #include "opa_types.h"
46:                #include "opa_interface.h"
47:                // Section: Data Type Definitions
48:                
49:                /**
50:                 * @ingroup  opadriver
51:                 * @brief    Structure object of type OPA_INTERFACE with the custom name
52:                 *           given by the user in the Melody Driver User interface. The default name 
53:                 *           e.g. OPA1 can be changed by the user in the OPA user interface. 
54:                 *           This allows defining a structure with application specific name using 
55:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
56:                */
57:                 extern const struct OPA_INTERFACE MCC_OPA_IA;
58:                
59:                /**
60:                 * @ingroup  opadriver
61:                 * @brief    This macro defines the Custom Name for \ref OPA1_Initialize API
62:                 */
63:                #define MCC_OPA_IA_Initialize OPA1_Initialize
64:                /**
65:                 * @ingroup  opadriver
66:                 * @brief    This macro defines the Custom Name for \ref OPA1_Deinitialize API
67:                 */
68:                #define MCC_OPA_IA_Deinitialize OPA1_Deinitialize
69:                /**
70:                 * @ingroup  opadriver
71:                 * @brief    This macro defines the Custom Name for \ref OPA1_Enable API
72:                 */
73:                #define MCC_OPA_IA_Enable OPA1_Enable
74:                /**
75:                 * @ingroup  opadriver
76:                 * @brief    This macro defines the Custom Name for \ref OPA1_Disable API
77:                 */
78:                #define MCC_OPA_IA_Disable OPA1_Disable
79:                /**
80:                 * @ingroup  opadriver
81:                 * @brief    This macro defines the Custom Name for \ref OPA1_InputVoltageRangeSelect API
82:                 */
83:                #define MCC_OPA_IA_InputVoltageRangeSelect OPA1_InputVoltageRangeSelect
84:                
85:                // Section: Interface Routines
86:                
87:                /**
88:                 * @ingroup  opadriver
89:                 * @brief    Initializes the OPA1 module
90:                 * @return   none  
91:                 */
92:                void OPA1_Initialize (void);
93:                
94:                /**
95:                 * @ingroup  opadriver
96:                 * @brief    Deinitializes the OPA1 to POR values
97:                 * @return   none  
98:                 */
99:                void OPA1_Deinitialize(void);
100:               
101:               /**
102:                * @ingroup  opadriver
103:                * @brief    This inline function enables the OPA1 module
104:                * @pre      The OPA1_Initialize function should be called for the specified 
105:                *           OPA1 driver instance.
106:                * @return   none  
107:                */
108:               inline static void OPA1_Enable( void )
109:               {
110:               	AMPCON1Lbits.AMPEN1 = 1; //Enable opa1;
008220  A808DC     BSET AMPCON1L, #0
009E16  A808DC     BSET AMPCON1L, #0
009F72  A808DC     BSET AMPCON1L, #0
111:               }
009F74  060000     RETURN
112:               
113:               /**
114:                * @ingroup  opadriver
115:                * @brief    This inline function disables the OPA1 module
116:                * @return   none  
117:                */
118:               inline static void OPA1_Disable( void )
119:               {
120:               	AMPCON1Lbits.AMPEN1 = 0; //Disable opa1;
009ED6  A908DC     BCLR AMPCON1L, #0
009F76  A908DC     BCLR AMPCON1L, #0
121:               }
009F78  060000     RETURN
009F7A  881850     MOV W0, MPER
122:               
123:               /**
124:                * @ingroup    opadriver
125:                * @brief      This inline function selects OPA1 Wide Input or Lowered input voltage range
126:                * @param[in]  input - Wide Input or Lowered Input
127:                * @return     none  
128:                */
129:               inline static void OPA1_InputVoltageRangeSelect(enum OPA_INPUT_VOLTAGE_RANGE input)
130:               {
131:               	AMPCON1Hbits.NCHDIS1 = input;
009E14  A908DE     BCLR AMPCON1H, #0
009ECE  0A2000     BFINS #0x0, #0x1, W0, AMPCON1H
009ED0  0008DE     NOP
132:               }
009ED2  060000     RETURN
009ED4  A9E8DD     BCLR 0x8DD, #7
133:               
134:               #endif //OPA1_H
135:               
136:               /**
137:                End of File
138:               */
139:               
140:               
141:               
142:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/util.h
1:                 /**
2:                  * util.h
3:                  * 
4:                  * Utility routines and types for computation
5:                  * 
6:                  * Component: miscellaneous
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __UTIL_H
48:                #define __UTIL_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                
53:                #ifdef __cplusplus
54:                extern "C" {
55:                #endif
56:                
57:                /**
58:                 * Limit the slew rate of an output signal to within positive and negative limits.
59:                 * This is intended to be called at a constant rate delta_t, in which case
60:                 * the slew rate limits are equal to limit_pos/delta_t and limit_neg/delta_t.
61:                 * 
62:                 * @param input raw incoming signal
63:                 * @param previousOutput previous output signal
64:                 * @param limitPos maximum positive slew rate
65:                 * @param limitNeg maximum negative slew rate
66:                 * @return updated output signal
67:                 */
68:                inline static int16_t UTIL_LimitSlewRate(int16_t input, int16_t previousOutput, 
69:                        int16_t limitPos, int16_t limitNeg)
70:                {
71:                    /* Note: use 32-bit difference. The difference of a pair of int16_t values
72:                     * is technically a 17-bit integer; contrast the following two cases:
73:                     *   (-10000) - (30000) = -40000
74:                     *   ( 28536) - ( 3000) =  25536
75:                     * If cast to an int16_t, both evaluate to 25536, but this is 
76:                     * clearly an overflow error in the first case.
77:                     */
78:                    const int32_t delta_in = (int32_t)input - previousOutput;
0062D4  901960     MOV [W0+60], W2
0062D6  B91461     MUL.SU W2, #0x1, W8
0062D8  B91B61     MUL.SU W3, #0x1, W6
0062DA  540306     SUB W8, W6, W6
0062DC  5C8387     SUBB W9, W7, W7
006804  B90361     MUL.SU W0, #0x1, W6
006806  B90A61     MUL.SU W1, #0x1, W4
006808  530204     SUB W6, W4, W4
00680A  5B8285     SUBB W7, W5, W5
00683A  B90361     MUL.SU W0, #0x1, W6
00683C  B91261     MUL.SU W2, #0x1, W4
00683E  530204     SUB W6, W4, W4
006840  5B8285     SUBB W7, W5, W5
79:                    int16_t output = previousOutput;
80:                    if (delta_in > limitPos)
0062DE  B92461     MUL.SU W4, #0x1, W8
0062E0  530F88     SUB W6, W8, [W15]
0062E2  5B8F89     SUBB W7, W9, [W15]
0062E4  340002     BRA LE, .L16
00680C  B91361     MUL.SU W2, #0x1, W6
00680E  520F86     SUB W4, W6, [W15]
006810  5A8F87     SUBB W5, W7, [W15]
006812  340002     BRA LE, .L21
006842  B91B61     MUL.SU W3, #0x1, W6
006844  520F86     SUB W4, W6, [W15]
006846  5A8F87     SUBB W5, W7, [W15]
006848  340002     BRA LE, .L26
81:                    {
82:                        output += limitPos;
0062E6  420103     ADD W4, W3, W2
0062E8  370008     BRA .LBE127, .LBE128, .LBE129, .L17
006814  410001     ADD W2, W1, W0
006816  370008     BRA .LBE505, .LBE506, .LBE507, .L22
00684A  418002     ADD W3, W2, W0
00684C  370008     BRA .LBE508, .LBE509, .L27
83:                    }
84:                    else if (delta_in < -limitNeg)
0062EA  EA0404     NEG W4, W8
0062EC  DEC4CF     ASR W8, #15, W9
0062EE  530F88     SUB W6, W8, [W15]
0062F0  5B8F89     SUBB W7, W9, [W15]
0062F2  3D0002     BRA GE, .L18
006818  EA0302     NEG W2, W6
00681A  DEB3CF     ASR W6, #15, W7
00681C  520F86     SUB W4, W6, [W15]
00681E  5A8F87     SUBB W5, W7, [W15]
006820  3D0002     BRA GE, .L23
00684E  EA0309     NEG W9, W6
006850  DEB3CF     ASR W6, #15, W7
006852  520F86     SUB W4, W6, [W15]
006854  5A8F87     SUBB W5, W7, [W15]
006856  3D0002     BRA GE, .L28
85:                    {
86:                        output -= limitNeg;
0062F4  518104     SUB W3, W4, W2
0062F6  370001     BRA .LBE127, .LBE128, .LBE129, .L17
006822  508002     SUB W1, W2, W0
006824  370001     BRA .LBE505, .LBE506, .LBE507, .L22
006858  510009     SUB W2, W9, W0
00685A  370001     BRA .LBE508, .LBE509, .L27
87:                    }
88:                    else
89:                    {
90:                        output += (int16_t)delta_in;
0062F8  418106     ADD W3, W6, W2
006826  408004     ADD W1, W4, W0
00685C  410004     ADD W2, W4, W0
91:                    }
92:                    return output;
93:                }
94:                
95:                /**
96:                 * Limit the slew rate of an output signal to within positive and negative limits.
97:                 * This is intended to be called at a constant rate delta_t, in which case
98:                 * the slew rate limits are equal to limit/delta_t and limit/delta_t.
99:                 * 
100:                * @param input raw incoming signal
101:                * @param previousOutput previous output signal
102:                * @param limit maximum slew rate
103:                * @return updated output signal
104:                */
105:               inline static int16_t UTIL_LimitSlewRateSymmetrical(int16_t input, int16_t previousOutput, 
106:                       int16_t limit)
107:               {
108:                   return UTIL_LimitSlewRate(input, previousOutput, limit, limit);
109:               }
110:               
111:               /**
112:                * Shifts right a 32-bit value by 15, returning the lower 16 bits of the result.
113:                * (We can gain some speed by doing it in a way that the compiler handles better.)
114:                * 
115:                * @param x input
116:                * @return x >> 15
117:                */
118:               inline static int16_t UTIL_Shr15(int32_t x)
119:               {
120:                   return (int16_t)((x << 1) >> 16);
000004  000B9A     NOP
000012  00091A     NOP
000016  000920     NOP
000024  000920     NOP
000034  000920     NOP
000042  000920     NOP
000044  000C16     NOP
000052  000920     NOP
000054  000920     NOP
00005E  000920     NOP
00006A  000920     NOP
000076  000920     NOP
00007E  000920     NOP
00008E  000920     NOP
00009C  000920     NOP
0000A2  000920     NOP
0000AC  000920     NOP
0000B6  000920     NOP
00098C  410102     ADD W2, W2, W2
00098E  498183     ADDC W3, W3, W3
000990  780003     MOV W3, W0
00099A  420204     ADD W4, W4, W4
00099C  4A8285     ADDC W5, W5, W5
00099E  780105     MOV W5, W2
005918  420204     ADD W4, W4, W4
00591A  4A8285     ADDC W5, W5, W5
00591C  780105     MOV W5, W2
005926  430306     ADD W6, W6, W6
005928  4B8387     ADDC W7, W7, W7
00592A  780207     MOV W7, W4
00595A  420204     ADD W4, W4, W4
00595C  4A8285     ADDC W5, W5, W5
00595E  780105     MOV W5, W2
005A64  440408     ADD W8, W8, W8
005A66  4C8489     ADDC W9, W9, W9
005A70  440408     ADD W8, W8, W8
005A72  4C8489     ADDC W9, W9, W9
005A9E  430306     ADD W6, W6, W6
005AA0  4B8387     ADDC W7, W7, W7
005AA2  780107     MOV W7, W2
005AAA  420204     ADD W4, W4, W4
005AAC  4A8285     ADDC W5, W5, W5
005B64  420204     ADD W4, W4, W4
005B66  4A8285     ADDC W5, W5, W5
005B68  780105     MOV W5, W2
005B72  430306     ADD W6, W6, W6
005B74  4B8387     ADDC W7, W7, W7
005B84  410102     ADD W2, W2, W2
005B86  498183     ADDC W3, W3, W3
005B90  440408     ADD W8, W8, W8
005B92  4C8489     ADDC W9, W9, W9
005B94  780209     MOV W9, W4
005BA2  410102     ADD W2, W2, W2
005BA4  498183     ADDC W3, W3, W3
005BAC  420204     ADD W4, W4, W4
005BAE  4A8285     ADDC W5, W5, W5
005BB8  420204     ADD W4, W4, W4
005BBA  4A8285     ADDC W5, W5, W5
005BBC  780105     MOV W5, W2
005BBE  988F65     MOV W5, [W14+156]
005BC4  440408     ADD W8, W8, W8
005BC6  4C8489     ADDC W9, W9, W9
005BCC  430306     ADD W6, W6, W6
005BCE  4B8387     ADDC W7, W7, W7
005EF2  440408     ADD W8, W8, W8
005EF4  4C8489     ADDC W9, W9, W9
005EF6  982819     MOV W9, [W0+82]
005F00  410302     ADD W2, W2, W6
005F02  498383     ADDC W3, W3, W7
005F04  780107     MOV W7, W2
005F06  982827     MOV W7, [W0+84]
005F1C  420204     ADD W4, W4, W4
005F1E  4A8285     ADDC W5, W5, W5
005F20  980845     MOV W5, [W0+24]
005F34  410202     ADD W2, W2, W4
005F36  498283     ADDC W3, W3, W5
005F38  780205     MOV W5, W4
005F9A  420204     ADD W4, W4, W4
005F9C  4A8285     ADDC W5, W5, W5
005FBA  420204     ADD W4, W4, W4
005FBC  4A8285     ADDC W5, W5, W5
005FBE  983015     MOV W5, [W0+98]
0068A4  420204     ADD W4, W4, W4
0068A6  4A8285     ADDC W5, W5, W5
0068D0  400000     ADD W0, W0, W0
0068D2  488081     ADDC W1, W1, W1
0068E2  420204     ADD W4, W4, W4
0068E4  4A8285     ADDC W5, W5, W5
0068E8  410102     ADD W2, W2, W2
0068EA  498183     ADDC W3, W3, W3
006904  410102     ADD W2, W2, W2
006906  498183     ADDC W3, W3, W3
006A5C  420204     ADD W4, W4, W4
006A5E  4A8285     ADDC W5, W5, W5
006A60  98B405     MOV W5, [W8+224]
006A66  45050A     ADD W10, W10, W10
006A68  4D858B     ADDC W11, W11, W11
006A6A  98B41B     MOV W11, [W8+226]
006A70  410202     ADD W2, W2, W4
006A72  498283     ADDC W3, W3, W5
006A74  98B425     MOV W5, [W8+228]
006ABE  420204     ADD W4, W4, W4
006AC0  4A8285     ADDC W5, W5, W5
006AC2  98AC65     MOV W5, [W8+220]
006AC6  410102     ADD W2, W2, W2
006AC8  498183     ADDC W3, W3, W3
006ACA  98AC73     MOV W3, [W8+222]
00730E  440408     ADD W8, W8, W8
007310  4C8489     ADDC W9, W9, W9
00731C  420204     ADD W4, W4, W4
00731E  4A8285     ADDC W5, W5, W5
007320  780105     MOV W5, W2
00732A  420204     ADD W4, W4, W4
00732C  4A8285     ADDC W5, W5, W5
00732E  780205     MOV W5, W4
007334  430306     ADD W6, W6, W6
007336  4B8387     ADDC W7, W7, W7
00734E  410202     ADD W2, W2, W4
007350  498283     ADDC W3, W3, W5
0094EA  420204     ADD W4, W4, W4
0094EC  4A8285     ADDC W5, W5, W5
0094FA  420204     ADD W4, W4, W4
0094FC  4A8285     ADDC W5, W5, W5
121:                   /* use << 1 >> 16, rather than >> 15, because it helps the XC16 compiler
122:                    * produce more optimal code; right now there are no specializations
123:                    * for >> 15
124:                    */
125:               }
126:               
127:               /**
128:                * Helper function to multiply two quantities and shift right by 14.
129:                * @param a first input
130:                * @param b second input
131:                * @return (a*b)>>14
132:                */
133:               inline static int16_t UTIL_MulQ14(int16_t a, int16_t b)
134:               {
135:                   return (int16_t)(__builtin_mulss(a,b) >> 14);
008D6C  240004     MOV #0x4000, W4
008D6E  237111     MOV #0x3711, W1
008D70  B98A04     MUL.SS W1, W4, W4
008D72  DD28C2     SL W5, #2, W1
008D74  DE214E     LSR W4, #14, W2
008D76  708102     IOR W1, W2, W2
008D78  980072     MOV W2, [W0+14]
136:               }
137:               
138:               /**
139:                * Helper function to multiply two Q15 quantities and return a Q15 result.
140:                * Note that this does NOT correctly handle the overflow situation
141:                * where -1.0*-1.0 -> -1.0, which needs to be special-cased.
142:                * 
143:                * @param a first input in Q15 format
144:                * @param b second input in Q15 format
145:                * @return a*b in Q15 format
146:                */
147:               inline static int16_t UTIL_MulQ15(int16_t a, int16_t b)
148:               {
149:                   return UTIL_Shr15(__builtin_mulss(a,b));
000002  000000     NOP
000010  000B66     NOP
000014  000920     NOP
000022  000BF6     NOP
000032  000920     NOP
000040  000920     NOP
000042  000920     NOP
000050  000920     NOP
00005C  000920     NOP
000068  000920     NOP
00006A  000920     NOP
000072  000920     NOP
00007C  000920     NOP
00008C  000920     NOP
00009A  000920     NOP
00009C  000920     NOP
0000A8  000920     NOP
0000B2  000920     NOP
00098A  B99102     MUL.SS W2, W2, W2
000998  B9A204     MUL.SS W4, W4, W4
005916  B9A204     MUL.SS W4, W4, W4
005924  B9B306     MUL.SS W6, W6, W6
005958  B9A204     MUL.SS W4, W4, W4
005A62  B99C03     MUL.SS W3, W3, W8
005A6E  B99402     MUL.SS W2, W2, W8
005A9C  B9AB05     MUL.SS W5, W5, W6
005AA8  B9A204     MUL.SS W4, W4, W4
005B62  B9A204     MUL.SS W4, W4, W4
005B70  B9B306     MUL.SS W6, W6, W6
005B82  B99102     MUL.SS W2, W2, W2
005B8E  B9C408     MUL.SS W8, W8, W8
005B9E  90912E     MOV [W14+164], W2
005BA0  B99101     MUL.SS W2, W1, W2
005BAA  B9A201     MUL.SS W4, W1, W4
005BB6  B99207     MUL.SS W2, W7, W4
005BC0  908C3E     MOV [W14+150], W8
005BC2  B9C401     MUL.SS W8, W1, W8
005BCA  B9CB06     MUL.SS W9, W6, W6
00689E  902208     MOV [W8+64], W4
0068A2  B9A211     MUL.SS W4, [W1], W4
0068CE  B98000     MUL.SS W0, W0, W0
0068DC  780091     MOV [W1], W1
0068DE  246354     MOV #0x4635, W4
0068E0  B98A04     MUL.SS W1, W4, W4
0068E6  B9A905     MUL.SS W5, W5, W2
0068FE  902118     MOV [W8+66], W2
006902  B99110     MUL.SS W2, [W0], W2
006A56  90A358     MOV [W8+202], W6
006A58  213882     MOV #0x1388, W2
006A5A  B9B202     MUL.SS W6, W2, W4
006A62  90A0E8     MOV [W8+204], W1
006A64  B98D02     MUL.SS W1, W2, W10
006A6C  90A078     MOV [W8+206], W0
006A6E  B98102     MUL.SS W0, W2, W2
006ABA  780210     MOV [W0], W4
006ABC  B9A202     MUL.SS W4, W2, W4
006AC4  B99902     MUL.SS W3, W2, W2
00730C  B9C408     MUL.SS W8, W8, W8
00731A  B9A204     MUL.SS W4, W4, W4
007328  B9B206     MUL.SS W6, W6, W4
007330  900320     MOV [W0+4], W6
007332  B9B305     MUL.SS W6, W5, W6
00734A  900110     MOV [W0+2], W2
00734C  B99104     MUL.SS W2, W4, W2
0094E6  23ED14     MOV #0x3ED1, W4
0094E8  B9A204     MUL.SS W4, W4, W4
0094F6  242834     MOV #0x4283, W4
0094F8  B9A204     MUL.SS W4, W4, W4
150:               }
151:               
152:               /**
153:                * Helper function to multiply two quantities and shift right by 16.
154:                * (It could be two Q16 numbers with a Q16 result, 
155:                * could be a Q16 and a Q15 number with a Q15 result.)
156:                * 
157:                * @param a first input
158:                * @param b second input
159:                * @return (a*b)>>16
160:                */
161:               inline static int16_t UTIL_MulQ16(int16_t a, int16_t b)
162:               {
163:                   return (int16_t)(__builtin_mulss(a,b) >> 16);
164:               }
165:               
166:               /**
167:                * Helper function to multiply two quantities and shift right by 16.
168:                * (It could be two Q16 numbers with a Q16 result, 
169:                * could be a Q16 and a Q15 number with a Q15 result.)
170:                * 
171:                * @param a first input (unsigned)
172:                * @param b second input
173:                * @return (a*b)>>16
174:                */
175:               inline static int16_t UTIL_MulUSQ16(uint16_t a, int16_t b)
176:               {
177:                   return (int16_t)(__builtin_mulus(a,b) >> 16);
178:               }
179:               
180:               /**
181:                * Helper function to multiply two unsigned 16-bit quantities and 
182:                * shift right by 16.
183:                * (It could be two Q16 numbers with a Q16 result, 
184:                * could be a Q16 and a Q15 number with a Q15 result.)
185:                * 
186:                * @param a first input (unsigned 16-bit)
187:                * @param b second input (unsigned 16-bit)
188:                * @return (a*b)>>16 (unsigned 16-bit)
189:                */
190:               inline static uint16_t UTIL_MulUUQ16(uint16_t a, uint16_t b)
191:               {
192:                   return (uint16_t)(__builtin_muluu(a,b) >> 16);
193:               }
194:               
195:               /**
196:                * Helper function to multiply two signed 16-bit quantities
197:                * and return a signed 32-bit result.
198:                * 
199:                * @param a first input (signed)
200:                * @param b second input (signed)
201:                * @return product a*b (signed)
202:                */
203:               inline static int32_t UTIL_mulss(int16_t a, int16_t b)
204:               {
205:                   return __builtin_mulss(a,b);
004C22  B98003     MUL.SS W0, W3, W0
004C40  B98003     MUL.SS W0, W3, W0
004E5C  B98003     MUL.SS W0, W3, W0
004E7A  B98003     MUL.SS W0, W3, W0
005F6E  9000F0     MOV [W0+14], W1
005F70  B98A04     MUL.SS W1, W4, W4
006352  9011A0     MOV [W0+36], W3
006356  B99902     MUL.SS W3, W2, W2
00637A  901340     MOV [W0+40], W6
00637C  B9A306     MUL.SS W4, W6, W6
0063B6  9011A0     MOV [W0+36], W3
0063BA  B99902     MUL.SS W3, W2, W2
0063E4  901340     MOV [W0+40], W6
0063E6  B9A306     MUL.SS W4, W6, W6
006412  901340     MOV [W0+40], W6
006414  B99306     MUL.SS W2, W6, W6
00646E  2201B6     MOV #0x201B, W6
006470  B9AB06     MUL.SS W5, W6, W6
00648A  901340     MOV [W0+40], W6
00648C  B99306     MUL.SS W2, W6, W6
0069A4  B98900     MUL.SS W1, W0, W2
0069AE  B9D500     MUL.SS W10, W0, W10
0069B8  B9B300     MUL.SS W6, W0, W6
007256  919978     MOV [W8+446], W2
007258  9190E8     MOV [W8+428], W1
00725A  B99101     MUL.SS W2, W1, W2
008B6E  930961     MOV [W1+796], W2
008B70  B9A902     MUL.SS W5, W2, W2
008B72  930B71     MOV [W1+798], W6
008B74  B98306     MUL.SS W0, W6, W6
008B82  931111     MOV [W1+802], W2
008B84  B9A902     MUL.SS W5, W2, W2
008B86  931221     MOV [W1+804], W4
008B88  B98204     MUL.SS W0, W4, W4
206:               }
207:               
208:               /**
209:                * Helper function to multiply an unsigned 16-bit quantity
210:                * and a signed 16-bit quantity
211:                * and return a signed 32-bit result.
212:                * 
213:                * @param a first input (unsigned)
214:                * @param b second input (signed)
215:                * @return product a*b (signed)
216:                */
217:               inline static int32_t UTIL_mulus(uint16_t a, int16_t b)
218:               {
219:                   return __builtin_mulus(a,b);
007F5A  B88204     MUL.US W0, W4, W4
220:               }
221:               
222:               /**
223:                * Helper function to multiply an signed 16-bit quantity
224:                * and an unsigned 16-bit quantity
225:                * and return a signed 32-bit result.
226:                * 
227:                * @param a first input (signed)
228:                * @param b second input (unsigned)
229:                * @return product a*b (signed)
230:                */
231:               inline static int32_t UTIL_mulsu(int16_t a, uint16_t b)
232:               {
233:                   return __builtin_mulsu(a,b);
234:               }
235:               
236:               /**
237:                * Helper function to multiply two unsigned 16-bit quantities
238:                * and return an unsigned 32-bit result.
239:                * 
240:                * @param a first input (unsigned)
241:                * @param b second input (unsigned)
242:                * @return product a*b (unsigned)
243:                */
244:               inline static uint32_t UTIL_muluu(uint16_t a, uint16_t b)
245:               {
246:                   return __builtin_muluu(a,b);
247:               }
248:               
249:               /**
250:                * Function to calculate square of signed number.
251:                * Please note that use of this function assumes there will be no overflow.
252:                * The input value -32768 is invalid and will result
253:                * in an overflow, with the output value -32768. All other inputs are valid.
254:                *
255:                * @param x input in Q15 format
256:                * @return x*x in Q15 format
257:                */
258:               inline static int16_t UTIL_SignedSqrNoOverflow(int16_t x) 
259:               {
260:                   return UTIL_MulQ15(x, x);
261:               }
262:               
263:               /**
264:                * Limit an unsigned 16-bit value to a specified minimum
265:                * 
266:                * @param x input value
267:                * @param xmin minimum output value
268:                * @return the input, limited at a minimum to xmin
269:                */
270:               inline static uint16_t UTIL_LimitMinimumU16(uint16_t x, uint16_t xmin)
271:               {
272:                   return (x < xmin) ? xmin : x;
004CEE  90B108     MOV [W8+224], W2
004CF0  200910     MOV #0x91, W0
004CF2  510F80     SUB W2, W0, [W15]
004CF4  310001     BRA C, UTIL_LimitMinimumU16
004CF6  780100     MOV W0, W2
004CF8  90B098     MOV [W8+226], W1
004CFA  200910     MOV #0x91, W0
004CFC  508F80     SUB W1, W0, [W15]
004CFE  310001     BRA C, UTIL_LimitMinimumU16
004D00  780080     MOV W0, W1
004D02  90B028     MOV [W8+228], W0
004D04  200913     MOV #0x91, W3
004D06  500F83     SUB W0, W3, [W15]
004D08  310001     BRA C, HAL_PWM_DutyCycleRegister_Set
004D0A  780003     MOV W3, W0
004D38  90B108     MOV [W8+224], W2
004D3A  200910     MOV #0x91, W0
004D3C  510F80     SUB W2, W0, [W15]
004D3E  310001     BRA C, UTIL_LimitMinimumU16
004D40  780100     MOV W0, W2
004D42  90B098     MOV [W8+226], W1
004D44  200910     MOV #0x91, W0
004D46  508F80     SUB W1, W0, [W15]
004D48  310001     BRA C, UTIL_LimitMinimumU16
004D4A  780080     MOV W0, W1
004D4C  90B028     MOV [W8+228], W0
004D4E  200913     MOV #0x91, W3
004D50  500F83     SUB W0, W3, [W15]
004D52  310001     BRA C, HAL_PWM_DutyCycleRegister_Set
004D54  780003     MOV W3, W0
004EC6  90B108     MOV [W8+224], W2
004EC8  200910     MOV #0x91, W0
004ECA  510F80     SUB W2, W0, [W15]
004ECC  310001     BRA C, UTIL_LimitMinimumU16
004ECE  780100     MOV W0, W2
004ED0  90B098     MOV [W8+226], W1
004ED2  200910     MOV #0x91, W0
004ED4  508F80     SUB W1, W0, [W15]
004ED6  310001     BRA C, UTIL_LimitMinimumU16
004ED8  780080     MOV W0, W1
004EDA  90B028     MOV [W8+228], W0
004EDC  200913     MOV #0x91, W3
004EDE  500F83     SUB W0, W3, [W15]
004EE0  310001     BRA C, HAL_PWM_DutyCycleRegister_Set
004EE2  780003     MOV W3, W0
273:               }
274:               
275:               /**
276:                * Limit a signed 16-bit value to a specified minimum
277:                * 
278:                * @param x input value
279:                * @param xmin minimum output value
280:                * @return the input, limited at a minimum to xmin
281:                */
282:               inline static int16_t UTIL_LimitMinimumS16(int16_t x, int16_t xmin)
283:               {
284:                   return (x < xmin) ? xmin : x;
000A70  500F82     SUB W0, W2, [W15]
000A72  3D0001     BRA GE, .LBE414, .L13
000A74  780002     MOV W2, W0
285:               }
286:               
287:               /**
288:                * Limit an unsigned 16-bit value to a specified maximum
289:                * 
290:                * @param x input value
291:                * @param xmax maximum output value
292:                * @return the input, limited at a maximum to xmax
293:                */
294:               inline static uint16_t UTIL_LimitMaximumU16(uint16_t x, uint16_t xmax)
295:               {
296:                   return (x > xmax) ? xmax : x;
297:               }
298:               
299:               /**
300:                * Limit a signed 16-bit value to a specified maximum
301:                * 
302:                * @param x input value
303:                * @param xmax maximum output value
304:                * @return the input, limited at a maximum to xmax
305:                */
306:               inline static int16_t UTIL_LimitMaximumS16(int16_t x, int16_t xmax)
307:               {
308:                   return (x > xmax) ? xmax : x;
309:               }
310:               
311:               /** * Limits the input between a minimum and a maximum */
312:               inline static int16_t UTIL_LimitS16(int16_t x, int16_t min, int16_t max)
313:               {
314:                   return (x > max ) ? max : ((x < min) ? min : x);
005D12  528F83     SUB W5, W3, [W15]
005D14  3C0005     BRA GT, .L31
005D16  780307     MOV W7, W6
005D18  538F85     SUB W7, W5, [W15]
005D1A  3D0003     BRA GE, UTIL_LimitS16
005D1C  780305     MOV W5, W6
005D1E  370001     BRA UTIL_LimitS16
005D20  780303     MOV W3, W6
005D22  520F83     SUB W4, W3, [W15]
005D24  3C0004     BRA GT, .LBE91, .L5
005D26  780187     MOV W7, W3
005D28  518F84     SUB W3, W4, [W15]
005D2A  3D0001     BRA GE, .LBE91, .L5
005D2C  780184     MOV W4, W3
005D86  528F83     SUB W5, W3, [W15]
005D88  3C0005     BRA GT, .L32
005D8A  780307     MOV W7, W6
005D8C  538F85     SUB W7, W5, [W15]
005D8E  3D0003     BRA GE, UTIL_LimitS16
005D90  780305     MOV W5, W6
005D92  370001     BRA UTIL_LimitS16
005D94  780303     MOV W3, W6
005D96  520F83     SUB W4, W3, [W15]
005D98  3C0004     BRA GT, .LBE104, .L12
005D9A  780187     MOV W7, W3
005D9C  518F84     SUB W3, W4, [W15]
005D9E  3D0001     BRA GE, .LBE104, .L12
005DA0  780184     MOV W4, W3
008114  540F87     SUB W8, W7, [W15]
008116  3C0004     BRA GT, .LBE279, .L26
008118  780388     MOV W8, W7
00811A  540F89     SUB W8, W9, [W15]
00811C  3D0001     BRA GE, .LBE279, .L26
00811E  780389     MOV W9, W7
315:               }
316:               
317:               /**
318:                * Saturates a signed 32-bit value to a 16-bit positive/negative bound.
319:                * 
320:                * @param x signed 32-bit input to saturate
321:                * @param xlim saturation limit
322:                * @return input x saturated to xlim
323:                */
324:               inline static int16_t UTIL_LimitS32ToS16(int32_t x, int16_t xlim)
325:               {
326:                   if (x >= xlim)
327:                   {
328:                       return xlim;
329:                   }
330:                   if (x <= -xlim)
331:                   {
332:                       return -xlim;
333:                   }
334:                   return (int16_t)x;
335:               }
336:               
337:               /**
338:                * Clears bits in uint16_t that are defined by mask
339:                * 
340:                * @param oldFlags input bits
341:                * @param mask bits to clear
342:                * @return input with mask cleared
343:                */
344:               inline static uint16_t UTIL_ClearBits(uint16_t oldFlags, uint16_t mask)
345:               {
346:                 return oldFlags & ~mask;
000A16  EA8111     COM [W1], W2
005992  90914E     MOV [W14+168], W2
005994  A10002     BCLR W2, #0
005A0E  90914E     MOV [W14+168], W2
005A10  A13002     BCLR W2, #3
005B4E  9090CE     MOV [W14+168], W1
005B50  A12001     BCLR W1, #2
005C44  9090CE     MOV [W14+168], W1
005C46  A14001     BCLR W1, #4
005CD0  9090CE     MOV [W14+168], W1
005CD2  A11001     BCLR W1, #1
0072E8  9001E0     MOV [W0+12], W3
0072EA  A11003     BCLR W3, #1
007304  9000E0     MOV [W0+12], W1
007306  A10001     BCLR W1, #0
007344  900130     MOV [W0+6], W2
007346  A11002     BCLR W2, #1
00735E  9000B0     MOV [W0+6], W1
007360  A10001     BCLR W1, #0
347:               }
348:               
349:               /**
350:                * Sets bits in uint16_t that are defined by mask
351:                * 
352:                * @param oldFlags input bits
353:                * @param mask bits to set
354:                * @return input with mask set
355:                */
356:               inline static uint16_t UTIL_SetBits(uint16_t oldFlags, uint16_t mask)
357:               {
358:                 return oldFlags | mask;
005984  90914E     MOV [W14+168], W2
005986  A00002     BSET W2, #0
0059D4  90914E     MOV [W14+168], W2
0059D6  A03002     BSET W2, #3
005B14  9090CE     MOV [W14+168], W1
005B16  A02001     BSET W1, #2
005C06  9090CE     MOV [W14+168], W1
005C08  A04001     BSET W1, #4
005CC2  9090CE     MOV [W14+168], W1
005CC4  A01001     BSET W1, #1
0072E0  9001E0     MOV [W0+12], W3
0072E2  A01003     BSET W3, #1
0072FC  9000E0     MOV [W0+12], W1
0072FE  A00001     BSET W1, #0
00733C  900130     MOV [W0+6], W2
00733E  A01002     BSET W2, #1
007356  9000B0     MOV [W0+6], W1
007358  A00001     BSET W1, #0
007FC6  710081     IOR W2, W1, W1
0092C8  A01002     BSET W2, #1
0092D0  AFC32F     BTSC 0x32F, #6
0092D2  A02002     BSET W2, #2
359:               }
360:               
361:               /**
362:                * Copies bits in uint16_t that are defined by mask:
363:                * clears if "on" is false, sets if "on" is true
364:                * 
365:                * @param oldFlags input bits
366:                * @param mask bits to set or clear
367:                * @param on true if setting, false if clearing
368:                * @return input with mask set or clear
369:                */
370:               inline static uint16_t UTIL_CopyBits(uint16_t oldFlags, uint16_t mask, bool on)    
371:               {
372:                   return (on) ? UTIL_SetBits(oldFlags, mask)
373:                               : UTIL_ClearBits(oldFlags, mask);
374:               }
375:               
376:               /* Unions for aliasing 32-bit and pairs of 16-bit variables */
377:               
378:               /** Unsigned 16/32 bit alias union */
379:               typedef union tagUX1632_t
380:               {
381:                   struct
382:                   {
383:                       uint16_t lo;    /** lower 16 bits */
384:                       uint16_t hi;    /** upper 16 bits */
385:                   } x16;              /** access as 16-bit values */
386:                   uint32_t x32;       /** access as 32-bit values */
387:               } ux1632_t;
388:               
389:               /** Signed 16/32 bit alias union */
390:               typedef union tagSX1632_t
391:               {
392:                   struct
393:                   {
394:                       uint16_t lo;    /** lower 16 bits */
395:                       int16_t  hi;    /** upper 16 bits */ 
396:                   } x16;              /** access as 16-bit values */
397:                   int32_t x32;        /** access as 32-bit values */ 
398:               } sx1632_t;
399:               
400:               typedef struct
401:               {
402:                   int16_t min;
403:                   int16_t max;
404:               } minmax16_t;
405:               
406:               typedef struct
407:               {
408:                   int16_t min;
409:                   int16_t med;
410:                   int16_t max;
411:               } minmedmax16_t;
412:               
413:               /* generalized fixed-point converter macro */
414:               #define FIXEDPT(x, q, result_t) \
415:                   ((result_t)(x * (1L << q) + 0.5))
416:               
417:               #define Q15(x) FIXEDPT(x, 15, int16_t)
418:               #define Q14(x) FIXEDPT(x, 14, int16_t)
419:               #define Q13(x) FIXEDPT(x, 13, int16_t)
420:               #define Q12(x) FIXEDPT(x, 12, int16_t)
421:               #define Q11(x) FIXEDPT(x, 11, int16_t)
422:                   
423:               #define Q17(x) FIXEDPT(x, 17, int32_t)
424:               #define Q16(x) FIXEDPT(x, 16, int32_t)
425:               
426:               /**
427:                * Construct an unsigned 32-bit integer from two 16-bit integers.
428:                * @param xlo low word (unsigned 16-bit)
429:                * @param xhi high word (unsigned 16-bit)
430:                * @return xhi << 16 | xlo
431:                */
432:               inline static uint32_t UTIL_PairU16(uint16_t xlo, uint16_t xhi)
433:               {
434:                   ux1632_t result;
435:                   result.x16.lo = xlo;
436:                   result.x16.hi = xhi;
437:                   return result.x32;
438:               }
439:               
440:               /**
441:                * Construct a signed 32-bit integer from two 16-bit integers.
442:                * @param xlo low word (unsigned 16-bit)
443:                * @param xhi high word (signed 16-bit)
444:                * @return xhi << 16 | xlo
445:                */
446:               inline static int32_t UTIL_PairS16(uint16_t xlo, int16_t xhi)
447:               {
448:                   sx1632_t result;
449:                   result.x16.lo = xlo;
450:                   result.x16.hi = xhi;
451:                   return result.x32;
452:               }
453:               
454:               /**
455:                * Right shift an unsigned 32-bit value by some runtime value N with N <= 16,
456:                * returning an unsigned 32-bit result. 
457:                * 
458:                * @param x input
459:                * @param N number of right shifts (N <= 16)
460:                * @return x >> N
461:                */
462:               inline static uint32_t UTIL_ShrU32N16(uint32_t x, uint16_t N)
463:               {
464:                   const uint16_t Ncomp = 16 - N;
465:                   uint16_t xlo = x;
466:                   uint16_t xhi = x >> 16;
467:                   
468:                   xlo >>= N;
469:                   xlo |= xhi << Ncomp;
470:                   xhi >>= N;
471:                   
472:                   return UTIL_PairU16(xlo, xhi);
473:               }
474:               
475:               /**
476:                * Right shift an unsigned 32-bit value by some runtime value N, returning an
477:                * unsigned 32-bit result.
478:                * 
479:                * @param x input
480:                * @param N number of right shifts
481:                * @return x >> N
482:                */
483:               inline static uint32_t UTIL_ShrU32N(uint32_t x, uint16_t N)
484:               {
485:                   const uint16_t Ncomp = 16 - N;
486:                   uint16_t xlo = x;
487:                   uint16_t xhi = x >> 16;
488:                   
489:                   if ((int16_t)Ncomp < 0)
490:                   {
491:                       xlo = xhi >> (-Ncomp);
492:                       xhi = 0;
493:                   }
494:                   else
495:                   {
496:                       xlo >>= N;
497:                       xlo |= xhi << Ncomp;
498:                       xhi >>= N;
499:                   }
500:                   
501:                   return UTIL_PairU16(xlo, xhi);
502:               }
503:               
504:               /**
505:                * Right shift a signed 32-bit value by some runtime value N with N <= 16,
506:                * returning a signed 32-bit result.
507:                * 
508:                * @param x input
509:                * @param N number of right shifts (0 <= N <= 16)
510:                * @return x >> N
511:                */
512:               inline static int32_t UTIL_ShrS32N16(int32_t x, uint16_t N)
513:               {
514:                   const uint16_t Ncomp = 16 - N;
515:                   uint16_t xlo = x;
516:                   int16_t xhi = x >> 16;
517:                   
518:                   xlo >>= N;
519:                   xlo |= xhi << Ncomp;
520:                   xhi >>= N;
521:                   
522:                   return UTIL_PairS16(xlo, xhi);
523:               }
524:               
525:               /**
526:                * Right shift a signed 32-bit value by some runtime value N, returning a
527:                * signed 32-bit result.
528:                * 
529:                * @param x input
530:                * @param N number of right shifts (N >= 0)
531:                * @return x >> N
532:                */
533:               inline static int32_t UTIL_ShrS32N(int32_t x, uint16_t N)
534:               {
535:                   const uint16_t Ncomp = 16 - N;
536:                   uint16_t xlo = x;
537:                   int16_t xhi = x >> 16;
538:                   
539:                   if ((int16_t)Ncomp < 0)
540:                   {
541:                       xlo = xhi >> (-Ncomp);
542:                       xhi >>= 15;
543:                   }
544:                   else
545:                   {
546:                       xlo >>= N;
547:                       xlo |= xhi << Ncomp;
548:                       xhi >>= N;
549:                   }
550:                   
551:                   return UTIL_PairS16(xlo, xhi);
552:               }
553:               
554:               /**
555:                * Returns a directed version of (a <= b). If dir is negative, we reverse the
556:                * sign and compute a >= b instead.
557:                * 
558:                * @param a first operand
559:                * @param b second operand
560:                * @param dir direction
561:                * @return a <= b if dir is nonnegative else a >= b
562:                */
563:               inline static bool UTIL_DirectedLessThanEqual(int16_t a, int16_t b, int16_t dir)
564:               {
565:                   return (dir >= 0)
566:                        ? (a <= b)
567:                        : (a >= b);
008126  E00005     CP0 W5
008128  350005     BRA LT, .L29
00812A  B3C013     MOV.B #0x1, W3
00812C  500F81     SUB W0, W1, [W15]
00812E  340006     BRA LE, .LBE281, .L31
008130  EB4180     CLR.B W3
008132  370004     BRA .LBE281, .L31
008134  B3C013     MOV.B #0x1, W3
008136  500F81     SUB W0, W1, [W15]
008138  3D0001     BRA GE, .LBE281, .L31
00813A  EB4180     CLR.B W3
568:               }
569:               
570:               /**
571:                * Computes the absolute value of an int16_t number.
572:                * An input of -32768 will produce an output of +32767;
573:                * clipping is preferable to overflow. (The dsPIC libq implementation
574:                * of _Q15abs() uses these same instructions.)
575:                * 
576:                * @param x input value
577:                * @return the absolute value of x
578:                */
579:               inline static int16_t UTIL_Abs16(int16_t x)
580:               {
581:                   asm volatile (
000000  040200     GOTO __resetPRI, __reset
000A66  780001     MOV W1, W0
000A68  A7F000     BTSC W0, #15
000A6A  EA0000     NEG W0, W0
000A6C  A7F000     BTSC W0, #15
000A6E  EA8000     COM W0, W0
005ADC  90B0F1     MOV [W1+238], W1
005ADE  A7F001     BTSC W1, #15
005AE0  EA0081     NEG W1, W1
005AE2  A7F001     BTSC W1, #15
005AE4  EA8081     COM W1, W1
005CE4  903190     MOV [W0+98], W3
005CE6  A7F003     BTSC W3, #15
005CE8  EA0183     NEG W3, W3
005CEA  A7F003     BTSC W3, #15
005CEC  EA8183     COM W3, W3
005F3E  780082     MOV W2, W1
005F40  A7F001     BTSC W1, #15
005F42  EA0081     NEG W1, W1
005F44  A7F001     BTSC W1, #15
005F46  EA8081     COM W1, W1
00633E  900980     MOV [W0+16], W3
006340  A7F003     BTSC W3, #15
006342  EA0183     NEG W3, W3
006344  A7F003     BTSC W3, #15
006346  EA8183     COM W3, W3
0063A2  900980     MOV [W0+16], W3
0063A4  A7F003     BTSC W3, #15
0063A6  EA0183     NEG W3, W3
0063A8  A7F003     BTSC W3, #15
0063AA  EA8183     COM W3, W3
0064D8  780104     MOV W4, W2
0064DA  A7F002     BTSC W2, #15
0064DC  EA0102     NEG W2, W2
0064DE  A7F002     BTSC W2, #15
0064E0  EA8102     COM W2, W2
0072D0  780201     MOV W1, W4
0072D2  A7F004     BTSC W4, #15
0072D4  EA0204     NEG W4, W4
0072D6  A7F004     BTSC W4, #15
0072D8  EA8204     COM W4, W4
0072EE  A7F001     BTSC W1, #15
0072F0  EA0081     NEG W1, W1
0072F2  A7F001     BTSC W1, #15
0072F4  EA8081     COM W1, W1
582:                       "   ;UTIL_Abs16\n"
583:                       "   btsc %[x], #15\n"
584:                       "   neg  %[x], %[x]\n"
585:                       "   btsc %[x], #15\n"
586:                       "   com  %[x], %[x]\n"
587:                       : [x]"+r"(x)
588:                   );
589:                   return x;
590:               }
591:               
592:               /**
593:                * Computes the sign of a nonzero value:
594:                * negative numbers return -1, zero and positive numbers return +1
595:                */
596:               inline static int16_t UTIL_SignFromHighBit(int16_t x)
597:               {
598:                   return (x >> 15) | 1;
004F10  DE804F     ASR W0, #15, W0
004F12  A00000     BSET W0, #0
006CD0  913828     MOV [W8+372], W0
006CD2  DE804F     ASR W0, #15, W0
006CD4  A00000     BSET W0, #0
00723E  913928     MOV [W8+372], W2
007240  DE914F     ASR W2, #15, W2
007242  A00002     BSET W2, #0
599:               }
600:               
601:               /**
602:                * Computes the saturated signed addition x+y limited to the -32768,
603:                * +32767 range.
604:                * 
605:                * @param x input value
606:                * @param y input value
607:                * @return the saturated signed addition x+y
608:                */
609:               inline static int16_t UTIL_SatAddS16(int16_t x, int16_t y)
610:               {
611:                   /* Saturation can only occur if x and y have the same sign.
612:                    * If x is nonnegative and y is nonnegative and we get overflow,
613:                    *    x+y is positive and should be limited to 32767.
614:                    * If x is negative and y is negative and we get overflow,
615:                    *    x+y is negative and should be limited to -32768.
616:                    * In either case, if overflow occurs, 
617:                    *    we can use either x or y's most significant bit to decide the result
618:                    */
619:                   int16_t saturated_sum;
620:                   asm volatile (
621:                       "   ;UTIL_SatAddS16\n"
622:                       "   asr %[y], #15, %[s]\n"  // s = 0xFFFF if y is negative, 0 otherwise
623:                       "   btg %[s], #15\n"        // s = 0x7FFF if y is negative, 0x8000 otherwise
624:                       "   add %[x], %[y], %[x]\n" // x = x+y
625:                       "   btsc SR, #2\n"          // overflow in OV = SR<2>
626:                       "   com %[s], %[x]\n"       // x = ~s if overflow bit was set, skip otherwise
627:                       : [x]"+r"(x),
628:                         [s]"=&r"(saturated_sum)
629:                       : [y]"r"(y)
630:                   );
631:                   return x;
632:               }
633:               
634:               /**
635:                * Computes the saturated signed difference x-y, which is equal to
636:                * (x-y) limited to the -32768, +32767 range.
637:                * 
638:                * @param x input value
639:                * @param y input value
640:                * @return the saturated signed difference x-y
641:                */
642:               inline static int16_t UTIL_SatSubS16(int16_t x, int16_t y)
643:               {
644:                   /* Saturation can only occur if x and y have opposite signs.
645:                    *   (we can lump zero with positive values for arithmetic efficiency
646:                    *    so we can just look at the high bit)
647:                    * If x is nonnegative and y is negative and we get overflow,
648:                    *    x-y is positive and should be limited to 32767
649:                    * If x is negative and y is nonnegative and we get overflow
650:                    *    x-y is negative and should be limited to -32768
651:                    * In either case, if overflow occurs, 
652:                    *    we can use either x or y's most significant bit to decide the result
653:                    */
654:                   int16_t saturated_difference;
655:                   asm volatile (
00001E  000920     NOP
000044  000C16     NOP
005A2E  780185     MOV W5, W3
005A30  DEB14F     ASR W6, #15, W2
005A32  A2F002     BTG W2, #15
005A34  518186     SUB W3, W6, W3
005A36  AF4042     BTSC SR, #2
005A38  780182     MOV W2, W3
005A54  780104     MOV W4, W2
005A56  DECC4F     ASR W9, #15, W8
005A58  A2F008     BTG W8, #15
005A5A  510109     SUB W2, W9, W2
005A5C  AF4042     BTSC SR, #2
005A5E  780108     MOV W8, W2
656:                       "   ;UTIL_SatSubS16\n"
657:                       "   asr %[y], #15, %[s]\n"  // s = 0xFFFF if y is negative, 0 otherwise
658:                       "   btg %[s], #15\n"        // s = 0x7FFF if y is negative, 0x8000 otherwise
659:                       "   sub %[x], %[y], %[x]\n" // x = x-y
660:                       "   btsc SR, #2\n"          // overflow in OV = SR<2>
661:                       "   mov %[s], %[x]\n"       // x = s if overflow was set
662:                       : [x]"+r"(x),
663:                         [s]"=&r"(saturated_difference)
664:                       : [y]"r"(y)
665:                   );
666:                   return x;
667:               }
668:               
669:               /**
670:                * Computes the approximate absolute value of an int16_t number.
671:                * Nonnegative inputs produce an exact output;
672:                * negative inputs produce an output that is off by 1
673:                * (e.g. abs16approx(-37) = 36, abs16approx(-32768) = 32767)
674:                * in order to decrease execution time while preventing overflow.
675:                * 
676:                * This function should *not* be used by algorithms which are sensitive
677:                * to off-by-1 errors: integrators being the main example.
678:                * 
679:                * @param x input
680:                * @return the approximate absolute value of x, equal to (x < 0 ? ~x : x)
681:                */
682:               inline static int16_t UTIL_Abs16Approx(int16_t x)
683:               {
684:                   asm volatile (
000006  000B2E     NOP
00000A  000BD2     NOP
000018  000920     NOP
00001A  000920     NOP
00002A  000C36     NOP
000038  000920     NOP
000048  000920     NOP
000056  000920     NOP
000062  000920     NOP
000094  000920     NOP
0000A0  000920     NOP
000992  A7F000     BTSC W0, #15
000994  EA8000     COM W0, W0
0009A0  A7F002     BTSC W2, #15
0009A2  EA8102     COM W2, W2
00591E  A7F002     BTSC W2, #15
005920  EA8102     COM W2, W2
00592C  A7F004     BTSC W4, #15
00592E  EA8204     COM W4, W4
005960  A7F002     BTSC W2, #15
005962  EA8102     COM W2, W2
005A68  780189     MOV W9, W3
005A6A  A7F003     BTSC W3, #15
005A6C  EA8183     COM W3, W3
005A74  780109     MOV W9, W2
005A76  A7F002     BTSC W2, #15
005A78  EA8102     COM W2, W2
005AA4  A7F002     BTSC W2, #15
005AA6  EA8102     COM W2, W2
005AAE  780185     MOV W5, W3
005AB0  A7F003     BTSC W3, #15
005AB2  EA8183     COM W3, W3
005B54  9000EE     MOV [W14+12], W1
005B56  A7F001     BTSC W1, #15
005B58  EA8081     COM W1, W1
005B6A  A7F002     BTSC W2, #15
005B6C  EA8102     COM W2, W2
005B76  780187     MOV W7, W3
005B78  A7F003     BTSC W3, #15
005B7A  EA8183     COM W3, W3
005B88  A7F003     BTSC W3, #15
005B8A  EA8183     COM W3, W3
005B96  A7F004     BTSC W4, #15
005B98  EA8204     COM W4, W4
00636A  780184     MOV W4, W3
00636C  A7F003     BTSC W3, #15
00636E  EA8183     COM W3, W3
0063D4  780184     MOV W4, W3
0063D6  A7F003     BTSC W3, #15
0063D8  EA8183     COM W3, W3
0064AE  A7F003     BTSC W3, #15
0064B0  EA8183     COM W3, W3
0064C0  9019B0     MOV [W0+54], W3
0064C2  A7F003     BTSC W3, #15
0064C4  EA8183     COM W3, W3
0068D4  780001     MOV W1, W0
0068D6  A7F000     BTSC W0, #15
0068D8  EA8000     COM W0, W0
0068EC  780083     MOV W3, W1
0068EE  A7F001     BTSC W1, #15
0068F0  EA8081     COM W1, W1
007312  780089     MOV W9, W1
007314  A7F001     BTSC W1, #15
007316  EA8081     COM W1, W1
007322  A7F002     BTSC W2, #15
007324  EA8102     COM W2, W2
0094EE  780085     MOV W5, W1
0094F0  A7F001     BTSC W1, #15
0094F2  EA8081     COM W1, W1
0094FE  780085     MOV W5, W1
009500  A7F001     BTSC W1, #15
009502  EA8081     COM W1, W1
685:                       "   ;UTIL_Abs16Approx\n"
686:                       "   btsc %[x], #15\n"
687:                       "   com  %[x], %[x]\n"
688:                       : [x]"+r"(x)
689:                   );
690:                   return x;
691:               }
692:               
693:               /**
694:                * Function to calculate the square of signed Q15 values.
695:                * We use UTIL_Abs16Approx() to fixup the -32768 value efficiently
696:                * without branching: this is a 2-instruction hit that yields +32767.
697:                *
698:                * @param input in Q15 format
699:                * @return square of the input, in Q15 format
700:                */
701:               inline static int16_t UTIL_SignedSqr(int16_t x)
702:               {
703:                   return UTIL_Abs16Approx(UTIL_SignedSqrNoOverflow(x));
704:               }
705:               
706:               /**
707:                * Computes the Q15 quotient of num/den.
708:                * Does NOT check for overflow or divide-by-zero. 
709:                *
710:                * More specifically, it returns the integer calculation (32768 * num)/den,
711:                * if that is representable as an int16_t. 
712:                *
713:                * This is used mainly with num and den that have the same binary point,
714:                * in which case the result is a Q15 value.
715:                *
716:                * UTIL_DivQ15 can also act on inputs with unequal binary points:
717:                * if num and den are fixed-point values with Qn and Qd binary points,
718:                * then the result is a fixed-point value with binary point of Q(n-d+15).
719:                *
720:                * @param num dividend with Qn binary point
721:                * @param den divisor with Qd binary point
722:                * @return quotient = num/den with Q(n-d+15) binary point
723:                */
724:               inline static int16_t UTIL_DivQ15(int16_t num, int16_t den)
725:               {
726:                   return __builtin_divf(num, den);
727:               }
728:               
729:               /**
730:                * Computes the Q15 quotient of num/den, 
731:                * saturating the result to +32767 on overflow.
732:                * (NOTE: This assumes num/den is a positive value if it can overflow.
733:                * Negative quotients that overflow are NOT handled properly by this function.)
734:                * 
735:                * Behavior is identical to UTIL_DivQ15(),
736:                * except that on overflow (if the results are not representable in a signed
737:                * 16-bit integer) the result is overwritten with 32767, providing a saturated
738:                * positive value for positive overflow.
739:                * 
740:                * See UTIL_DivQ15 for guidance on using arbitrary binary points;
741:                * the same guidance applies to this function.
742:                * 
743:                * @param num dividend with Qn binary point
744:                * @param den divisor with Qd binary point
745:                * @return quotient = num/den with Q(n-d+15) binary point
746:                */
747:               inline static int16_t UTIL_DivQ15SatPos(int16_t num, int16_t den)
748:               {
749:                   int16_t quotient;
750:                   
751:                   asm (
006CC4  208000     MOV #0x800, W0
006CC6  090005     REPEAT #0x5
006CC8  D90002     DIVF W0, W2
006CCA  AF4042     BTSC SR, #2
006CCC  27FFF0     MOV #0x7FFF, W0
752:                       "    ;UTIL_DivQ15SatPos\n"
753:                       "    repeat  #__TARGET_DIVIDE_CYCLES\n"
754:                       "    divf    %[num],%[den]\n"
755:                       "    btsc    SR,#2\n"            // OV = bit 2
756:                       "    mov     #0x7fff, %[quotient]"
757:                       : [quotient]"=a"(quotient)
758:                       : [num]"r"(num), [den]"e"(den)   // den restricted to R2-R14 for DIVF
759:                   );
760:                   return quotient;
761:               }
762:               
763:               /* ----------------------------------------------------------------------------
764:                * The following functions are comparable to or slightly faster than
765:                * computing (abs16(x) < limit)
766:                * ----------------------------------------------------------------------------
767:                */
768:               
769:               /**
770:                * Returns whether a and b are both negative or both nonnegative
771:                * 
772:                * @param a
773:                * @param b
774:                * @return true if a and b are both negative, or both nonnegative.
775:                */
776:               inline static bool UTIL_BothNegativeOrNonnegative(int16_t a, int16_t b)
777:               {
778:                   return (a^b) >= 0;
000A52  688000     XOR W1, W0, W0
779:               }
780:               
781:               /**
782:                * Computes whether abs(x) < limit
783:                * @param x input
784:                * @param limit limit (must be nonnegative)
785:                * @return whether abs(x) < limit
786:                */
787:               inline static bool UTIL_AbsLessThan(int16_t x, int16_t limit)
788:               {
789:                   return (x > -limit) && (x < limit);
790:               }
791:               
792:               /**
793:                * Computes whether abs(x) <= limit
794:                * @param x input
795:                * @param limit limit (must be nonnegative)
796:                * @return whether abs(x) <= limit
797:                */
798:               inline static bool UTIL_AbsLessThanEqual(int16_t x, int16_t limit)
799:               {
800:                   return (x >= -limit) && (x <= limit);
801:               }
802:               
803:               /**
804:                * Computes whether abs(x) > limit
805:                * @param x input
806:                * @param limit limit (must be nonnegative)
807:                * @return whether abs(x) > limit
808:                */
809:               inline static bool UTIL_AbsGreaterThan(int16_t x, int16_t limit)
810:               {
811:                   return (x < -limit) || (x > limit);
812:               }
813:               
814:               /**
815:                * Computes whether abs(x) >= limit
816:                * @param x input
817:                * @param limit limit (must be nonnegative)
818:                * @return whether abs(x) >= limit
819:                */
820:               inline static bool UTIL_AbsGreaterThanEqual(int16_t x, int16_t limit)
821:               {
822:                   return (x <= -limit) || (x >= limit);
823:               }
824:               
825:               /**
826:                * Repeat NOP (n+1) times
827:                * @param n argument to the REPEAT instruction
828:                */
829:               inline static void UTIL_RepeatNop(uint16_t n)
830:               {
831:                   asm volatile (
008DC4  200310     MOV #0x31, W0
008DC6  098000     REPEAT W0
008DC8  000000     NOP
832:                       " ;UTIL_RepeatNop\n"
833:                       "   repeat %[n]\n"
834:                       "   nop"
835:                       :: [n]"r"(n) : "memory"
836:                   );
837:               }
838:               
839:               /**
840:                * Toggles the sign bit (bit 15)
841:                * @param x
842:                * @return x ^ 0x8000
843:                */
844:               inline static uint16_t UTIL_ToggleBit15(uint16_t x)
845:               {
846:                   asm (
847:                       "    ;UTIL_ToggleBit15\n"
848:                       "    btg %[x], #15\n"
849:                       : [x]"+r"(x)
850:                   );
851:                   return x;    
852:               }
853:               
854:               /**
855:                * Computes saturated shift-right with an U16 result.
856:                * If (x >> q) lies within the range of uint16_t values, return it,
857:                * otherwise return 0xFFFF.
858:                * 
859:                * @param x input to shift right
860:                * @param q number of bits to shift right
861:                * @return saturated right-shifted result
862:                */
863:               inline static uint16_t UTIL_SatShrU16(uint32_t x, uint16_t q)
864:               {
865:                   uint16_t hi_word = x >> 16;
866:                   if ((q < 16) && (hi_word >= (uint16_t)(1 << q)))
867:                   {
868:                       return 0xFFFF;
869:                   }
870:                   else
871:                   {
872:                       return x >> q;
873:                   }
874:               }
875:               
876:               /**
877:                * Computes saturated shift-right with an S16 result.
878:                * If (x >> q) lies within the range of int16_t values, return it,
879:                * otherwise return the appropriately saturated result (0x8000 if x is negative,
880:                * else 0x7fff).
881:                */
882:               inline static int16_t UTIL_SatShrS16(int32_t x, uint16_t q)
883:               {
884:                   const int32_t y = x >> q;    
005D32  DD3C44     SL W7, #4, W8
005D34  DE324C     LSR W6, #12, W4
005D36  740204     IOR W8, W4, W4
005D38  DEBACC     ASR W7, #12, W5
005D50  DD39C4     SL W7, #4, W3
005D52  DE324C     LSR W6, #12, W4
005D54  718204     IOR W3, W4, W4
005D56  DEBACC     ASR W7, #12, W5
005DA6  DD3C47     SL W7, #7, W8
005DA8  DE3249     LSR W6, #9, W4
005DAA  740204     IOR W8, W4, W4
005DAC  DEBAC9     ASR W7, #9, W5
005DC4  DD39C7     SL W7, #7, W3
005DC6  DE3249     LSR W6, #9, W4
005DC8  718204     IOR W3, W4, W4
005DCA  DEBAC9     ASR W7, #9, W5
005DFA  DD3C43     SL W7, #3, W8
005DFC  DE324D     LSR W6, #13, W4
005DFE  740204     IOR W8, W4, W4
005E00  DEBACD     ASR W7, #13, W5
005E32  DD3A43     SL W7, #3, W4
005E34  DE314D     LSR W6, #13, W2
005E36  720102     IOR W4, W2, W2
005E38  DEB9CD     ASR W7, #13, W3
005F72  DD2C45     SL W5, #5, W8
005F74  DE214B     LSR W4, #11, W2
005F76  740102     IOR W8, W2, W2
005F78  DEA9CB     ASR W5, #11, W3
885:                   const int16_t ylo = y;
005D3A  780504     MOV W4, W10
005D58  780184     MOV W4, W3
005DAE  780504     MOV W4, W10
005DCC  780184     MOV W4, W3
005E02  780184     MOV W4, W3
005E3A  780202     MOV W2, W4
005F7A  780082     MOV W2, W1
886:                   if (q < 16)       // the only chance of overflow is for shift counts < 16
887:                   {        
888:                       const int16_t yhi = y >> 16;
889:                       /* unused bits that will be thrown away
890:                        * These must match the sign of y: either all zero or all one
891:                        */
892:                       const int16_t sign_ylo = ylo >> 15; // -1 if ylo is negative, otherwise 0
005D3C  DED24F     ASR W10, #15, W4
005D5A  DE9A4F     ASR W3, #15, W4
005DB0  DED24F     ASR W10, #15, W4
005DCE  DE9A4F     ASR W3, #15, W4
005E04  DE9A4F     ASR W3, #15, W4
005E3C  DEA14F     ASR W4, #15, W2
005F7C  DE894F     ASR W1, #15, W2
893:                       if (yhi != sign_ylo)
005D3E  520F85     SUB W4, W5, [W15]
005D40  320004     BRA Z, .LBE93, .LBE94, .LBE95, .LBE96, .L7
005D5C  520F85     SUB W4, W5, [W15]
005D5E  320004     BRA Z, .LBE97, .LBE98, .LBE99, .LBE100, .L8
005DB2  520F85     SUB W4, W5, [W15]
005DB4  320004     BRA Z, .LBE106, .LBE107, .LBE108, .LBE109, .L14
005DD0  520F85     SUB W4, W5, [W15]
005DD2  320004     BRA Z, .LBE110, .LBE111, .LBE112, .LBE113, .L15
005E06  520F85     SUB W4, W5, [W15]
005E08  320004     BRA Z, .LBE114, .LBE115, .LBE116, .LBE117, .L16
005E3E  510F83     SUB W2, W3, [W15]
005E40  320004     BRA Z, .LBE118, .LBE119, .LBE120, .LBE121, .L17
005F7E  510F83     SUB W2, W3, [W15]
005F80  320004     BRA Z, .LBE132, .LBE133, .LBE142, .LBE143, .LBE144, .LBE145, .L30
894:                       {
895:                           // Uh oh, we had an overflow and need to saturate!
896:                           const int16_t xhi = x >> 16;
005D42  DEBDCF     ASR W7, #15, W11
005D60  DEBACF     ASR W7, #15, W5
005DB6  DEBDCF     ASR W7, #15, W11
005DD4  DEBACF     ASR W7, #15, W5
005E0A  DEBACF     ASR W7, #15, W5
005E42  DEBACF     ASR W7, #15, W5
005F82  DEA9CF     ASR W5, #15, W3
897:                           const int16_t sign_x = xhi >> 15;
005D44  78050B     MOV W11, W10
005D62  780205     MOV W5, W4
005DB8  78050B     MOV W11, W10
005DD6  780205     MOV W5, W4
005E0C  780205     MOV W5, W4
005E44  780205     MOV W5, W4
005F84  780103     MOV W3, W2
898:                           return sign_x ^ 0x7fff;
005D46  27FFF4     MOV #0x7FFF, W4
005D48  6D0504     XOR W10, W4, W10
005D64  27FFF5     MOV #0x7FFF, W5
005D66  6A0185     XOR W4, W5, W3
005DBA  27FFF4     MOV #0x7FFF, W4
005DBC  6D0504     XOR W10, W4, W10
005DD8  27FFF5     MOV #0x7FFF, W5
005DDA  6A0185     XOR W4, W5, W3
005E0E  27FFF5     MOV #0x7FFF, W5
005E10  6A0185     XOR W4, W5, W3
005E46  27FFF2     MOV #0x7FFF, W2
005E48  6A0202     XOR W4, W2, W4
005F86  27FFF3     MOV #0x7FFF, W3
005F88  690083     XOR W2, W3, W1
899:                       }
900:                   }
901:                   return ylo;
902:               }
903:               
904:               /**
905:                * Compute the average of two uint16_t values
906:                * @param a first value
907:                * @param b second value
908:                * @return (a+b)/2
909:                */
910:               inline static uint16_t UTIL_AverageU16(uint16_t a, uint16_t b)
911:               {
912:                   uint16_t c;
913:                   
914:                   asm (
915:                       "    ;UTIL_AverageU16\n"
916:                       "    add %[a],%[b],%[c]\n"
917:                       "    rrc %[c],%[c]"
918:                       : [c]"=r"(c)
919:                       : [a]"r"(a), [b]"r"(b)
920:                   );
921:                   return c;
922:               }
923:               
924:               /**
925:                * Compute the average of two int16_t values
926:                * @param a first value
927:                * @param b second value
928:                * @return (a+b)/2
929:                */
930:               inline static int16_t UTIL_AverageS16(int16_t a, int16_t b)
931:               {
932:                   return (int16_t)((((int32_t)a) + b) >> 1);
933:               }
934:               
935:               /**
936:                * Compute the average of two int16_t values
937:                * @param a first value
938:                * @param b second value
939:                * @return (a+b)/2
940:                */
941:               inline static int16_t UTIL_AverageS16_asm(int16_t a, int16_t b)
942:               {
943:                   return UTIL_ToggleBit15(
944:                            UTIL_AverageU16(
945:                              UTIL_ToggleBit15(a),
946:                              UTIL_ToggleBit15(b)
947:                            )
948:                          );
949:               }
950:               
951:               /**
952:                * Compute the minimum and maximum of a set of three int16_t values
953:                * @param a first value
954:                * @param b second value
955:                * @param c third value
956:                * @return struct containing minimum and maximum value --
957:                *   this is fairly unusual but it permits the compiler to
958:                *   optimize by placing in an appropriate pair
959:                *   of adjacent working registers.
960:                */
961:               inline static minmax16_t UTIL_MinMax3_S16(int16_t a, int16_t b, int16_t c)
962:               {
963:                   /* Sort a,b,c */
964:                   asm (
965:                       "    ;UTIL_MinMax3_S16\n"
966:                       "    cpslt   %[a], %[b]\n"
967:                       "    exch    %[a], %[b]\n"
968:                       "    cpslt   %[a], %[c]\n"
969:                       "    exch    %[a], %[c]\n"
970:                       "    cpslt   %[b], %[c]\n"
971:                       "    exch    %[b], %[c]\n"
972:                       : [a]"+r"(a),
973:                         [b]"+r"(b),
974:                         [c]"+r"(c)
975:                   );
976:                   /* Now a <= b <= c */
977:               
978:                   minmax16_t result;
979:                   result.min = a;
980:                   result.max = c;
981:                   return result;
982:               }
983:               
984:               /**
985:                *
986:                * Computes x*k, limits the result to the [-32768, 32767 range]
987:                *   This implementation not valid if both x=-32768 and k=-32768
988:                * 
989:                * @param x input
990:                * @param k gain
991:                * @return x*k, limited to [-32768, 32767]
992:                */
993:               inline static int16_t UTIL_ScaleAndClip(int16_t x, int16_t k)
994:               {
995:                   int32_t result = (int32_t)x*k;
996:                   const int16_t intmax = INT16_MAX;
997:               
998:                   int16_t m; // most significant bits (30:15) of product
999:                   int16_t s; // sign of m: -1 for negative m, 0 for nonnegative m
1000:              
1001:                  // we will compute:
1002:                  // sat = intmax - s:  -32768 for negative m, +32767 for positive m
1003:                  // if m is either 0 or -1, then m == s
1004:              
1005:                  asm volatile (
1006:                      ";UTIL_ScaleAndClip\n"
1007:                      "   rlc     %[result], %[m]\n"
1008:                      "   rlc     %d[result], %[m]\n"
1009:                      "   asr     %[m], #15, %[s]\n"
1010:                      "   cpseq   %[m], %[s]\n"
1011:                      "   sub     %[intmax], %[s], %[result]\n"  // set result = sat
1012:                      : [result]"+r"(result), [m]"=&r"(m), [s]"=&r"(s)
1013:                      : [intmax]"r"(intmax)
1014:                  );
1015:                  return result;
1016:              }
1017:              
1018:              /**
1019:               * Computes  shift-left with an S16 result.
1020:               * If the shift count(q) is positive, the input x << q,
1021:               * else if the shift count(q) is negative, the input x >> (-q)
1022:               * This should only be done if the shift count is a compile-time constant
1023:               * otherwise it takes significant run time
1024:               */
1025:              inline static int16_t UTIL_BidirectionalShiftLeft(int16_t x, int16_t q)
1026:              {
1027:                  if (q < 0)
1028:                  {
1029:                     return x >> (-q);
1030:                  }
1031:                  else
1032:                  {
1033:                     return x << q;
1034:                  }   
1035:              }
1036:              
1037:              /**
1038:               * Computes (state & 1) ? x : -x;
1039:               * @param state input state
1040:               * @param x amplitude
1041:               * @return x if bit 0 of state is set, -x if it is clear
1042:               */
1043:              inline static int16_t UTIL_ApplySign(uint16_t state, int16_t x)
1044:              {
1045:                  asm (
1046:                      "; UTIL_ApplySign\n"
1047:                      "   btss  %[state], #0\n"   // skip if bit 0 set
1048:                      "   neg   %[x], %[x]\n"
1049:                      : [x]"+r"(x)
1050:                      : [state]"r"(state)
1051:                  );
1052:                  return x;   
1053:              }
1054:              
1055:              /**
1056:               * Copy sign from a source value: (state & 0x8000) ? -x : x;
1057:               * @param sign_source source value
1058:               * @param x amplitude
1059:               * @return x if bit 15 of sign_source is clear, -x if it is set
1060:               */
1061:              inline static int16_t UTIL_CopySign(int16_t sign_source, int16_t x)
1062:              {
1063:                  asm (
006CB2  91A8C8     MOV [W8+472], W1
006CB4  240000     MOV #0x4000, W0
006CB6  A7F001     BTSC W1, #15
006CB8  EA0000     NEG W0, W0
0072B6  91A8C8     MOV [W8+472], W1
0072B8  240000     MOV #0x4000, W0
0072BA  A7F001     BTSC W1, #15
0072BC  EA0000     NEG W0, W0
1064:                      "; UTIL_CopySign\n"
1065:                      "   btsc  %[src], #15\n"   // skip if bit 15 is clear
1066:                      "   neg   %[x], %[x]\n"
1067:                      : [x]"+r"(x)
1068:                      : [src]"r"(sign_source)
1069:                  );
1070:                  return x;   
1071:              }
1072:              
1073:              /**
1074:               * Sort the minimum, median, and maximum of a set of three int16_t values
1075:               * @param a first value
1076:               * @param b second value
1077:               * @param c third value
1078:               * @return struct containing minimum, median, and maximum value
1079:               */
1080:              inline static minmedmax16_t UTIL_Sort3_S16(int16_t a, int16_t b, int16_t c)
1081:              {
1082:                  /* Sort a,b,c */
1083:                  asm (
1084:                      "    ;UTIL_Sort3_S16\n"
1085:                      "    cpslt   %[a], %[b]\n"
1086:                      "    exch    %[a], %[b]\n"
1087:                      "    cpslt   %[a], %[c]\n"
1088:                      "    exch    %[a], %[c]\n"
1089:                      "    cpslt   %[b], %[c]\n"
1090:                      "    exch    %[b], %[c]\n"
1091:                      : [a]"+r"(a),
1092:                        [b]"+r"(b),
1093:                        [c]"+r"(c)
1094:                  );
1095:                  /* Now a <= b <= c */
1096:              
1097:                  minmedmax16_t result;
1098:                  result.min = a;
1099:                  result.med = b;
1100:                  result.max = c;
1101:                  return result;
1102:              }
1103:              
1104:              #ifdef __cplusplus
1105:              }
1106:              #endif
1107:              
1108:              #endif /* __UTIL_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/ui.h
1:                 /**
2:                  * ui.h
3:                  * 
4:                  * Management of user interface components (pushbutton, LED, potentiometer)
5:                  * 
6:                  * Component: external interface
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __UI_H
48:                #define __UI_H
49:                
50:                #include <stdbool.h>
51:                #include <stdint.h>
52:                #include "ui_types.h"
53:                
54:                #ifdef __cplusplus
55:                extern "C" {
56:                #endif
57:                
58:                /**
59:                 * Initializes UI state variables.
60:                 * @param pui UI state
61:                 */
62:                void MCAF_UiInit(volatile MCAF_UI_DATA *pui);
63:                
64:                /**
65:                 * Reinitializes UI state variables when we are restarting
66:                 * (exiting an error or debug state)
67:                 * @param pui UI state
68:                 */
69:                inline static void MCAF_UiRestart(volatile MCAF_UI_DATA *pui)
70:                {
71:                    pui->run = false;
004B8E  EB4480     CLR.B W9
004B90  9BEC49     MOV.B W9, [W8+492]
004DF6  EB4000     CLR.B W0
004DF8  9BEC40     MOV.B W0, [W8+492]
0079EE  EB4480     CLR.B W9
0079F0  9BEC49     MOV.B W9, [W8+492]
72:                    pui->indicatorState.tickPeriod = MCUILD_PERIOD;
004B92  B3C100     MOV.B #0x10, W0
004B94  9BFC20     MOV.B W0, [W8+506]
004DFA  B3C101     MOV.B #0x10, W1
004DFC  9BFC21     MOV.B W1, [W8+506]
0079F2  B3C100     MOV.B #0x10, W0
0079F4  9BFC20     MOV.B W0, [W8+506]
73:                    pui->indicatorState.isError = false;    
004B96  9BFC39     MOV.B W9, [W8+507]
004DFE  9BFC30     MOV.B W0, [W8+507]
0079F6  9BFC39     MOV.B W9, [W8+507]
74:                }
75:                
76:                /**
77:                 * Executes tasks needed to run at the ISR rate
78:                 * @param pui UI state
79:                 */
80:                void MCAF_UiStepIsr(volatile MCAF_UI_DATA *pui);
81:                
82:                /**
83:                 * Executes tasks needed to run in the main loop
84:                 * @param pui UI state
85:                 */
86:                void MCAF_UiStepMain(volatile MCAF_UI_DATA *pui);
87:                
88:                /**
89:                 * Returns true at each UI tick.
90:                 * @param pui UI state
91:                 * @return true when the UI tick is occurring.
92:                 */
93:                inline static bool MCAF_UiTick(const volatile MCAF_UI_DATA *pui)
94:                {
95:                    return pui->isrCount == 0;
96:                }
97:                
98:                /**
99:                 * Updates LEDs
100:                * @param p UI indicator state
101:                * @return a bitflag mask consisting of MCAF_UI_LED1_ON and MCAF_UI_LED2_ON
102:                */
103:               uint16_t MCAF_UiCalculateIndicatorState(volatile MCAF_UI_INDICATOR_STATE *p);
104:               
105:               /**
106:                * Setup UI to flashes an error code in a loop.
107:                * 
108:                * @param pindstate indicator states
109:                * @param code error code to display
110:                */
111:               void MCAF_UiSetupFlashErrorCode(volatile MCAF_UI_INDICATOR_STATE *pindstate, uint16_t code);
112:               
113:               /**
114:                * Record only new error codes
115:                *
116:                * @param pindstate indicator states
117:                * @param code
118:                */
119:               inline static void MCAF_UiRecordNewError(volatile MCAF_UI_INDICATOR_STATE *pindstate, uint16_t code)
120:               {
121:                   if (!pindstate->isError)
004A08  93F938     MOV.B [W8+507], W2
004A0C  E00402     CP0.B W2
004A0E  3A0059     BRA NZ, .L11
004AF4  93F938     MOV.B [W8+507], W2
004AF8  E00402     CP0.B W2
004AFA  3A0019     BRA NZ, .L29
122:                   {
123:                       MCAF_UiSetupFlashErrorCode(pindstate, code);
004A10  072896     RCALL MCAF_UiSetupFlashErrorCode
004A12  370057     BRA .L11
004AFC  072820     RCALL MCAF_UiSetupFlashErrorCode
004AFE  370017     BRA .L29
124:                   }
125:               }
126:               
127:               /**
128:                * Returns true if there is an error condition
129:                * 
130:                * @param pindstate indicator state data
131:                * @return true if an error condition exists
132:                */
133:               inline static bool MCAF_UiIsError(volatile const MCAF_UI_INDICATOR_STATE *pindstate)
134:               {
135:                   return pindstate->isError;
136:               }
137:               
138:               /**
139:                * Gets a copy of the error code
140:                * 
141:                * @param pindstate indicator state data
142:                * @return error code
143:                */
144:               inline static uint16_t MCAF_UiGetErrorCode(volatile const MCAF_UI_INDICATOR_STATE *pindstate)
145:               {
146:                   return pindstate->code;
0009D0  817F90     MOV 0x2FF2, W0
147:               }
148:               
149:               /**
150:                * Places a request to clear the fault condition and exit the fault state.
151:                * @param pui UI state data
152:                */
153:               inline static void MCAF_UiExitFaultState(volatile MCAF_UI_DATA *pui)
154:               {
155:                   pui->exitFaultState = true;
000A20  B3C011     MOV.B #0x1, W1
000A22  22FED0     MOV #0x2FED, W0
000A24  784801     MOV.B W1, [W0]
156:               }
157:               
158:               /**
159:                * Flashes a severe error code forever in an infinite loop.
160:                * We disable interrupts and never return; the only way to stop the error-flashing
161:                * routine is to reset the microcontroller.
162:                * 
163:                * @param code error code to display
164:                */
165:               void __attribute__((naked, noreturn)) MCAF_UiFlashErrorCodeForever(uint16_t code);
166:               
167:               /**
168:                * Check whether there was a recent direction change.
169:                * 
170:                * @param pui UI state
171:                * @return true if a direction change was pending
172:                */
173:               inline static bool MCAF_TestAndClearDirectionChangeFlag(volatile MCAF_UI_DATA *pui)
174:               {
175:                   if (pui->flags & MCAF_UI_DIRECTION_CHANGED)
0049E4  91B078     MOV [W8+494], W0
0049E8  A35800     BTST.Z W0, #5
0049EA  320018     BRA Z, .L8
0049EC  370013     BRA .LBE1566, .L104
176:                   {
177:                       pui->flags &= ~MCAF_UI_DIRECTION_CHANGED;
004A14  91B078     MOV [W8+494], W0
004A16  A15000     BCLR W0, #5
004A18  99B470     MOV W0, [W8+494]
178:                       return true;
004A1A  B3C012     MOV.B #0x1, W2
179:                   }
180:                   else
181:                   {   
182:                       return false;
0049E6  EB4100     CLR.B W2
183:                   }
184:               }
185:               
186:               #ifdef __cplusplus
187:               }
188:               #endif
189:               
190:               #endif /* __UI_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/ui.c
1:                 /**
2:                  * ui.c
3:                  * 
4:                  * Management of user interface components (pushbutton, LED, potentiometer)
5:                  * 
6:                  * Component: external interface
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                /*
48:                 * __delay_us() requires FCY to be defined before #including libpic30.h
49:                 * hal.h needs to be included before libpic30.h
50:                 */
51:                 
52:                #include "ui.h"
53:                #include "util.h"
54:                #include "hal.h"
55:                #include <libpic30.h>
56:                #include "parameters/operating_params.h"
57:                #include "parameters/timing_params.h"
58:                #include "mcaf_watchdog.h"
59:                #include "board_service.h"
60:                
61:                enum
62:                {
63:                    MCUI_PAUSE_TIME_END_OF_CODE = 3,
64:                    MCUI_PAUSE_TIME_END_OF_DIGIT = 1,
65:                    MCUI_INDICATOR_TICK_PERIOD_UILOOPS = 16, /** LED flash repeat time in UI loops */
66:                    
67:                    MCUI_ERROR_CODE_TICK_PERIOD_UILOOPS = 6, /** error code tick time in UI loops */
68:                    MCUI_ERROR_CODE_LOOP_DELAY_MICROSECONDS = 625, /** error code tick time in us */
69:                    MCUI_ERROR_CODE_LOOP_DELAYS_PER_TICK = 100, /** number of delays per tick */
70:                };
71:                
72:                void MCAF_UiInit(volatile MCAF_UI_DATA *pui)
73:                {
74:                    pui->run = false;
00949A  EB4080     CLR.B W1
00949C  784801     MOV.B W1, [W0]
75:                    pui->exitFaultState = false;
00949E  984011     MOV.B W1, [W0+1]
76:                    pui->isrCount = 0;
0094A0  EB0080     CLR W1
0094A2  980021     MOV W1, [W0+4]
77:                    pui->flags = 0;
0094A4  980011     MOV W1, [W0+2]
78:                    pui->indicatorState.tickCounter = 0;
0094A6  984851     MOV.B W1, [W0+13]
79:                    pui->indicatorState.tickPeriod = MCUI_INDICATOR_TICK_PERIOD_UILOOPS;
0094A8  B3C102     MOV.B #0x10, W2
0094AA  984862     MOV.B W2, [W0+14]
80:                    pui->indicatorState.isError = false;
0094AC  984871     MOV.B W1, [W0+15]
81:                    pui->indicatorState.pause = 0;
0094AE  984841     MOV.B W1, [W0+12]
82:                    pui->indicatorState.duty1 = 0;
0094B0  984821     MOV.B W1, [W0+10]
83:                    pui->indicatorState.duty2 = 0;
0094B2  984831     MOV.B W1, [W0+11]
84:                    pui->indicatorState.codeDigit = 0;
0094B4  980041     MOV W1, [W0+8]
85:                    
86:                    pui->velocityScaling.gain   = MCAF_VELOCITY_COMMAND_MAX - MCAF_VELOCITY_COMMAND_MIN;
0094B6  24A3E1     MOV #0x4A3E, W1
0094B8  980801     MOV W1, [W0+16]
87:                    pui->velocityScaling.offset = MCAF_VELOCITY_COMMAND_MIN;
0094BA  215551     MOV #0x1555, W1
0094BC  980811     MOV W1, [W0+18]
88:                }
0094BE  060000     RETURN
89:                
90:                void MCAF_UiStepIsr(volatile MCAF_UI_DATA *pui)
91:                {
92:                    pui->isrCount++;
009DEA  9000A0     MOV [W0+4], W1
009DEC  E80081     INC W1, W1
009DEE  980021     MOV W1, [W0+4]
93:                }
009DF0  060000     RETURN
009DF2  EB0080     CLR W1
94:                
95:                void MCAF_UiStepMain(volatile MCAF_UI_DATA *pui)
96:                {
97:                    if (pui->isrCount >= MCAF_UI_LOOP_TIME_IN_ISRS)
0094C0  900120     MOV [W0+4], W2
0094C2  207CF1     MOV #0x7CF, W1
0094C4  510F81     SUB W2, W1, [W15]
0094C6  36000E     BRA LEU, .LBE84, .LBE91, .L15
98:                    {
99:                        pui->isrCount = 0; /* reset counter to 0 to restart */
0094C8  EB0080     CLR W1
0094CA  980021     MOV W1, [W0+4]
100:               
101:                       uint16_t leds = MCAF_UiCalculateIndicatorState(&pui->indicatorState);
0094CC  400066     ADD W0, #0x6, W0
0094CE  07F581     RCALL MCAF_UiCalculateIndicatorState
102:                       if (leds & MCAF_UI_LED1_ON)
0094D0  A32800     BTST.Z W0, #2
0094D2  320002     BRA Z, HAL_LedGp1_Deactivate
103:                       {
104:                           HAL_LedGp1_Activate();
105:                       }
106:                       else
107:                       {
108:                           HAL_LedGp1_Deactivate();
109:                       }
110:                       if (leds & MCAF_UI_LED2_ON)
0094DA  A33800     BTST.Z W0, #3
0094DC  320002     BRA Z, HAL_LedGp2_Deactivate
111:                       {
112:                           HAL_LedGp2_Activate();
113:                       }
114:                       else
115:                       {
116:                           HAL_LedGp2_Deactivate();
117:                       }
118:               
119:                   }
120:               }
0094E4  060000     RETURN
0094E6  23ED14     MOV #0x3ED1, W4
121:               
122:               /**
123:                * Updates the LEDs when there is an error, with error-code blink behavior.
124:                * @param p indicator state
125:                * @return bitmask containing LED flags
126:                */
127:               inline uint16_t MCAF_UiUpdateIndicatorErrorCode(volatile MCAF_UI_INDICATOR_STATE *p)
128:               {
129:                   /*
130:                    * Display error code flash pattern, based around 1/2 period blinks.
131:                    * We work in base 4, display 1/2/3/4 blinks per digit,
132:                    * pauses between digits and a long pause at end.
133:                    */
134:               
135:                   /* At the beginning of each tick period, update what we're doing. */
136:                   if (p->tickCounter == 0)
007FEA  9040F0     MOV.B [W0+7], W1
007FEC  E00401     CP0.B W1
007FEE  3A001B     BRA NZ, .L6
137:                   {
138:                       if (p->pause > 0)
007FF0  9040E0     MOV.B [W0+6], W1
007FF2  E00401     CP0.B W1
007FF4  320004     BRA Z, .L7
139:                       {
140:                           /*
141:                            * When we are pausing,
142:                            * - turn LEDs off the entire time,
143:                            * - wait until the end of the period
144:                            * - decrement pause counter
145:                            * - when we are done pausing:
146:                            *     if we're all done displaying,
147:                            *       start a long pause and then start over
148:                            *     otherwise go to next digit
149:                            */
150:                           --p->pause;
007FF6  9040E0     MOV.B [W0+6], W1
007FF8  E94081     DEC.B W1, W1
007FFA  984061     MOV.B W1, [W0+6]
007FFC  370014     BRA .L6
151:                       }
152:                       else
153:                       {
154:                           /*
155:                            * at end of tick period,
156:                            * pause after we have displayed N+1 blinks
157:                            * where N is the least significant digit in base 4
158:                            */
159:                           if (p->codeDigit == 0)
007FFE  900090     MOV [W0+2], W1
008000  E00001     CP0 W1
008002  3A0005     BRA NZ, .L8
160:                           {
161:                               p->pause = MCUI_PAUSE_TIME_END_OF_CODE;
008004  B3C031     MOV.B #0x3, W1
008006  984061     MOV.B W1, [W0+6]
162:                               p->codeDigit = p->code;
008008  780090     MOV [W0], W1
00800A  980011     MOV W1, [W0+2]
00800C  37000C     BRA .L6
163:                               /*
164:                                * if we're all done displaying,
165:                                * start a long pause and then start over
166:                                */
167:                           }
168:                           else if ((p->codeDigit & 0x03) == 0)
00800E  900090     MOV [W0+2], W1
008010  6080E3     AND W1, #0x3, W1
008012  3A0006     BRA NZ, .L9
169:                           {
170:                               p->pause = MCUI_PAUSE_TIME_END_OF_DIGIT;
008014  B3C011     MOV.B #0x1, W1
008016  984061     MOV.B W1, [W0+6]
171:                               p->codeDigit >>= 2;
008018  900090     MOV [W0+2], W1
00801A  DE08C2     LSR W1, #2, W1
00801C  980011     MOV W1, [W0+2]
00801E  370003     BRA .L6
172:                               /* at the end of each digit, go to the next and pause */
173:                           }
174:                           else
175:                           {
176:                               --p->codeDigit;
008020  900090     MOV [W0+2], W1
008022  E90081     DEC W1, W1
008024  980011     MOV W1, [W0+2]
177:                           }
178:                       }
179:                   }
180:               
181:                   /*
182:                    * if not pausing:
183:                    * blink LEDs on at 50% duty cycle
184:                    */
185:                   if ((p->pause == 0)
008026  904160     MOV.B [W0+6], W2
00802A  E00402     CP0.B W2
00802C  3A0014     BRA NZ, .LBE82, .LBE83, .L10
186:                           && (p->tickCounter < (p->tickPeriod >> 1)))
00802E  904170     MOV.B [W0+7], W2
008030  904800     MOV.B [W0+8], W0
008032  0A8071     BFEXT #0x1, #0x7, W0, W0
008034  000000     NOP
008038  514F80     SUB.B W2, W0, [W15]
00803A  39000D     BRA NC, .LBE82, .LBE83, .L10
187:                   {
188:                       return MCAF_UI_BOTH_LEDS_ON;
008036  2000C1     MOV #0xC, W1
189:                   }            
190:                   else
191:                   {
192:                       return 0;
008028  EB0080     CLR W1
00803C  EB0080     CLR W1
00803E  37000B     BRA .LBE82, .LBE83, .L10
193:                   }
194:               }
195:               
196:               /**
197:                * Updates the LEDs when there is not an error, with duty-cycle blink behavior.
198:                * @param p indicator state
199:                * @return bitmask containing LED flags
200:                */
201:               inline uint16_t MCAF_UiUpdateIndicatorNoErrorCode(volatile MCAF_UI_INDICATOR_STATE *p)
202:               {
203:                   uint16_t result = 0;
00804A  EB0080     CLR W1
204:                   if (p->tickCounter < p->duty1)
008040  9041F0     MOV.B [W0+7], W3
008042  904140     MOV.B [W0+4], W2
008046  51CF82     SUB.B W3, W2, [W15]
008048  390001     BRA NC, .L11
205:                   {
206:                       result |= MCAF_UI_LED1_ON;
008044  200041     MOV #0x4, W1
207:                   }
208:                   if (p->tickCounter < p->duty2)
00804C  904170     MOV.B [W0+7], W2
00804E  904050     MOV.B [W0+5], W0
008050  514F80     SUB.B W2, W0, [W15]
008052  310001     BRA C, .LBE82, .LBE83, .L10
209:                   {
210:                       result |= MCAF_UI_LED2_ON;
008054  A03001     BSET W1, #3
211:                   }
212:                   return result;
213:               }
214:               
215:               uint16_t MCAF_UiCalculateIndicatorState(volatile MCAF_UI_INDICATOR_STATE *p)
216:               {   
217:                   /* update indicator */
218:                   if (++p->tickCounter >= p->tickPeriod)
007FD2  9040F0     MOV.B [W0+7], W1
007FD4  E84081     INC.B W1, W1
007FD6  984071     MOV.B W1, [W0+7]
007FD8  904170     MOV.B [W0+7], W2
007FDA  904880     MOV.B [W0+8], W1
007FDC  514F81     SUB.B W2, W1, [W15]
007FDE  390002     BRA NC, .L4
219:                   {
220:                       p->tickCounter = 0;
007FE0  EB4080     CLR.B W1
007FE2  984071     MOV.B W1, [W0+7]
221:                   }
222:                   
223:                   if (p->isError)
007FE4  904890     MOV.B [W0+9], W1
007FE6  E00401     CP0.B W1
007FE8  32002B     BRA Z, MCAF_UiCalculateIndicatorState::MCAF_UiUpdateIndicatorNoErrorCode
224:                   {
225:                       return MCAF_UiUpdateIndicatorErrorCode(p);
226:                   }
227:                   else /* no error */
228:                   {
229:                       return MCAF_UiUpdateIndicatorNoErrorCode(p);        
230:                   }
231:               }
008056  780001     MOV W1, W0
008058  060000     RETURN
00805A  781F88     MOV W8, [W15++]
232:               
233:               /* inline applies to the use of this function in MCAF_UiFlashErrorCodeForever,
234:                * not from external callers */
235:               inline void MCAF_UiSetupFlashErrorCode(volatile MCAF_UI_INDICATOR_STATE *pindstate, uint16_t code)
236:               {
237:                   pindstate->code = code;
00885E  780E00     MOV W0, [W12]
009B3E  780801     MOV W1, [W0]
238:                   pindstate->codeDigit = 0;
008860  EB0000     CLR W0
008862  89BA50     MOV W0, 0x374A
009B40  EB0080     CLR W1
009B42  980011     MOV W1, [W0+2]
239:                   pindstate->isError = true;
008864  B3C011     MOV.B #0x1, W1
008866  984E11     MOV.B W1, [W12+9]
009B44  B3C012     MOV.B #0x1, W2
009B46  984812     MOV.B W2, [W0+9]
240:                   pindstate->pause = 0;
008868  984660     MOV.B W0, [W12+6]
009B48  984061     MOV.B W1, [W0+6]
241:                   pindstate->tickPeriod = MCUI_ERROR_CODE_TICK_PERIOD_UILOOPS;    
00886A  B3C060     MOV.B #0x6, W0
00886C  984E00     MOV.B W0, [W12+8]
009B4A  B3C061     MOV.B #0x6, W1
009B4C  984801     MOV.B W1, [W0+8]
242:               }
009B4E  060000     RETURN
009B50  EB0080     CLR W1
009B52  780801     MOV W1, [W0]
243:               
244:               /* Reserve dedicated memory for an indicator in case of severe errors. */
245:               static MCAF_UI_INDICATOR_STATE errorIndicatorState;
246:               void __attribute__((naked, noreturn)) MCAF_UiFlashErrorCodeForever(uint16_t code)
247:               {    
0088A4  200648     MOV #0x64, W8
248:                   __builtin_disable_interrupts();
008856  A9E8C3     BCLR 0x8C3, #7
008858  000000     NOP
00885A  000000     NOP
249:                   MCAF_UiSetupFlashErrorCode(&errorIndicatorState, code);
00885C  23748C     MOV #0x3748, W12
250:                   HAL_PWM_Outputs_Disable();
251:                   
252:                   MCAF_CareForWatchdog();
253:               
254:                   while (true)
255:                   {
256:                       uint16_t leds = MCAF_UiCalculateIndicatorState(&errorIndicatorState);
00888C  78000C     MOV W12, W0
00888E  07FBA1     RCALL MCAF_UiCalculateIndicatorState
257:                       if (leds & MCAF_UI_LED1_ON)
008890  A32800     BTST.Z W0, #2
008892  320002     BRA Z, HAL_LedGp1_Deactivate
258:                       {
259:                           HAL_LedGp1_Activate();
260:                       }
261:                       else
262:                       {
263:                           HAL_LedGp1_Deactivate();
264:                       }
265:                       if (leds & MCAF_UI_LED2_ON)
00889A  A33800     BTST.Z W0, #3
00889C  320002     BRA Z, HAL_LedGp2_Deactivate
266:                       {
267:                           HAL_LedGp2_Activate();
268:                       }
269:                       else
270:                       {
271:                           HAL_LedGp2_Deactivate();
272:                       }    
273:                     
274:                       int i;
275:                       for (i = 0; i < MCUI_ERROR_CODE_LOOP_DELAYS_PER_TICK; ++i)
0088AE  3AFFFB     BRA NZ, .L26
0088B0  37FFED     BRA .L27
0088B2  EB0080     CLR W1
276:                       {
277:                           MCAF_CareForWatchdog();
278:                           __delay_us(MCUI_ERROR_CODE_LOOP_DELAY_MICROSECONDS);
008888  2F424A     MOV #0xF424, W10
00888A  20000B     MOV #0x0, W11
0088A8  BE000A     MOV.D W10, W0
0088AA  0707D6     RCALL ___delay32, .LFE0
0088AC  E90408     DEC W8, W8
279:                       }
280:                   }
281:               }
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/test_harness.h
1:                 /**
2:                  * test_harness.h
3:                  * 
4:                  * Test harness definitions
5:                  * 
6:                  * Component: test harness
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __TEST_HARNESS_H
48:                #define __TEST_HARNESS_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                #include "motor_control_types.h"
53:                #include "hal.h"
54:                #include "units.h"
55:                #include "util.h"
56:                #include "parameters/options.h"
57:                
58:                #ifdef __cplusplus
59:                extern "C" {
60:                #endif
61:                
62:                /* define timestamps for profiling */
63:                    
64:                #define MCTH_TIMESTAMP(NAME,VAL) MCTIMESTAMP_##NAME=VAL,
65:                    
66:                enum MCAF_TIMESTAMP_NAMES {
67:                #include "test_harness_timestamps.h"
68:                };
69:                    
70:                #undef MCTH_TIMESTAMP
71:                    
72:                /**
73:                 * Test operating mode
74:                 */
75:                typedef enum tagMCAF_OPERATING_MODE 
76:                {
77:                    OM_DISABLED = 0,          /** motor disabled */
78:                    OM_FORCE_VOLTAGE_DQ = 1,  /** applying dq-frame voltage */
79:                    OM_FORCE_CURRENT = 2,     /** current loop enabled */
80:                    OM_NORMAL = 3             /** current and velocity loop enabled */
81:                } MCAF_OPERATING_MODE;
82:                
83:                enum MCAF_TEST_CONSTANTS
84:                {
85:                    TEST_OVERRIDE_VELOCITY_COMMAND     = 1,  /** Override velocity command */
86:                    TEST_OVERRIDE_COMMUTATION          = 2,  /** Override commutation angle */
87:                    TEST_OVERRIDE_DC_LINK_COMPENSATION = 4,  /** Override DC link compensation */
88:                    TEST_OVERRIDE_STALL_DETECTION      = 8,  /** Override stall detection */
89:                    TEST_OVERRIDE_D_AXIS_VOLTAGE_PRIORITY = 16, /** Override to give d-axis voltage priority */
90:                    TEST_OVERRIDE_STARTUP_PAUSE        = 32, /** Override to pause startup upon reaching the HOLD state */
91:                    TEST_OVERRIDE_FLUX_CONTROL         = 64, /** Override flux control */
92:                    TEST_OVERRIDE_ZERO_SEQUENCE_MODULATION = 128, /** Override zero-sequence modulation */
93:                    
94:                    TEST_GUARD_VALID = 0xD1A6,    /** valid guard key */
95:                    TEST_GUARD_RESET = 0x0000,    /** value set at reset */
96:                    
97:                    TEST_FLAGS_SEIZURE_MAINLOOP = 0x0001, /** causes main loop to seize */
98:                    TEST_FLAGS_SEIZURE_ISR      = 0x0002, /** causes ISR to seize */
99:                    TEST_FLAGS_STACK_OVERFLOW   = 0x0004, /** causes stack overflow */
100:               
101:                   TEST_FORCE_STATE_INACTIVE = 0,          /** No action */
102:                   TEST_FORCE_STATE_RUN      = 1,          /** Run (turns ui.run to true) */
103:                   TEST_FORCE_STATE_STOP     = 2,          /** Stop (turns ui.run to false) */
104:                   TEST_FORCE_STATE_STOP_NOW = 3,          /** Stop immediately */
105:               };
106:               
107:               /**
108:                * Test harness uneven commutation (on/off)
109:                */
110:               typedef struct tagMCAF_TEST_COMMUTATION_ON_OFF
111:               {
112:                   uint16_t maxCount;        /** (period - 1) in ISR counts */
113:                   uint16_t counter;         /** counter */
114:                   uint16_t threshold;       /** threshold, below which we apply omegaElectrical */
115:               } MCAF_TEST_COMMUTATION_ON_OFF_T;
116:               
117:               /**
118:                * Perturbation on each phase of asymmetric perturbation
119:                * (not applicable for symmetric square-wave perturbation)
120:                */
121:               typedef struct {
122:                   uint32_t duration;            /** duration, in cycles, or zero to stop */
123:                   
124:                   /* values */
125:                   MCAF_U_VELOCITY   velocity;   /** velocity command perturbation */
126:                   MCAF_U_CURRENT_DQ idq;        /** dq-axis current perturbation */
127:                   MCAF_U_VOLTAGE_DQ vdq;        /** dq-axis voltage perturbation */
128:               } MCAF_TEST_PERTURB_PHASE;
129:               
130:               /**
131:                * Bit flags for asymmetric perturbation
132:                * (not applicable for symmetric square-wave perturbation)
133:                */
134:               typedef enum {
135:                   MCAF_TPF_PHASE       =  1 /** which phase is active? */
136:               } MCAF_TEST_PERTURB_FLAGS;
137:               
138:               
139:               /**
140:                * Autostepping of current perturbation
141:                * (not applicable for symmetric square-wave perturbation)
142:                */
143:               typedef struct {
144:                   uint16_t count;               /** number of steps */
145:               
146:                   /* values */
147:                   MCAF_U_CURRENT_DQ idq;        /** dq-axis current step */
148:               } MCAF_TEST_PERTURB_STEP;
149:               
150:               /**
151:                * Test harness state variables, per-motor
152:                */
153:               typedef struct tagMCAF_MOTOR_TEST_MANAGER
154:               {
155:               #ifdef MCAF_TEST_HARNESS
156:               #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
157:                   /** Square-wave state variables */
158:                   struct tagSqWave 
159:                   {
160:                       uint32_t halfperiod;      /** half-period of square-wave disturbance, in control cycles */
161:               
162:                       /* amplitudes */
163:                       MCAF_U_VELOCITY   velocity;        /** amplitude of velocity command perturbation */
164:                       MCAF_U_CURRENT_DQ idq;             /** amplitudes of dq-axis current perturbation */
165:                       MCAF_U_VOLTAGE_DQ vdq;             /** amplitudes of dq-axis voltage perturbation */
166:               
167:                       /* mutable state */
168:                       int16_t  value;           /** value of the square wave */
169:                       uint32_t count;           /** square-wave counter for each half-period */
170:                   } sqwave;                     /** square-wave state variables */
171:               #else  // MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC == 0
172:                   /** Pulse-wave state variables */
173:                   struct tagPerturbation
174:                   {
175:                       MCAF_TEST_PERTURB_PHASE phase[2];     /** each phase */
176:                       volatile MCAF_TEST_PERTURB_PHASE *activePhase; /** which phase is active */
177:                       uint32_t count;                       /** time counter for each phase */        
178:                       uint16_t flags;                       /** flags: see  MCAF_TEST_PERTURB_FLAGS */
179:                       uint16_t autobalanceRatio;            /** automatic balancing of the second phase from the first */
180:                       int16_t  enable;                      /** 1 or 0 to enable/disable perturbation */
181:                       MCAF_TEST_PERTURB_STEP step;          /** automatic stepping for some number of steps */
182:                   } perturb;
183:               #endif // MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
184:                   
185:                   uint16_t                overrides;       /** override bits */
186:                   
187:                   /** commutation frequency to use in case TEST_OVERRIDE_VELOCITY_COMMAND is set */
188:                   MCAF_U_VELOCITY_DTHETA_ELEC_DT overrideOmegaElectrical; 
189:                   MCAF_TEST_COMMUTATION_ON_OFF_T overrideCommutationOnOff; /** override commutation unevenly */
190:                   MCAF_U_DUTYCYCLE               overrideZeroSequenceOffset; /** override offset for zero sequence modulation */
191:                   MCAF_OPERATING_MODE    operatingMode;   /** operating mode */
192:                   
193:                   uint16_t    forceStateChange;
194:                   bool        stopNow;
195:                   bool        testRestartRequired;
196:               #endif
197:                  
198:               #ifdef MCAF_TEST_PROFILING
199:               #define MCAF_PROFILING_TIMESTAMP_CAPACITY 8
200:                   uint16_t    timestampReference; /** reference for timestamps */
201:                   uint16_t    timestamps[MCAF_PROFILING_TIMESTAMP_CAPACITY];   /** timestamps for profiling */
202:               #endif
203:               } MCAF_MOTOR_TEST_MANAGER;
204:               
205:               /**
206:                * Test harness state variables, per-system
207:                */
208:               typedef struct tagMCAF_SYSTEM_TEST_MANAGER
209:               {
210:                   uint16_t flags;              /** system-wide test flags */
211:                                                 
212:                   /** Guard state variables */
213:                   struct tagGuard
214:                   {
215:                       uint16_t key;            /** guard key */
216:                       uint16_t timeout;        /** timeout counter */
217:                   } guard;                     /** guard state variables */
218:               } MCAF_SYSTEM_TEST_MANAGER;
219:               
220:               /**
221:                * State variables for manually-triggered average value calculation routine
222:                */
223:               typedef struct tagMCAF_TRIGGERED_AVERAGE
224:               {
225:                   bool triggerActive;     /** Flag to begin routine */
226:                   uint16_t sampleCount;   /** Number of samples to acquire */
227:                   uint16_t shiftCount;    /** Number of right bit-shifts to calculate average */
228:                   uint16_t count;         /** Samples remaining to acquire */
229:                   int32_t sum;            /** Sum of inputs to average */
230:                   int16_t average;        /** Result of average calculation */
231:               } MCAF_TRIGGERED_AVERAGE_T;
232:               
233:               
234:               /* accessor functions for checking override status */
235:               
236:               /**
237:                * Returns <code>true</code> if velocity command override is set.
238:                * 
239:                * @param ptest testing state
240:                * @return <code>true</code> if velocity command override is set.
241:                */
242:               inline static bool MCAF_OverrideVelocityCommand(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
243:               {
244:               #ifdef MCAF_TEST_HARNESS 
245:                   return ptest->overrides & TEST_OVERRIDE_VELOCITY_COMMAND;
008BA4  92A861     MOV [W1+732], W0
246:               #else
247:                   return false;
248:               #endif
249:               }
250:               
251:               /**
252:                * Returns <code>true</code> if commutation override is set.
253:                * 
254:                * @param ptest testing state
255:                * @return <code>true</code> if commutation override is set.
256:                */
257:               inline static bool MCAF_OverrideCommutation(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
258:               {
259:               #ifdef MCAF_TEST_HARNESS 
260:                   return ptest->overrides & TEST_OVERRIDE_COMMUTATION;
007218  92A868     MOV [W8+732], W0
261:               #else
262:                   return false;
263:               #endif
264:               }
265:               
266:               /**
267:                * Returns <code>true</code> if DC link compensation override is set.
268:                * 
269:                * @param ptest testing state
270:                * @return <code>true</code> if DC link compensation override is set.
271:                */
272:               inline static bool MCAF_OverrideDCLinkCompensation(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
273:               {
274:               #ifdef MCAF_TEST_HARNESS
275:                   return ptest->overrides & TEST_OVERRIDE_DC_LINK_COMPENSATION;
00909E  92A868     MOV [W8+732], W0
276:               #else
277:                   return false;
278:               #endif
279:               }
280:               
281:               /**
282:                * Returns <code>true</code> if stall detection override is set.
283:                * 
284:                * @param ptest testing state
285:                * @return <code>true</code> if stall detection override is set.
286:                */
287:               inline static bool MCAF_OverrideStallDetection(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
288:               {
289:               #ifdef MCAF_TEST_HARNESS
290:                   return ptest->overrides & TEST_OVERRIDE_STALL_DETECTION;
004A32  92A8E8     MOV [W8+732], W1
0090E6  92A868     MOV [W8+732], W0
291:               #else
292:                   return false;
293:               #endif
294:               }
295:               
296:               /**
297:                * Returns <code>true</code> if d-axis voltage priority override is set.
298:                * 
299:                * @param ptest testing state
300:                * @return <code>true</code> if d-axis voltage priority override is set.
301:                *   (d-axis voltage has priority; the default case is that d- and q-axes
302:                *    have equal competing priority)
303:                */
304:               inline static bool MCAF_OverrideDAxisVoltagePriority(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
305:               {
306:               #ifdef MCAF_TEST_HARNESS
307:                   return ptest->overrides & TEST_OVERRIDE_D_AXIS_VOLTAGE_PRIORITY;
0068C8  92A8E8     MOV [W8+732], W1
308:               #else
309:                   return false;
310:               #endif
311:               }
312:               
313:               /**
314:                * Returns <code>true</code> if startup-pause override is set.
315:                * (This will keep the motor in open-loop commutation after acceleration.)
316:                * 
317:                * @param ptest testing state
318:                * @return <code>true</code> if startup-pause override is set.
319:                */
320:               inline static bool MCAF_OverrideStartupPause(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
321:               {
322:               #ifdef MCAF_TEST_HARNESS
323:                   return ptest->overrides & TEST_OVERRIDE_STARTUP_PAUSE;
004EAA  92A8E8     MOV [W8+732], W1
00720E  92A868     MOV [W8+732], W0
324:               #else
325:                   return false;
326:               #endif
327:               }
328:               
329:               /**
330:                * Returns <code>true</code> if flux-control override is set.
331:                * (This will disable calculation of D-axis current.)
332:                * 
333:                * @param ptest testing state
334:                * @return <code>true</code> if flux-control override is set.
335:                */
336:               inline static bool MCAF_OverrideFluxControl(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
337:               {
338:               #ifdef MCAF_TEST_HARNESS
339:                   return ptest->overrides & TEST_OVERRIDE_FLUX_CONTROL;
00686C  92A868     MOV [W8+732], W0
340:               #else
341:                   return false;
342:               #endif
343:               }
344:               
345:               /**
346:                * Returns <code>true</code> if zero-sequence modulation override is set.
347:                * (This will disable ZSM calculation.)
348:                * 
349:                * @param ptest testing state
350:                * @return <code>true</code> if zero-sequence modulation override is set.
351:                */
352:               inline static bool MCAF_OverrideZeroSequenceModulation(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
353:               {
354:               #ifdef MCAF_TEST_HARNESS
355:                   return ptest->overrides & TEST_OVERRIDE_ZERO_SEQUENCE_MODULATION;
000002  000000     NOP
0069CE  92A868     MOV [W8+732], W0
356:               #else
357:                   return false;
358:               #endif
359:               }
360:               
361:               /**
362:                * Returns zero sequence offset override.
363:                * 
364:                * @param ptest testing state
365:                * @return zero sequence offset override
366:                */
367:               inline static MCAF_U_DUTYCYCLE MCAF_GetOverrideZeroSequenceOffset(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
368:               {
369:               #ifdef MCAF_TEST_HARNESS
370:                   return ptest->overrideZeroSequenceOffset;
000066  000920     NOP
006A26  92B038     MOV [W8+742], W0
371:               #else
372:                   return 0;
373:               #endif
374:               }
375:               
376:               /**
377:                * Returns <code>true</code> if we're in a normal operating mode.
378:                * 
379:                * @param ptest testing state
380:                * @return <code>true</code> if we're in a normal operating mode.
381:                */
382:               inline static bool MCAF_OperatingModeNormal(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
383:               {
384:               #ifdef MCAF_TEST_HARNESS
385:                   return ptest->operatingMode == OM_NORMAL;
0067EC  92B048     MOV [W8+744], W0
386:               #else
387:                   return true;
388:               #endif
389:               }
390:               
391:               /**
392:                * Returns <code>true</code> if we're in an operating mode where the current loop is active
393:                * 
394:                * @param ptest testing state
395:                * @return <code>true</code> if we're in an operating mode where the current loop is active
396:                */
397:               inline static bool MCAF_OperatingModeCurrentLoopActive(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
398:               {
399:               #ifdef MCAF_TEST_HARNESS
400:                   return ptest->operatingMode >= OM_FORCE_CURRENT;
00687E  92B048     MOV [W8+744], W0
401:               #else
402:                   return true;
403:               #endif
404:               }
405:               
406:               /**
407:                * Returns test perturbation velocity 
408:                * 
409:                * @param ptest testing state 
410:                * @return test perturbation velocity
411:                */
412:               inline static MCAF_U_VELOCITY_ELEC MCAF_TestPerturbationVelocity(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
413:               {
414:               #ifdef MCAF_TEST_HARNESS
415:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
416:                   return ptest->sqwave.value * ptest->sqwave.velocity.electrical;
0067F8  92A838     MOV [W8+726], W0
0067FA  92A368     MOV [W8+716], W6
0067FE  B9B380     MULW.SS W6, W0, W6
417:                 #else
418:                   return ptest->perturb.enable * ptest->perturb.activePhase->velocity.electrical;
419:                 #endif
420:               #else
421:                   return 0;
422:               #endif
423:               }
424:               
425:               /**
426:                * Returns test perturbation q-axis current
427:                * 
428:                * @param ptest testing state 
429:                * @return test perturbation q-axis current
430:                */
431:               inline static int16_t MCAF_TestPerturbationIq(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
432:               {
433:               #ifdef MCAF_TEST_HARNESS
434:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
435:                   return ptest->sqwave.value * ptest->sqwave.idq.q;
006884  92A838     MOV [W8+726], W0
006886  92A908     MOV [W8+720], W2
006888  B99180     MULW.SS W2, W0, W2
436:                 #else
437:                   return ptest->perturb.enable * ptest->perturb.activePhase->idq.q;
438:                 #endif
439:               #else
440:                   return 0;
441:               #endif
442:               }
443:               
444:               /**
445:                * Returns test perturbation d-axis current
446:                * 
447:                * @param ptest testing state 
448:                * @return test perturbation d-axis current
449:                */
450:               inline static int16_t MCAF_TestPerturbationId(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
451:               {
452:               #ifdef MCAF_TEST_HARNESS
453:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
454:                   return ptest->sqwave.value * ptest->sqwave.idq.d;
006890  92A838     MOV [W8+726], W0
006892  92A178     MOV [W8+718], W2
006894  B99080     MULW.SS W2, W0, W0
455:                 #else
456:                   return ptest->perturb.enable * ptest->perturb.activePhase->idq.d;
457:                 #endif
458:               #else
459:                return 0;
460:               #endif
461:               }
462:               
463:               /**
464:                * Returns test perturbation q-axis voltage
465:                * 
466:                * @param ptest testing state 
467:                * @return test perturbation q-axis voltage
468:                */
469:               inline static int16_t MCAF_TestPerturbationVq(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
470:               {
471:               #ifdef MCAF_TEST_HARNESS
472:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
473:                   return ptest->sqwave.value * ptest->sqwave.vdq.q;
006920  92A838     MOV [W8+726], W0
006922  92A8A8     MOV [W8+724], W1
006924  B98880     MULW.SS W1, W0, W0
00692E  92A838     MOV [W8+726], W0
006930  92A8A8     MOV [W8+724], W1
006932  B98880     MULW.SS W1, W0, W0
474:                 #else
475:                   return ptest->perturb.enable * ptest->perturb.activePhase->vdq.q;
476:                 #endif
477:               #else
478:                   return 0;
479:               #endif
480:               }
481:               
482:               /**
483:                * Returns test perturbation d-axis voltage
484:                * 
485:                * @param ptest testing state 
486:                * @return test perturbation d-axis voltage
487:                */
488:               inline static int16_t MCAF_TestPerturbationVd(const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
489:               {
490:               #ifdef MCAF_TEST_HARNESS
491:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
492:                   return ptest->sqwave.value * ptest->sqwave.vdq.d;
0068BC  92A838     MOV [W8+726], W0
0068BE  92A898     MOV [W8+722], W1
0068C0  B98880     MULW.SS W1, W0, W0
00693A  92A838     MOV [W8+726], W0
00693C  92A898     MOV [W8+722], W1
00693E  B98880     MULW.SS W1, W0, W0
493:                 #else
494:                   return ptest->perturb.enable * ptest->perturb.activePhase->vdq.d;
495:                 #endif
496:               #else
497:                   return 0;
498:               #endif
499:               }
500:               
501:               /**
502:                * Reinitializes state variables.
503:                * 
504:                * @param ptest testing state
505:                */
506:               void MCAF_TestHarness_Restart(volatile MCAF_MOTOR_TEST_MANAGER *ptest);
507:               
508:               /**
509:                * Initializes system-wide state variables.
510:                * 
511:                * @param ptest testing state
512:                */
513:               void MCAF_SystemTestHarness_Init(volatile MCAF_SYSTEM_TEST_MANAGER *ptest);
514:               
515:               /**
516:                * Returns whether a clean test restart is required 
517:                * 
518:                * @param ptest testing state
519:                * @return true if clean test restart is required
520:                */
521:               inline static bool MCAF_TestHarness_TestRestartRequired(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
522:               {
523:               #ifdef MCAF_TEST_HARNESS
524:                   return ptest->testRestartRequired;
004B1E  202ED0     MOV #0x2ED, W0
004B20  400008     ADD W0, W8, W0
525:               #else
526:                   return false;
527:               #endif
528:               }
529:               
530:               /**
531:                * Clear restart flag: clean test restart is no longer required
532:                * 
533:                * @param ptest testing state
534:                */
535:               inline static void MCAF_TestHarness_ClearRestartRequired(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
536:               {
537:               #ifdef MCAF_TEST_HARNESS
538:                   ptest->testRestartRequired = false;
004E3E  202ED0     MOV #0x2ED, W0
004E40  400008     ADD W0, W8, W0
004E42  EB4800     CLR.B [W0]
00960A  986051     MOV.B W1, [W0+37]
539:               #endif
540:               }
541:               
542:               /**
543:                * Return commutation frequency used when commutation inputs are overridden by the test harness
544:                * 
545:                * @param ptest testing state
546:                * @return commutation frequency
547:                */
548:               inline static MCAF_U_VELOCITY_DTHETA_ELEC_DT MCAF_GetOverrideCommutationFrequency (volatile MCAF_MOTOR_TEST_MANAGER *ptest)
549:               {
550:               #ifdef MCAF_TEST_HARNESS
551:                   /* return overrideOmegaElectrical for k cycles, 0 for N-k cycles,
552:                    * where N-1 = overrideCommutationOnOff.maxCount
553:                    * and k = overrideCommutationOnOff.threshold
554:                    */
555:                   volatile MCAF_TEST_COMMUTATION_ON_OFF_T *pOnOff = &ptest->overrideCommutationOnOff;
556:                   if (pOnOff->counter == 0)
00721E  92B018     MOV [W8+738], W0
007220  E00000     CP0 W0
007222  3A0003     BRA NZ, .L5
557:                   {
558:                       pOnOff->counter = pOnOff->maxCount;
007224  92B008     MOV [W8+736], W0
007226  9AB410     MOV W0, [W8+738]
007228  370003     BRA .L6
559:                   }
560:                   else
561:                   {
562:                       --pOnOff->counter;
00722A  92B018     MOV [W8+738], W0
00722C  E90000     DEC W0, W0
00722E  9AB410     MOV W0, [W8+738]
563:                   }
564:                   
565:                   if (pOnOff->counter < pOnOff->threshold)
007230  92B118     MOV [W8+738], W2
007232  92B0A8     MOV [W8+740], W1
007236  510F81     SUB W2, W1, [W15]
007238  310022     BRA C, .LBE124, .LBE136, .L7
566:                   {
567:                       return ptest->overrideOmegaElectrical;
00723A  92A878     MOV [W8+734], W0
00723C  370020     BRA .LBE124, .LBE136, .L7
568:                   }
569:                   else
570:                   {
571:                       return 0;
007234  EB0000     CLR W0
572:                   }
573:               #else
574:                   return 0;
575:               #endif
576:               }
577:               
578:               inline static void MCAF_TestHarness_Init(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
579:               {
580:               #ifdef MCAF_TEST_HARNESS
581:                   ptest->operatingMode = OM_NORMAL;
0079C6  200030     MOV #0x3, W0
0079C8  9AB440     MOV W0, [W8+744]
582:                   ptest->forceStateChange = TEST_FORCE_STATE_INACTIVE;
0079CA  9AB459     MOV W9, [W8+746]
583:                   ptest->stopNow = false;
0079CC  202EC0     MOV #0x2EC, W0
0079CE  400008     ADD W0, W8, W0
0079D0  784809     MOV.B W9, [W0]
584:               #endif
585:               }
586:               
587:               inline static MCAF_OPERATING_MODE MCAF_GetOperatingMode (const volatile MCAF_MOTOR_TEST_MANAGER *ptest)
588:               {
589:               #ifdef MCAF_TEST_HARNESS
590:                   return ptest->operatingMode;
004B16  92B048     MOV [W8+744], W0
591:               #else
592:                   return OM_NORMAL;
593:               #endif
594:               }
595:               
596:               inline static void MCAF_TestPerturbationUpdate(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
597:               {
598:               #ifdef MCAF_TEST_HARNESS
599:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
600:                   const int16_t value = ptest->sqwave.value;
004F0A  92A838     MOV [W8+726], W0
601:                   /* update test perturbation waveform */
602:                   if (value != 0)
004F0C  E00000     CP0 W0
004F0E  320016     BRA Z, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
603:                   {
604:                       /* Ensure square wave value maintains sign and is +/- 1 */
605:                       const int16_t valueLimited = UTIL_SignFromHighBit(value);
606:                       
607:                       /*
608:                        * Reverse sign after N cycles (N = sqwave.halfperiod)
609:                        */
610:                       if (++ptest->sqwave.count >= ptest->sqwave.halfperiod)
004F14  92A948     MOV [W8+728], W2
004F16  92A9D8     MOV [W8+730], W3
004F18  410161     ADD W2, #0x1, W2
004F1A  4981E0     ADDC W3, #0x0, W3
004F1C  9AAC42     MOV W2, [W8+728]
004F1E  9AAC53     MOV W3, [W8+730]
004F20  92AA48     MOV [W8+728], W4
004F22  92AAD8     MOV [W8+730], W5
004F24  92A148     MOV [W8+712], W2
004F26  92A1D8     MOV [W8+714], W3
004F28  520F82     SUB W4, W2, [W15]
004F2A  5A8F83     SUBB W5, W3, [W15]
004F2C  390006     BRA NC, .L72
611:                       {
612:                           ptest->sqwave.value = -valueLimited;
004F2E  EA0000     NEG W0, W0
004F30  9AAC30     MOV W0, [W8+726]
613:                           ptest->sqwave.count = 0;
004F32  B81160     MUL.UU W2, #0x0, W2
004F34  9AAC42     MOV W2, [W8+728]
004F36  9AAC53     MOV W3, [W8+730]
004F38  370001     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
614:                       }    
615:                       else
616:                       {
617:                           ptest->sqwave.value = valueLimited;
004F3A  9AAC30     MOV W0, [W8+726]
618:                       }
619:                   }
620:                 #else // MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC == 0
621:                   if (ptest->perturb.enable == 0)
622:                   {
623:                       return;
624:                   }
625:                   
626:                   ptest->perturb.enable = UTIL_SignFromHighBit(ptest->perturb.enable);
627:                   if (++ptest->perturb.count >= ptest->perturb.activePhase->duration)
628:                   {
629:                       // Time to start over and switch phases!
630:                       ptest->perturb.count = 0;
631:                       ptest->perturb.flags ^= MCAF_TPF_PHASE;
632:               
633:                       const int16_t newphase = ptest->perturb.flags & MCAF_TPF_PHASE;
634:                       volatile MCAF_TEST_PERTURB_PHASE * const activePhase = 
635:                           &ptest->perturb.phase[newphase];
636:                       ptest->perturb.activePhase = activePhase;
637:                       if (activePhase->duration == 0)
638:                       {
639:                           /* Do we need to produce some number of steps? */
640:                           if (ptest->perturb.step.count > 1)
641:                           {
642:                               --ptest->perturb.step.count;
643:                               ptest->perturb.phase[0].idq.q += ptest->perturb.step.idq.q;
644:                               ptest->perturb.phase[0].idq.d += ptest->perturb.step.idq.d;
645:                           }
646:                           else
647:                           {
648:                               /* deactivate so that user just has to set perturb.enable = 1
649:                                */
650:                               ptest->perturb.enable = 0;
651:                           }
652:                           
653:                           /* reset to phase 0 */
654:                           ptest->perturb.flags &= ~MCAF_TPF_PHASE;
655:                           ptest->perturb.activePhase = &ptest->perturb.phase[0];
656:                       }
657:                       else
658:                       {
659:                           const uint16_t alpha = ptest->perturb.autobalanceRatio;
660:                           if (alpha > 0 && newphase != 0)
661:                           {
662:                               /*
663:                                * Autobalance: set phase[1] values to be scaled from phase[0] values
664:                                * by the same ratio alpha, and invert sign.
665:                                */
666:                               const volatile MCAF_TEST_PERTURB_PHASE *phase0 = &ptest->perturb.phase[0];
667:                               activePhase->velocity.electrical = UTIL_MulUSQ16(alpha, phase0->velocity.electrical);
668:                               activePhase->idq.d = UTIL_MulUSQ16(alpha, phase0->idq.d);
669:                               activePhase->idq.q = UTIL_MulUSQ16(alpha, phase0->idq.q);
670:                               activePhase->vdq.d = UTIL_MulUSQ16(alpha, phase0->vdq.d);
671:                               activePhase->vdq.q = UTIL_MulUSQ16(alpha, phase0->vdq.q);
672:                               ptest->perturb.enable = -1;
673:                           }
674:                           else
675:                           {
676:                               ptest->perturb.enable = 1;
677:                           }
678:                       }
679:                   }    
680:                 #endif // MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
681:               #endif
682:               }
683:               
684:               /**
685:                * Guards test state variables by resetting them to default values
686:                * if the specified system-wide guard key is not valid.
687:                * 
688:                * @param ptest test state
689:                * @param psystest system-wide test state
690:                */
691:               inline static void MCAF_TestGuard(volatile MCAF_MOTOR_TEST_MANAGER *ptest, 
692:                                                  const volatile MCAF_SYSTEM_TEST_MANAGER *psystest)
693:               {
694:               #ifdef MCAF_TEST_HARNESS
695:                   if (psystest->guard.key != TEST_GUARD_VALID)
004EF8  9000C0     MOV [W0+8], W1
004EFA  2D1A60     MOV #0xD1A6, W0
004EFC  508F80     SUB W1, W0, [W15]
004EFE  320005     BRA Z, MCAF_SystemStateMachine_StepIsr::MCAF_MotorControllerOnAllStatesLowPriority::MCAF_TestPerturbationUpdate
696:                   {
697:                       ptest->overrides     = 0;
004F00  EB0000     CLR W0
004F02  9AAC60     MOV W0, [W8+732]
698:                       ptest->operatingMode = OM_NORMAL;
004F04  200031     MOV #0x3, W1
004F06  9AB441     MOV W1, [W8+744]
699:                 #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
700:                       ptest->sqwave.value  = 0;
004F08  9AAC30     MOV W0, [W8+726]
701:                 #else
702:                       ptest->perturb.enable = 0;
703:                 #endif
704:                   }
705:               #endif
706:               }
707:               
708:               #ifdef MCAF_TEST_HARNESS
709:               /**
710:                * Causes a "seizure" (infinite loop) if the guard key is valid and
711:                * the flags are tested against a mask.
712:                * 
713:                * @param psystest system-wide test state
714:                * @param mask test mask
715:                */
716:               inline static bool MCAF_TestHarness_CheckFlags(
717:                   const volatile MCAF_SYSTEM_TEST_MANAGER *psystest,
718:                   uint16_t mask)
719:               {
720:               
721:                   return ((psystest->guard.key == TEST_GUARD_VALID)
000AD4  818C61     MOV 0x318C, W1
00916E  818C61     MOV 0x318C, W1
00918C  818C61     MOV 0x318C, W1
722:                        && (psystest->flags & mask));
000AD6  2D1A60     MOV #0xD1A6, W0
000AD8  508F80     SUB W1, W0, [W15]
000ADA  3A0005     BRA NZ, _ADCAN15Interrupt::MCAF_CaptureTimestamp
000ADC  818C50     MOV 0x318A, W0
000ADE  A31800     BTST.Z W0, #1
000AE0  320002     BRA Z, _ADCAN15Interrupt::MCAF_CaptureTimestamp
009170  2D1A60     MOV #0xD1A6, W0
009172  508F80     SUB W1, W0, [W15]
009174  3A000B     BRA NZ, .L4
009176  818C50     MOV 0x318A, W0
009178  A30800     BTST.Z W0, #0
00917A  320008     BRA Z, .L4
009180  818C50     MOV 0x318A, W0
009182  A32800     BTST.Z W0, #2
009184  320001     BRA Z, .LBE41, .L6
00918E  2D1A60     MOV #0xD1A6, W0
009190  508F80     SUB W1, W0, [W15]
009192  3AFFFA     BRA NZ, .LBE41, .L6
009194  37FFF5     BRA MCAF_MainLoop::MCAF_TestHarnessStepMain::MCAF_TestHarness_CheckFlags
009196  EF2140     CLR QEI1CON
723:               }
724:               
725:               inline static void MCAF_TestHarness_TriggerSeizure()
726:               {
727:                   while (true)
728:                   {
729:                       __builtin_nop(); /* prevent the compiler from optimizing this loop out */
000AE2  000000     NOP
000AE4  37FFFE     BRA _ADCAN15Interrupt::MCAF_TestHarnessStepIsr::MCAF_TestHarness_TriggerSeizure
00917C  000000     NOP
00917E  37FFFE     BRA MCAF_MainLoop::MCAF_TestHarnessStepMain::MCAF_TestHarness_TriggerSeizure
730:                   }
731:               }
732:               #endif
733:               
734:               inline static void MCAF_TestHarnessStepIsr(const volatile MCAF_SYSTEM_TEST_MANAGER *psystest)
735:               {
736:               #ifdef MCAF_TEST_HARNESS
737:                   if (MCAF_TestHarness_CheckFlags(psystest, TEST_FLAGS_SEIZURE_ISR))
738:                   {
739:                       MCAF_TestHarness_TriggerSeizure();
740:                   }
741:               #endif
742:               }
743:               
744:               inline static void MCAF_TestHarnessHandleForceStateChange(volatile MCAF_MOTOR_TEST_MANAGER *ptest, volatile bool *prun)
745:               {
746:               #ifdef MCAF_TEST_HARNESS
747:                   if (ptest->forceStateChange != TEST_FORCE_STATE_INACTIVE)
00848C  92B0D0     MOV [W0+746], W1
00848E  E00001     CP0 W1
008490  320015     BRA Z, .LBE1985, .L114
748:                   {
749:                       switch (ptest->forceStateChange)
008492  92B0D0     MOV [W0+746], W1
008494  508FE2     SUB W1, #0x2, [W15]
008496  320007     BRA Z, .L126
008498  508FE3     SUB W1, #0x3, [W15]
00849A  320008     BRA Z, .L127
00849C  508FE1     SUB W1, #0x1, [W15]
00849E  3A000C     BRA NZ, .L124
750:                       {
751:                           case TEST_FORCE_STATE_RUN:
752:                               *prun = true;
0084A0  B3C011     MOV.B #0x1, W1
0084A2  9BE841     MOV.B W1, [W0+492]
0084A4  370009     BRA .L124
753:                               break;
754:                           case TEST_FORCE_STATE_STOP:
755:                               *prun = false;
0084A6  EB4080     CLR.B W1
0084A8  9BE841     MOV.B W1, [W0+492]
0084AA  370006     BRA .L124
756:                               break;
757:                           case TEST_FORCE_STATE_STOP_NOW:
758:                               *prun = false;
0084AC  EB4080     CLR.B W1
0084AE  9BE841     MOV.B W1, [W0+492]
759:                               ptest->stopNow = true;
0084B0  202EC1     MOV #0x2EC, W1
0084B2  408080     ADD W1, W0, W1
0084B4  B3C012     MOV.B #0x1, W2
0084B6  784882     MOV.B W2, [W1]
760:                               break;
761:                           default:
762:                               /* no action */
763:                               break;
764:                       }        
765:                       ptest->forceStateChange = TEST_FORCE_STATE_INACTIVE;
0084B8  EB0080     CLR W1
0084BA  9AB051     MOV W1, [W0+746]
766:                   }
767:               #endif
768:               }
769:               
770:               inline static bool MCAF_TestHarnessCheckStopNowAndReset(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
771:               {
772:               #ifdef MCAF_TEST_HARNESS
773:                   const bool result = ptest->stopNow;
004A88  202EC0     MOV #0x2EC, W0
004A8A  400008     ADD W0, W8, W0
004A8C  784090     MOV.B [W0], W1
774:                   ptest->stopNow = false;
004A8E  EB4800     CLR.B [W0]
775:                   return result;
776:               #else
777:                   return false;
778:               #endif    
779:               }
780:               
781:               #ifdef MCAF_TEST_HARNESS
782:               /**
783:                * Causes a stack overflow.
784:                */
785:               void MCAF_TestHarness_TriggerStackOverflow(void);
786:               #endif
787:               
788:               inline static void MCAF_TestHarnessStepMain(const volatile MCAF_SYSTEM_TEST_MANAGER *psystest)
789:               {
790:               #ifdef MCAF_TEST_HARNESS
791:                   if (MCAF_TestHarness_CheckFlags(psystest, TEST_FLAGS_SEIZURE_MAINLOOP))
792:                   {
793:                       MCAF_TestHarness_TriggerSeizure();
794:                   }
795:                   if (MCAF_TestHarness_CheckFlags(psystest, TEST_FLAGS_STACK_OVERFLOW))
796:                   {
797:                       MCAF_TestHarness_TriggerStackOverflow();
009186  0706D9     RCALL MCAF_TestHarness_TriggerStackOverflow
798:                   }
799:               #endif
800:               }
801:               
802:               /**
803:                * Capture a timestamp, for diagnostic purposes. 
804:                * Optimized out if MCAF_TEST_PROFILING is not enabled
805:                * 
806:                * @param ptest test state
807:                * @param k timestamp slot -- this should be known at compile time so the
808:                *                            compiler can optimize out the if-test
809:                */
810:               inline static void MCAF_CaptureTimestamp(volatile MCAF_MOTOR_TEST_MANAGER *ptest, int k)
811:               {
812:               #ifdef MCAF_TEST_PROFILING
813:                   if (k >= 0 && k < MCAF_PROFILING_TIMESTAMP_CAPACITY)
814:                   {
815:                       ptest->timestamps[k] = HAL_ProfilingCounter_Get() - ptest->timestampReference;
000AE8  230EE8     MOV #0x30EE, W8
000AEA  230FC0     MOV #0x30FC, W0
000AEC  508818     SUB W1, [W8], [W0]
000AF2  230FE0     MOV #0x30FE, W0
000AF4  508818     SUB W1, [W8], [W0]
00499A  92B078     MOV [W8+750], W0
00499C  508000     SUB W1, W0, W0
00499E  9ABC00     MOV W0, [W8+752]
0049B2  92B078     MOV [W8+750], W0
0049B4  508000     SUB W1, W0, W0
0049B6  9ABC10     MOV W0, [W8+754]
004B34  92B078     MOV [W8+750], W0
004B36  508000     SUB W1, W0, W0
004B38  9ABC20     MOV W0, [W8+756]
004EEC  92B078     MOV [W8+750], W0
004EEE  508000     SUB W1, W0, W0
004EF0  9ABC30     MOV W0, [W8+758]
004F3E  92B078     MOV [W8+750], W0
004F40  508000     SUB W1, W0, W0
004F42  9ABC40     MOV W0, [W8+760]
816:                   }
817:               #endif
818:               }
819:               
820:               /**
821:                * Initialize average calculation routine. This must be called before running
822:                * MCAF_TriggeredAverage_Step().
823:                * 
824:                * @param ptrigavg trigger average data
825:                * @param sampleCount number of samples to average
826:                * @param shiftCount number of right-shifts to compute average
827:                */
828:               inline static void MCAF_TriggeredAverage_Init(MCAF_TRIGGERED_AVERAGE_T *ptrigavg,
829:                                                                   uint16_t sampleCount,
830:                                                                   uint16_t shiftCount)
831:               {
832:               #ifdef MCAF_TEST_HARNESS
833:                   ptrigavg->triggerActive = false;
834:                   ptrigavg->sampleCount = sampleCount;
835:                   ptrigavg->shiftCount = shiftCount;
836:                   ptrigavg->count = sampleCount;
837:                   ptrigavg->sum = 0;
838:                   ptrigavg->average = 0;
839:               #endif
840:               }
841:               
842:               /**
843:                * Executes one step of the average calculation routine. When the desired sample
844:                * number is reached, the average of the samples is calculated and the routine 
845:                * is reset and disabled.
846:                * 
847:                * @param ptrigavg trigger average data
848:                * @param input variable to average
849:                */
850:               inline static void MCAF_TriggeredAverage_Step(MCAF_TRIGGERED_AVERAGE_T *ptrigavg,
851:                                                                   int16_t input)
852:               {
853:               #ifdef MCAF_TEST_HARNESS
854:                   if (ptrigavg->triggerActive)
855:                   {
856:                       ptrigavg->sum += input;
857:                       if (--ptrigavg->count == 0)
858:                       {
859:                           ptrigavg->average = UTIL_ShrS32N16(ptrigavg->sum, ptrigavg->shiftCount);
860:                           ptrigavg->count = ptrigavg->sampleCount;
861:                           ptrigavg->sum = 0;
862:                           ptrigavg->triggerActive = false;
863:                       }
864:                   }
865:               #endif
866:               }
867:               
868:               #ifdef __cplusplus
869:               }
870:               #endif
871:               
872:               #endif /* __TEST_HARNESS_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/test_harness.c
1:                 /**
2:                  * test_harness.c
3:                  * 
4:                  * Test harness definitions
5:                  * 
6:                  * Component: test harness
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include "test_harness.h"
48:                
49:                void MCAF_TestHarness_Restart(volatile MCAF_MOTOR_TEST_MANAGER *ptest)
50:                {
51:                #ifdef MCAF_TEST_HARNESS 
52:                  #if MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC
53:                    ptest->sqwave.idq.d = 0;
0095EA  EB0080     CLR W1
0095EC  980031     MOV W1, [W0+6]
54:                    ptest->sqwave.idq.q = 0;
0095EE  980041     MOV W1, [W0+8]
55:                    ptest->sqwave.vdq.d = 0;
0095F0  980051     MOV W1, [W0+10]
56:                    ptest->sqwave.vdq.q = 0;
0095F2  980061     MOV W1, [W0+12]
57:                    ptest->sqwave.velocity.electrical = 0;
0095F4  980021     MOV W1, [W0+4]
58:                    ptest->sqwave.value = 0;
0095F6  980071     MOV W1, [W0+14]
59:                    ptest->sqwave.count = 0;
0095F8  B81160     MUL.UU W2, #0x0, W2
0095FA  980802     MOV W2, [W0+16]
0095FC  980813     MOV W3, [W0+18]
60:                  #else // MCAF_TEST_HARNESS_PERTURBATION_SYMMETRIC == 0
61:                    int16_t i;
62:                    for (i = 0; i < 2; ++i)
63:                    {
64:                        volatile MCAF_TEST_PERTURB_PHASE *phase = &ptest->perturb.phase[i];
65:                        phase->idq.d = 0;
66:                        phase->idq.q = 0;
67:                        phase->vdq.d = 0;
68:                        phase->vdq.q = 0;
69:                        phase->velocity.electrical = 0;
70:                        phase->duration = 0;
71:                    }
72:                    ptest->perturb.flags = 0;
73:                    ptest->perturb.enable = 0;
74:                    ptest->perturb.count = 0;
75:                    ptest->perturb.autobalanceRatio = 0;
76:                    ptest->perturb.activePhase = &ptest->perturb.phase[0];
77:                    ptest->perturb.step.idq.d = 0;
78:                    ptest->perturb.step.idq.q = 0;
79:                    ptest->perturb.step.count = 0;
80:                  #endif
81:                    ptest->overrides = 0;
0095FE  980821     MOV W1, [W0+20]
82:                    ptest->overrideOmegaElectrical = 0;
009600  980831     MOV W1, [W0+22]
83:                    ptest->overrideCommutationOnOff.maxCount = 0;
009602  980841     MOV W1, [W0+24]
84:                    ptest->overrideCommutationOnOff.threshold = 1;
009604  200012     MOV #0x1, W2
009606  980862     MOV W2, [W0+28]
85:                    ptest->overrideZeroSequenceOffset = 0;
009608  980871     MOV W1, [W0+30]
86:                    MCAF_TestHarness_ClearRestartRequired(ptest);
87:                #endif
88:                }
00960C  060000     RETURN
00960E  22B1E1     MOV #0x2B1E, W1
89:                
90:                void MCAF_SystemTestHarness_Init(volatile MCAF_SYSTEM_TEST_MANAGER *ptest)
91:                {
92:                    ptest->flags = 0;
009DF2  EB0080     CLR W1
009DF4  780801     MOV W1, [W0]
93:                    ptest->guard.key = TEST_GUARD_RESET;
009DF6  980011     MOV W1, [W0+2]
94:                }
009DF8  060000     RETURN
009DFA  B02C60     ADD #0x2C6, W0
95:                
96:                #ifdef MCAF_TEST_HARNESS
97:                static uint16_t stack_overflow_helper(void)
98:                {
009C0E  FA0010     LNK #0x10
99:                    volatile uint16_t wasted_space[8];
100:                   wasted_space[0] = 0;
009C10  EB0000     CLR W0
009C12  9FBF80     MOV W0, [W15-16]
101:                   return stack_overflow_helper() + wasted_space[0];
009C14  07FFFC     RCALL stack_overflow_helper
009C16  97B88F     MOV [W15-16], W1
009C18  400001     ADD W0, W1, W0
102:               }
009C1A  FA8000     ULNK
009C1C  060000     RETURN
103:               
104:               void MCAF_TestHarness_TriggerStackOverflow(void)
105:               {
106:                   stack_overflow_helper();
009F3A  07FE69     RCALL stack_overflow_helper
107:               }
009F3C  060000     RETURN
009F3E  07FEB7     RCALL UART1_IsTxReady
108:               #endif
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/system_state.h
1:                 /**
2:                  * system_state.h
3:                  * 
4:                  * Main system state variable structure definitions
5:                  * 
6:                  * Component: main application
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __SYSTEM_STATE_H
48:                #define __SYSTEM_STATE_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                
53:                #include "parameters/options.h" // pick up MCAF_INCLUDE_STALL_DETECT
54:                #include "motor_control_types.h"
55:                #include "units.h"
56:                #include "startup_types.h"
57:                #include "ui_types.h"
58:                #include "sat_PI_types.h"
59:                #include "stall_detect_types.h"
60:                #include "fault_detect_types.h"
61:                #include "state_machine_types.h"
62:                #include "recover.h"
63:                #include "monitor_types.h"
64:                #include "adc_compensation_types.h"
65:                #include "foc_types.h"
66:                #include "test_harness.h"
67:                #include "commutation_types.h"
68:                #include "board_service_types.h"
69:                #include "deadtimecomp_types.h"
70:                #include "flux_control_types.h"
71:                #include "dyn_current_types.h"
72:                #include "current_measure_types.h"
73:                #include "hal/hardware_access_functions_types.h"
74:                #include "mcapi_types.h"
75:                
76:                #ifdef __cplusplus
77:                extern "C" {
78:                #endif
79:                
80:                /**
81:                 * Main system data. Variables are included here if they pertain
82:                 * to the entire system, not just one motor axis.
83:                 */
84:                typedef struct tagMCAF_SYSTEM_DATA
85:                {
86:                    /** measured DC link voltage */
87:                    MCAF_U_VOLTAGE vDC;
88:                    
89:                    /**
90:                     * Debugging counters for making sure we are aware of resets
91:                     * and how many times the motors have been stopped.
92:                     */
93:                    struct tagDebugCounters
94:                    {
95:                        uint16_t reset;   /** number of resets */
96:                        uint16_t stop;    /** number of times the motors have been stopped */
97:                    } debugCounters;
98:                        
99:                    volatile MCAF_SYSTEM_TEST_MANAGER testing;     /** system-wide test harness state */
100:                   MCAF_BOARD_DATA board;                         /** system-wide board state */
101:               } MCAF_SYSTEM_DATA;
102:               
103:               typedef struct tagBridgeTemperature {
104:                   uint16_t raw;               /** raw ADC reading */
105:                   MCAF_U_TEMPERATURE processed; /** scaled/processed temperature */
106:                   struct tagBridgeTemperatureFilter {
107:                       MCAF_U_TEMPERATURE output;   /** filter output */
108:                       uint16_t           gain;     /** filter gain */
109:                       sx1632_t           state;    /** filter state */            
110:                       int16_t            slewRate; /** slew rate */
111:                   } filter;        /** filtering */
112:                   uint16_t gain;              /** scaling gain */
113:                   int16_t  offset;            /** offset */
114:               } MCAF_BRIDGE_TEMPERATURE;       /** bridge temperature */
115:               
116:               
117:               /**
118:                * Motor state data
119:                */
120:               typedef struct tagMOTOR
121:               {
122:                   /* Current loop command */
123:                   MCAF_U_CURRENT_DQ        idqCmdRaw;  /** Input command for the current loops, prior to rate limiting */
124:                   MCAF_U_CURRENT_DQ        idqCmdPerturbed; /** Input command for the current loops, prior to rate limiting */
125:                   MCAF_U_CURRENT_DQ        idqCmd;     /** Input command for the current loops */
126:               
127:                   /* Current feedback path */
128:                   MCAF_U_CURRENT_ABC       iabc;       /** phase current measurements */
129:                   MCAF_U_CURRENT_ALPHABETA ialphabeta; /** stationary (alphabeta) frame current measurements */
130:                   MCAF_U_CURRENT           i0;         /** zero-sequence current = (Ia + Ib + Ic)/3 */
131:                   MCAF_U_CURRENT_DQ        idq;        /** rotating (dq) frame current measurements */
132:               
133:                   /* Current controllers */
134:                   MCAF_PISTATE_T      idCtrl;  /** controller state for the D axis */
135:                   MCAF_PISTATE_T      iqCtrl;  /** controller state for the Q axis */
136:                    
137:                   /** Output limit for each axis of the current loops, normalized to DC link voltage,
138:                    *  line-to-neutral, so that 0.57735 = 1/sqrt(3) = full line-to-line voltage */
139:                   MCAF_U_NORMVOLTAGE_DQ    idqCtrlOutLimit; 
140:                   
141:                   MCAF_DYNAMIC_CURRENT_LIMIT dynLimit;  /** dynamic current limit */
142:                   MCAF_U_CURRENT           iqCmdLimit;  /** maximum output current amplitude, q-axis */
143:                   
144:                   MCAF_STANDARD_INPUT_SIGNALS_T standardInputs;  /** standard input signals */
145:                   MCAF_MOTOR_PARAMETERS_T       motorParameters; /** motor parameters */
146:                   MCAF_BACKEMF_CALCULATION_T    backEMF;         /** quantities for estimated back-emf calculation */
147:               
148:                   /* Current loop forward path */
149:                   MCAF_U_VOLTAGE_DQ        vdqCmd;     /** desired dq-frame voltage, output of current loop */
150:                   MCAF_U_VOLTAGE_DQ        vdq;        /** desired dq-frame voltage */
151:                   MCAF_U_VOLTAGE_ALPHABETA valphabeta; /** desired alphabeta-frame voltage */
152:                   MCAF_U_VOLTAGE_ALPHABETA valphabetaPerturbed; /** desired alphabeta-frame voltage, after perturbation */
153:                   MCAF_U_VOLTAGE_ABC       vabc;       /** desired phase voltage */
154:                   MCAF_U_RVOLTAGE          rVdc;       /** reciprocal of DC link voltage */
155:                   MCAF_U_DUTYCYCLE_ABC     dabcRaw;    /** scaled duty cycle, per-unit, before dead-time compensation */
156:                   MCAF_DEAD_TIME_COMPENSATION deadTimeCompensation; /** dead-time compensation state */
157:                   MCAF_U_DUTYCYCLE_ABC     dabcUnshifted;  /** scaled duty cycle, per-unit, prior to ZSM and clipping */
158:                   MCAF_U_DUTYCYCLE_ABC     dabc;       /** after ZSM + clip */
159:                   MCAF_U_DUTYCYCLE_ALPHABETA dalphabetaOut[3]; /** convert dabc back to alpha-beta frame for estimators, with history */
160:                   MCAF_U_VOLTAGE_ALPHABETA valphabetaOut; /** value of applied alpha-beta voltage, including deadtime compensation */
161:                   MCAF_U_DUTYCYCLE_ABC pwmDutycycle;   /** PWM count */
162:                   MCAF_FLUX_CONTROL_STATE_T fluxControl; /** flux-control state */
163:                   MCAF_FILTER_LOW_PASS_S16_T vqFiltered; /** filtered q-axis voltage, for feedback purposes */
164:                   MCAF_CURRENT_MEASUREMENT currentMeasure; /** current measure state */
165:               
166:                   /* Angle and speed, including estimators */
167:                   MCAF_U_ANGLE_ELEC       thetaElectrical;  /** electrical angle */
168:                   MCAF_U_VELOCITY_ELEC    omegaElectrical;  /** electrical frequency */
169:                   MCAF_U_DIMENSIONLESS_SINCOS  sincos;     /** sine and cosine of electrical angle */
170:               
171:                   MCAF_ESTIMATOR_T estimator;  /** position and velocity estimator state */
172:               
173:                   /* Velocity loop */
174:                   MCAF_U_VELOCITY_ELEC    omegaCmd;   /** input command for the velocity loop */
175:                  
176:                   MCAF_PISTATE_T      omegaCtrl;  /** controller state for the velocity loop */
177:                   MCAF_VELOCITY_CONTROL_DATA velocityControl; /** Control inputs for the velocity loop */
178:                   MCAF_U_CURRENT    iqTorqueCmd;  /** output of the velocity loop */
179:                   uint16_t          controlFlags; /** MCAF_CTRL_FLAGS bitfields */
180:                   uint16_t          stateFlags;   /** MCAF_STATE_FLAGS bitfields */    
181:                   HAL_ADC_SELECT_T  adcSelect;    /** which channel we are scanning */
182:                   int16_t           potInput; /** potentiometer input */
183:                   
184:                   MCAF_BRIDGE_TEMPERATURE bridgeTemperature;  /** bridge temperature */
185:                   
186:                   /* open-loop to closed-loop transition */
187:                   MCAF_MOTOR_STARTUP_DATA    startup;  /** State variables for the startup code */
188:                   
189:                   MCAF_FSM_STATE      state;           /** motor control state machine state */
190:                   
191:                   /** counter for subsampling (e.g. executing something every N counts */
192:                   uint16_t subsampleCounter;            
193:                   
194:                   /** user interface data exchanged via main thread and ISR */
195:                   volatile MCAF_UI_DATA ui;
196:               #if MCAF_INCLUDE_STALL_DETECT      
197:                   MCAF_STALL_DETECT_T stallDetect;     /** stall detect state */
198:               #endif
199:                   MCAF_FAULT_DETECT_T faultDetect;     /** fault detect state */
200:                   MCAF_RECOVERY_DATA_T recovery; /** recovery status */
201:                   MCAF_MONITOR_DATA_T monitor;   /** monitor data */
202:               
203:                   /** test harness state, used by ISR, may be shared with main thread in future */
204:                   volatile MCAF_MOTOR_TEST_MANAGER testing;
205:                   
206:                   MCAF_SYSTEM_DATA *psys;       /** pointer to shared system state */
207:                   MCAF_SAT_DETECT_T sat;        /** saturation detection */
208:                   MCAF_STOPPING_STATE stopping; /** Stopping timer state */
209:               
210:                   /** current calibration parameters */
211:                   MCAF_CURRENT_COMPENSATION_PARAMETERS currentCalibration;
212:                       
213:                   /** initialization */
214:                   MCAF_MOTOR_INITIALIZATION initialization;  
215:               
216:                   /** miscellaneous configurable parameters */
217:                   struct tagConfig {
218:                       /** number of ISR cycles to delay forward-path voltages
219:                        *  to match the delay of the current feedback signals
220:                        */
221:                       uint16_t deadTimeCompensationVoltageDelay;  
222:                   } config;
223:                   
224:                   /** MCAPI related shared data */
225:                   volatile MCAPI_MOTOR_DATA apiData;
226:                   /** MCAPI related feedback data in MCAF that is 
227:                    * published to the application through MCAPI */
228:                   MCAPI_FEEDBACK_SIGNALS apiFeedback;
229:                   
230:                   /** measured DC link voltage */
231:                   MCAF_U_VOLTAGE vDC;
232:                   
233:                   /** measured DC link current*/
234:                   MCAF_U_CURRENT iDC;
235:                   /** measured absolute voltage reference */
236:                   uint16_t vAbsRef;
237:               #if MCAF_TRIGGERED_AVERAGE_EXAMPLE == 1
238:                   MCAF_TRIGGERED_AVERAGE_T iqAverage;  /** Triggered average example implementation */
239:               #endif
240:               } MCAF_MOTOR_DATA;
241:               
242:               /**
243:                * Increments a running count each time the motor is requested to stop.
244:                * @param pmotor motor state
245:                */
246:               inline static void MCAF_IncrementStopCount(MCAF_MOTOR_DATA *pmotor)
247:               {
248:                   ++pmotor->psys->debugCounters.stop;
004D84  930008     MOV [W8+768], W0
004D86  9000A0     MOV [W0+4], W1
004D88  E80081     INC W1, W1
004D8A  980021     MOV W1, [W0+4]
249:               }
250:               
251:               /**
252:                * Returns the upper current limit value
253:                * @param pmotor motor data
254:                * @return upper current limit value
255:                */
256:               static inline int16_t MCAF_CurrentLimitIqUpperGet(volatile MCAF_MOTOR_DATA *pmotor)
257:               {
258:                   return pmotor->omegaCtrl.outMax;
259:               }
260:               
261:               /**
262:                * Returns the lower current limit value
263:                * @param pmotor motor data
264:                * @return lower current limit value
265:                */
266:               static inline int16_t MCAF_CurrentLimitIqLowerGet(volatile MCAF_MOTOR_DATA *pmotor)
267:               {
268:                   return pmotor->omegaCtrl.outMin;
269:               }
270:               
271:               /**
272:                * Gets the measured value of DC link voltage
273:                * @param pMotor motor data
274:                * @return measured value of DC link voltage
275:                */
276:               inline static int16_t MCAF_GetDcLinkVoltage(MCAF_MOTOR_DATA *pmotor)
277:               {
278:                   return pmotor->vDC;
279:               }
280:               
281:               /**
282:                * Mark the motor state as being out of closed-loop commutation
283:                * @param pmotor motor data
284:                */
285:               inline static void MCAF_ClearClosedLoopCommutation(MCAF_MOTOR_DATA *pmotor)
286:               {
287:                   pmotor->stateFlags &= ~MSF_CLOSED_LOOP_COMMUTATION;
288:               }
289:               
290:               /**
291:                * Mark the motor state as being in closed-loop commutation
292:                * @param pmotor motor data
293:                */
294:               inline static void MCAF_SetClosedLoopCommutation(MCAF_MOTOR_DATA *pmotor)
295:               {
296:                   pmotor->stateFlags |= MSF_CLOSED_LOOP_COMMUTATION;
297:               }
298:               
299:               /**
300:                * Is the motor in closed-loop commutation?
301:                * @param pmotor motor data
302:                * @return whether the motor is in closed-loop commutation
303:                */
304:               inline static bool MCAF_IsClosedLoopCommutation(const MCAF_MOTOR_DATA *pmotor)
305:               {
306:                   return pmotor->stateFlags & MSF_CLOSED_LOOP_COMMUTATION;
307:               }
308:               
309:               /**
310:                * Mark the motor state as being out of closed-loop current control
311:                * @param pmotor motor data
312:                */
313:               inline static void MCAF_ClearClosedLoopCurrent(MCAF_MOTOR_DATA *pmotor)
314:               {
315:                   pmotor->stateFlags &= ~MSF_CLOSED_LOOP_CURRENT;
316:               }
317:               
318:               /**
319:                * Mark the motor state as being in closed-loop current control
320:                * @param pmotor motor data
321:                */
322:               inline static void MCAF_SetClosedLoopCurrent(MCAF_MOTOR_DATA *pmotor)
323:               {
324:                   pmotor->stateFlags |= MSF_CLOSED_LOOP_CURRENT;
004CE4  918028     MOV [W8+388], W0
004CE6  A02000     BSET W0, #2
004CE8  998420     MOV W0, [W8+388]
325:               }
326:               
327:               /**
328:                * Is the motor in closed-loop current control?
329:                * @param pmotor motor data
330:                * @return whether the motor is in closed-loop current control
331:                */
332:               inline static bool MCAF_IsClosedLoopCurrent(const MCAF_MOTOR_DATA *pmotor)
333:               {
334:                   return pmotor->stateFlags & MSF_CLOSED_LOOP_CURRENT;
335:               }
336:               
337:               /**
338:                * Mark the motor state as being out of closed-loop velocity control
339:                * @param pmotor motor data
340:                */
341:               inline static void MCAF_ClearClosedLoopVelocity(MCAF_MOTOR_DATA *pmotor)
342:               {
343:                   pmotor->stateFlags &= ~MSF_CLOSED_LOOP_VELOCITY;
344:               }
345:               
346:               /**
347:                * Mark the motor state as being in closed-loop velocity control
348:                * @param pmotor motor data
349:                */
350:               inline static void MCAF_SetClosedLoopVelocity(MCAF_MOTOR_DATA *pmotor)
351:               {
352:                   pmotor->stateFlags |= MSF_CLOSED_LOOP_VELOCITY;
004D30  B300A0     IOR #0xA, W0
004D32  998420     MOV W0, [W8+388]
353:               }
354:               
355:               /**
356:                * Is the motor in closed-loop velocity control?
357:                * @param pmotor motor data
358:                * @return whether the motor is in closed-loop velocity control
359:                */
360:               inline static bool MCAF_IsClosedLoopVelocity(const MCAF_MOTOR_DATA *pmotor)
361:               {
362:                   return pmotor->stateFlags & MSF_CLOSED_LOOP_VELOCITY;
004D18  918028     MOV [W8+388], W0
0067F2  918028     MOV [W8+388], W0
363:               }
364:               
365:               /**
366:                * Clear all closed-loop flags
367:                * @param pmotor motor data
368:                */
369:               inline static void MCAF_ClearClosedLoopFlags(MCAF_MOTOR_DATA *pmotor)
370:               {
371:                   pmotor->stateFlags &= (~MSF_CLOSED_LOOP_COMMUTATION
004C86  9180A8     MOV [W8+388], W1
004C88  2FFF10     MOV #0xFFF1, W0
004C8A  608000     AND W1, W0, W0
004C8C  998420     MOV W0, [W8+388]
004D7C  9180A8     MOV [W8+388], W1
004D7E  2FFF10     MOV #0xFFF1, W0
004D80  608000     AND W1, W0, W0
004D82  998420     MOV W0, [W8+388]
004DC4  9180A8     MOV [W8+388], W1
004DC6  2FFF10     MOV #0xFFF1, W0
004DC8  608000     AND W1, W0, W0
004DCA  998420     MOV W0, [W8+388]
004DCC  37008E     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
372:                                        & ~MSF_CLOSED_LOOP_CURRENT
373:                                        & ~MSF_CLOSED_LOOP_VELOCITY);
374:               }
375:               
376:               /**
377:                * Initialize system state.
378:                * @param pmotor motor state data
379:                * @param psys system state data
380:                */
381:               void MCAF_SystemStateInit(MCAF_MOTOR_DATA *pmotor, MCAF_SYSTEM_DATA *psys);
382:               
383:               #ifdef __cplusplus
384:               }
385:               #endif
386:               
387:               #endif /* __SYSTEM_STATE_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/system_state.c
1:                 /**
2:                  * system_state.c
3:                  * 
4:                  * Main system state variable structure definitions
5:                  * 
6:                  * Component: main application
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include "system_state.h"
48:                
49:                void MCAF_SystemStateInit(MCAF_MOTOR_DATA *pmotor, MCAF_SYSTEM_DATA *psys)
50:                {
51:                    pmotor->psys = psys;
009F5E  9B0001     MOV W1, [W0+768]
52:                }
009F60  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/system_init.c
1:                 /**
2:                  * system_init.c
3:                  * 
4:                  * System initialization tasks
5:                  * 
6:                  * Component: main application
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include "system_state.h"
49:                #include "system_init.h"
50:                #include "diagnostics.h"
51:                #include "hal.h"
52:                #include "util.h"
53:                #include "timing.h"
54:                #include "parameters/options.h"
55:                
56:                /**
57:                 * Reset counter; incremented each time we have a reset and
58:                 * a new system initialization.
59:                 * 
60:                 * The persistent attribute is necessary to prevent the compiler's
61:                 * initialization code from overwriting it.
62:                 * 
63:                 * Unfortunately we can't put it into a larger structure;
64:                 * the compiler applies the "persistent" attribute to the entire object,
65:                 * so there's no way, for example, to mark one member of the main system
66:                 * structure (MCAF_SYSTEM_DATA) as persistent. So it "lives" here,
67:                 * and we copy it to the debugCounters.reset member of MCAF_SYSTEM_DATA.
68:                 */
69:                static uint16_t MCAF_resetCounter __attribute__ ((persistent, section("MCAF_persistent")));
70:                
71:                void MCAF_SystemInit(MCAF_SYSTEM_DATA *psys)
72:                {
73:                    psys->debugCounters.reset = ++MCAF_resetCounter;
0081E2  8092D1     MOV MCAF_resetCounter, W1
0081E4  E80081     INC W1, W1
0081E6  8892D1     MOV W1, MCAF_resetCounter
0081E8  980011     MOV W1, [W0+2]
74:                    
75:                    MCAF_PIN_MANAGER_Initialize();
0081EA  070EE9     RCALL MCAF_PIN_MANAGER_Initialize
76:                    HAL_Initialize();
0081EC  070EEA     RCALL HAL_Initialize
77:                    MCAF_ConfigurationPwmUpdate();
78:                    if (MCAF_OpAmpsEnabled())
79:                    {
80:                        HAL_OpAmpsEnable();
81:                        HAL_OpAmpsInputVoltageRangeSelect();
82:                    }
83:                    HAL_InterruptPrioritySet();
84:                    HAL_CMP_SetComparatorOvercurrentThreshold(HAL_PARAM_DAC_OVERCURRENT_THRESHOLD);
85:                    HAL_ADC_SignalsInit();
86:                    HAL_ADC_ResolutionInit();
87:                    HAL_ADC_Enable();
88:                    HAL_UART_ReconfigureIoMapping();
89:                    MCAF_DiagnosticsInit();
00825C  070E26     RCALL MCAF_DiagnosticsInit
90:                }
00825E  060000     RETURN
91:                
92:                void MCAF_SystemStart(MCAF_SYSTEM_DATA *psys)
93:                {
94:                    /* Output a short pulse as a testpoint signal,
95:                     * enable PWMs,
96:                     * enable ADC interrupt,
97:                     * begin main loop timing,
98:                     * and start board timer */
99:                
100:                   HAL_TestpointGp1_Activate();
101:                   MCAF_DelayNanoseconds(500);
102:                   HAL_TestpointGp1_Deactivate();
103:                   HAL_PWM_ADCTrigger1AEnable();
104:               
105:                   if (MCAF_SingleChannelEnabled())
106:                   {
107:                       HAL_PWM_ModeDualEdgeSingleUpdate();
108:                       HAL_PWM_SelectLocalPhase();
109:                       HAL_PWM_ADCTrigger2BEnable();
110:                       HAL_PWM_ADCTrigger2CEnable();
111:                   }
112:                   else
113:                   {
114:                       HAL_PWM_SelectMasterPhase();
115:                       
116:                       if (MCAF_IsDoubleUpdatePwmAllowed())
117:                       {
118:                           HAL_PWM_ModeDoubleUpdate();
119:                       }      
120:                       else
121:                       {
122:                           HAL_PWM_ModeSingleUpdate();
123:                       }
124:                   }
125:                   
126:                   HAL_PWM_ModuleEnable();
127:                   HAL_ADC_InterruptFlag_Clear();
128:                   HAL_ADC_Interrupt_Enable();
129:               }
008E04  060000     RETURN
008E06  500FE2     SUB W0, #0x2, [W15]
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/state_machine.c
1:                 /**
2:                  * state_machine.c
3:                  * 
4:                  * Top-level motor controller state-machine
5:                  * 
6:                  * Component: state machine
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include <stdbool.h>
49:                #include "system_state.h"
50:                #include "foc.h"
51:                #include "adc_compensation.h"
52:                #include "commutation.h"
53:                #include "parameters/hal_params.h"
54:                #include "parameters/operating_params.h"
55:                #include "parameters/timing_params.h"
56:                #include "parameters/options.h"
57:                #include "board_service.h"
58:                #include "hal.h"
59:                #include "recover.h"
60:                #include "stall_detect.h"
61:                #include "util.h"
62:                #include "monitor.h"
63:                #include "error_codes.h"
64:                #include "ui.h"
65:                #include "flux_control.h"
66:                #include "fault_detect.h"
67:                #include "test_harness.h"
68:                #include "current_measure.h"
69:                
70:                inline static void MCAF_SetPwmMinimalImpact(void)
71:                {
72:                    HAL_PWM_LowerTransistorsDutyCycle_Set(HAL_PARAM_PWM_PERIOD_COUNTS, 
73:                            HAL_PARAM_MIN_LOWER_DUTY_COUNTS);
74:                }
75:                
76:                /**
77:                 * Initializes PWM registers for normal operation and
78:                 * set a default "safe" duty cycle
79:                 */
80:                inline static void EnablePwmMinDuty(void)
81:                {
82:                    HAL_PWM_DutyCycle_SetIdentical(HAL_PARAM_MIN_DUTY_COUNTS);
83:                    HAL_PWM_UpperTransistorsOverride_Disable();
84:                }
85:                
86:                /**
87:                 * Resets stopping timer state.
88:                 * 
89:                 * @param pmotor motor state data
90:                 */
91:                inline static void MCAF_StoppingTimerReset(MCAF_MOTOR_DATA *pmotor)
92:                {
93:                    pmotor->stopping.timer.count = pmotor->stopping.timer.duration;
004D8C  930808     MOV [W8+784], W0
004D8E  930898     MOV [W8+786], W1
004D90  9B0C20     MOV W0, [W8+788]
004D92  9B0C31     MOV W1, [W8+790]
94:                    pmotor->stopping.timer.rate  = 1;
004D94  200010     MOV #0x1, W0
004D96  9B0C40     MOV W0, [W8+792]
95:                }
96:                
97:                /**
98:                 * Updates stopping timer state.
99:                 * 
100:                * @param pmotor motor state data
101:                * @return true if timer has expired
102:                */
103:               inline static bool MCAF_StoppingTimerUpdate(MCAF_MOTOR_DATA *pmotor)
104:               {
105:                   int32_t newcount = pmotor->stopping.timer.count - pmotor->stopping.timer.rate;
004A7E  930848     MOV [W8+792], W0
004A80  930928     MOV [W8+788], W2
004A82  9309B8     MOV [W8+790], W3
004A84  510100     SUB W2, W0, W2
004A86  5981E0     SUBB W3, #0x0, W3
106:                   const bool stopNow = MCAF_TestHarnessCheckStopNowAndReset(&pmotor->testing);
107:                   const bool expired = (newcount <= 0) || stopNow;
004A90  510FE0     SUB W2, #0x0, [W15]
004A92  598FE0     SUBB W3, #0x0, [W15]
004A94  340261     BRA LE, .L22
108:                                         
109:                   if (expired)
004A96  E00401     CP0.B W1
004A98  3A025F     BRA NZ, .L22
110:                   {
111:                       newcount = 0;
112:                   }
113:                   pmotor->stopping.timer.count = newcount;
004A9A  9B0C22     MOV W2, [W8+788]
004A9C  9B0C33     MOV W3, [W8+790]
004A9E  370011     BRA .L11
004F58  B80060     MUL.UU W0, #0x0, W0
004F5A  9B0C20     MOV W0, [W8+788]
004F5C  9B0C31     MOV W1, [W8+790]
114:                   return expired;
115:               }
116:               
117:               /** 
118:                * Reset state variables for recovery:
119:                * if there is user intervention and runRequested is no longer true,
120:                * we allow retry efforts to make a fresh start.
121:                */
122:               inline void MCAF_ResetRecoveryIfNotRunRequested(MCAF_MOTOR_DATA *pmotor)
123:               {
124:                   const bool runRequested = pmotor->ui.run;
004CAA  93E848     MOV.B [W8+492], W0
004D98  93E848     MOV.B [W8+492], W0
125:                   if (!runRequested)
004CAC  E00400     CP0.B W0
004CAE  3A011D     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004D9A  E00400     CP0.B W0
004D9C  3A00A6     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
126:                   {
127:                       MCAF_RecoveryReset(&pmotor->recovery);
004CB0  202BA0     MOV #0x2BA, W0
004CB2  400008     ADD W0, W8, W0
004CB4  0727C4     RCALL MCAF_RecoveryReset
004CB6  370119     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004D9E  202BA0     MOV #0x2BA, W0
004DA0  400008     ADD W0, W8, W0
004DA2  07274D     RCALL MCAF_RecoveryReset
004DA4  3700A2     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
128:                   }    
129:               }
130:               
131:               /**
132:                * Executes actions on entry to the STOPPED state.
133:                * 
134:                * @param pmotor motor state data
135:                */
136:               inline static void MCAF_MotorControllerOnStoppedInit(MCAF_MOTOR_DATA *pmotor)
137:               {
138:                   MCAF_SetPwmMinimalImpact();
139:                   MCAF_ClearClosedLoopFlags(pmotor);
140:                   MCAF_MonitorRecoveryAcknowledged(pmotor);
004C8E  780008     MOV W8, W0
004C90  0728B4     RCALL MCAF_MonitorRecoveryAcknowledged
141:                   MCAF_RecoverySetInputFlag(&pmotor->recovery, MCAF_RECOVERY_FSMI_STOP_COMPLETED);
142:               #if MCAF_INCLUDE_STALL_DETECT      
143:                   MCAF_StallDetectReset(&pmotor->stallDetect);
004C98  202000     MOV #0x200, W0
004C9A  400008     ADD W0, W8, W0
004C9C  072388     RCALL MCAF_StallDetectReset
144:                   MCAF_StallDetectDeactivate(&pmotor->stallDetect);
145:               #endif
146:                   MCAF_FaultDetectReset(&pmotor->faultDetect);
004CA4  202B20     MOV #0x2B2, W0
004CA6  400008     ADD W0, W8, W0
004CA8  0728FA     RCALL MCAF_FaultDetectReset
147:                   /* faults/failures are reset by re-init */
148:               }
149:               
150:               /**
151:                * Executes actions in the STOPPED state.
152:                * 
153:                * @param pmotor motor state data
154:                */
155:               inline static void MCAF_MotorControllerOnStopped(MCAF_MOTOR_DATA *pmotor)
156:               {    
157:                   MCAF_ResetRecoveryIfNotRunRequested(pmotor);
158:               }
159:               
160:               /**
161:                * Executes actions on entry to STARTING state.
162:                * 
163:                * @param pmotor motor state data
164:                */
165:               inline static void MCAF_MotorControllerOnStartingInit(MCAF_MOTOR_DATA *pmotor)
166:               {       
167:                   MCAF_CommutationStartupInit(pmotor);
004CBC  780008     MOV W8, W0
004CBE  072105     RCALL MCAF_CommutationStartupInit
168:                   MCAF_CurrentMeasureRestart(&pmotor->currentMeasure);
169:                   MCAF_FocInitializeIntegrators(pmotor);
170:                   MCAF_FluxControlStartupInit(&pmotor->fluxControl);
171:               #if MCAF_INCLUDE_STALL_DETECT      
172:                   MCAF_StallDetectActivate(&pmotor->stallDetect);
173:               #endif
174:                   EnablePwmMinDuty();
175:                   MCAF_SetClosedLoopCurrent(pmotor);
176:               }
177:               
178:               /**
179:                * Limits an array of three duty cycle values to at least a specified 
180:                * minimum. 
181:                * 
182:                * @param output output array
183:                * @param pinput input duty cycle values
184:                * @param min minimum output value
185:                */
186:               inline static void constrainDutyCycleAsArray(uint16_t *output, 
187:                       const MCAF_U_DUTYCYCLE_ABC *pinput, uint16_t min)
188:               {
189:                   output[0] = UTIL_LimitMinimumU16(pinput->a, min);
190:                   output[1] = UTIL_LimitMinimumU16(pinput->b, min);
191:                   output[2] = UTIL_LimitMinimumU16(pinput->c, min);
192:               }
193:               
194:               /**
195:                * Executes actions common to the "active states":
196:                * - STARTING
197:                * - RUN
198:                * - TEST_ENABLE
199:                * 
200:                * @param pmotor motor state data
201:                */
202:               inline static void MCAF_MotorControllerOnActiveStates(MCAF_MOTOR_DATA *pmotor)
203:               {
204:                   MCAF_FocStepIsrForwardPath(pmotor);
004CEA  780008     MOV W8, W0
004CEC  070E3A     RCALL MCAF_FocStepIsrForwardPath
004D34  780008     MOV W8, W0
004D36  070E15     RCALL MCAF_FocStepIsrForwardPath
004EC2  780008     MOV W8, W0
004EC4  070D4E     RCALL MCAF_FocStepIsrForwardPath
205:                   
206:               #if MCAF_SINGLE_CHANNEL_SUPPORT 
207:                   {
208:                       const MCAF_CURRENT_MEASUREMENT *pcurr = &pmotor->currentMeasure;
209:                       uint16_t pwmPhase[3];
210:                       uint16_t pwmDutyCycle[3];
211:                       constrainDutyCycleAsArray(pwmPhase, &pcurr->pwmDutyCycleOut.rising, HAL_PARAM_MIN_DUTY_COUNTS);
212:                       constrainDutyCycleAsArray(pwmDutyCycle, &pcurr->pwmDutyCycleOut.falling, HAL_PARAM_MIN_DUTY_COUNTS);
213:                       HAL_PWM_DutyCycleDualEdge_Set(pwmPhase, pwmDutyCycle);
214:                   }
215:               #else
216:                   {
217:                       uint16_t pwmDutyCycle[3];
218:                       constrainDutyCycleAsArray(pwmDutyCycle, &pmotor->pwmDutycycle, HAL_PARAM_MIN_DUTY_COUNTS);
219:                       HAL_PWM_DutyCycleRegister_Set(pwmDutyCycle);
220:                   }
221:               #endif    
222:               }
223:               
224:               /**
225:                * Executes actions on the STARTING state.
226:                * 
227:                * @param pmotor motor state data
228:                */
229:               inline static void MCAF_MotorControllerOnStarting(MCAF_MOTOR_DATA *pmotor)
230:               {
231:                   MCAF_MotorControllerOnActiveStates(pmotor);
232:               }
233:               
234:               /**
235:                * Executes actions on entry to the RUNNING state.
236:                * 
237:                * @param pmotor motor state data
238:                */
239:               inline static void MCAF_MotorControllerOnRunningInit(MCAF_MOTOR_DATA *pmotor)
240:               {
241:                   if (!MCAF_IsClosedLoopVelocity(pmotor))
004D1A  A33800     BTST.Z W0, #3
004D1C  3A000B     BRA NZ, MCAF_MotorControllerOnRunning
242:                   {
243:                       MCAF_CommutationTransitionToClosedLoop(pmotor);
244:                   }
245:               }
246:               
247:               /**
248:                * Executes actions in the RUNNING state.
249:                * 
250:                * @param pmotor motor state data
251:                */
252:               inline static void MCAF_MotorControllerOnRunning(MCAF_MOTOR_DATA *pmotor)
253:               {
254:                   MCAF_MotorControllerOnActiveStates(pmotor);
255:               }
256:               
257:               /**
258:                * Executes actions on entry to the STOPPING state.
259:                * 
260:                * @param pmotor motor state data
261:                */
262:               inline static void MCAF_MotorControllerOnStoppingInit(MCAF_MOTOR_DATA *pmotor)
263:               {
264:                   if (MCAF_StoppingClosedLoopCurrent())
265:                   {
266:                       pmotor->velocityControl.velocityCmd = 0;
267:                       if (!MCAF_StoppingClosedLoopVelocity())
268:                       {
269:                           pmotor->idqCmdRaw.d = 0;
270:                           pmotor->idqCmdRaw.q = 0;
271:                           MCAF_ClearClosedLoopVelocity(pmotor);
272:                       }
273:                   }
274:                   else
275:                   {
276:                       pmotor->omegaCmd = 0;
004D62  EB0000     CLR W0
004D64  992C70     MOV W0, [W8+350]
277:                       MCAF_SetPwmMinimalImpact();
278:                       MCAF_ClearClosedLoopFlags(pmotor);
279:                   }
280:                   MCAF_IncrementStopCount(pmotor);
281:                   MCAF_StoppingTimerReset(pmotor);
282:               }
283:               
284:               /**
285:                * Executes actions in the STOPPING state.
286:                * 
287:                * @param pmotor motor state data
288:                */
289:               inline static void MCAF_MotorControllerOnStopping(MCAF_MOTOR_DATA *pmotor)
290:               {
291:                   MCAF_ResetRecoveryIfNotRunRequested(pmotor);
292:                   if (MCAF_StoppingClosedLoopCurrent())
293:                   {
294:                       MCAF_MotorControllerOnActiveStates(pmotor);
295:                   }
296:               }
297:               
298:               /**
299:                * Executes actions on entry to the FAULT state.
300:                * 
301:                * @param pmotor motor state data
302:                */
303:               inline static void MCAF_MotorControllerOnFaultInit(MCAF_MOTOR_DATA *pmotor)
304:               {
305:                   pmotor->ui.run = false;
004DAA  EB4000     CLR.B W0
004DAC  9BEC40     MOV.B W0, [W8+492]
306:                   MCAF_SetPwmMinimalImpact();
307:                   MCAF_ClearClosedLoopFlags(pmotor);
308:               }
309:               
310:               /**
311:                * Executes actions in the FAULT state.
312:                * 
313:                * @param pmotor motor state data
314:                */
315:               inline static void MCAF_MotorControllerOnFault(MCAF_MOTOR_DATA *pmotor)
316:               {
317:                   /* do nothing */
318:               }
319:               
320:               /**
321:                * Executes actions on entry to the TEST_DISABLE state.
322:                * 
323:                * @param pmotor motor state data
324:                */
325:               inline static void MCAF_MotorControllerOnTestDisableInit(MCAF_MOTOR_DATA *pmotor)
326:               {
327:                   /* do nothing */
328:               }
329:               
330:               /**
331:                * Executes actions in the TEST_DISABLE state.
332:                * 
333:                * @param pmotor motor state data
334:                */
335:               inline static void MCAF_MotorControllerOnTestDisable(MCAF_MOTOR_DATA *pmotor)
336:               {
337:                   MCAF_SetPwmMinimalImpact();
338:               }
339:               
340:               /**
341:                * Executes actions in the TEST_RESTART state.
342:                * 
343:                * @param pmotor motor state data
344:                * @param init whether this is entry to the TEST_RESTART state
345:                */
346:               inline static void MCAF_MotorControllerOnTestRestart(MCAF_MOTOR_DATA *pmotor, bool init)
347:               {
348:                   /* First time here: we need to delay for at least one cycle.
349:                    */
350:                   if (init)
004DE6  E0040A     CP0.B W10
004DE8  32001B     BRA Z, MCAF_OvercurrentHWFlagValid
351:                   {
352:                       /* 
353:                        * Put PWMs in a safe state to keep gate drive going.
354:                        * Clear latching PWM fault and delay for at least one ISR cycle.
355:                        */
356:                       MCAF_BOARD_DATA *pboard = &pmotor->psys->board;
004DEA  930008     MOV [W8+768], W0
004DEC  40006C     ADD W0, #0xC, W0
357:                       MCAF_BootstrapChargeInit(pboard);
004DEE  07277D     RCALL MCAF_BootstrapChargeInit
358:                       HAL_PWM_FaultClearBegin();
359:                       MCAF_UiRestart(&pmotor->ui);
360:                       MCAF_FocRestart(pmotor);
361:                       
362:                       MCAF_FocInitializeIntegrators(pmotor);
363:                   }
364:                   /* Otherwise, delay some number of samples for fault-latch circuitry 
365:                    * to stabilize, then re-enable PWM fault latching.
366:                    * (PWM peripheral requires the interval between disable
367:                    * and reenable to straddle the PWM boundary)
368:                    */
369:                   else if (!MCAF_OvercurrentHWFlagValid(pmotor))
004E22  E00000     CP0 W0
004E24  320007     BRA Z, .LBE1876, .LBE1878, .LBE1883, .LBB1885, .L61
370:                   {
371:                       MCAF_OvercurrentHWFlagAttemptClear(pmotor);
372:                   }    
373:                   else
374:                   {
375:                       MCAF_BOARD_DATA *pboard = &pmotor->psys->board;
004E34  930008     MOV [W8+768], W0
004E36  40006C     ADD W0, #0xC, W0
376:                       bool bootstrapComplete = MCAF_BootstrapChargeStepIsr(pboard);
004E38  071008     RCALL MCAF_BootstrapChargeStepIsr
377:                       if (bootstrapComplete)
004E3A  E00400     CP0.B W0
004E3C  320056     BRA Z, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
378:                       {
379:                           MCAF_TestHarness_ClearRestartRequired(&pmotor->testing);
380:                           MCAF_ADCCalibrateCurrentOffsets(&pmotor->initialization,
381:                                                       &pmotor->currentCalibration,
382:                                                       &pmotor->iabc,
383:                                                       pmotor->iDC);
384:                       }
385:                   }    
386:               }
387:               
388:               /**
389:                * Executes actions on entry to the TEST_ENABLE state.
390:                * 
391:                * @param pmotor motor state data
392:                */
393:               inline static void MCAF_MotorControllerOnTestEnableInit(MCAF_MOTOR_DATA *pmotor, MCAF_FSM_STATE previous_state)
394:               {
395:                   /* Special-case entering the enable state from the following circumstance:
396:                    * - STARTUP_PAUSE override flag set
397:                    * - left STARTING state 
398:                    */
399:                   if (   MCAF_OverrideStartupPause(&pmotor->testing)
004EAC  A35801     BTST.Z W1, #5
004EAE  320002     BRA Z, EnablePwmMinDuty
400:                       && previous_state == MCSM_STARTING)
004EB0  500FE2     SUB W0, #0x2, [W15]
004EB2  320007     BRA Z, MCAF_MotorControllerOnTestEnable
401:                   {
402:                       ; 
403:                       /*
404:                        * do nothing: we don't want to mess with the PWM duty cycles
405:                        * in a mode where switching is already occurring
406:                        */
407:                   }
408:                   else
409:                   {
410:                       EnablePwmMinDuty();
411:                   }
412:               }
413:               
414:               /**
415:                * Executes actions in the TEST_ENABLE state.
416:                * 
417:                * @param pmotor motor state data
418:                */
419:               inline static void MCAF_MotorControllerOnTestEnable(MCAF_MOTOR_DATA *pmotor)
420:               {
421:                   MCAF_MotorControllerOnActiveStates(pmotor);
422:               }
423:               
424:               /**
425:                * Executes actions on entry to the RESTART state.
426:                * 
427:                * @param pmotor motor state data
428:                */
429:               inline static void MCAF_MotorControllerOnRestartInit(MCAF_MOTOR_DATA *pmotor)
430:               {
431:                   /* 
432:                    * Put PWMs in a safe state to keep gate drive going.
433:                    * Clear latching PWM fault and delay for at least one ISR cycle.
434:                    */
435:                   MCAF_BOARD_DATA *pboard = &pmotor->psys->board;
004B72  930008     MOV [W8+768], W0
004B74  40006C     ADD W0, #0xC, W0
0079D2  930008     MOV [W8+768], W0
0079D4  40006C     ADD W0, #0xC, W0
436:                   MCAF_BootstrapChargeInit(pboard);
004B76  0728B9     RCALL MCAF_BootstrapChargeInit
0079D6  071189     RCALL MCAF_BootstrapChargeInit
437:                   HAL_PWM_FaultClearBegin();
438:                   
439:                   MCAF_FocRestart(pmotor);
440:                   
441:                   MCAF_UiRestart(&pmotor->ui);
442:                   MCAF_TestHarness_Restart(&pmotor->testing);
004B98  202C80     MOV #0x2C8, W0
004B9A  400008     ADD W0, W8, W0
004B9C  072526     RCALL MCAF_TestHarness_Restart
0079F8  202C80     MOV #0x2C8, W0
0079FA  400008     ADD W0, W8, W0
0079FC  070DF6     RCALL MCAF_TestHarness_Restart
443:                   MCAF_CommutationRestart(pmotor);
444:               #if MCAF_INCLUDE_STALL_DETECT      
445:                   MCAF_StallDetectReset(&pmotor->stallDetect);
004BD0  202000     MOV #0x200, W0
004BD2  400008     ADD W0, W8, W0
004BD4  0723EC     RCALL MCAF_StallDetectReset
007A30  202000     MOV #0x200, W0
007A32  400008     ADD W0, W8, W0
007A34  070CBC     RCALL MCAF_StallDetectReset
446:                   MCAF_StallDetectDeactivate(&pmotor->stallDetect);
447:               #endif    
448:                   MCAF_FaultDetectInit(&pmotor->faultDetect);
004BDC  202B20     MOV #0x2B2, W0
004BDE  400008     ADD W0, W8, W0
004BE0  07275E     RCALL MCAF_FaultDetectInit
007A3C  202B20     MOV #0x2B2, W0
007A3E  400008     ADD W0, W8, W0
007A40  07102E     RCALL MCAF_FaultDetectInit
449:                   MCAF_RecoveryInit(&pmotor->recovery);
004BE2  202BA0     MOV #0x2BA, W0
004BE4  400008     ADD W0, W8, W0
004BE6  072833     RCALL MCAF_RecoveryInit
007A42  202BA0     MOV #0x2BA, W0
007A44  400008     ADD W0, W8, W0
007A46  071103     RCALL MCAF_RecoveryInit
450:                   MCAF_CurrentMeasureRestart(&pmotor->currentMeasure);
451:               }
452:               
453:               inline static bool restartStateComplete(const MCAF_MOTOR_DATA *pmotor)
454:               {
455:                   /* ADC initialization is the last phase of the RESTART state; see 
456:                    * MCAF_MotorControllerOnRestart
457:                    */
458:                   return MCAF_ADCInitializationReady(pmotor);
459:               }
460:               
461:               /**
462:                * Executes actions in the RESTART state.
463:                * 
464:                * @param pmotor motor state data
465:                * @param init true if this is the first time we enter this state
466:                */
467:               inline static void MCAF_MotorControllerOnRestart(MCAF_MOTOR_DATA *pmotor, bool init)
468:               {
469:                   /* First time here: we need to delay for at least one cycle.
470:                    */
471:                   if (init)
004BE8  E0040A     CP0.B W10
004BEA  3A017F     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
472:                   {
473:                       /* do nothing */
474:                   }
475:                   /* Otherwise, delay some number of samples for fault-latch circuitry 
476:                    * to stabilize, then re-enable PWM fault latching.
477:                    * (PWM peripheral requires the interval between disable
478:                    * and reenable to straddle the PWM boundary)
479:                    */
480:                   else if (!MCAF_OvercurrentHWFlagValid(pmotor))
004BEE  E00000     CP0 W0
004BF0  320007     BRA Z, .LBE1648, .LBE1650, .LBE1655, .LBB1657, .L45
481:                   {
482:                       MCAF_OvercurrentHWFlagAttemptClear(pmotor);
483:                   }
484:                   /* Calibrate current offsets when the bootstrap charging sequence
485:                    * is complete.
486:                    */
487:                   else
488:                   {
489:                       MCAF_BOARD_DATA *pboard = &pmotor->psys->board;
004C00  930008     MOV [W8+768], W0
004C02  40006C     ADD W0, #0xC, W0
490:                       bool bootstrapComplete = MCAF_BootstrapChargeStepIsr(pboard);
004C04  071122     RCALL MCAF_BootstrapChargeStepIsr
491:                       if (bootstrapComplete)
004C06  E00400     CP0.B W0
004C08  320170     BRA Z, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
492:                       {
493:                           MCAF_ADCCalibrateCurrentOffsets(&pmotor->initialization,
494:                                                       &pmotor->currentCalibration,
495:                                                       &pmotor->iabc,
496:                                                       pmotor->iDC); 
497:                       }
498:                   }
499:               }
500:               
501:               /**
502:                * Executes actions common to all states.
503:                * 
504:                * @param pmotor motor state data
505:                */
506:               inline static void MCAF_MotorControllerOnAllStates(MCAF_MOTOR_DATA *pmotor)
507:               {
508:                   MCAF_ADCRead(pmotor);
0049A0  780008     MOV W8, W0
0049A2  0720DD     RCALL MCAF_ADCRead
509:                   MCAF_FocStepIsrFeedbackPath(pmotor);
0049A4  780008     MOV W8, W0
0049A6  07113B     RCALL MCAF_FocStepIsrFeedbackPath
510:                   MCAF_CommutationPrepareStallDetectInputs(pmotor);
0049A8  780008     MOV W8, W0
0049AA  0726C7     RCALL MCAF_CommutationPrepareStallDetectInputs
511:                   MCAF_MonitorSysDiagnose(pmotor);
0049AC  780008     MOV W8, W0
0049AE  07238D     RCALL MCAF_MonitorSysDiagnose
512:               }
513:               
514:               /**
515:                * Executes low-priority actions common to all states.
516:                * 
517:                * @param pmotor motor state data
518:                */
519:               inline static void MCAF_MotorControllerOnAllStatesLowPriority(MCAF_MOTOR_DATA *pmotor)
520:               {   
521:                   MCAF_FocStepIsrNonCriticalTask(pmotor);
004EF2  780008     MOV W8, W0
004EF4  0720D0     RCALL MCAF_FocStepIsrNonCriticalTask
522:                   MCAF_TestGuard(&pmotor->testing, &pmotor->psys->testing);
004EF6  930008     MOV [W8+768], W0
523:                   MCAF_TestPerturbationUpdate(&pmotor->testing);
524:               }
525:               
526:               inline static bool stopping_complete(MCAF_MOTOR_DATA *pmotor)
527:               {
528:                   if (MCAF_StoppingClosedLoopCurrent())
529:                   {
530:                       // Reset timer if the speed is too high
531:                       const MCAF_U_VELOCITY_ELEC speed = UTIL_Abs16Approx(pmotor->omegaElectrical);
532:                       if (speed > pmotor->stopping.speedThreshold)
533:                       {
534:                           MCAF_StoppingTimerReset(pmotor);
535:                           return false;
536:                       }
537:                   }
538:               
539:                   const bool timerExpired = MCAF_StoppingTimerUpdate(pmotor);
540:                   const bool acceptTimerExpiration = MCAF_StoppingClosedLoopCurrent() || MCAF_MonitorIsMotorStopped(pmotor);
541:                   return acceptTimerExpiration && timerExpired;
542:               }
543:               
544:               /**
545:                * Determines transition in state machine in the primary modes 
546:                * (those modes aside from test modes)
547:                *
548:                * Side effect: report any new error to the UI.
549:                * 
550:                * @param pmotor motor data
551:                * @return next state
552:                */
553:               inline static MCAF_FSM_STATE MCAF_FSM_DetermineNextState(MCAF_MOTOR_DATA *pmotor)
554:               {
555:                   /* By default, we stay in the same state. */
556:                   const MCAF_FSM_STATE this_state = pmotor->state;
0049BE  91B4C8     MOV [W8+488], W9
557:                   MCAF_FSM_STATE next_state = this_state;    
558:                   
559:                   /* Check if a fault has been detected. 
560:                    * Mask reporting of new faults during the FAULT state; this is okay,
561:                    * because if they are still around when we re-enter the RESTART state,
562:                    * we'll drop back into the FAULT state.
563:                    */
564:                   const bool operating_fault_detected = 
565:                       (next_state != MCSM_FAULT) &&
0049C0  548FE5     SUB W9, #0x5, [W15]
0049C2  320010     BRA Z, MCAF_TestAndClearDirectionChangeFlag
566:                       MCAF_DetectFault(pmotor, FDM_PRIMARY);
567:               
568:                   if (operating_fault_detected)
569:                   {
570:                       next_state = MCSM_FAULT;
004A0A  200059     MOV #0x5, W9
571:                       const uint16_t error_code = MCAF_GetFaultCode(pmotor);
572:                       MCAF_UiRecordNewError(&pmotor->ui.indicatorState, error_code);
004A04  201F20     MOV #0x1F2, W0
004A06  400008     ADD W0, W8, W0
573:                   }
574:                   else
575:                   {
576:                       const bool directionChanged = MCAF_TestAndClearDirectionChangeFlag(&pmotor->ui);
577:                       const bool run_requested = pmotor->ui.run && !directionChanged;
004A1C  93E8C8     MOV.B [W8+492], W1
004A1E  EB0000     CLR W0
004A20  E00401     CP0.B W1
004A22  320002     BRA Z, .L12
004A26  FB8002     ZE W2, W0
004A28  784100     MOV.B W0, W2
578:                       const bool run_permitted =
579:                           MCAF_MonitorIsRunPermitted(pmotor)
580:                        || MCAF_OverrideStallDetection(&pmotor->testing);
004A2C  200011     MOV #0x1, W1
004A2E  A30800     BTST.Z W0, #0
004A30  320003     BRA Z, .LBE1555, .L13
004A34  0A8133     BFEXT #0x3, #0x1, W1, W1
004A36  000001     NOP
581:                       const bool run = run_requested && run_permitted;
004A38  EB0000     CLR W0
004A3A  E00402     CP0.B W2
004A3C  320001     BRA Z, .L14
004A3E  FB8001     ZE W1, W0
582:                       switch (this_state)
004A40  548FE2     SUB W9, #0x2, [W15]
004A42  320014     BRA Z, .L17
004A44  3E0005     BRA GTU, .L21
004A46  E00009     CP0 W9
004A48  320009     BRA Z, restartStateComplete
004A4A  548FE1     SUB W9, #0x1, [W15]
004A4C  3A002D     BRA NZ, .LBE1542, .L82
004A4E  37000B     BRA .L106
004A50  548FE4     SUB W9, #0x4, [W15]
004A52  320015     BRA Z, stopping_complete
004A54  390011     BRA NC, .L18
004A56  548FE5     SUB W9, #0x5, [W15]
004A58  3A0027     BRA NZ, .LBE1542, .L82
004A5A  370022     BRA .LBB1542, .LBE1543, .LBE1544, .LBE1545, .LBE1546, .L107
583:                       {
584:                           case MCSM_RESTART:
585:                               {
586:                                   if (restartStateComplete(pmotor))
004A60  E00410     CP0.B [W0]
004A62  3A0024     BRA NZ, .L83
004A64  37002E     BRA .L11
587:                                   {
588:                                       if (MCAF_StoppingClosedLoopCurrent() 
589:                                               && !MCAF_StartupHasCompleted(&pmotor->startup))
590:                                       {
591:                                           next_state = MCSM_STOPPED;
592:                                       }
593:                                       else
594:                                       {
595:                                           next_state = MCSM_STOPPING;
004AAC  200049     MOV #0x4, W9
004AAE  370009     BRA .L11
596:                                       }
597:                                   }
598:                               }
599:                               break;
600:                           case MCSM_STOPPED:
601:                               if (run) 
004A66  E00400     CP0.B W0
004A68  3A0023     BRA NZ, .L84
004A6A  37002B     BRA .L11
602:                               {
603:                                   next_state = MCSM_STARTING;
004AB0  200029     MOV #0x2, W9
004AB2  370007     BRA .L11
604:                               }
605:                               break;
606:                           case MCSM_STARTING:
607:                               if (!run)
004A6C  E00400     CP0.B W0
004A6E  320022     BRA Z, .L85
608:                               {
609:                                   next_state = MCSM_STOPPING;
004AB4  200049     MOV #0x4, W9
004AB6  370005     BRA .L11
610:                               }
611:                               else if (MCAF_StartupHasCompleted(&pmotor->startup))
004A70  93D858     MOV.B [W8+477], W0
004A72  E00400     CP0.B W0
004A74  3A0021     BRA NZ, .L86
004A76  370025     BRA .L11
612:                               {
613:                                   next_state = MCSM_RUNNING;
004AB8  200039     MOV #0x3, W9
004ABA  370003     BRA .L11
614:                               }
615:                               break;
616:                           case MCSM_RUNNING:
617:                               if (!run)
004A78  E00400     CP0.B W0
004A7A  320020     BRA Z, .L87
004A7C  370022     BRA .L11
618:                               {
619:                                   next_state = MCSM_STOPPING;
004ABC  200049     MOV #0x4, W9
004ABE  370001     BRA .L11
620:                               }
621:                               break;
622:                           case MCSM_STOPPING:
623:                               if (MCAF_StoppingClosedLoopCurrent() 
624:                                       && run
625:                                       && MCAF_StartupHasCompleted(&pmotor->startup))
626:                               {
627:                                   next_state = MCSM_RUNNING;
628:                               }
629:                               else if (stopping_complete(pmotor))
630:                               {
631:                                   next_state = MCSM_STOPPED;
004F5E  200019     MOV #0x1, W9
004F60  37FDB0     BRA .L11
632:                               }
633:                               break;
634:                           case MCSM_FAULT:
635:                               {
636:                                   const bool ok_to_restart = pmotor->ui.exitFaultState;
004AA0  93E858     MOV.B [W8+493], W0
637:                                   if (ok_to_restart)
004AA2  E00400     CP0.B W0
004AA4  3A000D     BRA NZ, .L88
004AA6  37000D     BRA .L11
638:                                   {
639:                                       next_state = MCSM_RESTART;
004AC0  EB0480     CLR W9
640:                                   }
641:                               }
642:                               break;
643:                           default:
644:                               next_state = MCSM_RESTART;
004AA8  EB0480     CLR W9
004AAA  37000B     BRA .L11
645:                       }
646:                   }
647:                   pmotor->ui.exitFaultState = false;   // clear any pending requests
004AC2  EB4000     CLR.B W0
004AC4  9BEC50     MOV.B W0, [W8+493]
004AC6  370035     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
648:                   return next_state;
649:               }
650:               
651:               /**
652:                * Determines transition in state machine in the test modes
653:                * 
654:                * Side effect: report any new error to the UI.
655:                * 
656:                * @param pmotor motor data
657:                * @return next state
658:                */
659:               inline static MCAF_FSM_STATE MCAF_FSM_DetermineNextStateTestMode(MCAF_MOTOR_DATA *pmotor)
660:               {    
661:                   const MCAF_FSM_STATE this_state = pmotor->state;
004AC8  91B4C8     MOV [W8+488], W9
662:                   MCAF_FSM_STATE next_state = this_state;    
004B08  200059     MOV #0x5, W9
004B0A  370011     BRA .L29
663:                   const bool test_fault_detected = MCAF_DetectFault(pmotor, FDM_TEST);
664:                   const bool test_fault_newly_detected = test_fault_detected &&
004ACC  E00000     CP0 W0
004ACE  320249     BRA Z, .L24
004AD0  548FE5     SUB W9, #0x5, [W15]
004AD2  320016     BRA Z, .LBB1598, .LBE1599, .LBE1600, .L25
665:                                                          (this_state != MCSM_FAULT);
666:               
667:                   if (test_fault_newly_detected)
668:                   {
669:                       next_state = MCSM_FAULT;
004AF6  200059     MOV #0x5, W9
670:                       const uint16_t error_code = MCAF_GetFaultCode(pmotor);
671:                       MCAF_UiRecordNewError(&pmotor->ui.indicatorState, error_code);
004AF0  201F20     MOV #0x1F2, W0
004AF2  400008     ADD W0, W8, W0
672:                   }
673:                   else
674:                   {
675:                       switch (this_state)
004F62  548FE5     SUB W9, #0x5, [W15]
004F64  32FDCD     BRA Z, .LBB1598, .LBE1599, .LBE1600, .L25
004F66  548FE8     SUB W9, #0x8, [W15]
004F68  3AFDD6     BRA NZ, MCAF_GetOperatingMode
004F6A  37FDD0     BRA restartStateComplete
676:                       {
677:                       case MCSM_FAULT:
678:                           {
679:                               const bool ok_to_restart = pmotor->ui.exitFaultState;
004B00  93E858     MOV.B [W8+493], W0
680:                               if (ok_to_restart)
004B04  E00400     CP0.B W0
004B06  3A0013     BRA NZ, .L29
681:                               {
682:                                   next_state = MCSM_TEST_RESTART;
004B02  200089     MOV #0x8, W9
683:                               }
684:                           }
685:                           break;
686:                       case MCSM_TEST_RESTART:
687:                           {
688:                               if (restartStateComplete(pmotor))
004B10  E00410     CP0.B [W0]
004B12  3A000C     BRA NZ, .L94
004B14  37000C     BRA .L29
689:                               {
690:                                   next_state = MCSM_TEST_DISABLE;
004B2C  200069     MOV #0x6, W9
691:                               }        
692:                           }
693:                           break;
694:                       default:
695:                           /* All other states: ignore which state we're in,
696:                            * and instead determine next state based only on operating mode
697:                            * and whether a clean restart is required.
698:                            * 
699:                            * Please note that this_state may be one of the non-test states
700:                            * if operating mode is suddenly switched from OM_NORMAL
701:                            * to one of the test modes.
702:                            * 
703:                            * This gives the test operator one of two ways to enter a test state:
704:                            * 
705:                            * - just change operating mode to OM_xyz: changes abruptly
706:                            * - set motor.testing.testRestartRequired = true,
707:                            *   and *then* change operating mode to OM_xyz:
708:                            *   goes through MCSM_TEST_RESTART first,
709:                            *   then switches to MCSM_TEST_ENABLE
710:                            */
711:                           if (MCAF_GetOperatingMode(&pmotor->testing) == OM_DISABLED)
004B1A  E00000     CP0 W0
004B1C  320008     BRA Z, .L29
712:                           {
713:                               next_state = MCSM_TEST_DISABLE;
004B18  200069     MOV #0x6, W9
714:                           }
715:                           else  // operating mode != disabled
716:                           {
717:                               if (MCAF_TestHarness_TestRestartRequired(&pmotor->testing))
004B24  E00410     CP0.B [W0]
004B26  320003     BRA Z, .L29
718:                               {
719:                                   next_state = MCSM_TEST_RESTART;
004B28  200089     MOV #0x8, W9
004B2A  370001     BRA .L29
720:                               }
721:                               else
722:                               {
723:                                   next_state = MCSM_TEST_ENABLE;
004B22  200079     MOV #0x7, W9
724:                               }
725:                           }
726:                       }
727:                   }
728:                   pmotor->ui.exitFaultState = false;   // clear any pending requests
004B2E  EB4000     CLR.B W0
004B30  9BEC50     MOV.B W0, [W8+493]
729:                   return next_state;
730:               }
731:               
732:               /**
733:                * Performs actions appropriate in each state, including on-entry actions
734:                * 
735:                * @param pmotor motor state data
736:                * @param next_state the next state of the state machine
737:                */
738:               inline static void MCAF_FSM_Dispatch(MCAF_MOTOR_DATA *pmotor, MCAF_FSM_STATE next_state)
739:               {
740:                   const MCAF_FSM_STATE this_state = pmotor->state;
004B3A  91B048     MOV [W8+488], W0
741:                   const bool state_changed = (next_state != this_state);
004B3C  6C8500     XOR W9, W0, W10
004B3E  A7F00A     BTSC W10, #15
004B40  EA050A     NEG W10, W10
004B42  EA050A     NEG W10, W10
004B44  DE554F     LSR W10, #15, W10
742:                   pmotor->state = next_state;
004B46  99B449     MOV W9, [W8+488]
743:                   
744:                   switch (next_state)
004B48  548FE4     SUB W9, #0x4, [W15]
004B4A  320109     BRA Z, .LBE1754, .LBE1755, .LBE1757, .LBE1766, .LBE1771, .L37
004B4C  3E0008     BRA GTU, .L42
004B4E  548FE1     SUB W9, #0x1, [W15]
004B50  32008D     BRA Z, .LBE1644, .LBE1657, .LBE1658, .L34
004B52  39000D     BRA NC, .L33
004B54  548FE2     SUB W9, #0x2, [W15]
004B56  3200B0     BRA Z, .LBE1701, .LBE1702, .LBE1703, .L35
004B58  548FE3     SUB W9, #0x3, [W15]
004B5A  3A01C7     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004B5C  3700DB     BRA .LBE1727, .LBE1728, .LBE1730, .LBE1739, .LBE1744, .L109
004B5E  548FE6     SUB W9, #0x6, [W15]
004B60  320136     BRA Z, MCAF_MotorControllerOnTestDisable
004B62  390121     BRA NC, .LBE1804, .LBE1805, .LBE1806, .L38
004B64  548FE7     SUB W9, #0x7, [W15]
004B66  32019F     BRA Z, .LBE1858, .LBE1885, .LBE1888, .L40
004B68  548FE8     SUB W9, #0x8, [W15]
004B6A  3A01BF     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004B6C  37013C     BRA MCAF_MotorControllerOnTestRestart
745:                   {
746:                       case MCSM_RESTART:
747:                           if (state_changed)
004B6E  E0040A     CP0.B W10
004B70  32003D     BRA Z, MCAF_OvercurrentHWFlagValid
748:                           {
749:                               MCAF_MotorControllerOnRestartInit(pmotor);
750:                           }
751:                           MCAF_MotorControllerOnRestart(pmotor, state_changed);
752:                           break;
753:                       case MCSM_STOPPED:
754:                           if (state_changed)
004C6C  E0040A     CP0.B W10
004C6E  32001D     BRA Z, MCAF_MotorControllerOnStopped
755:                           {
756:                               MCAF_MotorControllerOnStoppedInit(pmotor);
757:                           }
758:                           MCAF_MotorControllerOnStopped(pmotor);
759:                           break;
760:                       case MCSM_STARTING:
761:                           if (state_changed)
004CB8  E0040A     CP0.B W10
004CBA  320017     BRA Z, MCAF_MotorControllerOnStarting
762:                           {
763:                              MCAF_MotorControllerOnStartingInit(pmotor);
764:                           }
765:                           MCAF_MotorControllerOnStarting(pmotor);
766:                           break;
767:                       case MCSM_RUNNING:
768:                           if (state_changed)
004D14  E0040A     CP0.B W10
004D16  32000E     BRA Z, MCAF_MotorControllerOnRunning
769:                           {
770:                               MCAF_MotorControllerOnRunningInit(pmotor);
771:                           }
772:                           MCAF_MotorControllerOnRunning(pmotor);
773:                           break;
774:                       case MCSM_STOPPING:
775:                           if (state_changed)
004D5E  E0040A     CP0.B W10
004D60  32001B     BRA Z, MCAF_MotorControllerOnStopping
776:                           {
777:                               MCAF_MotorControllerOnStoppingInit(pmotor);
778:                           }
779:                           MCAF_MotorControllerOnStopping(pmotor);
780:                           break;                    
781:                       case MCSM_FAULT:
782:                           if (state_changed)
004DA6  E0040A     CP0.B W10
004DA8  3200A0     BRA Z, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
783:                           {
784:                               MCAF_MotorControllerOnFaultInit(pmotor);
785:                           }
786:                           MCAF_MotorControllerOnFault(pmotor);
787:                           break;                    
788:                       case MCSM_TEST_DISABLE:
789:                           if (state_changed)
790:                           {
791:                               MCAF_MotorControllerOnTestDisableInit(pmotor);
792:                           }
793:                           MCAF_MotorControllerOnTestDisable(pmotor);
794:                           break;                    
795:                       case MCSM_TEST_RESTART:
796:                           MCAF_MotorControllerOnTestRestart(pmotor, state_changed);
797:                           break;
798:                       case MCSM_TEST_ENABLE:
799:                           if (state_changed)
004EA6  E0040A     CP0.B W10
004EA8  32000C     BRA Z, MCAF_MotorControllerOnTestEnable
800:                           {
801:                               MCAF_MotorControllerOnTestEnableInit(pmotor, this_state);
802:                           }
803:                           MCAF_MotorControllerOnTestEnable(pmotor);
804:                           break;
805:                   }    
806:               }
807:               
808:               
809:               /* ----- implementations of functions used outside this module: ----- */
810:               
811:               void MCAF_SystemStateMachine_StepIsr(MCAF_MOTOR_DATA *pmotor)
004A24  A20402     BTG.B W2, #0
812:               {
004992  BE9F88     MOV.D W8, [W15++]
004994  781F8A     MOV W10, [W15++]
004996  780400     MOV W0, W8
813:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_STATEMACH_START);
814:               
815:                   /* 1. Perform critical tasks that are independent of the state. */
816:                   MCAF_MotorControllerOnAllStates(pmotor);
817:                   
818:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_STATEMACH_ON_ALL_STATES);
819:               
820:                   /* 2. Determine next state. */
821:                   const MCAF_FSM_STATE next_state =
822:                   #ifdef MCAF_TEST_HARNESS
823:                       pmotor->testing.operatingMode == OM_NORMAL 
0049B8  92B048     MOV [W8+744], W0
824:                           ? MCAF_FSM_DetermineNextState(pmotor)
825:                           : MCAF_FSM_DetermineNextStateTestMode(pmotor);
0049BA  500FE3     SUB W0, #0x3, [W15]
0049BC  3A0085     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_FSM_DetermineNextStateTestMode
826:                   #else
827:                       MCAF_FSM_DetermineNextState(pmotor);
828:                   #endif
829:               
830:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_STATEMACH_NEXT_STATE);
831:                   
832:                   /* 3. Update state and execute appropriate actions. */
833:                   MCAF_FSM_Dispatch(pmotor, next_state);
834:               
835:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_STATEMACH_DISPATCH);
836:               
837:                   /* 4. Perform noncritical tasks that are independent of the state. */
838:                   MCAF_MotorControllerOnAllStatesLowPriority(pmotor);
839:               
840:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_STATEMACH_END);
841:               }
004F44  78054F     MOV [--W15], W10
004F46  BE044F     MOV.D [--W15], W8
004F48  060000     RETURN
842:               
843:               void MCAF_SystemStateMachine_Init(MCAF_MOTOR_DATA *pmotor)
844:               {
0079B0  BE9F88     MOV.D W8, [W15++]
845:                   pmotor->state = MCSM_RESTART;
0079B4  EB0480     CLR W9
0079B6  99B449     MOV W9, [W8+488]
846:                   pmotor->stateFlags = 0;
0079B8  998429     MOV W9, [W8+388]
847:                   pmotor->stopping.timer.duration = MCAF_StoppingClosedLoopCurrent()
0079BA  22DC80     MOV #0x2DC8, W0
0079BC  200001     MOV #0x0, W1
0079BE  9B0C00     MOV W0, [W8+784]
0079C0  9B0C11     MOV W1, [W8+786]
848:                                                ? MCAF_CLOSED_LOOP_STOPPING_TIME
849:                                                : VELOCITY_COASTDOWN_TIME;        
850:                   pmotor->stopping.speedThreshold = MCAF_CLOSED_LOOP_STOPPING_SPEED;
0079C2  204440     MOV #0x444, W0
0079C4  9B0C50     MOV W0, [W8+794]
851:                   MCAF_TestHarness_Init(&pmotor->testing);
852:                   MCAF_MotorControllerOnRestartInit(pmotor);    
853:                   MCAF_CommutationInit(pmotor);
007A48  780008     MOV W8, W0
007A4A  0711A6     RCALL MCAF_CommutationInit
854:                   pmotor->initialization.faultLatchDelay = MCAF_POWERUP_FAULT_LATCH_DELAY;
007A4C  200140     MOV #0x14, W0
007A4E  9B2410     MOV W0, [W8+834]
855:                   
856:                   /* Start Timer-1, used for implementing time profiling
857:                    * feature within the test harness */
858:                   HAL_ProfilingCounter_Start();
859:               }
007A52  BE044F     MOV.D [--W15], W8
007A54  060000     RETURN
007A56  500FE2     SUB W0, #0x2, [W15]
860:               
861:               void MCAF_SystemStateMachine_StepMain(volatile MCAF_MOTOR_DATA *pmotor)
862:               {
863:                   /* Fault display is stateful: we only set it up once,
864:                    * and afterwards we leave things alone. 
865:                    *
866:                    * Regular status display is stateless: it's just a slow PWM
867:                    * for the LEDs
868:                    */
869:                   if (pmotor->state != MCSM_FAULT)
008450  91B0C0     MOV [W0+488], W1
008452  508FE5     SUB W1, #0x5, [W15]
008454  32001B     BRA Z, MCAF_SystemStateMachine_StepMain::MCAF_TestHarnessHandleForceStateChange
870:                   {
871:                       uint8_t duty1;
872:                       uint8_t duty2;
873:                       /* Mapping between system state and duty cycle of LED blink */
874:                       switch (pmotor->state)
008456  91B0C0     MOV [W0+488], W1
00845C  508FE2     SUB W1, #0x2, [W15]
00845E  32000E     BRA Z, .L117
008460  3E0004     BRA GTU, .L121
008464  508FE1     SUB W1, #0x1, [W15]
008466  3A0008     BRA NZ, .L116
008468  370009     BRA .L117
00846E  508FE3     SUB W1, #0x3, [W15]
008470  320005     BRA Z, .L117
008474  508FE4     SUB W1, #0x4, [W15]
008476  320002     BRA Z, .L117
875:                       {
876:                           case MCSM_RESTART:
877:                           case MCSM_TEST_RESTART:
878:                           default:
879:                               duty1 = MCUILD_OFF;
00847A  784103     MOV.B W3, W2
880:                               duty2 = MCUILD_OFF;
008478  EB4180     CLR.B W3
881:                               break;
882:                           case MCSM_STOPPED:
883:                               duty1 = MCUILD_LOW;
884:                               duty2 = MCUILD_OFF;
008462  EB4180     CLR.B W3
885:                               break;
886:                           case MCSM_STARTING:
887:                               duty1 = MCUILD_LOW;
00845A  B3C012     MOV.B #0x1, W2
888:                               duty2 = MCUILD_ON;
008458  B3C103     MOV.B #0x10, W3
889:                               break;
890:                           case MCSM_STOPPING:
891:                               duty1 = MCUILD_HIGH;
892:                               duty2 = MCUILD_OFF;
008472  EB4180     CLR.B W3
893:                               break;
894:                           case MCSM_RUNNING:
895:                               duty1 = MCUILD_HIGH;
00846C  B3C0F2     MOV.B #0xF, W2
896:                               duty2 = MCUILD_ON;
00846A  B3C103     MOV.B #0x10, W3
897:                               break;
898:                       }
899:               
900:                       if (pmotor->ui.flags & MCAF_UI_REVERSE)
00847C  91B0F0     MOV [W0+494], W1
00847E  A34801     BTST.Z W1, #4
008480  320003     BRA Z, .L122
901:                       {
902:                           pmotor->ui.indicatorState.duty1 = duty1;        
008482  9BF062     MOV.B W2, [W0+502]
903:                           pmotor->ui.indicatorState.duty2 = duty2;        
008484  9BF073     MOV.B W3, [W0+503]
008486  370002     BRA MCAF_SystemStateMachine_StepMain::MCAF_TestHarnessHandleForceStateChange
904:                       }
905:                       else
906:                       {
907:                           pmotor->ui.indicatorState.duty1 = duty2;        
008488  9BF063     MOV.B W3, [W0+502]
908:                           pmotor->ui.indicatorState.duty2 = duty1;        
00848A  9BF072     MOV.B W2, [W0+503]
909:                       }
910:                   }
911:                   MCAF_TestHarnessHandleForceStateChange(&pmotor->testing, &pmotor->ui.run);
912:               }
0084BC  060000     RETURN
0084BE  FA0004     LNK #0x4
0084C0  BE9F88     MOV.D W8, [W15++]
0084C2  BE9F8A     MOV.D W10, [W15++]
0084C4  BE9F8C     MOV.D W12, [W15++]
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/startup_types.h
1:                 /**
2:                  * startup_types.h
3:                  * 
4:                  * Type definitions for startup and open loop to closed loop transition 
5:                  *
6:                  * Component: state machine
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __STARTUP_TYPES_H
48:                #define __STARTUP_TYPES_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                #include "units.h"
53:                #include "util.h"
54:                
55:                #ifdef __cplusplus
56:                extern "C" {
57:                #endif
58:                
59:                  
60:                /** Different state for startup and open-loop to close transitioning  */
61:                typedef enum tagMCAF_STARTUP_FSM_STATE
62:                {
63:                   /** Start state (entered only on reset + exiting fault) */
64:                   SSM_START            = 0,
65:                   /** Rotor is locked during align state. 
66:                    * Current ramp is applied during this state, angle held constant */
67:                   SSM_CURRENT_RAMPUP   = 1, 
68:                   /** Rotor is locked during align state. 
69:                    * Current and angle held constant. */
70:                   SSM_ALIGN            = 2, 
71:                   /** Alignment acceleration of motor with forced commutation to overcome cogging torque. 
72:                    * Motor is accelerated slowly from standstill to a certain alignment velocity */
73:                   SSM_ACCEL0           = 3, 
74:                   /** Initial acceleration of motor with forced commutation. 
75:                    * Motor is accelerated from alignment velocity to minimum velocity */
76:                   SSM_ACCEL1           = 4, 
77:                   /** Motor is allowed to recover after initial acceleration during hold state. 
78:                    * Speed and applied current torque command are constant during this state. */     
79:                   SSM_HOLD             = 5,
80:                   /** Current torque command is ramp down during this state. 
81:                    * In this state, startup theta error (imposed theta - estimated theta) is also computed */  
82:                   SSM_CURRENT_RAMPDOWN = 6, 
83:                   /** When startup theta error falls below threshold, open to close loop transition takes place. 
84:                    * Estimated theta is used for commutation after transition */
85:                   SSM_TRANSITION       = 7,
86:                   /** indicates completion of open to close loop transition */
87:                   SSM_COMPLETE         = 8,
88:                   SSM_INACTIVE         = 9  /** inactive state for test modes */
89:                } MCAF_STARTUP_FSM_STATE;
90:                
91:                typedef enum tagMCAF_STARTUP_STATUS_T
92:                {
93:                    /** startup in progress; something is going on */
94:                    MSST_UNSPECIFIED = 0,
95:                    /** startup restarting, awaiting further action */
96:                    MSST_RESTART = 1,
97:                    /** align: commutation angle and current are constant */
98:                    MSST_ALIGN = 2,
99:                    /** accel: electrical frequency increases to accelerate the motor */
100:                   MSST_ACCEL = 3,
101:                   /** spin: electrical frequency held constant to support measurements (example: QEI synchronization) */
102:                   MSST_SPIN = 4,
103:                   /** angle lock: electrical frequency may be changed by primary estimator */
104:                   MSST_ANGLE_LOCK = 5,
105:                   /** startup is complete; return to closed-loop operation */
106:                   MSST_COMPLETE = 6
107:               } MCAF_STARTUP_STATUS_T;
108:               
109:               /**
110:                * Motor startup state variables for use during open-loop startup.
111:                * 
112:                * Some of these variables appear to duplicate the main state;
113:                * this is because during open-loop startup, the applied electrical angle
114:                * and the estimated electrical angle are different.
115:                * Variables stored here are related to the applied electrical angle.
116:                */
117:               typedef struct tagMOTOR_STARTUP_DATA
118:               {
119:                    MCAF_U_CURRENT_DQ   idq;              /** dq-frame current */
120:                    /** Slewrate limit for current. It is given by (max openloop Iq/rampup rate) */
121:                    int16_t           iRampupLimit;   
122:               
123:                    /** estimated electrical angle (from outside of open-loop operation) */
124:                    MCAF_U_ANGLE_ELEC thetaElectricalEstimated;
125:                    MCAF_U_VELOCITY_ELEC omegaElectricalEstimated;
126:                    MCAF_U_DIMENSIONLESS_SINCOS sincos;           /** Sine and Cosine of electrical angle */
127:                    
128:                    /* ----- open-loop commutation ----- */
129:                    sx1632_t          omegaElectrical;  /** open-loop electrical frequency */
130:                    sx1632_t          thetaElectrical;  /** open-loop electrical angle */
131:                    MCAF_U_ANGLE_ELEC rampupAngle;      /** angle applied during current rampup */
132:                    MCAF_U_ANGLE_ELEC alignAngleDelta;  /** angle shift for align stage */
133:                       /* ----- two-stage acceleration ----- */
134:                    int16_t           acceleration[2];  /** open-loop accelerations  */
135:                    MCAF_U_VELOCITY_ELEC velocityThreshold[2]; /** velocity threshold to complete acceleration */
136:                    int16_t           dt;               /** timestep scaling factor for angle */
137:                    int16_t           dtAcceleration;   /** timestep scaling factor for acceleration */     
138:                    /* --------------------------------- */
139:                    struct
140:                    {
141:                        MCAF_U_CURRENT iqmax;  /** maximum damping current */
142:                        int16_t k;             /** damping constant */
143:                        MCAF_U_VELOCITY_ELEC velocityThreshold; /** velocity threshold to enable */
144:                    } activeDamping;    /** active damping */
145:                    
146:                    /**
147:                     * Time after initial rampup of current at a fixed electrical angle,
148:                     * and before open-loop acceleration during startup
149:                     */
150:                    uint32_t           alignTime;
151:                    /**
152:                     * Time after intial acceleration of velocity
153:                     * and before the rampdown of current during startup
154:                     */
155:                    uint32_t           holdTime;
156:                    /**
157:                     * This value is used to transition from open loop to closed loop.
158:                     * It is difference between forced angle and estimated angle. This difference is stored in
159:                     * thetaError, and added to estimated theta after transition so the
160:                     * effective angle used for commutating the motor is the same at
161:                     * the end of open loop, and at the beginning of closed loop.
162:                     */
163:                    sx1632_t           thetaError;   
164:                    /**
165:                     * When theta error falls below this threshold, open to close loop transition happens 
166:                     */
167:                    MCAF_U_ANGLE_ELEC  thetaDelta;         
168:                    /** Amplitude of applied current during startup */
169:                    MCAF_U_CURRENT     iAmplitude;
170:                    /** Nominal current applied during startup (sign depends on direction) */
171:                    MCAF_U_CURRENT     iNominal;
172:                    /** open-loop state machine state */
173:                    MCAF_STARTUP_FSM_STATE state;
174:                    /** Whether open-loop startup is enabled */
175:                    bool               enable;
176:                    /** Whether open-loop startup is complete */
177:                    bool               complete;
178:                    /** Request for delay */
179:                    bool               delayRequest;
180:                    /** Counter used in openloop for different states */
181:                    uint32_t           counter;  
182:                    /** 32-bit variable for torque command */
183:                    int32_t            torqueCmd32;
184:                    
185:               } MCAF_MOTOR_STARTUP_DATA;
186:               
187:               /**
188:                * Get implementation-independent status category
189:                * @param pstartup startup state
190:                * @return status category
191:                */
192:               inline static MCAF_STARTUP_STATUS_T MCAF_StartupGetStatus(const MCAF_MOTOR_STARTUP_DATA *pstartup)
193:               {
194:                   MCAF_STARTUP_FSM_STATE state = pstartup->state;
195:                   switch (state)
005998  91A951     MOV [W1+474], W2
00599A  510167     SUB W2, #0x7, W2
00599C  510FE1     SUB W2, #0x1, [W15]
00599E  3E019B     BRA GTU, .L13
006C80  91A858     MOV [W8+474], W0
006C84  500FE4     SUB W0, #0x4, [W15]
006C86  320014     BRA Z, .LBE400, .LBE401, .L5
006C88  3E000A     BRA GTU, .L11
006C8C  500F81     SUB W0, W1, [W15]
006C8E  320010     BRA Z, .LBE400, .LBE401, .L5
006C92  500FE2     SUB W0, #0x2, [W15]
006C94  3E000D     BRA GTU, .LBE400, .LBE401, .L5
006C98  E00000     CP0 W0
006C9A  32000A     BRA Z, .LBE400, .LBE401, .L5
006C9C  370008     BRA .L3
006CA0  500FE7     SUB W0, #0x7, [W15]
006CA2  320006     BRA Z, .LBE400, .LBE401, .L5
006CA4  500FE8     SUB W0, #0x8, [W15]
006CA6  320004     BRA Z, .LBE400, .LBE401, .L5
006CAA  500FE5     SUB W0, #0x5, [W15]
006CAC  320001     BRA Z, .LBE400, .LBE401, .L5
007208  91A858     MOV [W8+474], W0
00720A  500FE5     SUB W0, #0x5, [W15]
00720C  3A0005     BRA NZ, MCAF_CommutationStep::MCAF_OverrideCommutation
007284  91A858     MOV [W8+474], W0
007288  500FE4     SUB W0, #0x4, [W15]
00728A  320014     BRA Z, .LBE138, .LBE139, .L11
00728C  3E000A     BRA GTU, .L17
007290  500F81     SUB W0, W1, [W15]
007292  320010     BRA Z, .LBE138, .LBE139, .L11
007296  500FE2     SUB W0, #0x2, [W15]
007298  3E000D     BRA GTU, .LBE138, .LBE139, .L11
00729C  E00000     CP0 W0
00729E  32000A     BRA Z, .LBE138, .LBE139, .L11
0072A0  370008     BRA .L9
0072A4  500FE7     SUB W0, #0x7, [W15]
0072A6  320006     BRA Z, .LBE138, .LBE139, .L11
0072A8  500FE8     SUB W0, #0x8, [W15]
0072AA  320004     BRA Z, .LBE138, .LBE139, .L11
0072AE  500FE5     SUB W0, #0x5, [W15]
0072B0  320001     BRA Z, .LBE138, .LBE139, .L11
196:                   {
197:                       case SSM_START:      return MSST_RESTART;
006C96  200011     MOV #0x1, W1
00729A  200011     MOV #0x1, W1
198:                       case SSM_ALIGN:      return MSST_ALIGN;
006C8A  200021     MOV #0x2, W1
00728E  200021     MOV #0x2, W1
199:                       case SSM_ACCEL0:     return MSST_ACCEL;
006C90  200031     MOV #0x3, W1
007294  200031     MOV #0x3, W1
200:                       case SSM_ACCEL1:     return MSST_ACCEL;
006C82  200031     MOV #0x3, W1
007286  200031     MOV #0x3, W1
201:                       case SSM_HOLD:       return MSST_SPIN;
006CA8  200041     MOV #0x4, W1
0072AC  200041     MOV #0x4, W1
202:                       case SSM_TRANSITION: return MSST_COMPLETE;   // from the outside, once we get to this state, closed-loop is entered
006C9E  200061     MOV #0x6, W1
0072A2  200061     MOV #0x6, W1
203:                       case SSM_COMPLETE:   return MSST_COMPLETE;
204:                       default:             return MSST_UNSPECIFIED;
006CAE  EB0080     CLR W1
0072B2  EB0080     CLR W1
205:                   }
206:               }
207:               
208:               /* Startup delay mechanism:
209:                * 
210:                * Estimators or other algorithms may request the startup routine 
211:                * to delay progress during certain stages, if the startup algorithm allows it.
212:                * 
213:                * MCAF_StartupRequestDelay   -- other algorithm requests a delay in startup
214:                * MCAF_StartupDelayPermitted -- startup specifies whether it can be delayed
215:                */
216:               
217:               /**
218:                * Set a delay request flag to remain in certain states (ALIGN and SPIN)
219:                * NOTE: This is not a persistent flag; it needs to be re-asserted every control ISR
220:                * @param pstartup startup state
221:                */
222:               inline static void MCAF_StartupRequestDelay(MCAF_MOTOR_STARTUP_DATA *pstartup)
223:               {
224:                   pstartup->delayRequest = true;
007214  B3C010     MOV.B #0x1, W0
007216  9BDC60     MOV.B W0, [W8+478]
225:               }
226:               
227:               /**
228:                * Determines whether additional delays are allowed
229:                * 
230:                * @param pstartup startup state
231:                * @return whether additional delay requests are accepted
232:                */
233:               inline static bool MCAF_StartupDelayPermitted(MCAF_MOTOR_STARTUP_DATA *pstartup)
234:               {
235:                   return false;
236:               }
237:               
238:               /**
239:                * Get angle difference from estimator
240:                * @param pstartup startup state
241:                */
242:               inline static MCAF_U_ANGLE_ELEC MCAF_StartupGetThetaError(const MCAF_MOTOR_STARTUP_DATA *pstartup)
243:               {
244:                   return pstartup->thetaError.x16.hi;
0064D6  901A30     MOV [W0+54], W4
245:               }
246:               
247:               /**
248:                * Set angle difference from estimator
249:                * (important for smooth state transitions)
250:                * 
251:                * @param pstartup startup state
252:                * @param thetaError desired angle difference
253:                */
254:               inline static void MCAF_StartupSetThetaError(MCAF_MOTOR_STARTUP_DATA *pstartup, MCAF_U_ANGLE_ELEC thetaError)
255:               {
256:                   pstartup->thetaError.x16.hi = thetaError;
006516  EB0100     CLR W2
006518  981832     MOV W2, [W0+54]
00726E  99AC12     MOV W2, [W8+466]
257:               }
258:               
259:               /**
260:                * Get angle of current vector command in dq-plane
261:                * used during forced commutation.
262:                *
263:                * Note that this is in the forced reference frame
264:                * (the reference frame defined by the forced electrical angle)
265:                * and not the actual electrical angle. If the current is sufficiently large,
266:                * so that maximum torque is much larger than the load torque, 
267:                * it will tend to pull the rotor's d-axis towards the current vector.
268:                *
269:                * A current vector angle of zero (along the d-axis) 
270:                * will tend to pull the rotor's d-axis toward the d-axis
271:                * of the forced reference frame.
272:                *
273:                * @param pstartup startup state
274:                * @return angle of current vector
275:                */
276:               inline static MCAF_U_ANGLE_ELEC MCAF_StartupGetIdqCmdAngle(const MCAF_MOTOR_STARTUP_DATA *pstartup)
277:               {
278:                   /* 
279:                    * If iNominal is positive, we're applying current along the positive Q axis = +90 degrees.
280:                    * otherwise we're applying current along the negative Q axis = -90 degrees.
281:                    */
282:                   
283:                   const MCAF_U_ANGLE_ELEC ninety_degrees = 0x4000;
284:                   return UTIL_CopySign(pstartup->iNominal, ninety_degrees);
285:               }
286:               
287:               #ifdef __cplusplus
288:               }
289:               #endif
290:               
291:               #endif /* __STARTUP_TYPES_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/startup.h
1:                 /**
2:                  * startup.h
3:                  * 
4:                  * Module for startup and open loop to closed loop transition 
5:                  *
6:                  * Component: state machine
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __STARTUP_H
48:                #define __STARTUP_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                #include "util.h"
53:                #include "motor_control_types.h"
54:                #include "startup_types.h"
55:                #include "parameters/startup_params.h"
56:                
57:                #ifdef __cplusplus
58:                extern "C" {
59:                #endif
60:                
61:                /**
62:                 * Initializes state variables used for startup and open to close transition
63:                 * 
64:                 * @param pstartup startup state
65:                 */
66:                void MCAF_StartupTransitioningInit(MCAF_MOTOR_STARTUP_DATA *pstartup);
67:                /**
68:                 * State machine step for startup and transition from open- to closed-loop commutation
69:                 *
70:                 * Updates the current command (idqCommand) where appropriate.
71:                 * 
72:                 * @param pstartup startup state
73:                 * @param idqCommand open loop current command
74:                 * @param direction +1 for positive rotation, -1 for negative rotation
75:                 */
76:                void MCAF_StartupTransitioningStep(MCAF_MOTOR_STARTUP_DATA *pstartup, MC_DQ_T *idqCommand, int16_t direction);
77:                
78:                /**
79:                 * Reinitializes the startup process.
80:                 * 
81:                 * @param pstartup startup state
82:                 */
83:                inline static void MCAF_StartupReinit(MCAF_MOTOR_STARTUP_DATA *pstartup, int16_t direction)
84:                {
85:                    pstartup->omegaElectrical.x32 = 0;
004BAA  B81160     MUL.UU W2, #0x0, W2
004BAC  999452     MOV W2, [W8+426]
004BAE  999463     MOV W3, [W8+428]
007A0A  B81160     MUL.UU W2, #0x0, W2
007A0C  999452     MOV W2, [W8+426]
007A0E  999463     MOV W3, [W8+428]
008EDE  B81160     MUL.UU W2, #0x0, W2
008EE0  999052     MOV W2, [W0+426]
008EE2  999063     MOV W3, [W0+428]
86:                    pstartup->thetaElectrical.x32 = ((int32_t)pstartup->rampupAngle) << 16;
004BB0  919818     MOV [W8+434], W0
004BB2  DE80CF     ASR W0, #15, W1
004BB4  DD00C0     SL W0, #0, W1
004BB6  200000     MOV #0x0, W0
004BB8  999470     MOV W0, [W8+430]
004BBA  999C01     MOV W1, [W8+432]
007A10  919818     MOV [W8+434], W0
007A12  DE80CF     ASR W0, #15, W1
007A14  DD00C0     SL W0, #0, W1
007A16  200000     MOV #0x0, W0
007A18  999470     MOV W0, [W8+430]
007A1A  999C01     MOV W1, [W8+432]
008EE4  919A10     MOV [W0+434], W4
008EE6  DEA2CF     ASR W4, #15, W5
008EE8  DD22C0     SL W4, #0, W5
008EEA  200004     MOV #0x0, W4
008EEC  999074     MOV W4, [W0+430]
008EEE  999805     MOV W5, [W0+432]
87:                    pstartup->state = SSM_START;
004BBC  EB0000     CLR W0
004BBE  99AC50     MOV W0, [W8+474]
007A1C  EB0000     CLR W0
007A1E  99AC50     MOV W0, [W8+474]
008EF0  99A851     MOV W1, [W0+474]
88:                    pstartup->counter = 0;
004BC0  99B402     MOV W2, [W8+480]
004BC2  99B413     MOV W3, [W8+482]
007A20  99B402     MOV W2, [W8+480]
007A22  99B413     MOV W3, [W8+482]
008EF2  99B002     MOV W2, [W0+480]
008EF4  99B013     MOV W3, [W0+482]
89:                    pstartup->complete = false;
004BC4  9BDC50     MOV.B W0, [W8+477]
007A24  9BDC50     MOV.B W0, [W8+477]
008EF6  9BD851     MOV.B W1, [W0+477]
90:                    pstartup->enable = false;
004BC6  9BDC49     MOV.B W9, [W8+476]
007A26  9BDC49     MOV.B W9, [W8+476]
91:                    pstartup->delayRequest = false;
004BC8  9BDC69     MOV.B W9, [W8+478]
007A28  9BDC69     MOV.B W9, [W8+478]
008EF8  EB4080     CLR.B W1
008EFA  9BD861     MOV.B W1, [W0+478]
92:                    pstartup->iRampupLimit = STARTUP_TORQUE_RAMPUP_RATE;
004BCA  200010     MOV #0x1, W0
004BCC  999400     MOV W0, [W8+416]
007A2A  200010     MOV #0x1, W0
007A2C  999400     MOV W0, [W8+416]
008EFC  200011     MOV #0x1, W1
008EFE  999001     MOV W1, [W0+416]
93:                }
94:                
95:                /**
96:                 * Allows the startup process to proceed.
97:                 * 
98:                 * @param pstartup startup state
99:                 */
100:               inline static void MCAF_StartupEnable(MCAF_MOTOR_STARTUP_DATA *pstartup)
101:               {
102:                   pstartup->enable = true;
008F02  9BD841     MOV.B W1, [W0+476]
103:               }
104:               
105:               /**
106:                * Returns whether startup has completed
107:                * 
108:                * @param pstartup startup state
109:                * @return true if startup has completed
110:                */
111:               inline static bool MCAF_StartupHasCompleted(const MCAF_MOTOR_STARTUP_DATA *pstartup)
112:               {
113:                   return pstartup->complete;
114:               }
115:               
116:               /**
117:                * Returns whether startup is in open-loop commutation
118:                * 
119:                * @param pstartup startup state
120:                * @return true if startup is in open-loop commutation
121:                */
122:               inline static bool MCAF_StartupInOpenLoopCommutation(const MCAF_MOTOR_STARTUP_DATA *pstartup)
123:               {
124:                   return pstartup->state < SSM_TRANSITION;
125:               }
126:               
127:               /**
128:                * Returns the startup electrical angle
129:                * 
130:                * @param pstartup startup state
131:                * @return the startup electrical angle
132:                */
133:               inline static int16_t MCAF_StartupGetElectricalAngle(const MCAF_MOTOR_STARTUP_DATA *pstartup)
134:               {
135:                   return pstartup->thetaElectrical.x16.hi;
007264  919908     MOV [W8+432], W2
136:               }
137:               
138:               /**
139:                * Sets the startup electrical angle.
140:                * This should only be used with knowledge of what's going on in startup
141:                * (for example, that omegaElectrical = 0 in the align phase)
142:                * 
143:                * @param pstartup startup state
144:                * @param theta electrical angle
145:                */
146:               inline static void MCAF_StartupSetElectricalAngle(MCAF_MOTOR_STARTUP_DATA *pstartup, MCAF_U_ANGLE_ELEC theta)
147:               {
148:                   pstartup->thetaElectrical.x16.hi = theta;
149:               }
150:               
151:               /**
152:                * Returns the startup electrical frequency
153:                * 
154:                * @param pstartup startup state
155:                * @return the startup electrical frequency
156:                */
157:               inline static int16_t MCAF_StartupGetElectricalFrequency(const MCAF_MOTOR_STARTUP_DATA *pstartup)
158:               {
159:                   return pstartup->omegaElectrical.x16.hi;
160:               }
161:               
162:               /**
163:                * Calculates the next electrical angle in open-loop commutation.
164:                * 
165:                * @param pstartup startup state
166:                * @return the next startup electrical angle
167:                */
168:               inline static int16_t MCAF_StartupCalcNextElectricalAngle(MCAF_MOTOR_STARTUP_DATA *pstartup)
169:               {
170:                   pstartup->thetaElectrical.x32 += 
007252  919278     MOV [W8+430], W4
007254  919A88     MOV [W8+432], W5
00725C  420102     ADD W4, W2, W2
00725E  4A8183     ADDC W5, W3, W3
007260  999472     MOV W2, [W8+430]
007262  999C03     MOV W3, [W8+432]
171:                           UTIL_mulss(pstartup->dt, MCAF_StartupGetElectricalFrequency(pstartup));
172:                   return MCAF_StartupGetElectricalAngle(pstartup);
173:               }
174:               
175:               /**
176:                * Returns whether the reference frame has been flipped (rotated 180)
177:                * 
178:                * @param pstartup startup state
179:                * @return true if the reference frame has been flipped
180:                */
181:               inline static bool MCAF_StartupReferenceFrameFlip(MCAF_MOTOR_STARTUP_DATA *pstartup)
182:               {
183:                   return false;
184:               }
185:               
186:               #ifdef __cplusplus
187:               }
188:               #endif
189:               
190:               #endif /* __STARTUP_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/startup.c
1:                 /**
2:                  * startup.c
3:                  *
4:                  * Module for startup and open loop to closed loop transition
5:                  * 
6:                  * Component: state machine
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include <stdbool.h>
49:                #include "startup.h"
50:                #include "parameters/timing_params.h"
51:                #include "parameters/startup_params.h"
52:                #include "ui.h"
53:                #include "error_codes.h"
54:                #include "util.h"
55:                
56:                void MCAF_StartupTransitioningInit(MCAF_MOTOR_STARTUP_DATA *pstartup)
57:                {
58:                    pstartup->velocityThreshold[0] = STARTUP_ACCEL0_VELOCITY_THRESHOLD;
008E8A  216A61     MOV #0x16A6, W1
59:                    pstartup->velocityThreshold[1] = STARTUP_ACCEL1_VELOCITY_THRESHOLD;
008E8E  2176A1     MOV #0x176A, W1
008E90  981001     MOV W1, [W0+32]
60:                    pstartup->acceleration[0] = STARTUP_ACCELERATION0;
008E92  24CD11     MOV #0x4CD1, W1
008E94  980851     MOV W1, [W0+26]
61:                    pstartup->acceleration[1] = STARTUP_ACCELERATION1;
008E96  26FBE1     MOV #0x6FBE, W1
008E98  980861     MOV W1, [W0+28]
62:                    pstartup->alignTime = STARTUP_ALIGN_TIME;
008E9A  B81160     MUL.UU W2, #0x0, W2
008E9C  981062     MOV W2, [W0+44]
008E9E  981073     MOV W3, [W0+46]
63:                    pstartup->holdTime = STARTUP_HOLD_TIME;
008EA0  981802     MOV W2, [W0+48]
008EA2  981813     MOV W3, [W0+50]
64:                    pstartup->rampupAngle = STARTUP_RAMPUP_ANGLE;
008EA4  2EAAB1     MOV #0xEAAB, W1
008EA6  980831     MOV W1, [W0+22]
65:                    pstartup->alignAngleDelta = STARTUP_ALIGN_ANGLE_DELTA;
008EA8  215551     MOV #0x1555, W1
008EAA  980841     MOV W1, [W0+24]
66:                    pstartup->thetaDelta = Q15_THETADELTA;
008EAC  2071C1     MOV #0x71C, W1
008EAE  981841     MOV W1, [W0+56]
67:                    pstartup->iAmplitude = MCAF_STARTUP_CURRENT;
008EB0  2028D1     MOV #0x28D, W1
008EB2  981851     MOV W1, [W0+58]
68:                    pstartup->dt = STARTUP_DELTA_T_FACTOR;
008EB4  20A001     MOV #0xA00, W1
008EB6  981011     MOV W1, [W0+34]
69:                    pstartup->dtAcceleration = STARTUP_DELTA_T_FACTOR_ACCELERATION;
008EB8  200031     MOV #0x3, W1
008EBA  981021     MOV W1, [W0+36]
70:                    
71:                    pstartup->activeDamping.iqmax = STARTUP_DAMPING_IQMAX;
008EBC  200571     MOV #0x57, W1
008EBE  981031     MOV W1, [W0+38]
72:                    pstartup->activeDamping.k = STARTUP_DAMPING_GAIN;
008EC0  200391     MOV #0x39, W1
008EC2  981041     MOV W1, [W0+40]
73:                    pstartup->activeDamping.velocityThreshold = STARTUP_DAMPING_THRESHOLD;
008EC4  2095E1     MOV #0x95E, W1
008EC6  981051     MOV W1, [W0+42]
74:                }
008EC8  060000     RETURN
75:                
76:                inline static int16_t limit32(int32_t x, int16_t limitLo, int16_t limitHi)
77:                {
78:                    if (x > limitHi)
006388  B91B61     MUL.SU W3, #0x1, W6
00638A  520F86     SUB W4, W6, [W15]
00638C  5A8F87     SUBB W5, W7, [W15]
00638E  3C0006     BRA GT, .L23
0063F2  B91B61     MUL.SU W3, #0x1, W6
0063F4  520F86     SUB W4, W6, [W15]
0063F6  5A8F87     SUBB W5, W7, [W15]
0063F8  3C0006     BRA GT, .L27
006420  B91361     MUL.SU W2, #0x1, W6
006422  520F86     SUB W4, W6, [W15]
006424  5A8F87     SUBB W5, W7, [W15]
006426  3C0006     BRA GT, .L28
006498  B91361     MUL.SU W2, #0x1, W6
00649A  520F86     SUB W4, W6, [W15]
00649C  5A8F87     SUBB W5, W7, [W15]
00649E  3C0006     BRA GT, .L30
79:                    {
80:                        return limitHi;
81:                    }
82:                    else if (x < limitLo)
006392  B91B61     MUL.SU W3, #0x1, W6
006394  520F86     SUB W4, W6, [W15]
006396  5A8F87     SUBB W5, W7, [W15]
006398  350001     BRA LT, .L23
0063FC  B91B61     MUL.SU W3, #0x1, W6
0063FE  520F86     SUB W4, W6, [W15]
006400  5A8F87     SUBB W5, W7, [W15]
006402  350001     BRA LT, .L27
00642A  B91361     MUL.SU W2, #0x1, W6
00642C  520F86     SUB W4, W6, [W15]
00642E  5A8F87     SUBB W5, W7, [W15]
006430  350001     BRA LT, .L28
0064A2  B91361     MUL.SU W2, #0x1, W6
0064A4  520F86     SUB W4, W6, [W15]
0064A6  5A8F87     SUBB W5, W7, [W15]
0064A8  350001     BRA LT, .L30
83:                    {
84:                        return limitLo;
85:                    }
86:                    else
87:                    {
88:                        return x;
00639A  780184     MOV W4, W3
006404  780184     MOV W4, W3
006432  780104     MOV W4, W2
0064AA  780104     MOV W4, W2
89:                    }
90:                }
91:                
92:                /**
93:                 * add damping to nominal current
94:                 *
95:                 * @param pstartup startup data
96:                 * @param nominalCurrent nominal current without damping
97:                 * @return modified current
98:                 */
99:                inline static int16_t MCAF_StartupAddDamping(const MCAF_MOTOR_STARTUP_DATA *pstartup,
100:                       int16_t nominalCurrent)
101:               {
102:                   const int16_t omega_error = pstartup->omegaElectrical.x16.hi
006376  900340     MOV [W0+8], W6
006378  520206     SUB W4, W6, W4
0063E0  900340     MOV [W0+8], W6
0063E2  520206     SUB W4, W6, W4
00640C  900B00     MOV [W0+16], W6
00640E  900140     MOV [W0+8], W2
006410  530102     SUB W6, W2, W2
006484  900B00     MOV [W0+16], W6
006486  900140     MOV [W0+8], W2
006488  530102     SUB W6, W2, W2
103:                                               - pstartup->omegaElectricalEstimated;
104:                   const int32_t iqdamping_q32 = UTIL_mulss(omega_error, pstartup->activeDamping.k)
00637E  DD3C48     SL W7, #8, W8
006380  DE3248     LSR W6, #8, W4
006382  740204     IOR W8, W4, W4
006384  DEBAC8     ASR W7, #8, W5
0063E8  DD39C8     SL W7, #8, W3
0063EA  DE3248     LSR W6, #8, W4
0063EC  718204     IOR W3, W4, W4
0063EE  DEBAC8     ASR W7, #8, W5
006416  DD3C48     SL W7, #8, W8
006418  DE3248     LSR W6, #8, W4
00641A  740204     IOR W8, W4, W4
00641C  DEBAC8     ASR W7, #8, W5
00648E  DD3948     SL W7, #8, W2
006490  DE3248     LSR W6, #8, W4
006492  710204     IOR W2, W4, W4
006494  DEBAC8     ASR W7, #8, W5
105:                                                 >> STARTUP_DAMPING_SHIFT;
106:                   const int16_t iqdamping = limit32(iqdamping_q32,
006390  EA0183     NEG W3, W3
0063FA  EA0183     NEG W3, W3
006428  EA0102     NEG W2, W2
0064A0  EA0102     NEG W2, W2
107:                                                       -pstartup->activeDamping.iqmax,
006386  9011B0     MOV [W0+38], W3
0063F0  9011B0     MOV [W0+38], W3
00641E  901130     MOV [W0+38], W2
006496  901130     MOV [W0+38], W2
108:                                                       pstartup->activeDamping.iqmax);
109:                   return nominalCurrent + iqdamping;
00639C  410103     ADD W2, W3, W2
006406  410103     ADD W2, W3, W2
006434  410103     ADD W2, W3, W2
0064AC  410103     ADD W2, W3, W2
110:               }
111:               
112:               enum MCAF_STARTUP_DAMPING { MSD_ENABLED = 1, MSD_CONDITIONAL = 0 };
113:               
114:               /**
115:                *
116:                * @param pstartup startup data
117:                * @param nominalCurrent nominal current
118:                * @param enableDampingAlways whether to enable damping always
119:                * @return current command
120:                */
121:               inline static int16_t MCAF_StartupCalcIq(const MCAF_MOTOR_STARTUP_DATA *pstartup,
122:                       int16_t nominalCurrent,
123:                       enum MCAF_STARTUP_DAMPING dampingPreference)
124:               {
125:                   int16_t result = nominalCurrent;
126:                   if ((dampingPreference == MSD_ENABLED) ||
006370  9012D0     MOV [W0+42], W5
006372  518F85     SUB W3, W5, [W15]
006374  3400D9     BRA LE, .L12
0063DA  9012D0     MOV [W0+42], W5
0063DC  518F85     SUB W3, W5, [W15]
0063DE  3400A4     BRA LE, .L12
127:                           UTIL_Abs16Approx(pstartup->omegaElectrical.x16.hi)
006368  900A00     MOV [W0+16], W4
0063D2  900A00     MOV [W0+16], W4
128:                             > pstartup->activeDamping.velocityThreshold)
129:                   {
130:                       result = MCAF_StartupAddDamping(pstartup, nominalCurrent);
131:                   }
132:                   return result;
133:               }
134:               
135:               /**
136:                * Accelerate velocity, check whether velocity threshold is reached
137:                *
138:                * @param pstartup startup data
139:                * @param directedAcceleration acceleration (+ or -)
140:                * @param velocityThreshold threshold for completion
141:                * @return true if threshold is reached
142:                */
143:               inline static bool MCAF_StartupAccelVelocityIsComplete(MCAF_MOTOR_STARTUP_DATA *pstartup,
144:                       int16_t directedAcceleration,
145:                       int16_t velocityThreshold)
146:               {
147:                   const bool thresholdReached =
148:                       UTIL_Abs16(pstartup->omegaElectrical.x16.hi) >= velocityThreshold;
149:                   if (!thresholdReached)
006348  900A70     MOV [W0+30], W4
00634A  520F83     SUB W4, W3, [W15]
00634C  34000A     BRA LE, .L20
0063AC  901200     MOV [W0+32], W4
0063AE  520F83     SUB W4, W3, [W15]
0063B0  34000A     BRA LE, .L24
150:                   {
151:                       pstartup->omegaElectrical.x32 +=
00634E  900370     MOV [W0+14], W6
006350  900B80     MOV [W0+16], W7
006358  430102     ADD W6, W2, W2
00635A  4B8183     ADDC W7, W3, W3
00635C  980072     MOV W2, [W0+14]
00635E  980803     MOV W3, [W0+16]
006360  370002     BRA .L21
0063B2  900370     MOV [W0+14], W6
0063B4  900B80     MOV [W0+16], W7
0063BC  430102     ADD W6, W2, W2
0063BE  4B8183     ADDC W7, W3, W3
0063C0  980072     MOV W2, [W0+14]
0063C2  980803     MOV W3, [W0+16]
0063C4  370005     BRA .L25
152:                               UTIL_mulss(pstartup->dtAcceleration, directedAcceleration);
153:                   }
154:                   return thresholdReached;
155:               }
156:               
157:               #define MCAF_STARTUP_RESET_CYCLES 1
158:               
159:               void MCAF_StartupTransitioningStep(MCAF_MOTOR_STARTUP_DATA *pstartup,
160:                       MC_DQ_T *idqCommand, int16_t direction)
161:               
162:               {
006286  BE9F88     MOV.D W8, [W15++]
163:                   const int16_t iqtorquecmd = idqCommand->q;
006288  900191     MOV [W1+2], W3
164:                   int16_t iqtorquecmd_next = iqtorquecmd;
0062CE  780103     MOV W3, W2
00632A  780103     MOV W3, W2
00632C  3700FD     BRA .L12
006338  780103     MOV W3, W2
00633A  3700F6     BRA .L12
0064FA  780103     MOV W3, W2
0064FC  370015     BRA .L12
00650E  780103     MOV W3, W2
006510  37000B     BRA .L12
00651A  780103     MOV W3, W2
00651C  370005     BRA .L12
006522  780103     MOV W3, W2
006524  370001     BRA .L12
006526  780103     MOV W3, W2
165:                   
166:                   switch (pstartup->state)
00628A  901A70     MOV [W0+62], W4
00628C  EB0280     CLR W5
00628E  520FE9     SUB W4, #0x9, [W15]
006290  5A8FE0     SUBB W5, #0x0, [W15]
006292  3E0145     BRA GTU, .LBE203, .LBE208, .L3
006294  010604     BRA W4
006296  370009     BRA .SE13, .L4
006298  37001C     BRA .L5
00629A  37003C     BRA .L6
00629C  37004F     BRA .LBB130, .L7
00629E  370080     BRA .LBE130, .LBB153, .L8
0062A0  3700B4     BRA .LBE153, .L9
0062A2  3700E3     BRA .LBB186, .L10
0062A4  370118     BRA MCAF_StartupGetThetaError
0062A6  37013D     BRA .L34
0062A8  37013C     BRA .L34
167:                   {
168:                       case SSM_START:
169:                           /* startup in reset: stay in this state until re-enabled */
170:                           if (pstartup->enable)
0062AA  90C200     MOV.B [W0+64], W4
0062AC  E00404     CP0.B W4
0062AE  32000C     BRA Z, .L14
171:                           {
172:                               if (pstartup->counter < MCAF_STARTUP_RESET_CYCLES)
0062B0  902220     MOV [W0+68], W4
0062B2  9022B0     MOV [W0+70], W5
0062B4  520FE0     SUB W4, #0x0, [W15]
0062B6  5A8FE0     SUBB W5, #0x0, [W15]
0062B8  3A0005     BRA NZ, .L15
173:                               {
174:                                   ++pstartup->counter;
0062BA  200014     MOV #0x1, W4
0062BC  200005     MOV #0x0, W5
0062BE  982024     MOV W4, [W0+68]
0062C0  982035     MOV W5, [W0+70]
0062C2  370002     BRA .L14
175:                               }
176:                               else
177:                               {
178:                                   pstartup->state = SSM_CURRENT_RAMPUP;
0062C4  200014     MOV #0x1, W4
0062C6  981874     MOV W4, [W0+62]
179:                               }
180:                           }
181:                           pstartup->iNominal = pstartup->iAmplitude * direction;
0062C8  901A50     MOV [W0+58], W4
0062CA  B99184     MULW.SS W2, W4, W2
0062CC  981862     MOV W2, [W0+60]
182:                           break;
0062D0  37012B     BRA .L12
183:                       case SSM_CURRENT_RAMPUP:
184:                       {
185:                           iqtorquecmd_next = UTIL_LimitSlewRateSymmetrical(
0062D2  900220     MOV [W0+4], W4
006310  780103     MOV W3, W2
006312  37010A     BRA .L12
186:                                   pstartup->iNominal,                /* input */
187:                                   iqtorquecmd,                        /* previousOutput */
188:                                   pstartup->iRampupLimit);           /* limit */
189:               
190:                           if (iqtorquecmd == iqtorquecmd_next)
0062FA  518F82     SUB W3, W2, [W15]
0062FC  3A0115     BRA NZ, .L12
191:                           {
192:                               pstartup->counter = 0;
0062FE  B82260     MUL.UU W4, #0x0, W4
006300  982024     MOV W4, [W0+68]
006302  982035     MOV W5, [W0+70]
193:                               pstartup->state = SSM_ALIGN;
006304  200022     MOV #0x2, W2
006306  981872     MOV W2, [W0+62]
194:                               pstartup->thetaElectrical.x16.hi += pstartup->alignAngleDelta;
006308  900A20     MOV [W0+20], W4
00630A  900940     MOV [W0+24], W2
00630C  420102     ADD W4, W2, W2
00630E  980822     MOV W2, [W0+20]
195:                           }
196:                           break;
197:                       }
198:                       case SSM_ALIGN:
199:                       {
200:                           if (pstartup->counter < pstartup->alignTime)
006314  902220     MOV [W0+68], W4
006316  9022B0     MOV [W0+70], W5
006318  901360     MOV [W0+44], W6
00631A  9013F0     MOV [W0+46], W7
00631C  520F86     SUB W4, W6, [W15]
00631E  5A8F87     SUBB W5, W7, [W15]
006320  310006     BRA C, .L19
201:                           {
202:                               ++pstartup->counter;
006322  420261     ADD W4, #0x1, W4
006324  4A82E0     ADDC W5, #0x0, W5
006326  982024     MOV W4, [W0+68]
006328  982035     MOV W5, [W0+70]
203:                           }
204:                           else if (!pstartup->delayRequest)
00632E  90C120     MOV.B [W0+66], W2
006330  E00402     CP0.B W2
006332  3A00F9     BRA NZ, .L35
205:                           {
206:                               pstartup->state = SSM_ACCEL0;
006334  200032     MOV #0x3, W2
006336  981872     MOV W2, [W0+62]
207:                           }
208:                           break;
209:                       }
210:                       case SSM_ACCEL0:
211:                       {
212:                           int16_t directed_accel = pstartup->acceleration[0] * direction;
00633C  900AD0     MOV [W0+26], W5
006354  B99185     MULW.SS W2, W5, W2
213:                           if (MCAF_StartupAccelVelocityIsComplete(pstartup, directed_accel,
214:                                   pstartup->velocityThreshold[0]))
215:                           {
216:                               pstartup->state = SSM_ACCEL1;
006362  200042     MOV #0x4, W2
006364  981872     MOV W2, [W0+62]
217:                           }
218:                           iqtorquecmd_next = MCAF_StartupCalcIq(pstartup, pstartup->iNominal, MSD_CONDITIONAL);
006366  901960     MOV [W0+60], W2
219:                           break;
00639E  3700C4     BRA .L12
220:                       }
221:                       case SSM_ACCEL1:
222:                       {
223:                           int16_t directed_accel = pstartup->acceleration[1] * direction;
0063A0  900AE0     MOV [W0+28], W5
0063B8  B99185     MULW.SS W2, W5, W2
224:                           if (MCAF_StartupAccelVelocityIsComplete(pstartup, directed_accel,
225:                                   pstartup->velocityThreshold[1]))
226:                           {
227:                               pstartup->counter = 0;
0063C6  B81160     MUL.UU W2, #0x0, W2
0063C8  982022     MOV W2, [W0+68]
0063CA  982033     MOV W3, [W0+70]
228:                               pstartup->state = SSM_HOLD;
0063CC  200052     MOV #0x5, W2
0063CE  981872     MOV W2, [W0+62]
229:                           }
230:                           iqtorquecmd_next = MCAF_StartupCalcIq(pstartup, pstartup->iNominal, MSD_CONDITIONAL);
0063D0  901960     MOV [W0+60], W2
231:                           break;
006408  37008F     BRA .L12
232:                       }
233:                       case SSM_HOLD:
234:                       {
235:                           iqtorquecmd_next = MCAF_StartupCalcIq(pstartup, pstartup->iNominal, MSD_ENABLED);
00640A  9019E0     MOV [W0+60], W3
236:                           if (pstartup->counter < pstartup->holdTime)
006436  902220     MOV [W0+68], W4
006438  9022B0     MOV [W0+70], W5
00643A  901B00     MOV [W0+48], W6
00643C  901B90     MOV [W0+50], W7
00643E  520F86     SUB W4, W6, [W15]
006440  5A8F87     SUBB W5, W7, [W15]
006442  310005     BRA C, .L29
237:                           {
238:                               ++pstartup->counter;
006444  420261     ADD W4, #0x1, W4
006446  4A82E0     ADDC W5, #0x0, W5
006448  982024     MOV W4, [W0+68]
00644A  982035     MOV W5, [W0+70]
00644C  37006D     BRA .L12
239:                           }
240:                           else
241:                           {                
242:                               if (!pstartup->delayRequest)
00644E  90C1A0     MOV.B [W0+66], W3
006450  E00403     CP0.B W3
006452  3A006A     BRA NZ, .L12
243:                               {
244:                                   pstartup->counter = 0;
006454  B82260     MUL.UU W4, #0x0, W4
006456  982024     MOV W4, [W0+68]
006458  982035     MOV W5, [W0+70]
245:                                   pstartup->state = SSM_CURRENT_RAMPDOWN;
00645A  200063     MOV #0x6, W3
00645C  981873     MOV W3, [W0+62]
246:                                   pstartup->torqueCmd32 = (int32_t)iqtorquecmd_next << 16;
00645E  B91261     MUL.SU W2, #0x1, W4
006460  DD22C0     SL W4, #0, W5
006462  200004     MOV #0x0, W4
006464  982044     MOV W4, [W0+72]
006466  982055     MOV W5, [W0+74]
006468  37005F     BRA .L12
247:                               }
248:                           }
249:                           break;
250:                       }
251:                       case SSM_CURRENT_RAMPDOWN:
252:                       {
253:                           /* Decrease magnitude of Iq current torque command
254:                            * to reduce startup theta error */
255:                           pstartup->torqueCmd32 -=
00647A  520202     SUB W4, W2, W4
00647C  5A8283     SUBB W5, W3, W5
00647E  982044     MOV W4, [W0+72]
006480  982055     MOV W5, [W0+74]
256:                                   UTIL_mulss(pstartup->torqueCmd32 >> 16,
00646A  902240     MOV [W0+72], W4
00646C  9022D0     MOV [W0+74], W5
257:                                               MCAF_RAMPDOWN_DECAY_RATE) >> MCAF_RAMPDOWN_DECAY_SHIFT;
006472  DD3C48     SL W7, #8, W8
006474  DE3148     LSR W6, #8, W2
006476  740102     IOR W8, W2, W2
006478  DEB9C8     ASR W7, #8, W3
258:                           const int16_t nominalCurrent = pstartup->torqueCmd32 >> 16;
006482  780185     MOV W5, W3
259:                           iqtorquecmd_next = MCAF_StartupCalcIq(pstartup, nominalCurrent, MSD_ENABLED);
260:                           if (UTIL_Abs16Approx(nominalCurrent) <= MCAF_RAMPDOWN_END_CURRENT)
0064B2  200214     MOV #0x21, W4
0064B4  518F84     SUB W3, W4, [W15]
0064B6  3C0004     BRA GT, UTIL_Abs16Approx
261:                           {
262:                               pstartup->complete = true;
0064B8  B3C013     MOV.B #0x1, W3
0064BA  98C013     MOV.B W3, [W0+65]
263:                               pstartup->state = SSM_TRANSITION;
0064BC  200073     MOV #0x7, W3
0064BE  981873     MOV W3, [W0+62]
264:                           }
265:                           if (UTIL_Abs16Approx(MCAF_StartupGetThetaError(pstartup)) < pstartup->thetaDelta)
0064C6  901A40     MOV [W0+56], W4
0064C8  520F83     SUB W4, W3, [W15]
0064CA  34002E     BRA LE, .L12
266:                           {
267:                               pstartup->complete = true;
0064CC  B3C013     MOV.B #0x1, W3
0064CE  98C013     MOV.B W3, [W0+65]
268:                               pstartup->state = SSM_TRANSITION;
0064D0  200073     MOV #0x7, W3
0064D2  981873     MOV W3, [W0+62]
0064D4  370029     BRA .L12
269:                           }
270:                           break;
271:                       }
272:                       case SSM_TRANSITION:
273:                       {
274:                           sx1632_t errorConvergeStep;
275:                           errorConvergeStep.x32 = ((int32_t)STARTUP_THETA_ERROR_CONVERGE_RATE) << (32-STARTUP_THETA_ERROR_CONVERGE_RATE_Q);
276:                           const MCAF_U_ANGLE_ELEC thetaError = MCAF_StartupGetThetaError(pstartup);
277:                           if (UTIL_Abs16(thetaError) > errorConvergeStep.x16.hi)
0064E2  510FE9     SUB W2, #0x9, [W15]
0064E4  340016     BRA LE, .L32
278:                           {
279:                               if (thetaError < 0)
0064E6  E00004     CP0 W4
0064E8  3D000A     BRA GE, .L33
280:                               {
281:                                   pstartup->thetaError.x32 += errorConvergeStep.x32;
0064EA  901B20     MOV [W0+52], W6
0064EC  901BB0     MOV [W0+54], W7
0064EE  21A004     MOV #0x1A00, W4
0064F0  200095     MOV #0x9, W5
0064F2  420206     ADD W4, W6, W4
0064F4  4A8287     ADDC W5, W7, W5
0064F6  981824     MOV W4, [W0+52]
0064F8  981835     MOV W5, [W0+54]
282:                               }
283:                               else
284:                               {
285:                                   pstartup->thetaError.x32 -= errorConvergeStep.x32;
0064FE  901B20     MOV [W0+52], W6
006500  901BB0     MOV [W0+54], W7
006502  2E6004     MOV #0xE600, W4
006504  2FFF65     MOV #0xFFF6, W5
006506  420206     ADD W4, W6, W4
006508  4A8287     ADDC W5, W7, W5
00650A  981824     MOV W4, [W0+52]
00650C  981835     MOV W5, [W0+54]
286:                               }
287:                           }
288:                           else
289:                           {
290:                               pstartup->state = SSM_COMPLETE;
006512  200082     MOV #0x8, W2
006514  981872     MOV W2, [W0+62]
291:                               MCAF_StartupSetThetaError(pstartup, 0);
292:                           }
293:                           break;
294:                       }
295:                       case SSM_COMPLETE:
296:                           /* startup complete: do nothing */
297:                           break;
298:                       case SSM_INACTIVE:
299:                           /* do nothing in test modes */
300:                           break;
301:                       default:
302:                       {
303:                           MCAF_UiFlashErrorCodeForever(ERR_INVALID_STARTUP_FSM_STATE);
00651E  200110     MOV #0x11, W0
006520  07119A     RCALL MCAF_UiFlashErrorCodeForever
304:                       }
305:                   }
306:                   idqCommand->q = iqtorquecmd_next;
006528  980092     MOV W2, [W1+2]
307:                   pstartup->delayRequest = false;
00652A  EB4080     CLR.B W1
00652C  98C021     MOV.B W1, [W0+66]
308:               }
00652E  BE044F     MOV.D [--W15], W8
006530  060000     RETURN
006532  002594     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/stall_detect.h
1:                 /**
2:                  * stall_detect.h
3:                  *
4:                  * Module to detect when motor is stall
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include <stdbool.h>
49:                #include "system_state.h"
50:                #include "stall_detect_types.h"
51:                
52:                #ifndef STALL_DETECT_H
53:                #define STALL_DETECT_H
54:                
55:                #ifdef __cplusplus
56:                extern "C" {
57:                #endif
58:                
59:                void MCAF_StallDetectInit(MCAF_STALL_DETECT_T *pstallDetect);
60:                
61:                void MCAF_StallDetectReset(MCAF_STALL_DETECT_T *pstallDetect);
62:                
63:                /**
64:                * Updates status of stall detect flag
65:                *
66:                * @param pstallDetect stall detect state
67:                * @param pmotor input signals for various indicators for stall detection
68:                */
69:                void MCAF_StallDetect(MCAF_STALL_DETECT_T *pstallDetect, const MCAF_MOTOR_DATA *pmotor);
70:                
71:                /**
72:                 * Returns whether stall detect is active
73:                 * @param pstallDetect stall detect state
74:                 * @return true if active
75:                 */
76:                inline static bool MCAF_StallDetectActive(const MCAF_STALL_DETECT_T *pstallDetect)
77:                {
78:                    return pstallDetect->active;
0090D6  202B00     MOV #0x2B0, W0
0090D8  400008     ADD W0, W8, W0
79:                }
80:                
81:                /**
82:                 * Activates stall detection
83:                 * @param pstallDetect stall detect state
84:                 */
85:                inline static void MCAF_StallDetectActivate(MCAF_STALL_DETECT_T *pstallDetect)
86:                {
87:                    pstallDetect->active = true;
004CCE  202B00     MOV #0x2B0, W0
004CD0  400008     ADD W0, W8, W0
004CD2  B3C011     MOV.B #0x1, W1
004CD4  784801     MOV.B W1, [W0]
88:                }
89:                
90:                /**
91:                 * Returns stall detection flag
92:                 * @param pstallDetect stall detect state
93:                 */
94:                inline static uint16_t MCAF_StallDetectGetMaskedFlags(const MCAF_STALL_DETECT_T *pstallDetect)
95:                {
96:                    return pstallDetect->stallDetectFlag & pstallDetect->stallDetectFlagMask;
0090EC  9290D8     MOV [W8+682], W1
0090EE  929048     MOV [W8+680], W0
0090F0  608000     AND W1, W0, W0
97:                }
98:                
99:                /**
100:                * Clears stall detection flag
101:                * @param pstallDetect stall detect state
102:                */
103:               inline static uint16_t MCAF_StallDetectClearMaskFlags(MCAF_STALL_DETECT_T *pstallDetect, uint16_t mask)
104:               {
105:                   pstallDetect->stallDetectFlag &= mask;
106:                   return pstallDetect->stallDetectFlag;
107:               }
108:               
109:               /**
110:                * Deactivates stall detection
111:                * @param pstallDetect stall detect state
112:                */
113:               inline static void MCAF_StallDetectDeactivate(MCAF_STALL_DETECT_T *pstallDetect)
114:               {
115:                   pstallDetect->active = false;
004BD6  202B00     MOV #0x2B0, W0
004BD8  400008     ADD W0, W8, W0
004BDA  784809     MOV.B W9, [W0]
004C9E  202B00     MOV #0x2B0, W0
004CA0  400008     ADD W0, W8, W0
004CA2  EB4800     CLR.B [W0]
007A36  202B00     MOV #0x2B0, W0
007A38  400008     ADD W0, W8, W0
007A3A  784809     MOV.B W9, [W0]
116:               }
117:               
118:               #ifdef __cplusplus
119:               }
120:               #endif
121:               
122:               #endif /* STALL_DETECT_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/stall_detect.c
1:                 /**
2:                  * stall_detect.c
3:                  *
4:                  * Module to detect when motor is stall
5:                  *
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include "stall_detect.h"
48:                #include "parameters/fault_detect_params.h"
49:                #include "parameters/options.h"
50:                #include "parameters/operating_params.h"
51:                #include "util.h"
52:                #include "filter_types.h"
53:                #include "filter.h"
54:                
55:                /**
56:                 * Initializes parameters related to variance detector
57:                 *
58:                 * @param pvariancex16 variance detect state
59:                 */
60:                void MCAF_VarianceDetectx16Init(MCAF_VARIANCE_DETECT_T *pvariancex16);
61:                
62:                /**
63:                 * Computes variance of Ed and Eq signal and indicate stall
64:                 * when high frequency content of Ed and Eq exceeds DC content
65:                 *
66:                 * Summary : 1st of 2 stage implementation of variance detect
67:                 *
68:                 * @param pvariancex16 variance detect state
69:                 * @param input signals including Ed and Eq
70:                 */
71:                void MCAF_VarianceDetectx16(MCAF_VARIANCE_DETECT_T *pvariancex16,
72:                        const MCAF_STALL_DETECT_INPUT_T *pinputs);
73:                
74:                /**
75:                 * Computes variance of Ed and Eq signal and indicate stall
76:                 * when high frequency content of Ed and Eq exceeds DC content
77:                 *
78:                 * Summary : 2nd of 2 stage implementation of variance detect
79:                 *
80:                 * @param pvariancex16 variance detect state
81:                 * @return whether high frequency content in Es is higher than DC content (true = detected)
82:                */
83:                bool MCAF_VarianceDetectx16PostDecimation(MCAF_VARIANCE_DETECT_T *pvariancex16);
84:                
85:                /**
86:                 * Initializes parameters related to torque angle based stall detection
87:                 *
88:                 * @param ptorqueangle torque angle detect state
89:                 */
90:                void MCAF_TorqueAngleDetectInit(MCAF_TORQUE_ANGLE_DETECT_T *ptorqueAngle);
91:                
92:                /**
93:                 * Computes torque angle of motor and indicates stall
94:                 * when torque angle falls below computed threshold based on speed
95:                 *
96:                 * Summary : Torque angle based stall detect
97:                 *
98:                 * @param ptorqueangle torque angle detect state
99:                 * @param pinputs input signals including Ed and Eq
100:                * @return whether (Vs^2)*(stall_const)^2 is greater than (Es^2) (true = detected)
101:               */
102:               bool MCAF_TorqueAngleDetect(MCAF_TORQUE_ANGLE_DETECT_T *ptorqueAngle,
103:                       const MCAF_STALL_DETECT_INPUT_T *pinputs);
104:               
105:               /**
106:                * Initializes parameters related to overcurrent detect
107:                *
108:                * @param povercurrent overcurrent detect state
109:                */
110:               void MCAF_OvercurrentDetectInit(MCAF_OVERCURRENT_SW_DETECT_T *povercurrent);
111:               
112:               /**
113:                * Computes Is (Id^2 + Iq^2) and indicates stall when Is exceeds threshold
114:                *
115:                * Summary : Over current stall detect
116:                *
117:                * @param povercurrent overcurrent detect state
118:                * @param pidq current vector Idq
119:                * @return whether (Is^2) is greater than threshold (true = detected)
120:                */
121:               bool MCAF_OvercurrentDetect(MCAF_OVERCURRENT_SW_DETECT_T *povercurrent, const MC_DQ_T *pidq);
122:               
123:               /**
124:                * Initializes parameters related to low speed detect
125:                *
126:                * @param plowspeed low speed detect state
127:                */
128:               void MCAF_LowSpeedDetectInit(MCAF_LOW_SPEED_DETECT_T *plowSpeed);
129:               
130:               /**
131:                * Monitors estimated velocity and indicates stall when velocity falls below threshold
132:                *
133:                * @param plowspeed low speed detect state
134:                * @param omega estimated velocity by estimator
135:                * @return whether omega_electrical is below threshold (true = detected)
136:                */
137:               bool MCAF_LowSpeedDetect(MCAF_LOW_SPEED_DETECT_T *plowSpeed, int16_t omega);
138:               
139:               /**
140:                * Initializes parameters related to negative Ed based stall detect
141:                *
142:                * @param Negative Ed stall detect state
143:                */
144:               void MCAF_NegativeEdDetectInit(MCAF_NEGATIVE_ED_DETECT_T *pEdState);
145:               
146:               /**
147:                * Monitors Ed and saturation state. It will indicates stall
148:                * when Ed goes negative and there is current saturation
149:                *
150:                * Summary : Negative Ed stall detect
151:                *
152:                * @param pedstate Negative Ed stall detect state
153:                * @param pinputs input signals including estimated d-axis back-EMF
154:                * @param currsat true = sat current, false = no saturation on current
155:                * @return whether Ed is below threshold during current saturation (true = detected)
156:                */
157:               bool MCAF_NegativeEdDetect(MCAF_NEGATIVE_ED_DETECT_T *pedState,
158:                       const MCAF_STALL_DETECT_INPUT_T *pinputs,
159:                       bool currsat);
160:               
161:               /**
162:                * Initializes various parameters associated with stall detect
163:                *
164:                * @param pstalldetect stall detect state
165:                */
166:               
167:               void MCAF_StallDetectInit(MCAF_STALL_DETECT_T *pstallDetect)
168:               {
009132  781F88     MOV W8, [W15++]
009134  780400     MOV W0, W8
169:               
170:                   MCAF_VarianceDetectx16Init(&pstallDetect->varianceDetect);
009136  44006E     ADD W8, #0xE, W0
009138  0702F1     RCALL MCAF_VarianceDetectx16Init
171:                   MCAF_OvercurrentDetectInit(&pstallDetect->overcurrentDetect);
00913A  200480     MOV #0x48, W0
00913C  400008     ADD W0, W8, W0
00913E  0704B9     RCALL MCAF_OvercurrentDetectInit
172:                   MCAF_LowSpeedDetectInit(&pstallDetect->lowSpeedDetect);
009140  2006E0     MOV #0x6E, W0
009142  400008     ADD W0, W8, W0
009144  0704CA     RCALL MCAF_LowSpeedDetectInit
173:                   MCAF_NegativeEdDetectInit(&pstallDetect->negativeEdDetect);
009146  2005C0     MOV #0x5C, W0
009148  400008     ADD W0, W8, W0
00914A  0704BD     RCALL MCAF_NegativeEdDetectInit
174:                   MCAF_TorqueAngleDetectInit(&pstallDetect->torqueAngleDetect);
00914C  200800     MOV #0x80, W0
00914E  400008     ADD W0, W8, W0
009150  07025E     RCALL MCAF_TorqueAngleDetectInit
175:                   pstallDetect->stallDetectFlag = 0;
009152  EB0000     CLR W0
009154  989440     MOV W0, [W8+168]
176:                   pstallDetect->stallDetectFlagMask = ~MCAF_TORQUE_ANGLE_STALL_DETECT;    //Do not detect torque angle stall
009156  2FFEF1     MOV #0xFFEF, W1
009158  989451     MOV W1, [W8+170]
177:                   pstallDetect->decimationTimer = 0;
00915A  989460     MOV W0, [W8+172]
178:                   pstallDetect->decimationTimerThreshold = DECIMATION_FACTOR;
00915C  200640     MOV #0x64, W0
00915E  989470     MOV W0, [W8+174]
179:               }
009160  78044F     MOV [--W15], W8
009162  060000     RETURN
009164  22FEC0     MOV #0x2FEC, W0
009166  0701AC     RCALL MCAF_UiStepMain
180:               
181:               
182:               void MCAF_VarianceDetectx16Reset(MCAF_VARIANCE_DETECT_T *pvariancex16)
183:               {
184:                       /* Initialize state variables for 16 bit implementation of LPF and HPF */
185:                   MCAF_LpfFilterInitx16(&pvariancex16->lpf1EsSqr);
186:                   MCAF_LpfFilterInitx16(&pvariancex16->lpf2EsSqr);
187:               
188:                   MCAF_LpfFilterInitx16(&pvariancex16->lpf1HpEsSqr);
189:                   MCAF_LpfFilterInitx16(&pvariancex16->lpf2HpEsSqr);
190:               
191:                   MCAF_HpfFilterInitx16(&pvariancex16->hpfEd);
192:                   MCAF_HpfFilterInitx16(&pvariancex16->hpfEq);
193:                   
194:                   /* Timer counts for variance detect */
195:                   pvariancex16->timer = 0;
00924C  981812     MOV W2, [W0+50]
00924E  981823     MOV W3, [W0+52]
196:               }
009250  060000     RETURN
197:               
198:               void MCAF_VarianceDetectx16Init(MCAF_VARIANCE_DETECT_T *pvariancex16)
199:               {
200:                   /* Initialize a1 filter constant for 16 bit implementation of LPF */
201:                   pvariancex16->lpf1EsSqr.coeff = DECIMATION_FILTER_LPF1_VARIANCE_DETECT_COEFFA1;
00971C  200672     MOV #0x67, W2
00971E  780802     MOV W2, [W0]
202:                   pvariancex16->lpf2EsSqr.coeff = DECIMATION_FILTER_LPF2_VARIANCE_DETECT_COEFFA1;
009720  205D71     MOV #0x5D7, W1
009722  980041     MOV W1, [W0+8]
203:               
204:                   pvariancex16->lpf1HpEsSqr.coeff = DECIMATION_FILTER_LPF1_VARIANCE_DETECT_COEFFA1;
009724  980802     MOV W2, [W0+16]
205:                   pvariancex16->lpf2HpEsSqr.coeff = DECIMATION_FILTER_LPF2_VARIANCE_DETECT_COEFFA1;
009726  980841     MOV W1, [W0+24]
206:               
207:                   /* Initialize filter constant for 16 bit implementation of HPF */
208:                   pvariancex16->hpfEd.coeff = FILTER_HPF_VARIANCE_DETECT;
009728  202561     MOV #0x256, W1
00972A  981001     MOV W1, [W0+32]
209:                   pvariancex16->hpfEq.coeff = FILTER_HPF_VARIANCE_DETECT;
00972C  981041     MOV W1, [W0+40]
210:               
211:                   /* Initialize timer for variance detect */
212:                   pvariancex16->timerThreshold = TIMER_COUNTS_VARIANCE_DETECT;
00972E  2000E2     MOV #0xE, W2
009730  200003     MOV #0x0, W3
009732  981832     MOV W2, [W0+54]
009734  981843     MOV W3, [W0+56]
213:                   /* Timer counts for variance detect */
214:                   MCAF_VarianceDetectx16Reset(pvariancex16);
009736  07FD76     RCALL MCAF_VarianceDetectx16Reset
215:               }
009738  060000     RETURN
00973A  912130     MOV [W0+326], W2
00973C  9121C0     MOV [W0+328], W3
00973E  9A0002     MOV W2, [W0+512]
009740  9A0013     MOV W3, [W0+514]
216:               
217:               void MCAF_OvercurrentDetectReset(MCAF_OVERCURRENT_SW_DETECT_T *povercurrent)
218:               {
219:                   /* Initialize state variables for LPF */
220:                   MCAF_LpfFilterInitx16(&povercurrent->lpfIs);
221:               
222:                   povercurrent->timer = 0;
009C28  980062     MOV W2, [W0+12]
009C2A  980073     MOV W3, [W0+14]
223:               }
009C2C  060000     RETURN
009C2E  200011     MOV #0x1, W1
224:               
225:               
226:               void MCAF_OvercurrentDetectInit(MCAF_OVERCURRENT_SW_DETECT_T *povercurrent)
227:               {
228:                   /* Initialize a1 filter constant for 16 bit implementation of LPF */
229:                   povercurrent->lpfIs.coeff = FILTER_LPF_OVERCURRENT_DETECT;
009AB2  200951     MOV #0x95, W1
230:               
231:                   povercurrent->overcurrentThreshold = THRESHOLD_OVERCURRENT_STALL_DETECT;
009AB6  203B71     MOV #0x3B7, W1
009AB8  980041     MOV W1, [W0+8]
232:                   povercurrent->timerThreshold = TIMER_COUNTS_OVERCURRENT_DETECT;
009ABA  200AA2     MOV #0xAA, W2
009ABC  200003     MOV #0x0, W3
009ABE  980802     MOV W2, [W0+16]
009AC0  980813     MOV W3, [W0+18]
233:               
234:                   MCAF_OvercurrentDetectReset(povercurrent);
009AC2  0700AD     RCALL MCAF_OvercurrentDetectReset
235:               }
009AC4  060000     RETURN
009AC6  21AE62     MOV #0x1AE6, W2
236:               
237:               void MCAF_NegativeEdDetectReset(MCAF_NEGATIVE_ED_DETECT_T *pEdState)
238:               {
239:                   pEdState->timerActive = 0;
009D3C  B81160     MUL.UU W2, #0x0, W2
009D3E  980052     MOV W2, [W0+10]
009D40  980063     MOV W3, [W0+12]
240:                   pEdState->timerInactive = 0;
009D42  980012     MOV W2, [W0+2]
009D44  980023     MOV W3, [W0+4]
241:               }
009D46  060000     RETURN
009D48  B81160     MUL.UU W2, #0x0, W2
242:               
243:               
244:               void MCAF_NegativeEdDetectInit(MCAF_NEGATIVE_ED_DETECT_T *pEdState)
245:               {
246:                   pEdState->timeActiveThreshold = ACTIVE_TIMER_THRESHOLD_NEGATIVE_ED_DETECT;
009AC6  21AE62     MOV #0x1AE6, W2
009AC8  200003     MOV #0x0, W3
009ACA  980072     MOV W2, [W0+14]
009ACC  980803     MOV W3, [W0+16]
247:               
248:                   pEdState->timerInactiveThreshold = INACTIVE_TIMER_THRESHOLD_NEGATIVE_ED_DETECT;
009ACE  980032     MOV W2, [W0+6]
009AD0  980043     MOV W3, [W0+8]
249:               
250:                   pEdState->edThreshold = THRESHOLD_ED_STALL_DETECT;
009AD2  200051     MOV #0x5, W1
009AD4  780801     MOV W1, [W0]
251:                   
252:                   MCAF_NegativeEdDetectReset(pEdState);
009AD6  070132     RCALL MCAF_NegativeEdDetectReset
253:               }
009AD8  060000     RETURN
009ADA  2071A1     MOV #0x71A, W1
254:               
255:               void MCAF_TorqueAngleDetectReset(MCAF_TORQUE_ANGLE_DETECT_T *pTorqueAngle)
256:               {
257:                   pTorqueAngle->esSqr = 0;
009B50  EB0080     CLR W1
258:                   pTorqueAngle->vsSqr = 0;
009B54  980011     MOV W1, [W0+2]
259:                   pTorqueAngle->timerActive = 0;
009B56  B81160     MUL.UU W2, #0x0, W2
009B58  980062     MOV W2, [W0+12]
009B5A  980073     MOV W3, [W0+14]
260:                   pTorqueAngle->timerInActive = 0;
009B5C  980022     MOV W2, [W0+4]
009B5E  980033     MOV W3, [W0+6]
261:               }
009B60  060000     RETURN
009B62  29F3E3     MOV #0x9F3E, W3
262:               
263:               void MCAF_TorqueAngleDetectInit(MCAF_TORQUE_ANGLE_DETECT_T *pTorqueAngle)
264:               {
265:                   pTorqueAngle->k = STALL_DETECT_TORQUE_ANGLE_K;
00960E  22B1E1     MOV #0x2B1E, W1
009610  980831     MOV W1, [W0+22]
266:                   pTorqueAngle->polycoef[0] = STALL_DETECT_TORQUE_ANGLE_COEFF0;
009612  2236A1     MOV #0x236A, W1
009614  981001     MOV W1, [W0+32]
267:                   pTorqueAngle->polycoef[1] = STALL_DETECT_TORQUE_ANGLE_COEFF1;
009616  24B191     MOV #0x4B19, W1
009618  981011     MOV W1, [W0+34]
268:                   pTorqueAngle->polycoef[2] = STALL_DETECT_TORQUE_ANGLE_COEFF2;
00961A  210351     MOV #0x1035, W1
00961C  981021     MOV W1, [W0+36]
269:                   pTorqueAngle->velocityThreshold = STALL_DETECT_TORQUE_ANGLE_VELOCITY_THRESHOLD;
00961E  222221     MOV #0x2222, W1
009620  980821     MOV W1, [W0+20]
270:                   
271:                   pTorqueAngle->timerActiveThreshold = ACTIVE_TIMER_THRESHOLD_TORQUE_ANGLE_DETECT;
009622  210242     MOV #0x1024, W2
009624  200003     MOV #0x0, W3
009626  980802     MOV W2, [W0+16]
009628  980813     MOV W3, [W0+18]
272:               
273:                   pTorqueAngle->timerInActiveThreshold = INACTIVE_TIMER_THRESHOLD_TORQUE_ANGLE_DETECT;
00962A  980042     MOV W2, [W0+8]
00962C  980053     MOV W3, [W0+10]
274:                   
275:                   MCAF_TorqueAngleDetectReset(pTorqueAngle);
00962E  070290     RCALL MCAF_TorqueAngleDetectReset
276:               
277:               }
009630  060000     RETURN
009632  781F88     MOV W8, [W15++]
278:               
279:               void MCAF_LowSpeedDetectReset(MCAF_LOW_SPEED_DETECT_T *plowspeed)
280:               {
281:                   plowspeed->timerActive = 0;
009D48  B81160     MUL.UU W2, #0x0, W2
009D4A  980052     MOV W2, [W0+10]
009D4C  980063     MOV W3, [W0+12]
282:                   plowspeed->timerInActive = 0;
009D4E  980012     MOV W2, [W0+2]
009D50  980023     MOV W3, [W0+4]
283:               }
009D52  060000     RETURN
009D54  E00400     CP0.B W0
284:               
285:               void MCAF_LowSpeedDetectInit(MCAF_LOW_SPEED_DETECT_T *plowspeed)
286:               {
287:                   /* Speed threshold for low speed */
288:                   plowspeed->lowSpeedThreshold = THRESHOLD_UNDERSPEED_STALL_DETECT;
009ADA  2071A1     MOV #0x71A, W1
009ADC  780801     MOV W1, [W0]
289:                   /* Timer counts for low speed detect */
290:                   plowspeed->timerActiveThreshold = ACTIVE_TIMER_THRESHOLD_LOW_SPEED_DETECT;
009ADE  210242     MOV #0x1024, W2
009AE0  200003     MOV #0x0, W3
009AE2  980072     MOV W2, [W0+14]
009AE4  980803     MOV W3, [W0+16]
291:               
292:                   /* Timer counts for low speed detect */
293:                   plowspeed->timerInActiveThreshold = INACTIVE_TIMER_THRESHOLD_LOW_SPEED_DETECT;
009AE6  980032     MOV W2, [W0+6]
009AE8  980043     MOV W3, [W0+8]
294:                   
295:                   MCAF_LowSpeedDetectReset(plowspeed);
009AEA  07012E     RCALL MCAF_LowSpeedDetectReset
296:               
297:               }
009AEC  060000     RETURN
009AEE  400FE1     ADD W0, #0x1, [W15]
298:               
299:               void MCAF_StallDetectReset(MCAF_STALL_DETECT_T *pstallDetect)
300:               {
0093AE  781F88     MOV W8, [W15++]
0093B0  780400     MOV W0, W8
301:                   MCAF_VarianceDetectx16Reset(&pstallDetect->varianceDetect);
0093B2  44006E     ADD W8, #0xE, W0
0093B4  07FF37     RCALL MCAF_VarianceDetectx16Reset
302:                   MCAF_OvercurrentDetectReset(&pstallDetect->overcurrentDetect);
0093B6  200480     MOV #0x48, W0
0093B8  400008     ADD W0, W8, W0
0093BA  070431     RCALL MCAF_OvercurrentDetectReset
303:                   MCAF_NegativeEdDetectReset(&pstallDetect->negativeEdDetect);
0093BC  2005C0     MOV #0x5C, W0
0093BE  400008     ADD W0, W8, W0
0093C0  0704BD     RCALL MCAF_NegativeEdDetectReset
304:                   MCAF_TorqueAngleDetectReset(&pstallDetect->torqueAngleDetect);
0093C2  200800     MOV #0x80, W0
0093C4  400008     ADD W0, W8, W0
0093C6  0703C4     RCALL MCAF_TorqueAngleDetectReset
305:                   MCAF_LowSpeedDetectReset(&pstallDetect->lowSpeedDetect);
0093C8  2006E0     MOV #0x6E, W0
0093CA  400008     ADD W0, W8, W0
0093CC  0704BD     RCALL MCAF_LowSpeedDetectReset
306:                   pstallDetect->stallDetectFlag = 0;    
0093CE  EB0000     CLR W0
0093D0  989440     MOV W0, [W8+168]
307:               }
0093D2  78044F     MOV [--W15], W8
0093D4  060000     RETURN
0093D6  A9E951     BCLR 0x951, #7
308:               
309:               /**
310:                * Internal function for updating stall detect condition bit flags.
311:                * Updates mask bits of the stallDetectFlag field, based on a condition.
312:                * 
313:                * @param pstallDetect stall detect state
314:                * @param condition true to set the mask bits, false to clear the mask bits
315:                * @param mask bits that should be set or cleared
316:                */
317:               inline static void updateFlags(MCAF_STALL_DETECT_T *pstallDetect, bool condition, uint16_t mask)
318:               {
319:                   if (condition)
320:                   {
321:                       pstallDetect->stallDetectFlag = UTIL_SetBits(pstallDetect->stallDetectFlag, mask);
005988  989742     MOV W2, [W14+168]
00598A  370006     BRA MCAF_StallDetect::MCAF_StartupGetStatus
0059D8  989742     MOV W2, [W14+168]
0059DA  37001C     BRA MCAF_StallDetect::MCAF_VarianceDetectx16
005B18  989741     MOV W1, [W14+168]
005B1A  37001C     BRA MCAF_StallDetect::MCAF_TorqueAngleDetect
005C0A  989741     MOV W1, [W14+168]
005C0C  37001E     BRA .L22
005CC6  989741     MOV W1, [W14+168]
005CC8  370006     BRA .L13
322:                   }
323:                   else
324:                   {
325:                       pstallDetect->stallDetectFlag = UTIL_ClearBits(pstallDetect->stallDetectFlag, mask);
005996  989742     MOV W2, [W14+168]
005A12  989742     MOV W2, [W14+168]
005B52  989741     MOV W1, [W14+168]
005C48  989741     MOV W1, [W14+168]
005CD4  989741     MOV W1, [W14+168]
326:                   }    
327:               }
328:               
329:               void MCAF_StallDetect(MCAF_STALL_DETECT_T *pstallDetect, const MCAF_MOTOR_DATA *pmotor)
330:               {
00590A  BE9F88     MOV.D W8, [W15++]
00590C  BE9F8A     MOV.D W10, [W15++]
00590E  BE9F8C     MOV.D W12, [W15++]
005910  781F8E     MOV W14, [W15++]
005912  780700     MOV W0, W14
331:                   if (MCAF_OvercurrentDetectEnabled())
332:                   {
333:                       updateFlags(pstallDetect, 
334:                                 MCAF_OvercurrentDetect(&pstallDetect->overcurrentDetect, &pmotor->idq),
335:                                 MCAF_OVERCURRENT_STALL_DETECT);
336:                   }
337:                   
338:                   if (MCAF_StartupGetStatus(&pmotor->startup) == MSST_COMPLETE)
339:                   {
340:                   
341:                       if (MCAF_NegativeEdDetectEnabled())
342:                       {
343:                           updateFlags(pstallDetect,
344:                                     MCAF_NegativeEdDetect(&pstallDetect->negativeEdDetect,
345:                                                           &pstallDetect->inputs,
346:                                                           pmotor->sat.state == MCAF_SAT_CURRENT),
347:                                     MCAF_NEGATIVE_ED_STALL_DETECT);
348:                       }
349:                       
350:                       if (MCAF_VarianceDetectEnabled())
351:                       {
352:                           MCAF_VarianceDetectx16(&pstallDetect->varianceDetect, 
353:                                                  &pstallDetect->inputs);
354:                       }
355:                       
356:                       if (pmotor->state == MCSM_RUNNING)
005AD6  91B141     MOV [W1+488], W2
005AD8  510FE3     SUB W2, #0x3, [W15]
005ADA  3A00B7     BRA NZ, .L22
357:                       {
358:                           if (MCAF_LowSpeedDetectEnabled())
359:                           {
360:                               updateFlags(pstallDetect,
361:                                           MCAF_LowSpeedDetect(&pstallDetect->lowSpeedDetect, pmotor->omegaElectrical),
362:                                           MCAF_LOW_SPEED_STALL_DETECT);
363:                           }
364:                           if (MCAF_TorqueAngleDetectEnabled())
365:                           {
366:                               updateFlags(pstallDetect,
367:                                           MCAF_TorqueAngleDetect(&pstallDetect->torqueAngleDetect, 
368:                                                                  &pstallDetect->inputs),
369:                                           MCAF_TORQUE_ANGLE_STALL_DETECT);
370:                           }
371:                       }
372:                       if (MCAF_VarianceDetectEnabled() &&
005C4E  989761     MOV W1, [W14+172]
005C50  90917E     MOV [W14+174], W2
005C52  508F82     SUB W1, W2, [W15]
005C54  390040     BRA NC, .L13
373:                               ++pstallDetect->decimationTimer >= pstallDetect->decimationTimerThreshold)
005C4A  9090EE     MOV [W14+172], W1
005C4C  E80081     INC W1, W1
374:                       {
375:                           pstallDetect->decimationTimer = 0;
005C56  EB0080     CLR W1
005C58  989761     MOV W1, [W14+172]
376:                           updateFlags(pstallDetect,
377:                                       MCAF_VarianceDetectx16PostDecimation(&pstallDetect->varianceDetect),
378:                                       MCAF_LOSS_OF_LOCK_STALL_DETECT);
379:                       }
380:                   }
381:               }
005CD6  78074F     MOV [--W15], W14
005CD8  BE064F     MOV.D [--W15], W12
005CDA  BE054F     MOV.D [--W15], W10
005CDC  BE044F     MOV.D [--W15], W8
005CDE  060000     RETURN
005CE0  BE9F88     MOV.D W8, [W15++]
382:               
383:               inline void MCAF_VarianceDetectx16(MCAF_VARIANCE_DETECT_T *pvariancex16,
384:                       const MCAF_STALL_DETECT_INPUT_T *pinputs)
385:               {
000000  040200     GOTO __resetPRI, __reset
386:                   /* HPF for Esd */
387:                   const int16_t esdHpf = MCAF_HpfFilterx16(&pvariancex16->hpfEd, pinputs->esdq.d);
000004  000B9A     NOP
005A14  78029E     MOV [W14], W5
388:                   /* HPF for Esq */
389:                   const int16_t esqHpf = MCAF_HpfFilterx16(&pvariancex16->hpfEq, pinputs->esdq.q);
00002C  000920     NOP
005A3C  90021E     MOV [W14+2], W4
390:                   /* Esd(HPF)^2 + Esq(HPF)^2 */
391:                   const int16_t esHpf = UTIL_SignedSqr(esdHpf) + UTIL_SignedSqr(esqHpf);
00006C  000920     NOP
005A7E  410103     ADD W2, W3, W2
392:                   /* 1st stage for LPF for Es(HPF) */
393:                   MCAF_LpfFilterx16(&pvariancex16->lpf1HpEsSqr, esHpf);
394:                   /* Esd^2 + Esq^2 */
395:                   const int16_t esSqr = UTIL_SignedSqr(pinputs->esdq.d) + UTIL_SignedSqr(pinputs->esdq.q);
00008A  000920     NOP
000098  000920     NOP
0000AA  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
005AB8  418102     ADD W3, W2, W2
396:                   /* 1st stage LPF filter for Es */
397:                   MCAF_LpfFilterx16(&pvariancex16->lpf1EsSqr, esSqr);
398:               }
0000C6  000920     NOP
0000CC  0008E6     NOP
399:               
400:               inline bool MCAF_VarianceDetectx16PostDecimation(MCAF_VARIANCE_DETECT_T *pvariancex16)
401:               {
402:                  bool varianceDetect = false;
00005C  000920     NOP
000074  000920     NOP
403:                  /* 2nd stage filter for Es(HPF) */
404:                  MCAF_LpfFilterx16(&pvariancex16->lpf2HpEsSqr, pvariancex16->lpf1HpEsSqr.output);
405:                  /* 2nd stage filter for Es */
406:                  MCAF_LpfFilterx16(&pvariancex16->lpf2EsSqr, pvariancex16->lpf1EsSqr.output);
407:                  /* esLPF2 divide by 16 */
408:                  pvariancex16->esLp = (pvariancex16->lpf2EsSqr.output >> 4);
000044  000C16     NOP
005C9E  DEA244     ASR W4, #4, W4
005CA0  981F74     MOV W4, [W14+62]
409:               
410:                  /* Set the flag and start the timer when Es(HPF-LPF) > Es(LPF) */
411:                   if (pvariancex16->lpf2HpEsSqr.output > pvariancex16->esLp)
000048  000920     NOP
005CA2  520F82     SUB W4, W2, [W15]
005CA4  3D0012     BRA GE, .LBE508, .L28
412:                   {
413:                       pvariancex16->timer++;
00004C  000920     NOP
005CA6  90210E     MOV [W14+64], W2
005CA8  90219E     MOV [W14+66], W3
005CAA  410161     ADD W2, #0x1, W2
005CAC  4981E0     ADDC W3, #0x0, W3
005CAE  982702     MOV W2, [W14+64]
005CB0  982713     MOV W3, [W14+66]
414:                       if (pvariancex16->timer >= pvariancex16->timerThreshold)
000058  000920     NOP
00005E  000920     NOP
000060  000920     NOP
005CB2  90222E     MOV [W14+68], W4
005CB4  9022BE     MOV [W14+70], W5
005CB6  510F84     SUB W2, W4, [W15]
005CB8  598F85     SUBB W3, W5, [W15]
005CBA  39000A     BRA NC, MCAF_StallDetect::updateFlags::UTIL_ClearBits
415:                       {
416:                           /* Detects loss of lock when the timer exceeds the time counts */
417:                           varianceDetect = true;
00006A  000920     NOP
418:                           pvariancex16->timer = 0;
000064  000920     NOP
005CBC  B80060     MUL.UU W0, #0x0, W0
005CBE  982700     MOV W0, [W14+64]
005CC0  982711     MOV W1, [W14+66]
419:                       }
420:                   }
421:                   else
422:                   {
423:                       pvariancex16->timer = 0;
00006E  000B0E     NOP
005CCA  B81160     MUL.UU W2, #0x0, W2
005CCC  982702     MOV W2, [W14+64]
005CCE  982713     MOV W3, [W14+66]
424:                   }
425:                   return varianceDetect;
426:               }
000076  000920     NOP
00007A  000920     NOP
427:               
428:               /**
429:                * Evaluate a quadratic polynomial using Horner's rule and Q15 math.
430:                * @param x input variable
431:                * @param pcoef polynomial coefficients in order of increasing degree
432:                */
433:               inline static int16_t MCAF_TorqueAngleEvaluateQuadratic(
434:                   int16_t x,
435:                   const int16_t *pcoef)
436:               {
437:                   int16_t y;
438:                   y = UTIL_MulQ15(pcoef[2], x);
439:                   y += *++pcoef;
000058  000920     NOP
005BA6  90911E     MOV [W14+162], W2
005BA8  410203     ADD W2, W3, W4
440:                   y = UTIL_MulQ15(y, x);
441:                   y += *--pcoef;
000062  000920     NOP
005BB0  90920E     MOV [W14+160], W4
005BB2  420105     ADD W4, W5, W2
442:                   return y;
443:               }
444:               
445:               inline bool MCAF_TorqueAngleDetect(MCAF_TORQUE_ANGLE_DETECT_T *ptorqueangle,
446:                                                   const MCAF_STALL_DETECT_INPUT_T *pinputs)
447:               {
000000  040200     GOTO __resetPRI, __reset
448:                   bool detectedNow = false;
449:                   bool stall_detect = false;
0000A8  000920     NOP
0000C6  000920     NOP
450:                   const int16_t absElectricalFrequency = UTIL_Abs16Approx(pinputs->omegaElectrical);
451:                   
452:                   /* Torque angle detection is needed only when velocity is below a threshold */
453:                   if (absElectricalFrequency < ptorqueangle->velocityThreshold)
00000C  000BB6     NOP
005B5A  90892E     MOV [W14+148], W2
005B5C  508F82     SUB W1, W2, [W15]
005B5E  3D0057     BRA GE, .LBE492, .L26
454:                   {
455:               
456:                       /* if rotor is stop,most of Vs voltage should be added on R and L */
457:                       /* and the Es may become very small,and if Es < Vs*Gain,means rotor stall */
458:                       /* Es^2 = Ed^2 + Eq^2 */
459:                       ptorqueangle->esSqr = UTIL_SignedSqr(pinputs->esdqFiltered.d) +
000012  00091A     NOP
00002E  000920     NOP
005B60  90022E     MOV [W14+4], W4
005B7C  418382     ADD W3, W2, W7
005B7E  988707     MOV W7, [W14+128]
460:                                             UTIL_SignedSqr(pinputs->esdqFiltered.q);
000020  000920     NOP
005B6E  90033E     MOV [W14+6], W6
461:                       /* Vs^2 = Valpha^2 + Vbeta^2 */
462:                       ptorqueangle->vsSqr = UTIL_SignedSqr(pinputs->valphabeta.alpha) +
000030  000920     NOP
00004C  000920     NOP
005B80  90014E     MOV [W14+8], W2
005B9A  420303     ADD W4, W3, W6
005B9C  988716     MOV W6, [W14+130]
463:                                             UTIL_SignedSqr(pinputs->valphabeta.beta);
00003E  000920     NOP
005B8C  90045E     MOV [W14+10], W8
464:               
465:                       ptorqueangle->g = MCAF_TorqueAngleEvaluateQuadratic(
000066  000920     NOP
005BB4  988F52     MOV W2, [W14+154]
466:                                           absElectricalFrequency,
467:                                           ptorqueangle->polycoef);
468:                       ptorqueangle->gEsSqr = UTIL_MulQ15(ptorqueangle->g, ptorqueangle->esSqr);
469:                       ptorqueangle->kx = UTIL_MulQ15(ptorqueangle->k, absElectricalFrequency);
00007A  000920     NOP
00007C  000920     NOP
005BC8  988F49     MOV W9, [W14+152]
470:                       ptorqueangle->kxVsSqr = UTIL_MulQ15(ptorqueangle->kx, ptorqueangle->vsSqr);
000082  000920     NOP
005BD0  988F77     MOV W7, [W14+158]
471:                       
472:                       detectedNow = ptorqueangle->gEsSqr < ptorqueangle->kxVsSqr;
473:                   }
474:                   
475:                   if (detectedNow)
000084  000920     NOP
005BD2  538F82     SUB W7, W2, [W15]
005BD4  34001C     BRA LE, .LBE492, .L26
476:                   {
477:                       ptorqueangle->quotient = __builtin_divf(ptorqueangle->gEsSqr, ptorqueangle->kxVsSqr);
000088  000920     NOP
005BD6  090005     REPEAT #0x5
005BD8  D91007     DIVF W2, W7
005BDA  780100     MOV W0, W2
005BDC  989732     MOV W2, [W14+166]
478:                       ptorqueangle->timerInActive = 1;
000090  000920     NOP
005BDE  200012     MOV #0x1, W2
005BE0  200003     MOV #0x0, W3
005BE2  988722     MOV W2, [W14+132]
005BE4  988733     MOV W3, [W14+134]
479:                       
480:                       ptorqueangle->timerActive++;
000098  000920     NOP
005BE6  90816E     MOV [W14+140], W2
005BE8  9081FE     MOV [W14+142], W3
005BEA  410161     ADD W2, #0x1, W2
005BEC  4981E0     ADDC W3, #0x0, W3
005BEE  988762     MOV W2, [W14+140]
005BF0  988773     MOV W3, [W14+142]
481:               
482:                       /* check if the timer active exceed the threshold */
483:                       if (ptorqueangle->timerActive > ptorqueangle->timerActiveThreshold)
0000A4  000920     NOP
0000AA  000920     NOP
005BF2  908A0E     MOV [W14+144], W4
005BF4  908A9E     MOV [W14+146], W5
005BF6  510F84     SUB W2, W4, [W15]
005BF8  598F85     SUBB W3, W5, [W15]
005BFA  360024     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
484:                       {
485:                           /* set the fault state */
486:                           stall_detect = true;
0000BA  000920     NOP
487:                           
488:                           ptorqueangle->timerActive = 0;
0000B0  000920     NOP
005BFC  B81160     MUL.UU W2, #0x0, W2
005BFE  988762     MOV W2, [W14+140]
005C00  988773     MOV W3, [W14+142]
489:                           ptorqueangle->timerInActive = 0;
0000B6  000920     NOP
005C02  988722     MOV W2, [W14+132]
005C04  988733     MOV W3, [W14+134]
490:                       }
491:                   }
492:                   else
493:                   {
494:                       ptorqueangle->quotient = 0x7fff;
0000BE  000920     NOP
005C0E  27FFF1     MOV #0x7FFF, W1
005C10  989731     MOV W1, [W14+166]
495:                       if (ptorqueangle->timerActive > 0)
0000C2  000920     NOP
0000C8  00062E     NOP
0000CA  0008B2     NOP
005C12  90816E     MOV [W14+140], W2
005C14  9081FE     MOV [W14+142], W3
005C16  510FE0     SUB W2, #0x0, [W15]
005C18  598FE0     SUBB W3, #0x0, [W15]
005C1A  320014     BRA Z, MCAF_StallDetect::updateFlags::UTIL_ClearBits
496:                       {
497:                           ptorqueangle->timerActive++;
0000CE  000920     NOP
005C1C  410161     ADD W2, #0x1, W2
005C1E  4981E0     ADDC W3, #0x0, W3
005C20  988762     MOV W2, [W14+140]
005C22  988773     MOV W3, [W14+142]
498:                           
499:                           ptorqueangle->timerInActive++;
0000D6  000920     NOP
005C24  90812E     MOV [W14+132], W2
005C26  9081BE     MOV [W14+134], W3
005C28  410161     ADD W2, #0x1, W2
005C2A  4981E0     ADDC W3, #0x0, W3
005C2C  988722     MOV W2, [W14+132]
005C2E  988733     MOV W3, [W14+134]
500:                           /* if timer inactive exceeded the threshold */
501:                           if (ptorqueangle->timerInActive > ptorqueangle->timerInActiveThreshold)
0000E2  0007AE     NOP
005C30  90824E     MOV [W14+136], W4
005C32  9082DE     MOV [W14+138], W5
005C34  510F84     SUB W2, W4, [W15]
005C36  598F85     SUBB W3, W5, [W15]
005C38  360005     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
502:                           {
503:                               /* reset both timers */
504:                               ptorqueangle->timerActive = 0;
0000EC  000816     NOP
005C3A  B81160     MUL.UU W2, #0x0, W2
005C3C  988762     MOV W2, [W14+140]
005C3E  988773     MOV W3, [W14+142]
505:                               ptorqueangle->timerInActive = 0;
0000F2  000920     NOP
005C40  988722     MOV W2, [W14+132]
005C42  988733     MOV W3, [W14+134]
506:                           }
507:                       }
508:                   }
509:                   return stall_detect;
510:               
511:               }
0000F6  00084A     NOP
0000FE  000920     NOP
512:               
513:               inline bool MCAF_OvercurrentDetect(MCAF_OVERCURRENT_SW_DETECT_T *povercurrent, const MC_DQ_T *pidq)
514:               {
515:                   bool overCurrentDetect = false;
000062  000920     NOP
00007A  000920     NOP
516:                   povercurrent->is = UTIL_SignedSqr(pidq->d) + UTIL_SignedSqr(pidq->q);
000000  040200     GOTO __resetPRI, __reset
00000E  000920     NOP
00001C  000920     NOP
005914  900A41     MOV [W1+24], W4
005922  900B51     MOV [W1+26], W6
005930  420102     ADD W4, W2, W2
005932  982F12     MOV W2, [W14+82]
517:                   MCAF_LpfFilterx16(&povercurrent->lpfIs, povercurrent->is);
518:               
519:                   if (povercurrent->lpfIs.output > UTIL_SignedSqr(povercurrent->overcurrentThreshold))
000040  000920     NOP
00004E  000920     NOP
005956  902A0E     MOV [W14+80], W4
005964  530F82     SUB W6, W2, [W15]
005966  340012     BRA LE, .LBE346, .L14
520:                   {
521:                       /* start timer for over current when Is exceeds the threshold */
522:                       povercurrent->timer++;
000052  000920     NOP
005968  90292E     MOV [W14+84], W2
00596A  9029BE     MOV [W14+86], W3
00596C  410161     ADD W2, #0x1, W2
00596E  4981E0     ADDC W3, #0x0, W3
005970  982F22     MOV W2, [W14+84]
005972  982F33     MOV W3, [W14+86]
523:                       if (povercurrent->timer >= povercurrent->timerThreshold)
00005E  000920     NOP
000064  000920     NOP
005974  902A4E     MOV [W14+88], W4
005976  902ADE     MOV [W14+90], W5
005978  510F84     SUB W2, W4, [W15]
00597A  598F85     SUBB W3, W5, [W15]
00597C  39000A     BRA NC, MCAF_StallDetect::updateFlags::UTIL_ClearBits
524:                       {
525:                           overCurrentDetect = true;    /* set the global flag when timer exceeds threshold */
000070  000920     NOP
526:                           povercurrent->timer = 0;
00006A  000920     NOP
00006C  000920     NOP
00006E  000B0E     NOP
00597E  B81160     MUL.UU W2, #0x0, W2
005980  982F22     MOV W2, [W14+84]
005982  982F33     MOV W3, [W14+86]
527:                       }
528:                   }
529:                   else
530:                   {
531:                       povercurrent->timer = 0;
000074  000920     NOP
00598C  B81160     MUL.UU W2, #0x0, W2
00598E  982F22     MOV W2, [W14+84]
005990  982F33     MOV W3, [W14+86]
532:                   }
533:                   return overCurrentDetect;
534:               }
00007C  000920     NOP
000080  000920     NOP
535:               
536:               
537:               inline bool MCAF_NegativeEdDetect(MCAF_NEGATIVE_ED_DETECT_T *pedstate,
538:                        const MCAF_STALL_DETECT_INPUT_T *pinputs,
539:                        bool currsat)
540:               {
541:                   bool negativeEdDetect = false;
000022  000BF6     NOP
00003C  000920     NOP
542:                   
543:                   if ((currsat == true) && (pinputs->esdq.d < pedstate->edThreshold))
000000  040200     GOTO __resetPRI, __reset
0059A0  930111     MOV [W1+770], W2
0059A2  510FE2     SUB W2, #0x2, [W15]
0059A4  3A001B     BRA NZ, .LBE360, .L19
0059A6  90296E     MOV [W14+92], W2
0059A8  110F9E     SUBR W2, [W14], [W15]
0059AA  3D0018     BRA GE, .LBE360, .L19
544:                   {
545:                       /* re-initialize inactive timer */
546:                       /* initialize it with 1 to indicate it was started */
547:                       pedstate->timerInactive = 1;
00000A  000BD2     NOP
0059AC  200012     MOV #0x1, W2
0059AE  200003     MOV #0x0, W3
0059B0  982F72     MOV W2, [W14+94]
0059B2  983703     MOV W3, [W14+96]
548:                       
549:                       pedstate->timerActive++;
000012  00091A     NOP
0059B4  90313E     MOV [W14+102], W2
0059B6  9031CE     MOV [W14+104], W3
0059B8  410161     ADD W2, #0x1, W2
0059BA  4981E0     ADDC W3, #0x0, W3
0059BC  983732     MOV W2, [W14+102]
0059BE  983743     MOV W3, [W14+104]
550:               
551:                       /* check if the timer active exceed the threshold */
552:                       if (pedstate->timerActive > pedstate->timeActiveThreshold)
00001E  000920     NOP
000024  000920     NOP
0059C0  90325E     MOV [W14+106], W4
0059C2  9032EE     MOV [W14+108], W5
0059C4  510F84     SUB W2, W4, [W15]
0059C6  598F85     SUBB W3, W5, [W15]
0059C8  360022     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
553:                       {
554:                           /* set the fault state */
555:                           negativeEdDetect = true;
000034  000920     NOP
556:                           pedstate->timerActive = 0;
00002A  000C36     NOP
0059CA  B81160     MUL.UU W2, #0x0, W2
0059CC  983732     MOV W2, [W14+102]
0059CE  983743     MOV W3, [W14+104]
557:                           pedstate->timerInactive = 0;
000030  000920     NOP
0059D0  982F72     MOV W2, [W14+94]
0059D2  983703     MOV W3, [W14+96]
558:                       }
559:                   }
560:                   else
561:                   {
562:                       if (pedstate->timerActive > 0)
000038  000920     NOP
00003E  000920     NOP
0059DC  90313E     MOV [W14+102], W2
0059DE  9031CE     MOV [W14+104], W3
0059E0  510FE0     SUB W2, #0x0, [W15]
0059E2  598FE0     SUBB W3, #0x0, [W15]
0059E4  320014     BRA Z, MCAF_StallDetect::updateFlags::UTIL_ClearBits
563:                       {
564:                           pedstate->timerActive++;
000044  000C16     NOP
0059E6  410161     ADD W2, #0x1, W2
0059E8  4981E0     ADDC W3, #0x0, W3
0059EA  983732     MOV W2, [W14+102]
0059EC  983743     MOV W3, [W14+104]
565:                           
566:                           pedstate->timerInactive++;
00004C  000920     NOP
0059EE  90297E     MOV [W14+94], W2
0059F0  90318E     MOV [W14+96], W3
0059F2  410161     ADD W2, #0x1, W2
0059F4  4981E0     ADDC W3, #0x0, W3
0059F6  982F72     MOV W2, [W14+94]
0059F8  983703     MOV W3, [W14+96]
567:                           if (pedstate->timerInactive > pedstate->timerInactiveThreshold)
000058  000920     NOP
0059FA  90321E     MOV [W14+98], W4
0059FC  9032AE     MOV [W14+100], W5
0059FE  510F84     SUB W2, W4, [W15]
005A00  598F85     SUBB W3, W5, [W15]
005A02  360005     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
568:                           {
569:                               /* reset both timers */
570:                               pedstate->timerActive = 0;
000062  000920     NOP
005A04  B81160     MUL.UU W2, #0x0, W2
005A06  983732     MOV W2, [W14+102]
005A08  983743     MOV W3, [W14+104]
571:                               pedstate->timerInactive = 0;
000068  000920     NOP
005A0A  982F72     MOV W2, [W14+94]
005A0C  983703     MOV W3, [W14+96]
572:                           }
573:                       }
574:                   }
575:               
576:                   return negativeEdDetect;
577:                }
00006C  000920     NOP
000070  000920     NOP
578:               
579:               inline bool MCAF_LowSpeedDetect(MCAF_LOW_SPEED_DETECT_T *plowspeed, int16_t omega)
580:               {
581:                   bool lowSpeedDetect = false;
000024  000920     NOP
00003E  000920     NOP
582:                   /* initialize under speed as false, only a fault detect condition can change this state *
583:                    * if the under speed threshold was crossed */
584:                   if (UTIL_Abs16(omega) < plowspeed->lowSpeedThreshold)
000008  000B4A     NOP
005AE6  90317E     MOV [W14+110], W2
005AE8  508F82     SUB W1, W2, [W15]
005AEA  3D0018     BRA GE, .LBE424, .L23
585:                   {
586:                       /* re-initialize inactive timer */
587:                       /* initialize it with 1 to indicate it was started */
588:                       plowspeed->timerInActive = 1;
00000C  000BB6     NOP
005AEC  200012     MOV #0x1, W2
005AEE  200003     MOV #0x0, W3
005AF0  983F02     MOV W2, [W14+112]
005AF2  983F13     MOV W3, [W14+114]
589:                       
590:                       plowspeed->timerActive++;
000014  000920     NOP
005AF4  90394E     MOV [W14+120], W2
005AF6  9039DE     MOV [W14+122], W3
005AF8  410161     ADD W2, #0x1, W2
005AFA  4981E0     ADDC W3, #0x0, W3
005AFC  983F42     MOV W2, [W14+120]
005AFE  983F53     MOV W3, [W14+122]
591:               
592:                       /* check if the timer active exceed the threshold */
593:                       if (plowspeed->timerActive > plowspeed->timerActiveThreshold)
000020  000920     NOP
000026  000920     NOP
005B00  903A6E     MOV [W14+124], W4
005B02  903AFE     MOV [W14+126], W5
005B04  510F84     SUB W2, W4, [W15]
005B06  598F85     SUBB W3, W5, [W15]
005B08  360022     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
594:                       {
595:                           /* set the fault state */
596:                           lowSpeedDetect = true;
000036  000920     NOP
597:                           plowspeed->timerActive = 0;
00002C  000920     NOP
005B0A  B81160     MUL.UU W2, #0x0, W2
005B0C  983F42     MOV W2, [W14+120]
005B0E  983F53     MOV W3, [W14+122]
598:                           plowspeed->timerInActive = 0;
000032  000920     NOP
005B10  983F02     MOV W2, [W14+112]
005B12  983F13     MOV W3, [W14+114]
599:                       }
600:                   }
601:                   else
602:                   {
603:                       if (plowspeed->timerActive > 0)
00003A  000920     NOP
000040  000920     NOP
000042  000920     NOP
005B1C  90394E     MOV [W14+120], W2
005B1E  9039DE     MOV [W14+122], W3
005B20  510FE0     SUB W2, #0x0, [W15]
005B22  598FE0     SUBB W3, #0x0, [W15]
005B24  320014     BRA Z, MCAF_StallDetect::updateFlags::UTIL_ClearBits
604:                       {
605:                           plowspeed->timerActive++;
000046  000920     NOP
005B26  410161     ADD W2, #0x1, W2
005B28  4981E0     ADDC W3, #0x0, W3
005B2A  983F42     MOV W2, [W14+120]
005B2C  983F53     MOV W3, [W14+122]
606:                           
607:                           plowspeed->timerInActive++;
00004E  000920     NOP
005B2E  90390E     MOV [W14+112], W2
005B30  90399E     MOV [W14+114], W3
005B32  410161     ADD W2, #0x1, W2
005B34  4981E0     ADDC W3, #0x0, W3
005B36  983F02     MOV W2, [W14+112]
005B38  983F13     MOV W3, [W14+114]
608:                           /* if timer inactive exceeded the threshold */
609:                           if (plowspeed->timerInActive > plowspeed->timerInActiveThreshold)
00005A  000920     NOP
005B3A  903A2E     MOV [W14+116], W4
005B3C  903ABE     MOV [W14+118], W5
005B3E  510F84     SUB W2, W4, [W15]
005B40  598F85     SUBB W3, W5, [W15]
005B42  360005     BRA LEU, MCAF_StallDetect::updateFlags::UTIL_ClearBits
610:                           {
611:                               /* reset both timers */
612:                               plowspeed->timerActive = 0;
000064  000920     NOP
005B44  B81160     MUL.UU W2, #0x0, W2
005B46  983F42     MOV W2, [W14+120]
005B48  983F53     MOV W3, [W14+122]
613:                               plowspeed->timerInActive = 0;
00006A  000920     NOP
005B4A  983F02     MOV W2, [W14+112]
005B4C  983F13     MOV W3, [W14+114]
614:                           }
615:                       }
616:                   }
617:               
618:                  return lowSpeedDetect;
619:               }
00006E  000B0E     NOP
000072  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/sat_PI.c
1:                 /**
2:                  * sat_PI.c
3:                  * 
4:                  * Module to detect current and voltage saturation. It also contains modified PI controller
5:                  * 
6:                  * Component: FOC
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                 
47:                #include "sat_PI.h"
48:                #include "parameters/sat_PI_params.h"
49:                #include "util.h"
50:                #include "hal.h"
51:                #include "motor_control_types.h"
52:                
53:                volatile register int a_Reg asm("A");
54:                volatile register int b_Reg asm("B");
55:                
56:                /**
57:                 * Initializes parameters related to voltage saturation
58:                 * 
59:                 * @param pvoltsat voltage saturation state
60:                 */
61:                void MCAF_VoltSatInit(MCAF_SAT_T *pvoltsat)
62:                {
63:                    /* Threshold for coming out of voltage saturation */
64:                    pvoltsat->thresholdDownLimit = UTIL_SignedSqr(VOLTAGE_SATURATION_THRESHOLD_DOWN_CONSTANT);
0094F4  780801     MOV W1, [W0]
65:                    /* Threshold for entering voltage saturation */
66:                    pvoltsat->thresholdUpLimit = UTIL_SignedSqr(VOLTAGE_SATURATION_THRESHOLD_UP_CONSTANT);
009504  980011     MOV W1, [W0+2]
67:                    pvoltsat->satFlag = 0;
009506  EB0080     CLR W1
009508  980021     MOV W1, [W0+4]
68:                }
00950A  060000     RETURN
69:                
70:                /**
71:                 * Initializes parameters related to current saturation 
72:                 * 
73:                 * @param pcurrentsat current saturation state
74:                 */
75:                void MCAF_CurrentSatInit(MCAF_SAT_T *pcurrentsat)
76:                {
77:                    /* Threshold for coming out of current saturation */
78:                    pcurrentsat->thresholdDownLimit = CURRENT_SATURATION_THRESHOLD_DOWN;
009CDC  2034D1     MOV #0x34D, W1
79:                    pcurrentsat->thresholdUpLimit = CURRENT_SATURATION_THRESHOLD_UP;
009CE0  203821     MOV #0x382, W1
009CE2  980011     MOV W1, [W0+2]
80:                    pcurrentsat->satFlag = 0;
009CE4  EB0080     CLR W1
009CE6  980021     MOV W1, [W0+4]
81:                } 
009CE8  060000     RETURN
009CEA  EB0080     CLR W1
82:                
83:                void MCAF_SatInit(MCAF_SAT_DETECT_T *psat)
84:                {
009BFE  781F88     MOV W8, [W15++]
009C00  780400     MOV W0, W8
85:                    /* Initialize voltage and current saturation parameters */
86:                    MCAF_VoltSatInit(&psat->voltSat); 
009C02  E88008     INC2 W8, W0
009C04  07FC70     RCALL MCAF_VoltSatInit
87:                    MCAF_CurrentSatInit(&psat->currentSat);
009C06  440068     ADD W8, #0x8, W0
009C08  070069     RCALL MCAF_CurrentSatInit
88:                }
009C0A  78044F     MOV [--W15], W8
009C0C  060000     RETURN
009C0E  FA0010     LNK #0x10
89:                
90:                /**
91:                 * Updates latched flag:
92:                 *   INTO_SATURATION sets the latch,
93:                 *   OUT_OF_SATURATION clears the latch,
94:                 *   otherwise we just keep the previous state.
95:                 * 
96:                 * @param latch previous latch value
97:                 * @param satFlag saturation flag
98:                 * @return next latch value
99:                 */
100:               inline static bool updateLatchedFlag(bool latch, uint16_t satFlag)
101:               {
102:                   if (satFlag & MCAF_INTO_SATURATION)
00736A  A31801     BTST.Z W1, #1
00736C  3A0004     BRA NZ, .L13
00737A  A31803     BTST.Z W3, #1
00737C  3A0005     BRA NZ, .L14
103:                   {
104:                       latch = true;
007368  B3C012     MOV.B #0x1, W2
007378  B3C011     MOV.B #0x1, W1
105:                   }
106:                   else if (satFlag & MCAF_OUT_OF_SATURATION)
007370  A30801     BTST.Z W1, #0
007372  3A0001     BRA NZ, .L13
007380  A30803     BTST.Z W3, #0
007382  3A0002     BRA NZ, .L14
107:                   {
108:                       latch = false;
00736E  EB4100     CLR.B W2
00737E  EB4080     CLR.B W1
109:                   }
110:                   return latch;
111:               }
112:               
113:               /**
114:                * Monitors Vs (Vd^2 + Vq^2) and indicates voltage saturation status
115:                * 
116:                * Summary : Voltage Saturation Detect
117:                * 
118:                * @param pvoltsat voltage saturation state
119:                * @param pvdq voltage vector Vdq
120:                * @param vDC DC link voltage
121:                */
122:               inline static void MCAF_VoltSatDetect(MCAF_SAT_T *pvoltsat, const MC_DQ_T *pvdq, int16_t vDC)
123:               {
124:                   /* 
125:                    * uint16_t is used in the following calculations to avoid overflow;
126:                    * since UTIL_SignedSqr returns a number from 0-32767 we can store
127:                    * the sum of two such values in a uint16_t. 
128:                    * 
129:                    * Subsequent comparison operators are valid as long as
130:                    * both operands are uint16_t; we can safely cast an int16_t to uint16_t as long
131:                    * as it is a positive integer (for example, vDCSquared is always positive
132:                    * and pvoltsat->thresholdUpLimit should always be positive, so their
133:                    * product is positive.)
134:                    */
135:                   uint16_t vs = (uint16_t)(UTIL_SignedSqr(pvdq->d))
00730A  780412     MOV [W2], W8
007326  410081     ADD W2, W1, W1
136:                               + (uint16_t)(UTIL_SignedSqr(pvdq->q));
007318  900212     MOV [W2+2], W4
137:                   const int16_t vDCSquared = UTIL_SignedSqrNoOverflow(vDC);
138:                   if (vs >= (uint16_t)UTIL_MulQ15(pvoltsat->thresholdUpLimit, vDCSquared))
007338  508F87     SUB W1, W7, [W15]
00733A  390004     BRA NC, UTIL_ClearBits
139:                   {
140:                      pvoltsat->satFlag = UTIL_SetBits(pvoltsat->satFlag, MCAF_INTO_SATURATION); 
007340  980032     MOV W2, [W0+6]
007342  370003     BRA UTIL_MulQ15
141:                   }
142:                   else
143:                   {
144:                       pvoltsat->satFlag = UTIL_ClearBits(pvoltsat->satFlag, MCAF_INTO_SATURATION);
007348  980032     MOV W2, [W0+6]
145:                   }   
146:                   if (vs < (uint16_t)UTIL_MulQ15(pvoltsat->thresholdDownLimit, vDCSquared))
007352  508F85     SUB W1, W5, [W15]
007354  310004     BRA C, UTIL_ClearBits
147:                   {
148:                       pvoltsat->satFlag = UTIL_SetBits(pvoltsat->satFlag, MCAF_OUT_OF_SATURATION); 
00735A  980031     MOV W1, [W0+6]
00735C  370003     BRA .LBE226, .LBE227, .L12
149:                   }
150:                   else
151:                   {
152:                       pvoltsat->satFlag = UTIL_ClearBits(pvoltsat->satFlag, MCAF_OUT_OF_SATURATION);
007362  980031     MOV W1, [W0+6]
153:                   }   
154:               }
155:               
156:               /**
157:                * Monitors Iq and indicates current saturation status
158:                * 
159:                * Summary : Current Saturation Detect
160:                * @param pcurrentsat current saturation state
161:                * @param input current Iq 
162:                */
163:               inline static void MCAF_CurrentSatDetect(MCAF_SAT_T *pcurrentsat, const int16_t input)
164:               {
165:                   if (UTIL_Abs16(input) >= pcurrentsat->thresholdUpLimit)
0072DA  9001D0     MOV [W0+10], W3
0072DC  520F83     SUB W4, W3, [W15]
0072DE  350004     BRA LT, MCAF_SatDetect::MCAF_CurrentSatDetect::UTIL_ClearBits
166:                   {
167:                      pcurrentsat->satFlag = UTIL_SetBits(pcurrentsat->satFlag, MCAF_INTO_SATURATION); 
0072E4  980063     MOV W3, [W0+12]
0072E6  370003     BRA MCAF_SatDetect::MCAF_CurrentSatDetect::UTIL_Abs16
168:                   }
169:                   else
170:                   {
171:                       pcurrentsat->satFlag = UTIL_ClearBits(pcurrentsat->satFlag, MCAF_INTO_SATURATION);
0072EC  980063     MOV W3, [W0+12]
172:                   }
173:                   if (UTIL_Abs16(input) < pcurrentsat->thresholdDownLimit)
0072F6  9001C0     MOV [W0+8], W3
0072F8  508F83     SUB W1, W3, [W15]
0072FA  3D0004     BRA GE, MCAF_SatDetect::MCAF_CurrentSatDetect::UTIL_ClearBits
174:                   {
175:                       pcurrentsat->satFlag = UTIL_SetBits(pcurrentsat->satFlag, MCAF_OUT_OF_SATURATION); 
007300  980061     MOV W1, [W0+12]
007302  370003     BRA MCAF_SatDetect::MCAF_VoltSatDetect
176:                   }
177:                   else
178:                   {
179:                       pcurrentsat->satFlag = UTIL_ClearBits(pcurrentsat->satFlag, MCAF_OUT_OF_SATURATION);
007308  980061     MOV W1, [W0+12]
180:                   }
181:               }
182:               
183:               void MCAF_SatDetect(MCAF_SAT_DETECT_T *psat, const MC_DQ_T *pidq, const MC_DQ_T *pvdq, int16_t vDC)
184:               {
0072CA  BE9F88     MOV.D W8, [W15++]
0072CC  780303     MOV W3, W6
185:                   MCAF_CurrentSatDetect(&psat->currentSat, pidq->q);
0072CE  900091     MOV [W1+2], W1
186:                   MCAF_VoltSatDetect(&psat->voltSat, pvdq, vDC);
187:                   
188:                   /*
189:                    * Use the INTO_SATURATION to set, and OUT_OF_SATURATION to reset,
190:                    * each of the voltage and current saturation flags, independently.
191:                    * We take advantage of bitwise operations to do this, which depends on
192:                    * the fact that:
193:                    *     MCAF_SAT_NONE == 0
194:                    * and MCAF_SAT_VOLT | MCAF_SAT_CURRENT == MCAF_SAT_VOLT_AND_CURRENT
195:                    */
196:                   bool satVoltage = updateLatchedFlag(psat->state & MCAF_SAT_VOLT, 
007364  9000B0     MOV [W0+6], W1
007366  780210     MOV [W0], W4
007374  624161     AND.B W4, #0x1, W2
197:                                                       psat->voltSat.satFlag);
198:                   bool satCurrent = updateLatchedFlag(psat->state & MCAF_SAT_CURRENT, 
007376  9001E0     MOV [W0+12], W3
007384  0A8111     BFEXT #0x1, #0x1, W4, W1
007386  000004     NOP
199:                                                       psat->currentSat.satFlag);
200:                   
201:                   /* Now merge them together into an updated state. */
202:                   if (satVoltage)
007388  E00402     CP0.B W2
00738A  320006     BRA Z, .L15
203:                   {
204:                       psat->state = (satCurrent) ? MCAF_SAT_VOLT_AND_CURRENT : MCAF_SAT_VOLT;
00738C  200012     MOV #0x1, W2
00738E  E00401     CP0.B W1
007390  320001     BRA Z, .L16
007392  200032     MOV #0x3, W2
007394  780802     MOV W2, [W0]
007396  370005     BRA .L4
205:                   }
206:                   else
207:                   {
208:                       psat->state = (satCurrent) ? MCAF_SAT_CURRENT : MCAF_SAT_NONE;
007398  EB0100     CLR W2
00739A  E00401     CP0.B W1
00739C  320001     BRA Z, .L18
00739E  200022     MOV #0x2, W2
0073A0  780802     MOV W2, [W0]
209:                   }
210:               }
0073A2  BE044F     MOV.D [--W15], W8
0073A4  060000     RETURN
0073A6  4787EE     ADD W15, #0xE, W15
0073A8  BE9F88     MOV.D W8, [W15++]
0073AA  BE9F8A     MOV.D W10, [W15++]
0073AC  BE9F8C     MOV.D W12, [W15++]
0073AE  781F8E     MOV W14, [W15++]
0073B0  780700     MOV W0, W14
0073B2  BE0502     MOV.D W2, W10
0073B4  BE0404     MOV.D W4, W8
211:               
212:               /** * subtracts two 16-bit numbers but saturates the results * (requires saturation mode to be set) */
213:               inline static int16_t saturatedSubtract(int16_t x1, int16_t x2)
214:               {
215:                   a_Reg = __builtin_lac(x1, 0);
0080F0  CA0000     LAC W0, A
216:                   b_Reg = __builtin_lac(x2, 0);
0080F2  CA8001     LAC W1, B
217:                   a_Reg = __builtin_subab(a_Reg, b_Reg);
0080F4  CB3000     SUB A
218:                   return __builtin_sacr(a_Reg, 0);
0080F6  CD000A     SAC.R A, W10
219:               }
220:               
221:               /** * Read accumulator A */
222:               inline static int32_t readAccA32()
223:               {
224:               #if __XC16_VERSION__ >= 1026
225:                   const int32_t tmp = __builtin_sacd(a_Reg, 0);
008154  800110     MOV ACCA, W0
008156  800121     MOV ACCAH, W1
226:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
227:                   asm volatile ("");
228:                   return tmp;
229:               #else
230:                   int32_t result;
231:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
232:                   asm volatile ("" : "+w"(a_Reg):); 
233:                   result = ACCAH;
234:                   result <<= 16;
235:                   result |= ACCAL; return result;
236:               #endif
237:               }
238:               
239:               /** * Write accumulator B */
240:               inline static void writeAccB32(int32_t input)
241:               {
242:               #if __XC16_VERSION__ >= 1026
243:                   const int32_t tmp = input;
244:                   asm volatile ("" :: "r"(tmp)); 
245:                   b_Reg = __builtin_lacd(tmp, 0);
0080FA  CA8009     LAC W9, B
0080FC  880148     MOV W8, ACCB
246:               #else
247:                   uint32_t temp_dword;
248:                   uint16_t temp_word;
249:                   temp_dword = 0xFFFF0000 & input;
250:                   temp_dword = temp_dword >> 16;
251:                   temp_word = (uint16_t)temp_dword;
252:                   b_Reg = __builtin_lac(temp_word, 0);
253:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
254:                   asm volatile ("" : "+w"(b_Reg):); 
255:                   temp_word = (uint16_t)(0xFFFF & input);
256:                   ACCBL = temp_word;
257:               #endif
258:               }
259:               
260:               void MCAF_ControllerPIUpdate(int16_t in_Ref, int16_t in_Meas, 
261:                       MCAF_PISTATE_T *state, MCAF_SAT_STATE_T sat_State, int16_t *out,
262:                       int16_t direction)
263:               {
0080E0  BE9F88     MOV.D W8, [W15++]
0080E2  BE9F8A     MOV.D W10, [W15++]
264:                   int16_t error;
265:                   
266:                   /* non saturated output */
267:                   int16_t out_nonsat;
268:                   /* saturated output */
269:                   int16_t out_sat;
270:                   uint16_t saveCorcon = HAL_CORCON_RegisterValue_Get();
271:                   
272:                   /* Init CORCON register */
273:                   HAL_CORCON_Initialize();
274:                   
275:                   /* Calculate error */
276:                   error = saturatedSubtract(in_Ref, in_Meas);
277:               
278:                   /* Read state->integrator into B */
279:                   writeAccB32(state->integrator);
0080F8  BE0412     MOV.D [W2], W8
280:               
281:                   /* Calculate (Kp * error * 2^Nkp), store in A and out_Buffer */
282:                   a_Reg = __builtin_mpy(error, state->kp, 0, 0, 0, 0, 0, 0);
0080FE  900422     MOV [W2+4], W8
008100  78038A     MOV W10, W7
008102  780308     MOV W8, W6
008104  C60113     MPY W6*W7, A
283:                   a_Reg = __builtin_sftac(a_Reg, -state->nkp);
008106  9003D2     MOV [W2+10], W7
008108  EA0387     NEG W7, W7
00810A  C80007     SFTAC A, W7
284:                   a_Reg = __builtin_addab(a_Reg, b_Reg);
00810C  CB0000     ADD A
285:                   out_nonsat = __builtin_sacr(a_Reg, 0);
00810E  CD0008     SAC.R A, W8
286:               
287:                   /* Limit the output */
288:                   out_sat = UTIL_LimitS16(out_nonsat, state->outMin, state->outMax);
008110  9003F2     MOV [W2+14], W7
008112  900C82     MOV [W2+16], W9
289:                   
290:                   *out = out_sat;
008120  780A07     MOV W7, [W4]
291:                   /* Calculate integrator term and add it to previous value if not in saturation state */
292:                   if ((sat_State == MCAF_SAT_NONE)
008122  E00003     CP0 W3
008124  32000D     BRA Z, .L28
293:                        || (UTIL_DirectedLessThanEqual(in_Ref, in_Meas, direction)))
00813C  E00403     CP0.B W3
00813E  32000D     BRA Z, MCAF_ControllerPIUpdate::HAL_CORCON_RegisterValue_Set
294:                   {    
295:                       /* Calculate (error * Ki) and store in A */
296:                       a_Reg = __builtin_mpy(error, state->ki, 0, 0, 0, 0, 0, 0);
008140  900232     MOV [W2+6], W4
008142  78028A     MOV W10, W5
008144  C00113     MPY W4*W5, A
297:                       a_Reg = __builtin_sftac(a_Reg, -state->nki);
008146  900062     MOV [W2+12], W0
008148  EA0000     NEG W0, W0
00814A  C80000     SFTAC A, W0
298:                       
299:                       /* Calculate (excess * Kc), subtract from (error * Ki) and store in A */
300:                       error = out_nonsat - out_sat;
00814C  540207     SUB W8, W7, W4
301:                       a_Reg = __builtin_msc(a_Reg, error, state->kc,0,0,0,0,0,0,0,0);
00814E  9003C2     MOV [W2+8], W7
008150  C24112     MSC W4*W7, A
302:                       
303:                       /* Add (error * Ki)-(excess * Kc) to the integrator value in B */
304:                       a_Reg = __builtin_addab(a_Reg,b_Reg);
008152  CB0000     ADD A
305:                       
306:                       state->integrator = readAccA32();
008158  BE8900     MOV.D W0, [W2]
307:                   }
308:               
309:                   HAL_CORCON_RegisterValue_Set(saveCorcon);
310:                   
311:               }
00815C  BE054F     MOV.D [--W15], W10
00815E  BE044F     MOV.D [--W15], W8
008160  060000     RETURN
008162  EF2E06     CLR LATA
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/recover.h
1:                 /**
2:                  * recover.h
3:                  *
4:                  * Module to recover when motor is stall
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __RECOVER_H
48:                #define __RECOVER_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                
53:                #ifdef __cplusplus
54:                extern "C" {
55:                #endif
56:                
57:                /**
58:                 * State machine states for the recovery behavior
59:                 */    
60:                typedef enum tagMCAF_RECOVERY_FSM_STATE
61:                {
62:                    MCAF_RECOVERY_FSM_NO_ERROR = 0,           /** everything running fine */
63:                    MCAF_RECOVERY_FSM_STOP_PENDING = 1,       /** stall detected, motor stopping */
64:                    MCAF_RECOVERY_FSM_RESTART_PENDING = 2,    /** automatic retry pending a timer */
65:                    MCAF_RECOVERY_FSM_RETRIES_EXCEEDED = 3    /** too many retries */
66:                } MCAF_RECOVERY_FSM_STATE;
67:                
68:                /**
69:                 * State machine inputs for the recovery behavior
70:                 */    
71:                typedef enum tagMCAF_RECOVERY_FSM_INPUTS
72:                {
73:                    MCAF_RECOVERY_FSMI_STALL_DETECTED = 1,    /** stall detected */
74:                    MCAF_RECOVERY_FSMI_STOP_COMPLETED = 2     /** stop completed */            
75:                } MCAF_RECOVERY_FSM_INPUTS;
76:                
77:                /**
78:                 * State machine outputs for the recovery behavior
79:                 */    
80:                typedef enum tagMCAF_RECOVERY_FSM_OUTPUTS
81:                {
82:                    MCAF_RECOVERY_FSMO_STOP_MOTOR    = 1,     /** stop motor */
83:                    MCAF_RECOVERY_FSMO_RETRY_FAULT   = 2      /** failure: too many retries */
84:                } MCAF_RECOVERY_FSM_OUTPUTS;
85:                
86:                
87:                /**
88:                 * This structure hosts recovery variables
89:                 */
90:                typedef struct tagMCAF_RECOVERY_DATA
91:                {
92:                    int16_t countdownTrials;         /** number of unsuccessful recovery processes so far */
93:                    uint16_t recoveryTimer;  /** timer counting elapsed time from recovery processing start */
94:                    uint16_t time1stStaticRecovery;   /** time necessary for fault treatment */
95:                    
96:                    struct tagSTATEMACHINE {
97:                        MCAF_RECOVERY_FSM_STATE state;  /** state machine state */
98:                        uint16_t inputs;                /** state machine inputs */
99:                        uint16_t outputs;               /** state machine outputs */
100:                   } stateMachine;
101:               } MCAF_RECOVERY_DATA_T;
102:               
103:               
104:               /**
105:                * This function init the recovery module
106:                *
107:                * Summary : Initialize the recovery module
108:                *
109:                * @param precovery This parameter is pointer to MCAF_RECOVERY_DATA_T structure
110:                */
111:               void MCAF_RecoveryInit(MCAF_RECOVERY_DATA_T *precovery);
112:               
113:               /**
114:                * This function reset the recovery module
115:                *
116:                * Summary : Reset the recovery module
117:                *
118:                * @param precovery This parameter is pointer to MCAF_RECOVERY_DATA_T structure
119:                */
120:               void MCAF_RecoveryReset(MCAF_RECOVERY_DATA_T *precovery);
121:               
122:               /**
123:                * This function handles the recovery process, executing the recovery tasks, such
124:                * as coasting down the motor in the event of stall
125:                *
126:                * Summary : Runs the recovery task
127:                *
128:                * @param precovery This parameter is pointer to MCAF_RECOVERY_DATA_T structure
129:                */
130:               void MCAF_Recovery(MCAF_RECOVERY_DATA_T *precovery);
131:               
132:               /**
133:                * Sets an input flag
134:                * @param precovery state variable structure
135:                * @param flag which flag to set
136:                */
137:               static inline void MCAF_RecoverySetInputFlag(MCAF_RECOVERY_DATA_T *precovery, MCAF_RECOVERY_FSM_INPUTS flag)
138:               {
139:                   precovery->stateMachine.inputs |= flag;
004C92  92A018     MOV [W8+706], W0
004C94  A01000     BSET W0, #1
004C96  9AA410     MOV W0, [W8+706]
0090F4  92A018     MOV [W8+706], W0
0090F6  A00000     BSET W0, #0
0090F8  9AA410     MOV W0, [W8+706]
140:               }
141:               
142:               /**
143:                * Tests an output flag
144:                * 
145:                * @param precovery state variable structure
146:                * @param flag which flag to test
147:                * @return whether the flag was true
148:                */
149:               static inline bool MCAF_RecoveryTestFlag(const MCAF_RECOVERY_DATA_T *precovery, MCAF_RECOVERY_FSM_OUTPUTS flag)
150:               {
151:                   return (precovery->stateMachine.outputs & flag) != 0;
004A2A  92A028     MOV [W8+708], W0
00967E  92A020     MOV [W0+708], W0
009680  0A8011     BFEXT #0x1, #0x1, W0, W0
009682  000000     NOP
009684  37000A     BRA .L7
009686  92A120     MOV [W0+708], W2
152:               }
153:               
154:               /**
155:                * This function checks whether there was any failure reported in recovery
156:                *
157:                * Summary : Recovery ended with failure, is this true?
158:                *
159:                * @param pmotor This parameter is pointer to MCAF_RECOVERY_DATA_T structure
160:                * @return true if recovery failure is detected (number of recovery trials exceeded)
161:                */
162:               static inline bool MCAF_RecoveryIsFailureDetected(const MCAF_RECOVERY_DATA_T *precovery)
163:               {
164:                   return MCAF_RecoveryTestFlag(precovery, MCAF_RECOVERY_FSMO_RETRY_FAULT);
165:               }
166:               
167:               #ifdef __cplusplus
168:               }
169:               #endif
170:               
171:               #endif /* __RECOVER_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/recover.c
1:                 /**
2:                  * recover.c
3:                  *
4:                  * Module to recover when motor is stall condition
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include "recover.h"
48:                #include "hal.h"
49:                #include "util.h"
50:                #include "parameters/recover_params.h"
51:                
52:                
53:                void MCAF_RecoveryInit(MCAF_RECOVERY_DATA_T *precovery)
54:                {
009C4E  781F88     MOV W8, [W15++]
009C50  780400     MOV W0, W8
55:                    /* initialize the configuration structure */
56:                    MCAF_RecoveryReset(precovery);
009C52  780008     MOV W8, W0
009C54  07FFF4     RCALL MCAF_RecoveryReset
57:                    precovery->time1stStaticRecovery = MCAF_RECOVERY_COASTDOWN_TIME;
009C56  2C3500     MOV #0xC350, W0
009C58  980420     MOV W0, [W8+4]
58:                }
009C5A  78044F     MOV [--W15], W8
009C5C  060000     RETURN
009C5E  600067     AND W0, #0x7, W0
59:                
60:                void MCAF_RecoveryReset(MCAF_RECOVERY_DATA_T *precovery)
61:                {
62:                    /* initialize the configuration structure */
63:                    precovery->countdownTrials =  MCAF_RECOVERY_STARTUP_ATTEMPTS;
009C3E  200031     MOV #0x3, W1
009C40  780801     MOV W1, [W0]
64:                    precovery->recoveryTimer = 0;
009C42  EB0080     CLR W1
009C44  980011     MOV W1, [W0+2]
65:                    precovery->stateMachine.state = MCAF_RECOVERY_FSM_NO_ERROR;
009C46  980031     MOV W1, [W0+6]
66:                    precovery->stateMachine.inputs = 0;
009C48  980041     MOV W1, [W0+8]
67:                    precovery->stateMachine.outputs = 0;
009C4A  980051     MOV W1, [W0+10]
68:                }
009C4C  060000     RETURN
69:                
70:                void MCAF_Recovery(MCAF_RECOVERY_DATA_T *precovery)
71:                {           
72:                    const MCAF_RECOVERY_FSM_STATE thisState = precovery->stateMachine.state;
73:                    MCAF_RECOVERY_FSM_STATE nextState = thisState;
00860A  200032     MOV #0x3, W2
008614  EB0100     CLR W2
008626  200012     MOV #0x1, W2
00864E  200022     MOV #0x2, W2
74:                    switch (thisState)
0085FE  9000B0     MOV [W0+6], W1
008600  508FE1     SUB W1, #0x1, [W15]
008602  320010     BRA Z, .L6
008604  390006     BRA NC, .L5
008606  508FE2     SUB W1, #0x2, [W15]
008608  32001E     BRA Z, .L7
00860C  508F82     SUB W1, W2, [W15]
00860E  3A0027     BRA NZ, .L14
008610  370027     BRA .L4
75:                    {
76:                        case MCAF_RECOVERY_FSM_NO_ERROR:
77:                            if (precovery->stateMachine.inputs & MCAF_RECOVERY_FSMI_STALL_DETECTED)
008612  9000C0     MOV [W0+8], W1
008616  A30801     BTST.Z W1, #0
008618  320023     BRA Z, .L4
78:                            {
79:                                nextState = MCAF_RECOVERY_FSM_STOP_PENDING;
008620  200012     MOV #0x1, W2
008622  37001E     BRA .L4
80:                                precovery->stateMachine.outputs |= MCAF_RECOVERY_FSMO_STOP_MOTOR;
00861A  9000D0     MOV [W0+10], W1
00861C  A00001     BSET W1, #0
00861E  980051     MOV W1, [W0+10]
81:                            }
82:                            break;
83:                        case MCAF_RECOVERY_FSM_STOP_PENDING:
84:                            if (precovery->stateMachine.inputs & MCAF_RECOVERY_FSMI_STOP_COMPLETED)
008624  9000C0     MOV [W0+8], W1
008628  A31801     BTST.Z W1, #1
00862A  32001A     BRA Z, .L4
85:                            {
86:                                if (precovery->countdownTrials == 0)
00862C  780090     MOV [W0], W1
00862E  E00001     CP0 W1
008630  3A0005     BRA NZ, .L9
87:                                {
88:                                    nextState = MCAF_RECOVERY_FSM_RETRIES_EXCEEDED;
008638  200032     MOV #0x3, W2
00863A  370012     BRA .L4
89:                                    precovery->stateMachine.outputs |= MCAF_RECOVERY_FSMO_RETRY_FAULT;
008632  9000D0     MOV [W0+10], W1
008634  A01001     BSET W1, #1
008636  980051     MOV W1, [W0+10]
90:                                }
91:                                else
92:                                {
93:                                    /** We can retry... start a timer */
94:                                    --precovery->countdownTrials;
00863C  E90801     DEC W1, [W0]
95:                                    nextState = MCAF_RECOVERY_FSM_RESTART_PENDING;
008642  200022     MOV #0x2, W2
008644  37000D     BRA .L4
96:                                    precovery->recoveryTimer = 0;
00863E  EB0080     CLR W1
008640  980011     MOV W1, [W0+2]
97:                                }
98:                            }
99:                            break;
100:                       case MCAF_RECOVERY_FSM_RESTART_PENDING:
101:                           if (++precovery->recoveryTimer >= precovery->time1stStaticRecovery)
008646  900090     MOV [W0+2], W1
008648  E80081     INC W1, W1
00864A  980011     MOV W1, [W0+2]
00864C  9001A0     MOV [W0+4], W3
008650  508F83     SUB W1, W3, [W15]
008652  390006     BRA NC, .L4
102:                           {
103:                               /* Allow motor to restart */
104:                               nextState = MCAF_RECOVERY_FSM_NO_ERROR;
00865A  EB0100     CLR W2
00865C  370001     BRA .L4
105:                               precovery->stateMachine.outputs &= ~MCAF_RECOVERY_FSMO_STOP_MOTOR;
008654  9000D0     MOV [W0+10], W1
008656  A10001     BCLR W1, #0
008658  980051     MOV W1, [W0+10]
106:                           }
107:                           break;
108:                       case MCAF_RECOVERY_FSM_RETRIES_EXCEEDED:
109:                           break;
110:                       default:
111:                           nextState = MCAF_RECOVERY_FSM_NO_ERROR;
00865E  EB0100     CLR W2
112:                           break;
113:                   }
114:                   
115:                   /* clear inputs until next time and update state */
116:                   precovery->stateMachine.inputs = 0;
008660  EB0080     CLR W1
008662  980041     MOV W1, [W0+8]
117:                   precovery->stateMachine.state = nextState;
008664  980032     MOV W2, [W0+6]
118:               }
008666  060000     RETURN
008668  233B95     MOV #0x33B9, W5
1:                 /**
2:                  * init_params.c
3:                  * 
4:                  * Initialization of motor parameters
5:                  *
6:                  * Component: FOC
7:                  */ /*
8:                  *
9:                  * Motor Control Application Framework
10:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
11:                 *
12:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
13:                 * this software and any derivatives exclusively with Microchip products.
14:                 *
15:                 * This software and any accompanying information is for suggestion only.
16:                 * It does not modify Microchip's standard warranty for its products.
17:                 * You agree that you are solely responsible for testing the software and
18:                 * determining its suitability.  Microchip has no obligation to modify,
19:                 * test, certify, or support the software.
20:                 *
21:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
22:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
23:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
24:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
25:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
26:                 * APPLICATION.
27:                 *
28:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
29:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
30:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
31:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
32:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
33:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
34:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
36:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
37:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
38:                 * SOFTWARE.
39:                 *
40:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
41:                 * THESE TERMS.
42:                 *
43:                 *
44:                 ******************************************************************************/
45:                
46:                #include "../system_state.h"
47:                #include "foc_params.h"
48:                #include "adc_params.h"
49:                #include "outerloop_params.h"
50:                #include "filter.h"
51:                
52:                void MCAF_InitControlParameters_Motor1(MCAF_MOTOR_DATA *pmotor)
53:                {
54:                    /* ============= PI D Term =============== */
55:                    pmotor->idCtrl.kp = DKP;
008668  233B95     MOV #0x33B9, W5
00866A  981005     MOV W5, [W0+32]
56:                    pmotor->idCtrl.ki = DKI;
00866C  20F4F4     MOV #0xF4F, W4
00866E  981014     MOV W4, [W0+34]
57:                    pmotor->idCtrl.nkp = DKNP;
008670  200023     MOV #0x2, W3
008672  981033     MOV W3, [W0+38]
58:                    pmotor->idCtrl.nki = DKNI;
008674  EB0080     CLR W1
008676  981041     MOV W1, [W0+40]
59:                    pmotor->idCtrl.kc = DKC;
008678  27FFF2     MOV #0x7FFF, W2
00867A  981022     MOV W2, [W0+36]
60:                    pmotor->idCtrl.outMax = 0;
00867C  981051     MOV W1, [W0+42]
61:                    pmotor->idCtrl.outMin = 0;
00867E  981061     MOV W1, [W0+44]
62:                    pmotor->idqCtrlOutLimit.d = MCAF_CURRENT_CTRL_D_OUT_LIMIT;
008680  249E76     MOV #0x49E7, W6
008682  982006     MOV W6, [W0+64]
63:                
64:                    /* ============= PI Q Term =============== */
65:                    pmotor->iqCtrl.kp = QKP;
008684  981815     MOV W5, [W0+50]
66:                    pmotor->iqCtrl.ki = QKI;
008686  981824     MOV W4, [W0+52]
67:                    pmotor->iqCtrl.nkp = QKNP;
008688  981843     MOV W3, [W0+56]
68:                    pmotor->iqCtrl.nki = QKNI;
00868A  981851     MOV W1, [W0+58]
69:                    pmotor->iqCtrl.kc = QKC;
00868C  981832     MOV W2, [W0+54]
70:                    pmotor->iqCtrl.outMax = 0;
00868E  981861     MOV W1, [W0+60]
71:                    pmotor->iqCtrl.outMin = 0;
008690  981871     MOV W1, [W0+62]
72:                    pmotor->idqCtrlOutLimit.q = MCAF_CURRENT_CTRL_Q_OUT_LIMIT;
008692  254FC3     MOV #0x54FC, W3
008694  982013     MOV W3, [W0+66]
73:                
74:                    /* ============= PI W Term =============== */
75:                    if (MCAF_OuterLoopType() == MCAF_OLT_VOLTAGE)
76:                    {
77:                        pmotor->omegaCtrl.kp = MCAF_CONTROL_GAIN_KVP;
78:                        pmotor->omegaCtrl.ki = MCAF_CONTROL_GAIN_KVI;
79:                        pmotor->omegaCtrl.nkp = 15 - MCAF_CONTROL_GAIN_KVP_Q;
80:                        pmotor->omegaCtrl.nki = 15 - MCAF_CONTROL_GAIN_KVI_Q;
81:                        pmotor->velocityControl.velocityCmdGain = MCAF_VELOCITY_TO_VOLTAGE_GAIN;
82:                    }
83:                    else
84:                    {
85:                        pmotor->omegaCtrl.kp = WKP;
008696  20D883     MOV #0xD88, W3
008698  993023     MOV W3, [W0+356]
86:                        pmotor->omegaCtrl.ki = WKI;
00869A  200383     MOV #0x38, W3
00869C  993033     MOV W3, [W0+358]
87:                        pmotor->omegaCtrl.nkp = WKNP;
00869E  993051     MOV W1, [W0+362]
88:                        pmotor->omegaCtrl.nki = WKNI;
0086A0  993061     MOV W1, [W0+364]
89:                        pmotor->velocityControl.velocityCmdGain = INT16_MAX;
0086A2  993842     MOV W2, [W0+376]
90:                    }
91:                    pmotor->omegaCtrl.kc = WKC;
0086A4  993041     MOV W1, [W0+360]
92:                    pmotor->omegaCtrl.outMax = MCAF_VELOCITY_CTRL_IQ_OUT_LIMIT;
0086A6  203672     MOV #0x367, W2
0086A8  993072     MOV W2, [W0+366]
93:                    pmotor->omegaCtrl.outMin = -MCAF_VELOCITY_CTRL_IQ_OUT_LIMIT;
0086AA  2FC992     MOV #0xFC99, W2
0086AC  993802     MOV W2, [W0+368]
94:                    
95:                    pmotor->bridgeTemperature.gain   = MCAF_BRIDGE_TEMPERATURE_GAIN;
0086AE  280E82     MOV #0x80E8, W2
0086B0  998842     MOV W2, [W0+408]
96:                    pmotor->bridgeTemperature.offset = MCAF_BRIDGE_TEMPERATURE_OFFSET;
0086B2  213882     MOV #0x1388, W2
0086B4  998852     MOV W2, [W0+410]
97:                    pmotor->bridgeTemperature.filter.gain = MCAF_BRIDGE_TEMPERATURE_FILTER_GAIN;
0086B6  201482     MOV #0x148, W2
0086B8  998802     MOV W2, [W0+400]
98:                    pmotor->bridgeTemperature.filter.state.x32 = 0;
0086BA  B81160     MUL.UU W2, #0x0, W2
0086BC  998812     MOV W2, [W0+402]
0086BE  998823     MOV W3, [W0+404]
99:                    pmotor->bridgeTemperature.filter.output = 0;
0086C0  998071     MOV W1, [W0+398]
100:                   pmotor->bridgeTemperature.filter.slewRate = MCAF_BRIDGE_TEMPERATURE_SLEW_RATE;
0086C2  2051F1     MOV #0x51F, W1
0086C4  998831     MOV W1, [W0+406]
101:               
102:                   MCAF_FilterLowPassS16Init(&pmotor->vqFiltered, MCAF_FILTER_COEFF_VQ);
103:               }
0086CE  060000     RETURN
104:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/monitor.h
1:                 /**
2:                  * monitor.h
3:                  *
4:                  * Module to link recovery and stall detection
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __MONITOR_H
48:                #define __MONITOR_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                
53:                #include "system_state.h"
54:                #include "monitor_types.h"
55:                #include "recover.h"
56:                #include "fault_detect.h"
57:                #include "error_codes.h"
58:                #include "mcapi.h"
59:                
60:                #ifdef __cplusplus
61:                extern "C" {
62:                #endif
63:                
64:                /**
65:                 * System monitor fault types
66:                 */
67:                typedef enum tagMCAF_MONITOR_FAULT
68:                {
69:                    MCAF_MONITOR_RECOVERY_FAULT = 0x1,     /** recovery retrial exceed fault */
70:                    MCAF_MONITOR_OVERVOLTAGE_FAULT = 0x2, /** overvoltage fault */
71:                    MCAF_MONITOR_UNDERVOLTAGE_FAULT = 0x4, /** undervoltage fault */
72:                    MCAF_MONITOR_OVERCURRENT_HW_FAULT = 0x8, /** overcurrent fault */
73:                } MCAF_MONITOR_FAULT_FLAG;
74:                
75:                /**
76:                 * This function checks if regular run is accepted, since there is no fault to be acknowledged
77:                 *
78:                 * Summary : Check if running state can be achieved
79:                 *
80:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
81:                 * @return true if run is permitted
82:                 */
83:                static inline bool MCAF_MonitorIsRunPermitted(MCAF_MOTOR_DATA *pmotor)
84:                {
85:                    return !MCAF_RecoveryTestFlag(&pmotor->recovery, MCAF_RECOVERY_FSMO_STOP_MOTOR);
86:                }
87:                
88:                /**
89:                 * This function checks if motor achieved stopped state, or is it still recovering
90:                 *
91:                 * Summary : Check if stopped state was achieved, after recovery
92:                 *
93:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
94:                 * @return true if the motor is stopped
95:                 */
96:                static inline bool MCAF_MonitorIsMotorStopped(MCAF_MOTOR_DATA *pmotor)
97:                {
98:                    /* Placeholder -- at this time, we don't actually detect 
99:                     * whether the motor is stopped. */
100:                   return true;
101:               }
102:               
103:               /**
104:                * This function inits the monitor function
105:                *
106:                * Summary : Initializes the monitoring function
107:                *
108:                * @param pmotor This parameter is pointer to MCAF_MONITOR_DATA_T structure
109:                */
110:               void MCAF_MonitorInit(MCAF_MONITOR_DATA_T *pmonitor);
111:               
112:               /**
113:                * This function represents the core of monitoring, containing the detection
114:                * routines for stall and fault - also it provides the glue logic in between
115:                * stall and fault detection and recovery function, managing the activation
116:                * registers for each specific post detection action.
117:                *
118:                * Summary : Assigns actions to recovery function depending on the stall or fault
119:                * detection functions output
120:                *
121:                * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
122:                */
123:               void MCAF_MonitorSysDiagnose(MCAF_MOTOR_DATA *pmotor);
124:               
125:               /**
126:                * This function gathers all the monitoring functionalities that have the highest
127:                * execution priority: recovery function is one of them.
128:                *
129:                * Summary : Monitoring system highest priority functions: Recovery
130:                *
131:                * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
132:                */
133:               static inline void MCAF_MonitorStepIsr(MCAF_MOTOR_DATA *pmotor)
134:               {
135:                   MCAF_Recovery(&pmotor->recovery);
000954  230BA0     MOV #0x30BA, W0
000956  073E53     RCALL MCAF_Recovery
136:               }
137:               
138:               /**
139:                * This function check whether there was any failure reported by recovery
140:                *
141:                * Summary : Does recovery reported a failure?
142:                *
143:                * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
144:                * @param faultType This parameter indicates the fault for which the Fault state is returned
145:                * @return true if a fault is detected
146:                */
147:               
148:               bool MCAF_MonitorIsFaultDetected(MCAF_MOTOR_DATA *pmotor, MCAF_MONITOR_FAULT_FLAG faultType);
149:               
150:               /**
151:                * This function acknowledges the faults that were treated by recovery, clearing
152:                * the activated recovery tasks, indicating to the system that run can be possible
153:                *
154:                * Summary : Acknowledge recovery tasks activated, enabling the system running state
155:                *
156:                * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
157:                */
158:               void MCAF_MonitorRecoveryAcknowledged(MCAF_MOTOR_DATA *pmotor);
159:               
160:               /**
161:                * Fault detection mode
162:                */
163:               typedef enum tagFaultDetectionMode
164:               {
165:                   FDM_TEST    = 0,  /** test modes */
166:                   FDM_PRIMARY = 1   /** "normal" (non-test) modes */
167:               } MCAF_FaultDetectionMode;
168:               
169:               /**
170:                * Translates fault flags into an error code.
171:                * 
172:                * This requires prioritization of errors, so that if more than one fault
173:                * flag is set, the error code results from the highest-priority error only,
174:                * and lower-priority errors are not visible, at least using the error code.
175:                * 
176:                * @param pfaultinfo fault detection state
177:                * @return appropriate error code (or ERR_NO_ERROR if no faults have been detected
178:                */
179:               inline static MCAF_ERROR_CODE MCAF_MonitorTranslateFaultFlags(
180:                       const MCAF_FAULT_DETECT_T *pfaultinfo)
181:               {
182:                  MCAF_ERROR_CODE result = ERR_NO_ERROR;
183:                  if (MCAF_IsOvervoltageFlagSet(pfaultinfo))
0049DE  A30800     BTST.Z W0, #0
0049E0  3A0011     BRA NZ, .LBE1572, .L10
0049E2  370005     BRA .LBE1540, .LBE1561, .L103
004AD6  A30800     BTST.Z W0, #0
004AD8  3A000B     BRA NZ, .LBE1602, .LBE1603, .LBE1604, .L28
184:                  {
185:                      result = ERR_DCLINK_OVERVOLTAGE;
0049DC  200131     MOV #0x13, W1
004AD4  200131     MOV #0x13, W1
186:                  }
187:                  else if (MCAF_IsUndervoltageFlagSet(pfaultinfo))
0049F0  A31800     BTST.Z W0, #1
0049F2  3A0008     BRA NZ, .LBE1572, .L10
004ADC  A31800     BTST.Z W0, #1
004ADE  3A0008     BRA NZ, .LBE1602, .LBE1603, .LBE1604, .L28
188:                  {
189:                      result = ERR_DCLINK_UNDERVOLTAGE;
0049EE  200141     MOV #0x14, W1
004ADA  200141     MOV #0x14, W1
190:                  }
191:                  else if (MCAF_IsOvercurrentFlagSet(pfaultinfo))
0049F6  A32800     BTST.Z W0, #2
0049F8  3A0005     BRA NZ, .LBE1572, .L10
004AE2  A32800     BTST.Z W0, #2
004AE4  3A0005     BRA NZ, .LBE1602, .LBE1603, .LBE1604, .L28
192:                  {
193:                      result = ERR_HW_OVERCURRENT;
0049F4  200121     MOV #0x12, W1
004AE0  200121     MOV #0x12, W1
194:                  }
195:                  else if (MCAF_IsOvertemperatureFlagSet(pfaultinfo))
0049FC  A33800     BTST.Z W0, #3
0049FE  3A0002     BRA NZ, .LBE1572, .L10
004A00  3702A4     BRA .L105
004AE8  A33800     BTST.Z W0, #3
004AEA  3A0002     BRA NZ, .LBE1602, .LBE1603, .LBE1604, .L28
004AEC  37023F     BRA .L108
196:                  {
197:                      result = ERR_OVERTEMPERATURE;
0049FA  200151     MOV #0x15, W1
004AE6  200151     MOV #0x15, W1
198:                  }
199:                  return result;
200:               }
201:               
202:               /**
203:                * Tests to see if a fault has occurred
204:                *
205:                * @param pmotor motor structure
206:                * @param mode test or primary mode
207:                * @return whether a fault has been detected
208:                */
209:               inline static bool MCAF_DetectFault(MCAF_MOTOR_DATA *pmotor,
210:                       MCAF_FaultDetectionMode mode)
211:               {
212:                   bool result = false;
213:                   
214:                   /* ----- First we check for errors that occur in any mode. ----- */
215:                   if (MCAF_IsAnyFaultFlagSet(&pmotor->faultDetect))
0049C4  929848     MOV [W8+696], W0
0049C6  E00000     CP0 W0
0049C8  3A0008     BRA NZ, MCAF_GetFaultCode
216:                   {
217:                       result = true;
218:                   }
219:                   else if (mode != FDM_TEST)
220:                   {
221:                       /* ----- Then we check for errors that we only detect in the primary states. */
222:                       if (MCAF_MonitorIsFaultDetected(pmotor, MCAF_MONITOR_RECOVERY_FAULT))
0049CA  200011     MOV #0x1, W1
0049CC  780008     MOV W8, W0
0049CE  072655     RCALL MCAF_MonitorIsFaultDetected
0049D0  E00400     CP0.B W0
0049D2  3A0003     BRA NZ, MCAF_GetFaultCode
223:                       {
224:                           result = true;
225:                       }
226:                       else if (MCAPI_ApplicationFaultCodeGet(&pmotor->apiData) != ERR_NO_ERROR)
0049D6  E00000     CP0 W0
0049D8  320005     BRA Z, MCAF_TestAndClearDirectionChangeFlag
227:                       {
228:                           result = true;
229:                       }
230:                   }
231:                   return result;
232:               }
233:               
234:               /**
235:                * Gets the error code present in any detected fault
236:                *
237:                * @param pmotor motor structure
238:                * @return error code
239:                */
240:               inline static MCAF_ERROR_CODE MCAF_GetFaultCode(MCAF_MOTOR_DATA *pmotor)
241:               {
242:                   MCAF_ERROR_CODE code = MCAF_MonitorTranslateFaultFlags(&pmotor->faultDetect);
243:                   if (code == ERR_NO_ERROR)
244:                   {
245:                       if (MCAF_MonitorIsFaultDetected(pmotor, MCAF_MONITOR_RECOVERY_FAULT))
004F4A  200011     MOV #0x1, W1
004F4C  780008     MOV W8, W0
004F4E  072395     RCALL MCAF_MonitorIsFaultDetected
004F52  E00400     CP0.B W0
004F54  32FD56     BRA Z, MCAPI_ApplicationFaultCodeGet
004F56  37FD56     BRA .LBE1572, .L10
004F6C  200011     MOV #0x1, W1
004F6E  780008     MOV W8, W0
004F70  072384     RCALL MCAF_MonitorIsFaultDetected
004F74  E00400     CP0.B W0
004F76  32FDBB     BRA Z, MCAPI_ApplicationFaultCodeGet
004F78  37FDBB     BRA .LBE1602, .LBE1603, .LBE1604, .L28
246:                       {
247:                           code = ERR_STALL_RETRY_EXCEEDED;
004F50  200101     MOV #0x10, W1
004F72  200101     MOV #0x10, W1
248:                       }
249:                       else
250:                       {
251:                           code = MCAPI_ApplicationFaultCodeGet(&pmotor->apiData);
252:                       }
253:                   }
254:                   return code;
255:               }
256:               
257:               #ifdef __cplusplus
258:               }
259:               #endif
260:               
261:               #endif /* __MONITOR_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/monitor.c
1:                 /**
2:                  * monitor.c
3:                  *
4:                  * Module to link recovery and stall detection
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include "recover.h"
49:                #include "monitor.h"
50:                #include "stall_detect.h"
51:                #include "fault_detect.h"
52:                #include "system_state.h"
53:                #include "util.h"
54:                #include "test_harness.h"
55:                
56:                void MCAF_MonitorSysDiagnose(MCAF_MOTOR_DATA *pmotor)
57:                {
0090CA  781F88     MOV W8, [W15++]
58:                    /* fault detection */
59:                    MCAF_FaultDetect(&pmotor->faultDetect, pmotor);
0090CE  202B20     MOV #0x2B2, W0
0090D0  400008     ADD W0, W8, W0
0090D2  780088     MOV W8, W1
0090D4  0700EB     RCALL MCAF_FaultDetect
60:                
61:                #if MCAF_INCLUDE_STALL_DETECT    
62:                    if (MCAF_StallDetectActive(&pmotor->stallDetect))
0090DA  E00410     CP0.B [W0]
0090DC  32000E     BRA Z, .LBE27, .LBE30, .L1
63:                    {
64:                        /* check for stall conditions */
65:                        MCAF_StallDetect(&pmotor->stallDetect, pmotor);
0090DE  202000     MOV #0x200, W0
0090E0  400008     ADD W0, W8, W0
0090E2  780088     MOV W8, W1
0090E4  07E412     RCALL MCAF_StallDetect
66:                
67:                        /* ignore a stall condition if we override detection; otherwise handle it */
68:                        if (!MCAF_OverrideStallDetection(&pmotor->testing))
0090E8  A33800     BTST.Z W0, #3
0090EA  3A0007     BRA NZ, .LBE27, .LBE30, .L1
69:                        {
70:                            /* Have we detected a stall by one of the methods that is enabled? */
71:                            uint16_t maskedFlags = MCAF_StallDetectGetMaskedFlags(&pmotor->stallDetect);
72:                            if (maskedFlags != 0)
0090F2  320003     BRA Z, .LBE27, .LBE30, .L1
73:                            {
74:                                MCAF_RecoverySetInputFlag(&pmotor->recovery, MCAF_RECOVERY_FSMI_STALL_DETECTED);
75:                            }
76:                        }
77:                    }
78:                #endif
79:                }
0090FA  78044F     MOV [--W15], W8
0090FC  060000     RETURN
80:                
81:                void MCAF_MonitorInit(MCAF_MONITOR_DATA_T *pmonitor)
82:                {
83:                    /* initialize run as true */
84:                    pmonitor->runPermitted = true;
009EA4  B3C011     MOV.B #0x1, W1
85:                }
009EA8  060000     RETURN
009EAA  07FCC8     RCALL UART1_Initialize
86:                
87:                void MCAF_MonitorRecoveryAcknowledged(MCAF_MOTOR_DATA *pmotor)
88:                {
89:                    /* once acknowledged, run is permitted */
90:                    pmotor->monitor.runPermitted = true;
009DFA  B02C60     ADD #0x2C6, W0
009DFC  B3C011     MOV.B #0x1, W1
009DFE  784801     MOV.B W1, [W0]
91:                    
92:                }
009E00  060000     RETURN
009E02  A8E8DD     BSET 0x8DD, #7
93:                
94:                bool MCAF_MonitorIsFaultDetected(MCAF_MOTOR_DATA *pmotor, MCAF_MONITOR_FAULT_FLAG faultType)
95:                {
96:                    bool failure = false;
97:                    if (faultType == MCAF_MONITOR_RECOVERY_FAULT)
00967A  508FE1     SUB W1, #0x1, [W15]
00967C  3A0004     BRA NZ, MCAF_MonitorIsFaultDetected::MCAF_RecoveryIsFailureDetected
98:                    {
99:                        failure = MCAF_RecoveryIsFailureDetected(&pmotor->recovery);
100:                   }
101:                   else
102:                   {
103:                       failure = MCAF_RecoveryIsFailureDetected(&pmotor->recovery)
009698  784001     MOV.B W1, W0
104:                       || MCAF_Fault_IsFaultDetected(&pmotor->faultDetect);
009688  200011     MOV #0x1, W1
00968A  A31802     BTST.Z W2, #1
00968C  3A0005     BRA NZ, .L8
00968E  9298C0     MOV [W0+696], W1
009690  A7F001     BTSC W1, #15
009692  EA0081     NEG W1, W1
009694  EA0081     NEG W1, W1
009696  DE08CF     LSR W1, #15, W1
105:                   }
106:                   
107:                   return failure;
108:               }
00969A  060000     RETURN
00969C  500FE2     SUB W0, #0x2, [W15]
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcapi_internal.h
1:                 /**
2:                  * mcapi_internal.h
3:                  * 
4:                  * Internal/private interfaces used by MCAPI to interact with MCAF
5:                  * 
6:                  * Component: MCAPI
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __MCAPI_INTERNAL_H
48:                #define __MCAPI_INTERNAL_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                #include "mcapi_types.h"
53:                #include "system_state.h"
54:                #include "foc.h"
55:                #include "util.h"
56:                #include "state_machine.h"
57:                #include "sat_PI.h"
58:                #include "adc_compensation.h"
59:                #include "ui.h"
60:                #include "ui_types.h"
61:                #include "fault_detect.h"
62:                #include "error_codes.h"
63:                #include "filter.h"
64:                #include "parameters/mcapi_params.h"
65:                
66:                #ifdef __cplusplus
67:                extern "C" {
68:                #endif
69:                
70:                /**
71:                 * Private function to clear the specified fault flags
72:                 * @param pMotor motor data
73:                 */
74:                inline static void handleFaultFlags(MCAF_MOTOR_DATA *pMotor)
75:                {
76:                    volatile MCAPI_MOTOR_DATA *pApiData = &pMotor->apiData;
77:                    const uint16_t faultsToClear = pApiData->faultClearFlags;
000A12  231621     MOV #0x3162, W1
78:                    pApiData->faultFlags = UTIL_ClearBits(pApiData->faultFlags, faultsToClear);
000A14  231600     MOV #0x3160, W0
000A18  610810     AND W2, [W0], [W0]
79:                    pApiData->faultClearFlags = 0;
000A1A  EB0880     CLR [W1]
80:                }
81:                
82:                /**
83:                 * private function to handle all fault conditions in MCAF
84:                 * @param pMotor motor data
85:                 */
86:                inline static void handleFaults(MCAF_MOTOR_DATA *pMotor)
87:                {
88:                    volatile MCAPI_MOTOR_DATA *pApiData = &pMotor->apiData;
89:                    const uint16_t errorCode = MCAF_UiGetErrorCode(&pMotor->ui.indicatorState);
90:                
91:                    /* Read all active fault flags from MCAF */
92:                    if (MCAF_IsOvercurrentFlagSet(&pMotor->faultDetect))
0009D4  A32801     BTST.Z W1, #2
0009D6  320002     BRA Z, .L4
93:                    {
94:                        pApiData->faultFlags = UTIL_SetBits(pApiData->faultFlags,
0009D8  231602     MOV #0x3160, W2
0009DA  A00012     BSET [W2], #0
95:                                                            MCAPI_FAULT_FLAG_OVERCURRENT);
96:                    }
97:                    if (MCAF_IsUndervoltageFlagSet(&pMotor->faultDetect))
0009DC  A31801     BTST.Z W1, #1
0009DE  320002     BRA Z, .L5
98:                    {
99:                        pApiData->faultFlags = UTIL_SetBits(pApiData->faultFlags,
0009E0  231602     MOV #0x3160, W2
0009E2  A01012     BSET [W2], #1
100:                                                           MCAPI_FAULT_FLAG_UNDERVOLTAGE);
101:                   }
102:                   if (MCAF_IsOvervoltageFlagSet(&pMotor->faultDetect))
0009E4  A30801     BTST.Z W1, #0
0009E6  320002     BRA Z, .L6
103:                   {
104:                       pApiData->faultFlags = UTIL_SetBits(pApiData->faultFlags,
0009E8  231602     MOV #0x3160, W2
0009EA  A02012     BSET [W2], #2
105:                                                           MCAPI_FAULT_FLAG_OVERVOLTAGE);
106:                   }
107:                   if (MCAF_IsOvertemperatureFlagSet(&pMotor->faultDetect))
0009EC  A33801     BTST.Z W1, #3
0009EE  320002     BRA Z, .L7
108:                   {
109:                       pApiData->faultFlags = UTIL_SetBits(pApiData->faultFlags,
0009F0  231601     MOV #0x3160, W1
0009F2  A03011     BSET [W1], #3
110:                                                           MCAPI_FAULT_FLAG_OVERTEMPERATURE);
111:                   }
112:                   if (MCAF_UiIsError(&pMotor->ui.indicatorState))
0009F4  22FFB1     MOV #0x2FFB, W1
0009F6  E00411     CP0.B [W1]
0009F8  32000C     BRA Z, handleFaultFlags
113:                   {
114:                       /* check for any fault other than over-current, 
115:                        * over-voltage, under-voltage, and overtemperature faults */
116:                       if ((errorCode != ERR_NO_ERROR)&&
0009FA  E00000     CP0 W0
0009FC  32000A     BRA Z, handleFaultFlags
0009FE  500FF2     SUB W0, #0x12, [W15]
000A00  320008     BRA Z, handleFaultFlags
117:                           (errorCode != ERR_HW_OVERCURRENT)&&
000A02  500FF3     SUB W0, #0x13, [W15]
000A04  320006     BRA Z, handleFaultFlags
118:                           (errorCode != ERR_DCLINK_OVERVOLTAGE)&&
000A06  500FF4     SUB W0, #0x14, [W15]
000A08  320004     BRA Z, handleFaultFlags
119:                           (errorCode != ERR_DCLINK_UNDERVOLTAGE)&&
000A0A  500FF5     SUB W0, #0x15, [W15]
000A0C  320002     BRA Z, handleFaultFlags
120:                           (errorCode != ERR_OVERTEMPERATURE))
121:                       {
122:                           pApiData->faultFlags = UTIL_SetBits(pApiData->faultFlags,
000A0E  231600     MOV #0x3160, W0
000A10  A04010     BSET [W0], #4
123:                                                               MCAPI_FAULT_FLAG_MOTOR_DRIVE);
124:                       }
125:                   }    
126:                   
127:                   /* Handle faults that are currently active and request MCAF to
128:                    * exit its fault state if there are no active fault flags */
129:                   handleFaultFlags(pMotor);
130:                   if (pApiData->faultFlags == MCAPI_FAULT_FLAG_NO_FAULT)
000A1C  E00010     CP0 [W0]
000A1E  3A0003     BRA NZ, handleUI
131:                   {
132:                       MCAF_UiExitFaultState(&pMotor->ui);
133:                   }
134:               }
135:               
136:               /**
137:                * Ensure that the speed is limited to at least velocityMinimum in magnitude
138:                * @param pApiData MCAPI data
139:                * @return speed limited to at least the specified minimum magnitude
140:                */
141:               inline static MCAF_U_VELOCITY_MECH MCAF_private_limit_speed_command(const volatile MCAPI_MOTOR_DATA *pApiData)
142:               {
143:                   const MCAF_U_VELOCITY_MECH velocityReference = pApiData->velocityReference;
000A62  780090     MOV [W0], W1
144:                   MCAF_U_VELOCITY_MECH velocityCmd = 
145:                               UTIL_LimitMinimumS16(UTIL_Abs16(velocityReference),
000A64  818A92     MOV 0x3152, W2
146:                                                    pApiData->velocityMinimum);
147:                   if (velocityReference < 0)
000A76  E00001     CP0 W1
000A78  3D0001     BRA GE, .LBE410, .LBE411, .L14
148:                       velocityCmd = -velocityCmd;
000A7A  EA0000     NEG W0, W0
149:                   return velocityCmd;
150:               }
151:               
152:               /**
153:                * Private function that handles the User Interface related interactions 
154:                * between MCAF and MC API, which are motor start/stop and velocity reference.
155:                * @param pMotor motor data
156:                */
157:               inline static void handleUI(MCAF_MOTOR_DATA *pMotor)
158:               {
159:                   volatile MCAPI_MOTOR_DATA *pApiData = &pMotor->apiData;
160:                   
161:                   /* handle start/stop motor requests from the API */
162:                   if (pApiData->runMotorRequest)
000A26  231490     MOV #0x3149, W0
000A28  E00410     CP0.B [W0]
000A2A  320005     BRA Z, .L10
163:                   {
164:                       pMotor->ui.run = true;
000A2C  B3C011     MOV.B #0x1, W1
000A2E  22FEC0     MOV #0x2FEC, W0
000A30  784801     MOV.B W1, [W0]
165:                       pApiData->runMotorRequest = false;
000A32  231490     MOV #0x3149, W0
000A34  EB4800     CLR.B [W0]
166:                   }
167:                   if (pApiData->stopMotorRequest)
000A36  2314A0     MOV #0x314A, W0
000A38  E00410     CP0.B [W0]
000A3A  320005     BRA Z, .L11
168:                   {
169:                       pMotor->ui.run = false;
000A3C  EB4000     CLR.B W0
000A3E  22FEC1     MOV #0x2FEC, W1
000A40  784880     MOV.B W0, [W1]
170:                       pApiData->stopMotorRequest = false;
000A42  2314A1     MOV #0x314A, W1
000A44  784880     MOV.B W0, [W1]
171:                   }
172:                   
173:                   if (pApiData->velocityReferencePrevious != pApiData->velocityReference)
000A46  818A61     MOV 0x314C, W1
000A48  818A70     MOV 0x314E, W0
000A4A  508F80     SUB W1, W0, [W15]
000A4C  320007     BRA Z, .L12
174:                   {
175:                       /* determine if the direction of velocity reference changed */
176:                       if (!UTIL_BothNegativeOrNonnegative(pApiData->velocityReferencePrevious,
000A4E  818A70     MOV 0x314E, W0
000A50  818A61     MOV 0x314C, W1
000A54  3B0003     BRA NN, .L12
177:                                                          pApiData->velocityReference))
178:                       {
179:                           pMotor->ui.flags ^= MCAF_UI_REVERSE;
000A56  22FEE0     MOV #0x2FEE, W0
000A58  A24010     BTG [W0], #4
180:                           pMotor->ui.flags |= MCAF_UI_DIRECTION_CHANGED;
000A5A  A05010     BSET [W0], #5
181:                       }
182:                   }
183:                   pApiData->velocityReferencePrevious = pApiData->velocityReference;
000A5C  2314E0     MOV #0x314E, W0
000A5E  780310     MOV [W0], W6
000A60  898A66     MOV W6, 0x314C
184:                   
185:                   pMotor->velocityControl.velocityCmdApi = MCAF_private_limit_speed_command(pApiData);
000A7C  897B90     MOV W0, 0x2F72
186:               }
187:               
188:               /**
189:                * Private function that reads motor status from MCAF and 
190:                * returns an abstracted MCAPI_MOTOR_STATE type of status value.
191:                * @param pMotormotor data
192:                * @return abstracted motor status
193:                */
194:               inline static MCAPI_MOTOR_STATE determineMotorStatus(MCAF_MOTOR_DATA *pMotor)
195:               {
196:                   switch (pMotor->state)
000A7E  817F41     MOV 0x2FE8, W1
000A82  508F80     SUB W1, W0, [W15]
000A84  32001A     BRA Z, .LBE416, .L18
000A86  3E000D     BRA GTU, .L25
000A8A  508F80     SUB W1, W0, [W15]
000A8C  320016     BRA Z, .LBE416, .L18
000A90  508FE1     SUB W1, #0x1, [W15]
000A92  390013     BRA NC, .LBE416, .L18
000A96  508F80     SUB W1, W0, [W15]
000A98  320010     BRA Z, .LBE416, .L18
000A9C  508F80     SUB W1, W0, [W15]
000A9E  3A000C     BRA NZ, .L15
000AA0  37000C     BRA .LBE416, .L18
000AA4  508F80     SUB W1, W0, [W15]
000AA6  320009     BRA Z, .LBE416, .L18
000AAA  508FE6     SUB W1, #0x6, [W15]
000AAC  390006     BRA NC, .LBE416, .L18
000AB0  508FE7     SUB W1, #0x7, [W15]
000AB2  320003     BRA Z, .LBE416, .L18
000AB4  508FE8     SUB W1, #0x8, [W15]
000AB6  320001     BRA Z, .LBE416, .L18
197:                   {
198:                       case MCSM_STOPPED: 
199:                           return MCAPI_MOTOR_STOPPED;
000A88  200010     MOV #0x1, W0
200:                           
201:                       case MCSM_STARTING:
202:                           return MCAPI_MOTOR_STARTING;
000A94  200020     MOV #0x2, W0
203:                           
204:                       case MCSM_RUNNING:
205:                           return MCAPI_MOTOR_RUNNING;
000A9A  200030     MOV #0x3, W0
206:                           
207:                       case MCSM_STOPPING:
208:                           return MCAPI_MOTOR_STOPPING;
000A80  200040     MOV #0x4, W0
209:                           
210:                       case MCSM_RESTART:
211:                           return MCAPI_MOTOR_STOPPING;
000A8E  200040     MOV #0x4, W0
212:                           
213:                       case MCSM_FAULT:
214:                           return MCAPI_MOTOR_FAULT;
000AA8  200050     MOV #0x5, W0
215:                           
216:                       case MCSM_TEST_DISABLE:
217:                           return MCAPI_MOTOR_DIAGSTATE;
000AA2  200060     MOV #0x6, W0
218:                           
219:                       case MCSM_TEST_ENABLE:
220:                           return MCAPI_MOTOR_DIAGSTATE;
000AAE  200060     MOV #0x6, W0
221:                           
222:                       case MCSM_TEST_RESTART:
223:                           return MCAPI_MOTOR_DIAGSTATE;
224:                           
225:                       default:
226:                           return MCAPI_MOTOR_DIAGSTATE;
000AB8  200060     MOV #0x6, W0
227:                   }
228:               }
229:               
230:               /**
231:                * Private function that updates the operating parameters of motor
232:                * @param pMotor motor data
233:                */
234:               inline static void updateMotorOperatingParameters(MCAF_MOTOR_DATA *pMotor)
235:               {
236:                   volatile MCAPI_MOTOR_DATA *pApiData = &pMotor->apiData;
237:                   
238:                   pApiData->currentLimitIqLower = MCAF_CurrentLimitIqLowerGet(pMotor);
000ABC  817B80     MOV 0x2F70, W0
000ABE  898AF0     MOV W0, 0x315E
239:                   pApiData->currentLimitIqUpper = MCAF_CurrentLimitIqUpperGet(pMotor);
000AC0  817B71     MOV 0x2F6E, W1
000AC2  898AE1     MOV W1, 0x315C
240:                   pApiData->dcLinkVoltage = MCAF_GetDcLinkVoltage(pMotor);
000AC4  818BF4     MOV 0x317E, W4
000AC6  898AD4     MOV W4, 0x315A
241:                   pApiData->iqFiltered = pMotor->apiFeedback.iqFiltered;
000AC8  818B45     MOV 0x3168, W5
000ACA  898AC5     MOV W5, 0x3158
242:                   pApiData->isMagSquaredFiltered = pMotor->apiFeedback.isSquaredFiltered;
000ACC  818B66     MOV 0x316C, W6
000ACE  898AB6     MOV W6, 0x3156
243:                   pApiData->velocityMeasured = pMotor->omegaElectrical;
000AD0  817770     MOV 0x2EEE, W0
000AD2  898A80     MOV W0, 0x3150
244:               }
245:               
246:               /**
247:                * Executes one step of the MCAPI interaction with MCAF state data.
248:                * This function is NOT intended to be called by the application.
249:                * @param pMotor pointer to motor data structure
250:                */
251:               static inline void MCAF_ApiServiceIsr(MCAF_MOTOR_DATA *pMotor)
252:               {
253:                   volatile MCAPI_MOTOR_DATA *pApiData = &pMotor->apiData;
254:                   if (!pApiData->apiBusy)
0009CA  231480     MOV #0x3148, W0
0009CC  E00410     CP0.B [W0]
0009CE  3A0082     BRA NZ, _ADCAN15Interrupt::MCAF_TestHarnessStepIsr
255:                   {
256:                       handleFaults(pMotor);
257:                       handleUI(pMotor);
258:                       pApiData->motorStatus = determineMotorStatus(pMotor);
000ABA  898B20     MOV W0, 0x3164
259:                       updateMotorOperatingParameters(pMotor);
260:                   }
261:               }
262:               
263:               /**
264:                * Weak definition of Prolog ADC ISR user function
265:                * that can be used for purposes such as functional safety.
266:                */
267:               void __attribute__((weak)) MCAPI_AdcIsrProlog(void);
268:               
269:               /**
270:                * Weak definition of Epilog ADC ISR user function
271:                * that can be used for purposes such as functional safety.
272:                */
273:               void __attribute__((weak)) MCAPI_AdcIsrEpilog(void);
274:               
275:               /**
276:                * Initializes the filter state variables used for calculating
277:                * filtered values of motor currents for MCAPI usage.
278:                * @param pmotor motor data
279:                */
280:               inline static void MCAF_InitializeCurrentFilter(MCAF_MOTOR_DATA *pmotor)
281:               {
282:                   MCAF_LpfFilterInitx16(&pmotor->apiFeedback.isSquaredFiltState);
283:                   MCAF_LpfFilterInitx16(&pmotor->apiFeedback.iqFiltState);
284:                   pmotor->apiFeedback.isSquared = 0;
007CCA  9B3459     MOV W9, [W8+874]
285:                   pmotor->apiFeedback.isSquaredFiltered = 0;
007CCC  9B3469     MOV W9, [W8+876]
286:                   pmotor->apiFeedback.iqFiltered = 0;
007CCE  9B3449     MOV W9, [W8+872]
287:                   pmotor->apiFeedback.isSquaredFiltState.coeff = KFILTER_IS_SQUARED;
007CD0  206660     MOV #0x666, W0
007CD2  9B3C30     MOV W0, [W8+886]
288:                   pmotor->apiFeedback.iqFiltState.coeff = KFILTER_IQ;
007CD4  9B3470     MOV W0, [W8+878]
289:               }
290:               
291:               /**
292:                * Executes one step of the filter routines that are used to calculate
293:                * filtered values of motor currents for MCAPI usage.
294:                * @param pmotor motor data
295:                */
296:               inline static void MCAF_CalculateFilteredCurrent(MCAF_MOTOR_DATA *pmotor)
297:               {
298:                   MCAPI_FEEDBACK_SIGNALS *pApiFeedback = &pmotor->apiFeedback;
299:                   
300:                   pApiFeedback->iqFiltered = MCAF_LpfFilterx16(&pApiFeedback->iqFiltState,
000988  898B40     MOV W0, 0x3168
301:                                                                   pmotor->idq.q);
302:                   pApiFeedback->isSquared = UTIL_SignedSqr(pmotor->idq.q) + 
0009A4  410100     ADD W2, W0, W2
0009A6  898B52     MOV W2, 0x316A
303:                                                   UTIL_SignedSqr(pmotor->idq.d);
000996  8170C4     MOV 0x2E18, W4
304:                   pApiFeedback->isSquaredFiltered = MCAF_LpfFilterx16(&pApiFeedback->isSquaredFiltState,
0009C8  898B60     MOV W0, 0x316C
305:                                                                       pApiFeedback->isSquared);
306:               }
307:               
308:               #ifdef __cplusplus
309:               }
310:               #endif
311:               
312:               #endif /* __MCAPI_INTERNAL_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcapi.h
1:                 /**
2:                  * mcapi.h
3:                  * 
4:                  * Provides APIs that can be used by an application to control the motor.
5:                  * 
6:                  * Component: MCAPI
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __MCAPI_H
48:                #define __MCAPI_H
49:                
50:                #include <stdint.h>
51:                #include <stdbool.h>
52:                #include "mcapi_types.h"
53:                #include "math_asm.h"
54:                #include "util.h"
55:                #include "parameters/mcapi_params.h"
56:                
57:                #ifdef __cplusplus
58:                extern "C" {
59:                #endif
60:                
61:                /**
62:                 * Initializes MCAPI internal state data.
63:                 * This function should be called once before calling any of the MCAPI
64:                 * functions for the first time.
65:                 * @param pMotor
66:                 */
67:                static inline void MCAPI_Initialize(volatile MCAPI_MOTOR_DATA *pMotor)
68:                {
69:                   pMotor->apiBusy = false; 
00808C  231480     MOV #0x3148, W0
00808E  EB4800     CLR.B [W0]
70:                   pMotor->appFaultCode = 0;
008090  EB0080     CLR W1
008092  898B31     MOV W1, 0x3166
71:                   pMotor->currentLimitIqLower = 0; 
008094  898AF1     MOV W1, 0x315E
72:                   pMotor->currentLimitIqUpper = 0; 
008096  898AE1     MOV W1, 0x315C
73:                   pMotor->dcLinkVoltage = 0; 
008098  898AD1     MOV W1, 0x315A
74:                   pMotor->faultClearFlags = MCAPI_FAULT_FLAG_NO_FAULT; 
00809A  898B11     MOV W1, 0x3162
75:                   pMotor->faultFlags = MCAPI_FAULT_FLAG_NO_FAULT; 
00809C  898B01     MOV W1, 0x3160
76:                   pMotor->iqFiltered = 0; 
00809E  898AC1     MOV W1, 0x3158
77:                   pMotor->isMagSquaredFiltered = 0; 
0080A0  898AB1     MOV W1, 0x3156
78:                   pMotor->motorStatus = MCAPI_MOTOR_STOPPED; 
0080A2  200012     MOV #0x1, W2
0080A4  898B22     MOV W2, 0x3164
79:                   pMotor->runMotorRequest = false; 
0080A6  231492     MOV #0x3149, W2
0080A8  784901     MOV.B W1, [W2]
80:                   pMotor->stopMotorRequest = false; 
0080AA  2314A2     MOV #0x314A, W2
0080AC  784901     MOV.B W1, [W2]
81:                   pMotor->velocityMeasured = 0; 
0080AE  898A81     MOV W1, 0x3150
82:                   pMotor->velocityMinimum = MCAPI_MINIMUM_VELOCITY;
0080B0  231521     MOV #0x3152, W1
0080B2  215552     MOV #0x1555, W2
0080B4  780882     MOV W2, [W1]
83:                   pMotor->velocityMaximum = MCAPI_MAXIMUM_VELOCITY;
0080B6  25F932     MOV #0x5F93, W2
0080B8  898AA2     MOV W2, 0x3154
84:                   pMotor->velocityReference = pMotor->velocityMinimum;
0080BA  780111     MOV [W1], W2
0080BC  898A72     MOV W2, 0x314E
85:                   pMotor->velocityReferencePrevious = pMotor->velocityMinimum;
0080BE  780091     MOV [W1], W1
0080C0  898A61     MOV W1, 0x314C
86:                }
87:                    
88:                /**
89:                 * Starts the specified motor. There will be no change if the motor is already 
90:                 * running. If there is an active MCAF fault, this function will have no effect.
91:                 * @param pMotor
92:                 */
93:                static inline void MCAPI_MotorStart(volatile MCAPI_MOTOR_DATA *pMotor)
94:                {
95:                    pMotor->apiBusy = true;
007FA4  B3C010     MOV.B #0x1, W0
007FA6  784C80     MOV.B W0, [W9]
96:                    pMotor->runMotorRequest = true;
007FA8  984490     MOV.B W0, [W9+1]
97:                    pMotor->apiBusy = false;
007FAA  EB4C80     CLR.B [W9]
98:                }
99:                
100:               /**
101:                * Stops the specified motor. There will be no change if the motor is already 
102:                * in fault, stopped or stopping states.
103:                * @param pMotor
104:                */
105:               static inline void MCAPI_MotorStop(volatile MCAPI_MOTOR_DATA *pMotor)
106:               {
107:                   pMotor->apiBusy = true;
007FAE  B3C010     MOV.B #0x1, W0
007FB0  784C80     MOV.B W0, [W9]
108:                   pMotor->stopMotorRequest = true;
007FB2  9844A0     MOV.B W0, [W9+2]
109:                   pMotor->apiBusy = false;
007FB4  EB4C80     CLR.B [W9]
110:               }
111:               
112:               /**
113:                * Uses the specified value to update velocity reference for the specified motor. 
114:                * Sign of the input value will determine the direction of rotation of the motor. 
115:                * Changes in velocity command when the motor is not in running state will be 
116:                * saved and will take effect only when the motor reaches this state.
117:                * Before this function is called for the first time after initialization, the 
118:                * set value of velocity reference is either zero, or equal to the minimum 
119:                * value of velocity reference specified by MCAPI_VelocityReferenceMinimumGet()
120:                * @param pMotor
121:                * @param velocity reference value, signed Q15 with the scaling factor 
122:                * specified by MCAPI_FullscaleVelocityGet()
123:                */
124:               static inline void MCAPI_VelocityReferenceSet(volatile MCAPI_MOTOR_DATA *pMotor, int16_t velocity)
125:               {
126:                   pMotor->apiBusy = true;
007F62  B3C010     MOV.B #0x1, W0
007F64  784C80     MOV.B W0, [W9]
127:                   pMotor->velocityReference = velocity;
007F66  9804B2     MOV W2, [W9+6]
128:                   pMotor->apiBusy = false;
007F68  EB4C80     CLR.B [W9]
129:               }
130:               
131:               /**
132:                * Returns velocity reference value for the specified motor. 
133:                * The return value will exactly match the set value set by the "set velocity" 
134:                * function.
135:                * Before the "set velocity" function is called for the first time after 
136:                * initialization, the return value of velocity reference is either zero, or 
137:                * equal to the minimum value of velocity reference specified 
138:                * by MCAPI_VelocityReferenceMinimumGet()
139:                * @param pMotor
140:                * @return velocity reference for the specified motor, signed Q15 with the 
141:                * scaling factor specified by MCAPI_FullscaleVelocityGet()
142:                */
143:               static inline int16_t MCAPI_VelocityReferenceGet(volatile MCAPI_MOTOR_DATA *pMotor)
144:               {
145:                   pMotor->apiBusy = true;
146:                   int16_t velocityReference = pMotor->velocityReference;
147:                   pMotor->apiBusy = false;
148:                   return velocityReference;
149:               }
150:               
151:               /**
152:                * Returns velocity of the specified motor as measured by an estimator in MCAF.
153:                * Sign of the input value will determine the direction of rotation of the motor.
154:                * @param pMotor
155:                * @return measured motor velocity, signed Q15 with the scaling factor 
156:                * specified by MCAPI_FullscaleVelocityGet()
157:                */
158:               static inline int16_t MCAPI_VelocityMeasuredGet(volatile MCAPI_MOTOR_DATA *pMotor)
159:               {
160:                   pMotor->apiBusy = true;
161:                   int16_t velocityMeasured = pMotor->velocityMeasured;
162:                   pMotor->apiBusy = false;
163:                   return velocityMeasured;
164:               }
165:               
166:               /**
167:                * Returns a value that represents the amplitude of current in the 
168:                * specified motor, that is sqrt(Id*Id + Iq*Iq).
169:                * Since this value is derived from a square root operation, this function
170:                * will require additional CPU cycles to execute when compared to other
171:                * getter functions in MCAPI.
172:                * Since this value is derived from signals with low pass filtering, this is 
173:                * not an instantaneous value and will have some delay when compared to the 
174:                * actual current in the motor.
175:                * @param pMotor
176:                * @return current amplitude in the motor, signed Q15 with the scaling factor 
177:                * specified by MCAPI_FullscaleCurrentGet()
178:                */
179:               static inline int16_t MCAPI_CurrentMagnitudeGet(volatile MCAPI_MOTOR_DATA *pMotor)
180:               {
181:                   pMotor->apiBusy = true;
182:                   int16_t isMagSquaredFiltered = pMotor->isMagSquaredFiltered;
183:                   pMotor->apiBusy = false;
184:                   return Q15SQRT(isMagSquaredFiltered);
185:               }
186:               
187:               /**
188:                * Returns a bit-field with individual flags for each fault type for the 
189:                * specified motor.
190:                * @param pMotor
191:                * @return fault flags
192:                */
193:               static inline uint16_t MCAPI_FaultStatusGet(volatile MCAPI_MOTOR_DATA *pMotor)
194:               {
195:                   pMotor->apiBusy = true;
007FB8  B3C011     MOV.B #0x1, W1
007FBA  784C81     MOV.B W1, [W9]
196:                   uint16_t faultFlags = pMotor->faultFlags;
007FBC  900949     MOV [W9+24], W2
197:                   pMotor->apiBusy = false;
007FBE  EB4000     CLR.B W0
007FC0  784C80     MOV.B W0, [W9]
198:                   return faultFlags;
199:               }
200:               
201:               /**
202:                * Clears the specified fault flags for a specified motor. This function does 
203:                * not implicitly start the motor after clearing one or more active faults.
204:                * @param pMotor
205:                * @param mask bit mask with desired fault flags to be cleared set to 1
206:                */
207:               static inline void MCAPI_FaultStatusClear(volatile MCAPI_MOTOR_DATA *pMotor, 
208:                                                         uint16_t mask)
209:               {
210:                   pMotor->apiBusy = true;
007FC2  784C81     MOV.B W1, [W9]
211:                   pMotor->faultClearFlags = UTIL_SetBits(pMotor->faultClearFlags, mask);
007FC4  9008D9     MOV [W9+26], W1
007FC8  980CD1     MOV W1, [W9+26]
212:                   pMotor->apiBusy = false;
007FCA  784C80     MOV.B W0, [W9]
213:               }
214:               
215:               /**
216:                * Gets status of the specified motor.
217:                * @param pMotor
218:                * @return state value that categorizes the motor operation status
219:                */
220:               static inline MCAPI_MOTOR_STATE MCAPI_OperatingStatusGet(volatile MCAPI_MOTOR_DATA *pMotor)
221:               {
222:                   pMotor->apiBusy = true;
007F84  B3C010     MOV.B #0x1, W0
007F86  784C80     MOV.B W0, [W9]
223:                   uint16_t motorStatus = pMotor->motorStatus;
007F88  900869     MOV [W9+28], W0
224:                   pMotor->apiBusy = false;
007F8A  EB4C80     CLR.B [W9]
225:                   return motorStatus;
226:               }
227:               
228:               /**
229:                * Returns a value that represents the measured q-axis current in the 
230:                * specified motor. 
231:                * Since this value is derived from signals with low pass filtering, this 
232:                * is not an instantaneous value and will have some delay compared to the 
233:                * actual current in the motor.
234:                * @param pMotor
235:                * @return q-axis current, signed Q15 with the scaling factor 
236:                * specified by MCAPI_FullscaleCurrentGet()
237:                */
238:               static inline int16_t MCAPI_CurrentIqGet(volatile MCAPI_MOTOR_DATA *pMotor)
239:               {
240:                   pMotor->apiBusy = true;
241:                   int16_t iqFiltered = pMotor->iqFiltered;
242:                   pMotor->apiBusy = false;
243:                   return iqFiltered;
244:               }
245:               
246:               /**
247:                * Returns the full-scale value of current used by MCAF for the specified 
248:                * motor, as a floating-point number.
249:                * @param pMotor
250:                * @return full-scale value of current in Amperes
251:                */
252:               static inline float MCAPI_FullscaleCurrentGet(const volatile MCAPI_MOTOR_DATA *pMotor)
253:               {
254:                   return MCAPI_FULLSCALE_CURRENT;
255:               }
256:               
257:               /**
258:                * Returns the full-scale value of voltage used by MCAF for the specified 
259:                * motor, as a floating-point number.
260:                * @param pMotor
261:                * @return full-scale value of voltage in Volts
262:                */
263:               static inline float MCAPI_FullscaleVoltageGet(const volatile MCAPI_MOTOR_DATA *pMotor)
264:               {
265:                   return MCAPI_FULLSCALE_VOLTAGE;
266:               }
267:               
268:               /**
269:                * Returns the full-scale value of electromagnetic torque used by MCAF for 
270:                * the specified motor, as a floating-point number.
271:                * Factors such as reluctance torque, iron saturation and changes in magnet 
272:                * flux due to temperature can impact the accuracy of this scaling factor. Hence,
273:                * this is to be consumed by the application on a "for indication only" basis.
274:                * @param pMotor
275:                * @return full-scale value of torque in Nm
276:                */
277:               static inline float MCAPI_FullscaleTorqueGet(const volatile MCAPI_MOTOR_DATA *pMotor)
278:               {
279:                   return MCAPI_FULLSCALE_TORQUE;
280:               }
281:               
282:               /**
283:                * Returns the full-scale value of velocity used by MCAF for the specified 
284:                * motor, as a floating-point number.
285:                * @param pMotor
286:                * @return full-scale value of velocity in RPM
287:                */
288:               static inline float MCAPI_FullscaleVelocityGet(const volatile MCAPI_MOTOR_DATA *pMotor)
289:               {
290:                   return MCAPI_FULLSCALE_VELOCITY;
291:               }
292:               
293:               /**
294:                * Returns a value of DC link voltage in the sytem as measured by MCAF.
295:                * @param pMotor
296:                * @return measured value of DC link voltage, signed Q15 with the scaling factor 
297:                * specified by MCAPI_FullscaleVoltageGet()
298:                */
299:               static inline int16_t MCAPI_VoltageDclinkGet(volatile MCAPI_MOTOR_DATA *pMotor)
300:               {
301:                   pMotor->apiBusy = true;
302:                   int16_t dcLinkVoltage = pMotor->dcLinkVoltage;
303:                   pMotor->apiBusy = false;
304:                   return dcLinkVoltage;
305:               }
306:               
307:               /**
308:                * Returns a value that represents upper bound of the current limit that 
309:                * is implemented in MCAF.
310:                * This function does not synchronize its output with its counterpart function
311:                * that gets the lower bound of current limit. So, while calling these two 
312:                * functions right after one another, there will always be some skew in the instance 
313:                * of time when the current limit pair value are acquired.
314:                * @param pMotor
315:                * @return upper bound of current limit, signed Q15 with the scaling factor 
316:                * specified by MCAPI_FullscaleCurrentGet()
317:                */
318:               static inline int16_t MCAPI_CurrentLimitIqUpperGet(volatile MCAPI_MOTOR_DATA *pMotor)
319:               {
320:                   pMotor->apiBusy = true;
321:                   int16_t currentLimitIqUpper = pMotor->currentLimitIqUpper;
322:                   pMotor->apiBusy = false;
323:                   return currentLimitIqUpper;
324:               }
325:               
326:               /**
327:                * Returns a value that represents lower bound of the current limit that 
328:                * is implemented in MCAF.
329:                * This function does not synchronize its output with its counterpart function
330:                * that gets the upper bound of current limit. So, while calling these two 
331:                * functions right after one another, there will always be some skew in the instance 
332:                * of time when the current limit pair value are acquired.
333:                * @param pMotor
334:                * @return lower bound of current limit, signed Q15 with the scaling factor 
335:                * specified by MCAPI_FullscaleCurrentGet()
336:                */
337:               static inline int16_t MCAPI_CurrentLimitIqLowerGet(volatile MCAPI_MOTOR_DATA *pMotor)
338:               {
339:                   pMotor->apiBusy = true;
340:                   int16_t currentLimitIqLower = pMotor->currentLimitIqLower;
341:                   pMotor->apiBusy = false;
342:                   return currentLimitIqLower;
343:               }
344:               
345:               /**
346:                * Gets the minimum value of velocity reference that is currently supported
347:                * in the given configuration of MCAF.
348:                * @param pMotor
349:                * @return minimum value of velocity reference, signed Q15 with the scaling factor 
350:                * specified by MCAPI_FullscaleVelocityGet()
351:                */
352:               static inline int16_t MCAPI_VelocityReferenceMinimumGet(volatile MCAPI_MOTOR_DATA *pMotor)
353:               {
354:                   pMotor->apiBusy = true;
009286  784802     MOV.B W2, [W0]
009294  784802     MOV.B W2, [W0]
355:                   int16_t velocityMinimum = pMotor->velocityMinimum;
009288  900250     MOV [W0+10], W4
009296  900250     MOV [W0+10], W4
356:                   pMotor->apiBusy = false;
00928A  EB4180     CLR.B W3
00928C  784803     MOV.B W3, [W0]
009298  784803     MOV.B W3, [W0]
357:                   return velocityMinimum;
358:               }
359:               
360:               /**
361:                * Gets the maximum value of velocity command that is currently supported
362:                * in the given configuration of MCAF.
363:                * @param pMotor
364:                * @return maximum value of velocity command, signed Q15 with the scaling factor 
365:                * specified by MCAPI_FullscaleVelocityGet()
366:                */
367:               static inline int16_t MCAPI_VelocityReferenceMaximumGet(volatile MCAPI_MOTOR_DATA *pMotor)
368:               {
369:                   pMotor->apiBusy = true;
00929C  784802     MOV.B W2, [W0]
370:                   int16_t velocityMaximum = pMotor->velocityMaximum;
00929E  900160     MOV [W0+12], W2
371:                   pMotor->apiBusy = false;
0092A0  784803     MOV.B W3, [W0]
372:                   return velocityMaximum;
373:               }
374:               
375:               /**
376:                * Gets an application-level fault code, or ERR_NO_ERROR = 0 if no error.
377:                * 
378:                * @param pMotor
379:                * @return application-level fault code
380:                */
381:               static inline uint16_t MCAPI_ApplicationFaultCodeGet(volatile MCAPI_MOTOR_DATA *pMotor)
382:               {
383:                   return pMotor->appFaultCode;
0049D4  933038     MOV [W8+870], W0
004A02  9330B8     MOV [W8+870], W1
004AEE  9330B8     MOV [W8+870], W1
384:               }
385:               
386:               /**
387:                * Sets an application-level fault code
388:                * 
389:                * @param pMotor
390:                * @param faultcode application-level fault code
391:                */
392:               static inline void MCAPI_ApplicationFaultCodeSet(volatile MCAPI_MOTOR_DATA *pMotor, uint16_t faultCode)
393:               {
394:                   pMotor->appFaultCode = faultCode;
395:               }
396:               
397:               #ifdef __cplusplus
398:               }
399:               #endif
400:               
401:               #endif /* __MCAPI_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcapi.c
1:                 /**
2:                  * mcapi.c
3:                  * 
4:                  * Provides APIs that can be used by an application to control the motor.
5:                  * 
6:                  * Component: MCAPI
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 * 
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stddef.h>
48:                #include <stdbool.h>
49:                #include "mcapi.h"
50:                
51:                
52:                /**
53:                 * Weak definition of Prolog ADC ISR user function
54:                 * that can be used for purposes such as functional safety.
55:                 */
56:                void __attribute__((weak)) MCAPI_AdcIsrProlog(void)
57:                {
58:                    
59:                }
60:                
61:                /**
62:                 * Weak definition of Epilog ADC ISR user function
63:                 * that can be used for purposes such as functional safety.
64:                 */
65:                void __attribute__((weak)) MCAPI_AdcIsrEpilog(void)
66:                {
67:                    
68:                }
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcaf_watchdog.h
1:                 /**
2:                  * mcaf_watchdog.h
3:                  * 
4:                  * Functions for handling watchdog timer.
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __WATCHDOG_H
48:                #define __WATCHDOG_H
49:                
50:                #include <stdint.h>
51:                #include "hal.h"
52:                
53:                #ifdef  __cplusplus
54:                extern "C" {
55:                #endif
56:                
57:                enum 
58:                {
59:                    /** Threshold for main-loop timeout, in terms of ISR cycles. */
60:                    MCAF_WATCHDOG_MAINLOOP_TIMEOUT = 10000
61:                };
62:                    
63:                /**
64:                 * Watchdog state
65:                 */
66:                typedef struct tagWatchdog
67:                {
68:                    uint16_t isrCount; /** count of ISRs */
69:                } MCAF_WATCHDOG_T;
70:                
71:                /**
72:                 * Manages the watchdog in the main loop.
73:                 * 
74:                 * @param pwatchdog watchdog state
75:                 */
76:                inline static void MCAF_WatchdogManageMainLoop(volatile MCAF_WATCHDOG_T *pwatchdog)
77:                {
78:                    pwatchdog->isrCount = 0;
00808A  EF325C     CLR watchdog
00916C  EF325C     CLR watchdog
79:                }
80:                
81:                /**
82:                 * Care for the watchdog.
83:                 */
84:                inline static void MCAF_CareForWatchdog(void)
85:                {
86:                    HAL_WATCHDOG_Timer_Clear();
87:                }
88:                
89:                /**
90:                 * Manages the watchdog in the ISR.
91:                 * 
92:                 * @param pwatchdog watchdog state
93:                 */
94:                inline static void MCAF_WatchdogManageIsr(volatile MCAF_WATCHDOG_T *pwatchdog)
95:                {
96:                    if (pwatchdog->isrCount < MCAF_WATCHDOG_MAINLOOP_TIMEOUT)
000958  2270F0     MOV #0x270F, W0
00095A  E3125C     CP watchdog
00095C  3E0003     BRA GTU, .LBE364, .LBE366, .LBE367, .LBE368, .L2
97:                    {
98:                        ++pwatchdog->isrCount;
00095E  EC325C     INC watchdog
99:                        MCAF_CareForWatchdog();
100:                   }
101:               }
102:               
103:               #ifdef  __cplusplus
104:               }
105:               #endif
106:               
107:               #endif  /* __WATCHDOG_H */
108:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcaf_traps.c
1:                 /**
2:                  * mcaf_traps.c
3:                  * 
4:                  * Trap handlers
5:                  * 
6:                  * See DS70600C for more information on the non-maskable traps.
7:                  * 
8:                  * Component: main application
9:                  */
10:                
11:                /* *********************************************************************
12:                 * 
13:                 * Motor Control Application Framework
14:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
15:                 *
16:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
17:                 * this software and any derivatives exclusively with Microchip products.
18:                 *
19:                 * This software and any accompanying information is for suggestion only.
20:                 * It does not modify Microchip's standard warranty for its products.
21:                 * You agree that you are solely responsible for testing the software and
22:                 * determining its suitability.  Microchip has no obligation to modify,
23:                 * test, certify, or support the software.
24:                 *
25:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
26:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
27:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
28:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
29:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
30:                 * APPLICATION.
31:                 *
32:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
33:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
34:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
35:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
36:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
37:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
38:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
40:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
41:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
42:                 * SOFTWARE.
43:                 *
44:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
45:                 * THESE TERMS.
46:                 *
47:                 * *****************************************************************************/
48:                
49:                #include <xc.h>
50:                #include <stdint.h>
51:                #include "ui.h"
52:                #include "error_codes.h"
53:                #include "mcaf_watchdog.h"
54:                #include "hal.h"
55:                
56:                /**
57:                 * a private place to store the error code if we run into a severe error
58:                 */
59:                static volatile uint16_t error_code = -1;
60:                
61:                /** Global instance of watchdog data -- persistent so we can
62:                 * distinguish main-loop failure and ISR failure
63:                 */
64:                volatile MCAF_WATCHDOG_T watchdog __attribute__((persistent, section("MCAF_persistent")));
65:                
66:                /**
67:                 * Halts and displays an error code
68:                 * 
69:                 * @param code error code
70:                 */
71:                void __attribute__((naked, noreturn)) halt_on_error(uint16_t code)
72:                {
73:                    error_code = code;
009EB0  8892F0     MOV W0, 0x125E
009EB2  DA4000     BREAK
74:                #ifdef __DEBUG    
75:                    __builtin_software_breakpoint();
76:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
77:                #endif
78:                
79:                    MCAF_UiFlashErrorCodeForever(code);
009EB4  07F4D0     RCALL MCAF_UiFlashErrorCodeForever
80:                }
81:                
82:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
83:                #define ERROR_HANDLER_NORETURN ERROR_HANDLER __attribute__((noreturn))
84:                
85:                inline static uint16_t translate_error_code(uint16_t mcc_code)
86:                {
87:                    switch (mcc_code)
008FFE  500F81     SUB W0, W1, [W15]
009000  320012     BRA Z, .LBE8, .L15
009002  3E0007     BRA GTU, .L20
009006  E00000     CP0 W0
009008  32000E     BRA Z, .LBE8, .L15
00900C  500FE1     SUB W0, #0x1, [W15]
00900E  3A000A     BRA NZ, .L13
009010  37000A     BRA .LBE8, .L15
009014  500FE7     SUB W0, #0x7, [W15]
009016  320007     BRA Z, .LBE8, .L15
00901A  500FEA     SUB W0, #0xA, [W15]
00901C  320004     BRA Z, .LBE8, .L15
009020  500FE3     SUB W0, #0x3, [W15]
009022  320001     BRA Z, .LBE8, .L15
88:                    {
89:                        case TRAPS_OSC_FAIL:
90:                            return ERR_OSC_FAIL;
009004  200011     MOV #0x1, W1
91:                        case TRAPS_STACK_ERR:
92:                            return ERR_STACK_ERROR;
00900A  200041     MOV #0x4, W1
93:                        case TRAPS_ADDRESS_ERR:
94:                            return ERR_ADDRESS_ERROR;
008FFC  200021     MOV #0x2, W1
95:                        case TRAPS_MATH_ERR:
96:                            return ERR_MATH;
00901E  200051     MOV #0x5, W1
97:                        case TRAPS_HARD_ERR:
98:                            return ERR_HARD_TRAP;
009012  200031     MOV #0x3, W1
99:                        case TRAPS_DOOVR_ERR:
100:                           return ERR_SOFT_TRAP;
009018  200071     MOV #0x7, W1
101:                       default:
102:                           return ERR_UNEXPECTED_TRAP;
009024  200FF1     MOV #0xFF, W1
103:                   }
104:               }
105:               
106:               /** Reserved trap error */
107:               void ERROR_HANDLER_NORETURN _ReservedTrap7(void) { halt_on_error(ERR_RESERVED_TRAP7); }
00091A  F80036     PUSH RCOUNT
00091C  200080     MOV #0x8, W0
00091E  074AC8     RCALL halt_on_error
108:               
109:               /** 
110:                * Reports unexpected interrupt, by displaying error vector number.
111:                */
112:               void ERROR_HANDLER_NORETURN _DefaultInterrupt(void) {
000920  F80036     PUSH RCOUNT
113:                   halt_on_error(ERR_UNEXPECTED_INTERRUPT_BASE + HAL_InterruptVector_Get());
000926  B01000     ADD #0x100, W0
000928  074AC3     RCALL halt_on_error
00092A  F80036     PUSH RCOUNT
00092C  BE9F80     MOV.D W0, [W15++]
00092E  BE9F82     MOV.D W2, [W15++]
000930  BE9F84     MOV.D W4, [W15++]
000932  BE9F86     MOV.D W6, [W15++]
000934  BE9F88     MOV.D W8, [W15++]
000936  F80032     PUSH DSRPAG
000938  F80034     PUSH DSWPAG
00093A  200010     MOV #0x1, W0
00093C  8801A0     MOV W0, DSWPAG
00093E  202000     MOV #0x200, W0
000940  FED000     MOVPAG W0, DSRPAG
114:               }
115:               
116:               void MCAF_CheckResetCause(void)
117:               {
118:                   const uint16_t rconcopy = RCON;
009252  807C01     MOV RCON, W1
119:                   uint16_t errorCode = 0;
120:                   if (rconcopy & 0x8000) /* TRAPR */
009254  E00001     CP0 W1
009256  35000F     BRA LT, .L7
121:                   {
122:                       errorCode = MCAF_ERR_RCON_TRAPR;
009276  200200     MOV #0x20, W0
123:                   }
124:                   else if (rconcopy & 0x4000) /* IOPUWR */
00925A  A3E801     BTST.Z W1, #14
00925C  3A000D     BRA NZ, .L5
125:                   {
126:                       errorCode = MCAF_ERR_RCON_IOPUWR;    
009258  200210     MOV #0x21, W0
127:                   }
128:                   else if (rconcopy & 0x0200) /* CM */
009260  A39801     BTST.Z W1, #9
009262  3A000A     BRA NZ, .L5
129:                   {
130:                       errorCode = MCAF_ERR_RCON_CM;    
00925E  200220     MOV #0x22, W0
131:                   }
132:                   else if (rconcopy & 0x0010) /* WDTO */
009264  A34801     BTST.Z W1, #4
009266  32000A     BRA Z, .L6
133:                   {
134:                       if (watchdog.isrCount < MCAF_WATCHDOG_MAINLOOP_TIMEOUT)
00926A  2270F1     MOV #0x270F, W1
00926C  8092E2     MOV watchdog, W2
00926E  510F81     SUB W2, W1, [W15]
009270  3E0003     BRA GTU, .L5
135:                       {
136:                           errorCode = MCAF_ERR_RCON_WDTO_ISR;    
009272  200230     MOV #0x23, W0
009274  370001     BRA .L5
137:                       }
138:                       else
139:                       {
140:                           errorCode = ERR_RCON_WDTO_MAINLOOP;
009268  200240     MOV #0x24, W0
141:                       }
142:                   }
143:                   RCON = 0;    // clear RCON bits so that at next reset they will be accurate
009278  EF2F80     CLR RCON
00927C  EF2F80     CLR RCON
144:                   
145:                   if (errorCode != 0)
146:                   {
147:                       MCAF_UiFlashErrorCodeForever(errorCode);
00927A  07FAED     RCALL MCAF_UiFlashErrorCodeForever
148:                   }            
149:               }
00927E  060000     RETURN
009280  89B9D0     MOV W0, 0x373A
150:               
151:               /**
152:                * Error handler for traps
153:                * This overrides MCC's error handler (which has a "weak" attribute)
154:                */
155:               void __attribute__((naked)) TRAPS_halt_on_error(uint16_t code)
156:               {
157:                   if (code == TRAPS_STACK_ERR)
008FF4  500FE1     SUB W0, #0x1, [W15]
008FF6  3A0002     BRA NZ, TRAPS_halt_on_error::translate_error_code
158:                       halt_on_error(ERR_STACK_ERROR);
008FF8  200040     MOV #0x4, W0
008FFA  07075A     RCALL halt_on_error
159:               #ifdef __dsPIC33E__
160:                   if (code == TRAPS_DMAC_ERR)
161:                   {
162:                       if (HAL_DMA_ErrorHandler())
163:                       {
164:                           return; //we can recover, no need to halt
165:                       }
166:                   }
167:               #endif
168:                   halt_on_error(translate_error_code(code));
009026  780001     MOV W1, W0
009028  070743     RCALL halt_on_error
00902A  500FE2     SUB W0, #0x2, [W15]
00902C  32000B     BRA Z, .L37
00902E  500FE4     SUB W0, #0x4, [W15]
009030  320010     BRA Z, .L38
009032  500FE1     SUB W0, #0x1, [W15]
009034  3A0014     BRA NZ, .L34
169:               }
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcaf_sample_application.c
1:                 /**
2:                  * mcaf_sample_application.c
3:                  *
4:                  * Sample application for MCAF
5:                  * 
6:                  * Component: main application
7:                  */
8:                 /*
9:                  *
10:                 * Motor Control Application Framework
11:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
12:                 *
13:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
14:                 * this software and any derivatives exclusively with Microchip products.
15:                 *
16:                 * This software and any accompanying information is for suggestion only.
17:                 * It does not modify Microchip's standard warranty for its products.
18:                 * You agree that you are solely responsible for testing the software and
19:                 * determining its suitability.  Microchip has no obligation to modify,
20:                 * test, certify, or support the software.
21:                 *
22:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
23:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
24:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
25:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
26:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
27:                 * APPLICATION.
28:                 *
29:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
30:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
31:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
32:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
33:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
34:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
35:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
37:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
38:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
39:                 * SOFTWARE.
40:                 *
41:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
42:                 * THESE TERMS.
43:                 *
44:                 *
45:                 ******************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include <stdbool.h>
49:                #include "mcapi.h"
50:                #include "mcaf_sample_application.h"
51:                #include "util.h"
52:                #include "board_service.h"
53:                #include "hal/hardware_access_functions.h"
54:                
55:                APPLICATION_DATA app;
56:                void APP_TimerCallback(void);
57:                
58:                /**
59:                 * Determines the appropriate velocity command for a given input of unipolar
60:                 * speed reference.
61:                 * @param app application state data
62:                 * @param rawUnipolarValue unipolar speed reference input
63:                 * @return velocity command
64:                 */
65:                inline static int16_t APP_DetermineVelocityCommand(APPLICATION_DATA *app, uint16_t rawUnipolarValue)
66:                {
67:                    int16_t velocityRange = app->motorVelocityCommandMaximum - app->motorVelocityCommandMinimum;
007F54  900238     MOV [W8+6], W4
007F56  9000A8     MOV [W8+4], W1
007F58  520201     SUB W4, W1, W4
68:                    int16_t unsignedSpeed = 
007F5C  408105     ADD W1, W5, W2
69:                              (UTIL_mulus(rawUnipolarValue, velocityRange) >> 16)
70:                              + app->motorVelocityCommandMinimum;
71:                    return unsignedSpeed*app->motorDirection;
007F5E  B99198     MULW.SS W2, [W8], W2
72:                }
73:                
74:                void APP_ApplicationInitialize(volatile MCAPI_MOTOR_DATA *apiData, MCAF_BOARD_DATA *pboard)
75:                {
76:                    APPLICATION_DATA *appData = &app;
77:                    
78:                    appData->apiData = apiData;
009280  89B9D0     MOV W0, 0x373A
79:                    appData->motorDirection = 1;
009282  200012     MOV #0x1, W2
009284  89B982     MOV W2, app
80:                    appData->motorVelocityCommand = MCAPI_VelocityReferenceMinimumGet(apiData);
00928E  89B994     MOV W4, 0x3732
81:                    appData->hardwareUiEnabled = true;
009290  237384     MOV #0x3738, W4
009292  784A02     MOV.B W2, [W4]
82:                    appData->motorVelocityCommandMinimum = MCAPI_VelocityReferenceMinimumGet(apiData);
00929A  89B9A4     MOV W4, 0x3734
83:                    appData->motorVelocityCommandMaximum = MCAPI_VelocityReferenceMaximumGet(apiData);
0092A2  89B9B2     MOV W2, 0x3736
84:                    appData->pboard = pboard;
0092A4  89B9E1     MOV W1, 0x373C
85:                    HAL_TMR_TICK_SetCallbackFunction(APP_TimerCallback);
86:                }
0092AA  060000     RETURN
87:                
88:                void APP_ApplicationStep(APPLICATION_DATA *appData)
89:                {
007F40  BE9F88     MOV.D W8, [W15++]
007F42  781F8A     MOV W10, [W15++]
007F44  780400     MOV W0, W8
90:                    volatile MCAPI_MOTOR_DATA *apiData = appData->apiData;
007F46  9004D8     MOV [W8+10], W9
91:                    MCAF_BOARD_DATA *pboard = appData->pboard;
007F48  900568     MOV [W8+12], W10
92:                
93:                    if (appData->hardwareUiEnabled)
007F4A  904808     MOV.B [W8+8], W0
007F4C  E00400     CP0.B W0
007F4E  32003E     BRA Z, .LBE58, .LBE68, .LBE75, .LBE78, .L2
94:                    {
95:                        /* Use potentiometer to set motor velocity command */
96:                        int16_t potentiometerValue = MCAF_BoardServicePotentiometerValue(pboard);
97:                        appData->motorVelocityCommand = APP_DetermineVelocityCommand(appData, 
007F60  980412     MOV W2, [W8+2]
98:                                                                                     potentiometerValue);
99:                        MCAPI_VelocityReferenceSet(apiData, appData->motorVelocityCommand);
100:                       
101:                       /* Button2 toggles motor direction */
102:                       if (MCAF_ButtonGp2_EventGet(pboard))
007F6A  78000A     MOV W10, W0
007F6C  070FF6     RCALL MCAF_ButtonGp2_EventGet
007F6E  E00400     CP0.B W0
007F70  320003     BRA Z, .L4
103:                       {
104:                           MCAF_ButtonGp2_EventClear(pboard);
007F72  78000A     MOV W10, W0
007F74  070FA3     RCALL MCAF_ButtonGp2_EventClear
105:                           appData->motorDirection = appData->motorDirection * -1;
007F76  EA0C18     NEG [W8], [W8]
106:                       }
107:                       
108:                       /* Button1 toggles motor state + clears motor fault
109:                        * by reading MCAF state and implementing a simple UI logic:
110:                        * if motor is stopping or stopped, start it
111:                        * if motor is starting or running, stop it
112:                        * if motor is in a fault, clear it
113:                        * if motor is in a test state, do nothing
114:                        *  */
115:                       if (MCAF_ButtonGp1_EventGet(pboard))
007F78  78000A     MOV W10, W0
007F7A  070FED     RCALL MCAF_ButtonGp1_EventGet
007F7C  E00400     CP0.B W0
007F7E  320026     BRA Z, .LBE58, .LBE68, .LBE75, .LBE78, .L2
116:                       {
117:                           MCAF_ButtonGp1_EventClear(pboard);
007F80  78000A     MOV W10, W0
007F82  070F99     RCALL MCAF_ButtonGp1_EventClear
118:                           
119:                           MCAPI_MOTOR_STATE motorState = MCAPI_OperatingStatusGet(apiData);
120:                           switch (motorState)
007F8C  500FE3     SUB W0, #0x3, [W15]
007F8E  3E0005     BRA GTU, .L8
007F90  500FE2     SUB W0, #0x2, [W15]
007F92  31000D     BRA C, MCAPI_MotorStop
007F94  500FE1     SUB W0, #0x1, [W15]
007F96  3A001A     BRA NZ, .LBE58, .LBE68, .LBE75, .LBE78, .L2
007F98  370005     BRA MCAPI_MotorStart
007F9A  500FE4     SUB W0, #0x4, [W15]
007F9C  320003     BRA Z, MCAPI_MotorStart
007F9E  500FE5     SUB W0, #0x5, [W15]
007FA0  3A0015     BRA NZ, .LBE58, .LBE68, .LBE75, .LBE78, .L2
007FA2  37000A     BRA MCAPI_FaultStatusGet
121:                           {
122:                               case MCAPI_MOTOR_STOPPED:
123:                               case MCAPI_MOTOR_STOPPING:
124:                               {
125:                                   MCAPI_MotorStart(apiData);
126:                                   break;
007FAC  37000F     BRA .LBE58, .LBE68, .LBE75, .LBE78, .L2
127:                               }
128:               
129:                               case MCAPI_MOTOR_STARTING:
130:                               case MCAPI_MOTOR_RUNNING:
131:                               {
132:                                   MCAPI_MotorStop(apiData);
133:                                   break;
007FB6  37000A     BRA .LBE58, .LBE68, .LBE75, .LBE78, .L2
134:                               }
135:               
136:                               case MCAPI_MOTOR_FAULT:
137:                               {
138:                                   uint16_t faultFlags = MCAPI_FaultStatusGet(apiData);
139:                                   MCAPI_FaultStatusClear(apiData, faultFlags);
140:                                   break;
141:                               }
142:               
143:                               case MCAPI_MOTOR_DIAGSTATE:
144:                               {
145:                                   /* do nothing */
146:                                   break;
147:                               }
148:                           }
149:                       }        
150:                   }
151:               }
007FCC  78054F     MOV [--W15], W10
007FCE  BE044F     MOV.D [--W15], W8
007FD0  060000     RETURN
007FD2  9040F0     MOV.B [W0+7], W1
152:               
153:               /**
154:                * This is an application owned timer the user is responsible for configuring. 
155:                * The application timer period needs to match the value set in motorBench Customize page.
156:                */
157:               void APP_TimerCallback(void)
158:               {
159:                   MCAF_BoardServiceTasks(app.pboard);
009D84  81B9E0     MOV 0x373C, W0
009D86  07FC55     RCALL MCAF_BoardServiceTasks
160:                   APP_ApplicationStep(&app);
009D88  237300     MOV #0x3730, W0
009D8A  07F0DA     RCALL APP_ApplicationStep
161:               }
009D8C  060000     RETURN
009D8E  259C31     MOV #0x59C3, W1
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/mcaf_main.c
1:                 /**
2:                  * mcaf_main.c
3:                  *
4:                  * Main program entry point
5:                  * 
6:                  * Component: main application
7:                  */
8:                 /*
9:                  *
10:                 * Motor Control Application Framework
11:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
12:                 *
13:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
14:                 * this software and any derivatives exclusively with Microchip products.
15:                 *
16:                 * This software and any accompanying information is for suggestion only.
17:                 * It does not modify Microchip's standard warranty for its products.
18:                 * You agree that you are solely responsible for testing the software and
19:                 * determining its suitability.  Microchip has no obligation to modify,
20:                 * test, certify, or support the software.
21:                 *
22:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
23:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
24:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
25:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
26:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
27:                 * APPLICATION.
28:                 *
29:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
30:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
31:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
32:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
33:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
34:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
35:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
37:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
38:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
39:                 * SOFTWARE.
40:                 *
41:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
42:                 * THESE TERMS.
43:                 *
44:                 *
45:                 ******************************************************************************/
46:                
47:                #include <stdbool.h>
48:                #include "board_service.h"
49:                #include "hal.h"
50:                #include "system_state.h"
51:                #include "state_machine.h"
52:                #include "system_init.h"
53:                #include "foc.h"
54:                #include "diagnostics.h"
55:                #include "monitor.h"
56:                #include "stall_detect.h"
57:                #include "recover.h"
58:                #include "mcaf_watchdog.h"
59:                #include "mcaf_traps.h"
60:                #include "ui.h"
61:                #include "parameters/init_params.h"
62:                #include "mcaf_main.h"
63:                #include "test_harness.h"
64:                #include "fault_detect.h"
65:                #include "mcapi.h"
66:                #include "mcaf_sample_application.h"
67:                
68:                /** Global instance of the main set of motor state variables */
69:                MCAF_MOTOR_DATA motor;
70:                /** Global instance of the main set of system state variables */
71:                MCAF_SYSTEM_DATA systemData;
72:                
73:                extern volatile MCAF_WATCHDOG_T watchdog;
74:                
75:                bool MCAF_MainInit(void)
76:                {
00805A  781F88     MOV W8, [W15++]
77:                    MCAF_SystemStateInit(&motor, &systemData);
00805C  231841     MOV #0x3184, W1
00805E  22E000     MOV #0x2E00, W0
008060  070F7E     RCALL MCAF_SystemStateInit
78:                    MCAF_SystemInit(&systemData);
008062  231840     MOV #0x3184, W0
008064  0700BE     RCALL MCAF_SystemInit
79:                    MCAF_BoardServiceInit(&systemData.board);
008066  231900     MOV #0x3190, W0
008068  070BA3     RCALL MCAF_BoardServiceInit
80:                    MCAF_UiInit(&motor.ui);
00806A  22FEC0     MOV #0x2FEC, W0
00806C  070A16     RCALL MCAF_UiInit
81:                    MCAF_MonitorInit(&motor.monitor);
00806E  230C60     MOV #0x30C6, W0
008070  070F19     RCALL MCAF_MonitorInit
82:                #if MCAF_INCLUDE_STALL_DETECT  
83:                    MCAF_StallDetectInit(&motor.stallDetect);
008072  230000     MOV #0x3000, W0
008074  07085E     RCALL MCAF_StallDetectInit
84:                #endif
85:                    MCAF_FaultDetectInit(&motor.faultDetect);
008076  230B20     MOV #0x30B2, W0
008078  070D12     RCALL MCAF_FaultDetectInit
86:                    MCAF_RecoveryInit(&motor.recovery);
00807A  230BA0     MOV #0x30BA, W0
00807C  070DE8     RCALL MCAF_RecoveryInit
87:                    MCAF_SystemStateMachine_Init(&motor);
00807E  22E000     MOV #0x2E00, W0
008080  07FC97     RCALL MCAF_SystemStateMachine_Init
88:                    MCAF_SystemTestHarness_Init(&systemData.testing);
008082  2318A0     MOV #0x318A, W0
008084  070EB6     RCALL MCAF_SystemTestHarness_Init
89:                    
90:                    /* Check reset cause and act upon it, prior to clearing the watchdog,
91:                     * (see notes in declaration of MCAF_CheckResetCause)
92:                     */
93:                    MCAF_CheckResetCause();
008086  0708E5     RCALL MCAF_CheckResetCause
94:                    HAL_WATCHDOG_Timer_Enable();
95:                    MCAF_WatchdogManageMainLoop(&watchdog);
96:                    
97:                    MCAPI_Initialize(&motor.apiData);
98:                    
99:                    /* Ideally, MCAF has nothing to do with the application and hence this
100:                      function should be called from the main() in main.c */
101:                   APP_ApplicationInitialize(&motor.apiData, &systemData.board);
0080C2  231901     MOV #0x3190, W1
0080C4  0708DD     RCALL APP_ApplicationInitialize
102:                   
103:                   MCAF_InitControlParameters_Motor1(&motor);
0080C6  22E000     MOV #0x2E00, W0
0080C8  0702CF     RCALL MCAF_InitControlParameters_Motor1
104:                   
105:                   bool success = MCAF_FocInit(&motor);
0080CA  22E000     MOV #0x2E00, W0
0080CC  07FDBA     RCALL MCAF_FocInit
0080CE  784400     MOV.B W0, W8
106:                   if (success)
0080D0  E00408     CP0.B W8
0080D2  320003     BRA Z, .LBE37, .L2
107:                   {
108:                       MCAF_SystemStart(&systemData);
0080D4  231840     MOV #0x3184, W0
0080D6  070675     RCALL MCAF_SystemStart
109:               
110:                       /* Ideally, MCAF has nothing to do with the application timer and hence this
111:                          function should be called from the main() in main.c */
112:                       HAL_TMR_TICK_Start();
113:                   }
114:                   return success;
115:               }
0080DA  784008     MOV.B W8, W0
0080DC  78044F     MOV [--W15], W8
0080DE  060000     RETURN
116:               
117:               void MCAF_MainLoop(void)
118:               {
119:                   /* State variables are fine to access w/o volatile qualifier for ISR
120:                    * (since no interruptions)
121:                    * but in main loop, the ISR may interrupt + we need to assume volatile.
122:                    */
123:                   volatile MCAF_MOTOR_DATA *pmotor = &motor;
124:                   volatile MCAF_SYSTEM_DATA *psystemData = &systemData;
125:                   volatile MCAF_WATCHDOG_T *pwatchdog = &watchdog;
126:                   
127:                   MCAF_UiStepMain(&pmotor->ui);
009164  22FEC0     MOV #0x2FEC, W0
128:                   MCAF_SystemStateMachine_StepMain(pmotor);
009168  22E000     MOV #0x2E00, W0
00916A  07F972     RCALL MCAF_SystemStateMachine_StepMain
129:                   MCAF_WatchdogManageMainLoop(pwatchdog);
130:                   MCAF_TestHarnessStepMain(&psystemData->testing);
131:                   MCAF_DiagnosticsStepMain();
009188  0706E2     RCALL MCAF_DiagnosticsStepMain
132:               }
00918A  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/math_asm.s
                                                  1:     ; math_asm.s
                                                  2:     ;
                                                  3:     ; Math routines (sqrt)
                                                  4:     ;
                                                  5:     ; Component: miscellaneous
                                                  6:     ;
                                                  7:     ; ******************************************************************************
                                                  8:     ; (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use
                                                  9:     ; this software and any derivatives exclusively with Microchip products.
                                                  10:    ; 
                                                  11:    ; This software and any accompanying information is for suggestion only.
                                                  12:    ; It does not modify Microchip's standard warranty for its products.
                                                  13:    ; You agree that you are solely responsible for testing the software and
                                                  14:    ; determining its suitability.  Microchip has no obligation to modify,
                                                  15:    ; test, certify, or support the software.
                                                  16:    ; 
                                                  17:    ; THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
                                                  18:    ; WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
                                                  19:    ; INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
                                                  20:    ; AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
                                                  21:    ; MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
                                                  22:    ; APPLICATION.
                                                  23:    ; 
                                                  24:    ; IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
                                                  25:    ; PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
                                                  26:    ; ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
                                                  27:    ; motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
                                                  28:    ; HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
                                                  29:    ; CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
                                                  30:    ; POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
                                                  31:    ; FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
                                                  32:    ; CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
                                                  33:    ; OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
                                                  34:    ; SOFTWARE.
                                                  35:    ; 
                                                  36:    ; MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
                                                  37:    ; THESE TERMS.
                                                  38:    ;
                                                  39:    ; ******************************************************************************
                                                  40:    
                                                  41:    
                                                  42:              .global   _Q15SQRT
                                                  43:              .global   Q15SQRT
                                                  44:    
                                                  45:    _Q15SQRT:
                                                  46:    Q15SQRT:
007E18  780380     MOV W0, W7                     47:                 mov.w w0,w7             
007E1A  EB0000     CLR W0                         48:                 clr.w w0                
007E1C  E60017     CPBGT.W W0, W7, 0x7E20         49:                 cpsgt.w w0,w7           
007E1E  000000     NOP                            50:                 nop
007E20  000000     NOP                            51:                 nop
007E22  000000     NOP                            52:                 nop
007E24  BE9F88     MOV.D W8, [W15++]              53:                 mov.d w8,[w15++]        
007E26  CF8187     FF1L W7, W3                    54:                 ff1l w7,w3            
007E28  5180E2     SUB W3, #0x2, W1               55:                 sub.w w3,#2,w1          
007E2A  DD3901     SL W7, W1, W2                  56:                 sl w7,w1,w2             
007E2C  280000     MOV #0x8000, W0                57:                 mov.w #0x8000,w0        
007E2E  510280     SUB W2, W0, W5                 58:                 sub.w w2,w0,w5          
007E30  780205     MOV W5, W4                     59:                 mov.w w5,w4             
007E32  DD2AC1     SL W5, #1, W5                  60:                 sl w5,#1,w5             
007E34  240006     MOV #0x4000, W6                61:                 mov.w #0x4000,w6        
007E36  B9A306     MUL.SS W4, W6, W6              62:                 mul.ss w4,w6,w6         
007E38  B9A405     MUL.SS W4, W5, W8              63:                 mul.ss w4,w5,w8         
007E3A  2F0000     MOV #0xF000, W0                64:                 mov.w #0xf000,w0        
007E3C  B98109     MUL.SS W0, W9, W2              65:                 mul.ss w0,w9,w2         
007E3E  410306     ADD W2, W6, W6                 66:                 add.w w2,w6,w6          
007E40  498387     ADDC W3, W7, W7                67:                 addc.w w3,w7,w7         
007E42  B9CC05     MUL.SS W9, W5, W8              68:                 mul.ss w9,w5,w8         
007E44  208000     MOV #0x800, W0                 69:                 mov.w #0x800,w0         
007E46  B98109     MUL.SS W0, W9, W2              70:                 mul.ss w0,w9,w2         
007E48  410306     ADD W2, W6, W6                 71:                 add.w w2,w6,w6          
007E4A  498387     ADDC W3, W7, W7                72:                 addc.w w3,w7,w7         
007E4C  B9CC05     MUL.SS W9, W5, W8              73:                 mul.ss w9,w5,w8         
007E4E  2FB000     MOV #0xFB00, W0                74:                 mov.w #0xfb00,w0        
007E50  B98109     MUL.SS W0, W9, W2              75:                 mul.ss w0,w9,w2         
007E52  410306     ADD W2, W6, W6                 76:                 add.w w2,w6,w6          
007E54  498387     ADDC W3, W7, W7                77:                 addc.w w3,w7,w7         
007E56  B9CC05     MUL.SS W9, W5, W8              78:                 mul.ss w9,w5,w8         
007E58  203800     MOV #0x380, W0                 79:                 mov.w #0x380,w0         
007E5A  B98109     MUL.SS W0, W9, W2              80:                 mul.ss w0,w9,w2         
007E5C  410306     ADD W2, W6, W6                 81:                 add.w w2,w6,w6          
007E5E  498387     ADDC W3, W7, W7                82:                 addc.w w3,w7,w7         
007E60  B9CC05     MUL.SS W9, W5, W8              83:                 mul.ss w9,w5,w8         
007E62  2FD600     MOV #0xFD60, W0                84:                 mov.w #0xfd60,w0        
007E64  B98109     MUL.SS W0, W9, W2              85:                 mul.ss w0,w9,w2         
007E66  410306     ADD W2, W6, W6                 86:                 add.w w2,w6,w6          
007E68  498387     ADDC W3, W7, W7                87:                 addc.w w3,w7,w7         
007E6A  B9CC05     MUL.SS W9, W5, W8              88:                 mul.ss w9,w5,w8         
007E6C  202100     MOV #0x210, W0                 89:                 mov.w #0x210,w0         
007E6E  B98109     MUL.SS W0, W9, W2              90:                 mul.ss w0,w9,w2         
007E70  410306     ADD W2, W6, W6                 91:                 add.w w2,w6,w6          
007E72  498387     ADDC W3, W7, W7                92:                 addc.w w3,w7,w7         
007E74  B9CC05     MUL.SS W9, W5, W8              93:                 mul.ss w9,w5,w8         
007E76  2FE530     MOV #0xFE53, W0                94:                 mov.w #0xfe53,w0        
007E78  B98109     MUL.SS W0, W9, W2              95:                 mul.ss w0,w9,w2         
007E7A  410306     ADD W2, W6, W6                 96:                 add.w w2,w6,w6          
007E7C  498387     ADDC W3, W7, W7                97:                 addc.w w3,w7,w7         
007E7E  DE334F     LSR W6, #15, W6                98:                 lsr w6,#15,w6           
007E80  DD3841     SL W7, #1, W0                  99:                 sl w7,#1,w0             
007E82  730300     IOR W6, W0, W6                 100:                ior.w w6,w0,w6          
007E84  DEBBCF     ASR W7, #15, W7                101:                asr w7,#15,w7           
007E86  280000     MOV #0x8000, W0                102:                mov.w #0x8000,w0        
007E88  400306     ADD W0, W6, W6                 103:                add.w w0,w6,w6          
007E8A  4B83E0     ADDC W7, #0x0, W7              104:                addc.w w7,#0,w7         
007E8C  DE0941     LSR W1, #1, W2                 105:                lsr w1,#1,w2            
007E8E  110070     SUBR W2, #0x10, W0             106:                subr.w w2,#16,w0        
007E90  DE3302     LSR W6, W2, W6                 107:                lsr w6,w2,w6            
007E92  DD3800     SL W7, W0, W0                  108:                sl w7,w0,w0             
007E94  730300     IOR W6, W0, W6                 109:                ior.w w6,w0,w6          
007E96  DEBB82     ASR W7, W2, W7                 110:                asr w7,w2,w7            
007E98  A30001     BTST.C W1, #0                  111:                btst.c w1,#0            
007E9A  390005     BRA NC, 0x7EA6                 112:                bra nc, Sqrt_else       
007E9C  25A824     MOV #0x5A82, W4                113:                mov.w #0x5a82,w4        
007E9E  B9B004     MUL.SS W6, W4, W0              114:                mul.ss w6,w4,w0         
007EA0  DE004F     LSR W0, #15, W0                115:                lsr w0,#15,w0           
007EA2  DD08C1     SL W1, #1, W1                  116:                sl w1,#1,w1             
007EA4  700301     IOR W0, W1, W6                 117:                ior.w w0,w1,w6          
007EA6  780006     MOV W6, W0                     118:   Sqrt_else:   mov.w w6,w0             
007EA8  BE044F     MOV.D [--W15], W8              119:                mov.d [--w15],w8        
007EAA  060000     RETURN                         120:                return 
                                                  121:                
                                                  122:                
                                                  123:             .end
                                                  124:   
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/library/mc-library/motor_control_util.h
1:                 /* 
2:                  * File:   motor_control_util.h
3:                  * 
4:                  * Utility routines for computation used only in Motor control library
5:                  * 
6:                  */
7:                 
8:                 /* *********************************************************************
9:                  *
10:                 * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use
11:                 * this software and any derivatives exclusively with Microchip products.
12:                 *
13:                 * This software and any accompanying information is for suggestion only.
14:                 * It does not modify Microchip's standard warranty for its products.
15:                 * You agree that you are solely responsible for testing the software and
16:                 * determining its suitability.  Microchip has no obligation to modify,
17:                 * test, certify, or support the software.
18:                 
19:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
20:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
21:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
22:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
23:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
24:                 * APPLICATION.
25:                 
26:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
27:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
28:                 * ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
29:                 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
30:                 * FORESEEABLE.  TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
31:                 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT
32:                 * EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO
33:                 * MICROCHIP FOR THIS SOFTWARE.
34:                 
35:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
36:                 * THESE TERMS.
37:                 *
38:                 * *****************************************************************************/
39:                
40:                #ifndef _MOTOR_CONTROL_UTIL_H_
41:                #define	_MOTOR_CONTROL_UTIL_H_
42:                
43:                #include <stdint.h>
44:                
45:                // Declarations for DSP registers
46:                #include "motor_control_dsp.h"    
47:                
48:                /*
49:                 * Access to accumulator registers is required
50:                 * only for XC16 1.25 and earlier; this causes
51:                 * a dependency on <xc.h> which is unnecessary
52:                 * for newer versions of the compiler.
53:                 */
54:                #if __XC16_VERSION__ < 1026
55:                #include <xc.h>
56:                #endif
57:                
58:                
59:                #ifdef	__cplusplus
60:                extern "C" {
61:                #endif
62:                
63:                
64:                /**
65:                 * Helper function to multiply an unsigned 16-bit quantity
66:                 * and a signed 16-bit quantity and shift-right by 16.
67:                 * (one of the inputs should be a Q16 fixed-point values,
68:                 * and the other one and the output have identical binary points,
69:                 * e.g. Q12 = Q16 * Q12, or Q12 = Q12 * Q16)
70:                 *
71:                 * @param a first input (unsigned)
72:                 * @param b second input (signed)
73:                 * @return (a*b)>>16
74:                 */
75:                inline static int16_t MC_UTIL_mulus16(uint16_t a, int16_t b)
76:                {
77:                    return __builtin_mulus(a,b) >> 16;
006992  2DDB44     MOV #0xDDB4, W4
006994  B8A203     MUL.US W4, W3, W4
006A86  2AAAA2     MOV #0xAAAA, W2
006A88  B89106     MUL.US W2, W6, W2
006A8A  255556     MOV #0x5555, W6
006A8C  B8B501     MUL.US W6, W1, W10
006A8E  B8B300     MUL.US W6, W0, W6
006A90  780203     MOV W3, W4
006A98  293CD4     MOV #0x93CD, W4
006A9A  B8A301     MUL.US W4, W1, W6
006A9C  B8A200     MUL.US W4, W0, W4
78:                }
79:                
80:                /**
81:                 * Compute the average of two int16_t values
82:                 * @param a first value
83:                 * @param b second value
84:                 * @return (a+b)/2
85:                 */
86:                
87:                inline static int16_t MC_UTIL_AverageS16(int16_t a, int16_t b)
88:                {
89:                    return (int16_t)((((int32_t)a) + b) >> 1);
000020  000920     NOP
0069E2  B90961     MUL.SU W1, #0x1, W2
0069E4  DE82CF     ASR W0, #15, W5
0069E6  400002     ADD W0, W2, W0
0069E8  4A8083     ADDC W5, W3, W1
0069EA  D18081     ASR W1, W1
0069EC  D38000     RRC W0, W0
90:                }
91:                
92:                /**
93:                 * Compute the minimum and maximum of a set of three int16_t values
94:                 * @param a first value
95:                 * @param b second value
96:                 * @param c third value
97:                 * @return struct containing minimum and maximum value --
98:                 *   this is fairly unusual but it permits the compiler to
99:                 *   optimize by placing in an appropriate pair
100:                *   of adjacent working registers.
101:                */
102:               inline static MC_minmax16_t MC_UTIL_MinMax3_S16(int16_t a, int16_t b, int16_t c)
103:               {
104:                   /* Sort a,b,c */
105:                   asm (
00000E  000920     NOP
0069D4  BE0006     MOV.D W6, W0
0069D6  E68812     CPBLT.W W1, W2, 0x69DA
0069D8  FD0101     EXCH W1, W2
0069DA  E68810     CPBLT.W W1, W0, 0x69DE
0069DC  FD0001     EXCH W1, W0
0069DE  E69010     CPBLT.W W2, W0, MC_UTIL_AverageS16
0069E0  FD0002     EXCH W2, W0
106:                       "    cpslt   %[a], %[b]\n"
107:                       "    exch    %[a], %[b]\n"
108:                       "    cpslt   %[a], %[c]\n"
109:                       "    exch    %[a], %[c]\n"
110:                       "    cpslt   %[b], %[c]\n"
111:                       "    exch    %[b], %[c]\n"
112:                       : [a]"+r"(a),
113:                         [b]"+r"(b),
114:                         [c]"+r"(c)
115:                   );
116:                   /* Now a <= b <= c */
117:               
118:                   MC_minmax16_t result;
119:                   result.min = a;
120:                   result.max = c;
121:                   return result;
122:               }
123:               
124:               /**  Read accumulator A */
125:               inline static int32_t MC_UTIL_readAccA32()
126:               {
127:               #if __XC16_VERSION__ >= 1030
128:                   return __builtin_sacd(a_Reg, 0);
129:               #elif __XC16_VERSION__ >= 1026
130:                   const int32_t tmp = __builtin_sacd(a_Reg, 0);
131:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
132:                   asm volatile ("");
133:                   return tmp;
134:               #else
135:                   int32_t result;
136:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
137:                   asm volatile ("" : "+w"(a_Reg):); 
138:                   result = ACCAH;
139:                   result <<= 16;
140:                   result |= ACCAL; 
141:                   return result;
142:               #endif
143:               }
144:               
145:               /**  Write accumulator B */
146:               inline static void MC_UTIL_writeAccB32(int32_t input)
147:               {
148:               #if __XC16_VERSION__ >= 1030
149:                   b_Reg = __builtin_lacd(input, 0);
150:               #elif __XC16_VERSION__ >= 1026
151:                   const int32_t tmp = input;
152:                   asm volatile ("" :: "r"(tmp)); 
153:                   b_Reg = __builtin_lacd(tmp, 0);
154:               #else
155:                   uint32_t temp_dword;
156:                   uint16_t temp_word;
157:                   temp_dword = 0xFFFF0000 & input;
158:                   temp_dword = temp_dword >> 16;
159:                   temp_word = (uint16_t)temp_dword;
160:                   b_Reg = __builtin_lac(temp_word, 0);
161:                   /* Prevent optimization from re-ordering/ignoring this sequence of operations */
162:                   asm volatile ("" : "+w"(b_Reg):); 
163:                   temp_word = (uint16_t)(0xFFFF & input);
164:                   ACCBL = temp_word;
165:               #endif
166:               
167:               }
168:               
169:               
170:               
171:               #ifdef	__cplusplus
172:               }
173:               #endif
174:               
175:               #endif	/* _MOTOR_CONTROL_UTIL_H_ */
176:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/library/mc-library/motor_control_inline_internal.h
1:                 /*******************************************************************************
2:                   Header file for Motor Control library inline definitions of internal functions  
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     motor_control_inline_internal.h
9:                 
10:                  Summary:
11:                    This header file contains implementation details of the Motor Control Library 
12:                	that are not part of its public interface and are subject to change.
13:                    Please use the functions and type definitions contained in other header files
14:                	of the Motor Control Library instead.
15:                
16:                  Description:
17:                    This header file is automatically included when the library interfaces header file
18:                    is included in the project.
19:                *******************************************************************************/
20:                
21:                // DOM-IGNORE-BEGIN
22:                /* *********************************************************************
23:                 *
24:                 * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use
25:                 * this software and any derivatives exclusively with Microchip products.
26:                 *
27:                 * This software and any accompanying information is for suggestion only.
28:                 * It does not modify Microchip's standard warranty for its products.
29:                 * You agree that you are solely responsible for testing the software and
30:                 * determining its suitability.  Microchip has no obligation to modify,
31:                 * test, certify, or support the software.
32:                 
33:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
34:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
35:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
36:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
37:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
38:                 * APPLICATION.
39:                 
40:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
41:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
42:                 * ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
43:                 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
44:                 * FORESEEABLE.  TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
45:                 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT
46:                 * EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO
47:                 * MICROCHIP FOR THIS SOFTWARE.
48:                 
49:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
50:                 * THESE TERMS.
51:                 *
52:                 * *****************************************************************************/
53:                // DOM-IGNORE-END
54:                
55:                #ifndef _MOTOR_CONTROL_INLINE_INTERNAL_H_
56:                #define _MOTOR_CONTROL_INLINE_INTERNAL_H_
57:                
58:                // *****************************************************************************
59:                // *****************************************************************************
60:                // Section: Included Files
61:                // *****************************************************************************
62:                // *****************************************************************************
63:                /*  This section lists the other files that are included in this file.
64:                */
65:                #include <stdint.h>
66:                
67:                
68:                /**
69:                 * Compute limit(x + ofs_out, min, max)
70:                 * This optimized code works ONLY if ofs_out >= 0
71:                 */
72:                static inline int16_t MC_adjust_zero_sequence(int16_t x, int16_t ofs_out, int16_t min, int16_t max)
73:                {
74:                    int16_t w;
75:                    asm volatile (
000030  000920     NOP
000046  000920     NOP
000056  000920     NOP
000068  000920     NOP
00007C  000920     NOP
00008C  000920     NOP
0069F0  23EF92     MOV #0x3EF9, W2
0069F2  203B63     MOV #0x3B6, W3
0069F4  27A3D5     MOV #0x7A3D, W5
0069F6  410087     ADD W2, W7, W1
0069F8  E69811     CPBLT.W W3, W1, 0x69FC
0069FA  780083     MOV W3, W1
0069FC  AE4042     BTSS SR, #2
0069FE  E68815     CPBLT.W W1, W5, .LBE681, .LBE682
006A00  780085     MOV W5, W1
006A06  410084     ADD W2, W4, W1
006A08  E69811     CPBLT.W W3, W1, 0x6A0C
006A0A  780083     MOV W3, W1
006A0C  AE4042     BTSS SR, #2
006A0E  E68815     CPBLT.W W1, W5, .LBE683, .LBE684
006A10  780085     MOV W5, W1
006A16  410086     ADD W2, W6, W1
006A18  E69811     CPBLT.W W3, W1, 0x6A1C
006A1A  780083     MOV W3, W1
006A1C  AE4042     BTSS SR, #2
006A1E  E68815     CPBLT.W W1, W5, .LBE685, .LBE686
006A20  780085     MOV W5, W1
006A28  203B61     MOV #0x3B6, W1
006A2A  27A3D2     MOV #0x7A3D, W2
006A2C  400187     ADD W0, W7, W3
006A2E  E68813     CPBLT.W W1, W3, 0x6A32
006A30  780181     MOV W1, W3
006A32  AE4042     BTSS SR, #2
006A34  E69812     CPBLT.W W3, W2, .LBE691, .LBE692
006A36  780182     MOV W2, W3
006A3A  400184     ADD W0, W4, W3
006A3C  E68813     CPBLT.W W1, W3, 0x6A40
006A3E  780181     MOV W1, W3
006A40  AE4042     BTSS SR, #2
006A42  E69812     CPBLT.W W3, W2, .LBE693, .LBE694
006A44  780182     MOV W2, W3
006A48  400186     ADD W0, W6, W3
006A4A  E68813     CPBLT.W W1, W3, 0x6A4E
006A4C  780181     MOV W1, W3
006A4E  AE4042     BTSS SR, #2
006A50  E69812     CPBLT.W W3, W2, .LBE695, .LBE696
006A52  780182     MOV W2, W3
76:                        "    add     %[ofs_out], %[x], %[w]\n" /* overflow is only positive */
77:                        "    cpslt   %[min], %[w]\n"
78:                        "    mov     %[min], %[w]\n"    /* if (w < min) { w = min; } */
79:                        "    btss    SR, #2\n"          /* if ofs_out > 0, OV = SR<2> indicates we need positive clipping */
80:                        "    cpslt   %[w], %[max]\n"
81:                        "    mov     %[max], %[w]\n"
82:                        : [w]"=&r"(w)
83:                        : [x]"r"(x),
84:                          [ofs_out]"r"(ofs_out),
85:                          [min]"r"(min),
86:                          [max]"r"(max)
87:                    );
88:                    return w;
89:                }
90:                
91:                #ifdef __cplusplus  // Provide C++ Compatability
92:                    extern "C" {
93:                #endif
94:                
95:                #endif // _MOTOR_CONTROL_INLINE_INTERNAL_H_
96:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/library/mc-library/motor_control_inline_dspic.h
1:                 /*******************************************************************************
2:                   Motor Control library inline definitions header file
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     motor_control_inline_dspic.h
9:                 
10:                  Summary:
11:                    This header file hosts inline definitions of certain library functions included 
12:                    in the Motor Control library.
13:                
14:                  Description:
15:                    This header file hosts inline definitions of certain library functions included 
16:                    in the Motor Control library. This header file is automatically included when the
17:                    library interfaces header file is included in the project.
18:                *******************************************************************************/
19:                
20:                // DOM-IGNORE-BEGIN
21:                /* *********************************************************************
22:                 *
23:                 * (c) 2017 Microchip Technology Inc. and its subsidiaries. You may use
24:                 * this software and any derivatives exclusively with Microchip products.
25:                 *
26:                 * This software and any accompanying information is for suggestion only.
27:                 * It does not modify Microchip's standard warranty for its products.
28:                 * You agree that you are solely responsible for testing the software and
29:                 * determining its suitability.  Microchip has no obligation to modify,
30:                 * test, certify, or support the software.
31:                 
32:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
33:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
34:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
35:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
36:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
37:                 * APPLICATION.
38:                 
39:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
40:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
41:                 * ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
42:                 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
43:                 * FORESEEABLE.  TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
44:                 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT
45:                 * EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO
46:                 * MICROCHIP FOR THIS SOFTWARE.
47:                 
48:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
49:                 * THESE TERMS.
50:                 *
51:                 * *****************************************************************************/
52:                // DOM-IGNORE-END
53:                
54:                #ifndef _MOTOR_CONTROL_INLINE_DSPIC_H_
55:                #define _MOTOR_CONTROL_INLINE_DSPIC_H_
56:                
57:                // *****************************************************************************
58:                // *****************************************************************************
59:                // Section: Included Files
60:                // *****************************************************************************
61:                // *****************************************************************************
62:                /*  This section lists the other files that are included in this file.
63:                */
64:                #include <xc.h>
65:                #include <stdint.h>
66:                #include "motor_control_util.h"
67:                #include "motor_control_inline_internal.h"
68:                
69:                // Declarations for DSP registers
70:                #include "motor_control_dsp.h"
71:                
72:                #ifdef __cplusplus  // Provide C++ Compatability
73:                    extern "C" {
74:                #endif
75:                        
76:                #ifdef __dsPIC33F__
77:                __psv__ extern uint16_t MC_SineTableInFlash[] __attribute__((space(psv)));
78:                #elif defined(__dsPIC33E__) || defined(__dsPIC33C__)
79:                __eds__ extern uint16_t MC_SineTableInFlash[] __attribute__((space(psv)));
80:                #else
81:                #error The selected device is not compatible with the Motor Control library!
82:                #endif
83:                
84:                extern uint16_t       MC_SineTableInRam[];
85:                
86:                enum {
87:                   /** CORCON bit definitions  */
88:                   MC_LATENCY_CONTROL     = 0x8000,
89:                   MC_UNSIGNED_MULTIPLY   = 0x1000,
90:                   MC_MIXED_MULTPLY       = 0x2000,
91:                   MC_DO_lOOP_TERMINATION = 0x800,
92:                   MC_DO_LOOP_7           = 0x700,
93:                   MC_DO_LOOP_6           = 0x600,
94:                   MC_DO_LOOP_5           = 0x500,
95:                   MC_DO_LOOP_4           = 0x400,
96:                   MC_DO_LOOP_3           = 0x300,
97:                   MC_DO_LOOP_2           = 0x200,
98:                   MC_DO_LOOP_1           = 0x100, 
99:                   MC_SAT_ACCA_ENABLE     = 0x80,
100:                  MC_SAT_ACCB_ENABLE     = 0x40,
101:                  MC_SAT_DATASPACE       = 0x20,
102:                  MC_SAT_SUPER_MODE      = 0x10,
103:                  MC_CPU_HIGH_PRIORITY   = 0x8,
104:                  MC_STACK_FRAME_ACTIVE  = 0x4,
105:                  MC_ROUND_MODE_BIASED   = 0x2,
106:                  MC_INTEGER_MODE        = 0x1,
107:               };
108:               
109:               enum {
110:                  /** saturation enabled for ACCA and ACCB, DSP to data space write enabled, Biased rounding mode */
111:                  MC_CORECONTROL = ( MC_SAT_ACCA_ENABLE | MC_SAT_ACCB_ENABLE | MC_SAT_DATASPACE | MC_ROUND_MODE_BIASED ) 
112:               };
113:               // *****************************************************************************
114:               // *****************************************************************************
115:               // Section: Inline function definitions
116:               // *****************************************************************************
117:               // *****************************************************************************
118:               /*  This section lists inline implementation of the library functions.
119:               */
120:               
121:               static inline uint16_t MC_TransformPark_InlineC( const MC_ALPHABETA_T *alphabeta, const MC_SINCOS_T *sincos, MC_DQ_T *dq)
122:               {
123:                   uint16_t mcCorconSave = CORCON;
006C3C  800220     MOV CORCON, W0
124:                   CORCON = MC_CORECONTROL;
006C3E  880221     MOV W1, CORCON
125:               
126:                   /* Id =  Ialpha*cos(Angle) + Ibeta*sin(Angle) */
127:                   a_Reg = __builtin_mpy(alphabeta->alpha, sincos->cos,0,0,0,0,0,0);
006C40  90BB08     MOV [W8+240], W6
006C42  C10113     MPY W4*W6, A
128:                   a_Reg = __builtin_mac(a_Reg, alphabeta->beta, sincos->sin,0,0,0,0,0,0,0,0);
006C44  90BB98     MOV [W8+242], W7
006C46  C50112     MAC W5*W7, A
129:                   dq->d = __builtin_sacr(a_Reg,0);
006C48  CD0001     SAC.R A, W1
006C4A  980C41     MOV W1, [W8+24]
130:               
131:                   /* Iq = - Ialpha*sin(Angle) + Ibeta*cos(Angle) */
132:                   a_Reg = __builtin_mpy(alphabeta->beta, sincos->cos,0,0,0,0,0,0);
006C4C  C40113     MPY W5*W6, A
133:                   a_Reg = __builtin_msc(a_Reg, alphabeta->alpha, sincos->sin,0,0,0,0,0,0,0,0);
006C4E  C24112     MSC W4*W7, A
134:                   dq->q = __builtin_sacr(a_Reg,0);
006C50  CD0001     SAC.R A, W1
006C52  980C51     MOV W1, [W8+26]
135:               
136:                   CORCON = mcCorconSave;
006C54  880220     MOV W0, CORCON
137:                   return 1;
138:               }
139:               
140:                      
141:               static inline uint16_t MC_ControllerPIUpdate_InlineC(int16_t in_Ref, int16_t in_Meas, MC_PISTATE_T *state, int16_t *out)
142:               {
143:                   int16_t error;
144:                   int16_t out_Buffer;
145:                   int16_t output;
146:               
147:                   uint16_t mcCorconSave = CORCON;
148:                   CORCON = MC_CORECONTROL;
149:               
150:                   /* Calculate error */
151:                   a_Reg = __builtin_lac(in_Ref,0);
152:                   b_Reg = __builtin_lac(in_Meas,0);
153:                   a_Reg = __builtin_subab(a_Reg,b_Reg);
154:                   error = __builtin_sacr(a_Reg,0);
155:               
156:                   /* Read state->integrator into B */
157:                   MC_UTIL_writeAccB32(state->integrator);
158:               
159:                   /* Calculate (Kp * error * 2^4), store in A and out_Buffer */
160:                   a_Reg = __builtin_mpy(error, state->kp,0,0,0,0,0,0);
161:                   a_Reg = __builtin_sftac(a_Reg,-4);
162:                   a_Reg = __builtin_addab(a_Reg,b_Reg);
163:                   out_Buffer = __builtin_sacr(a_Reg,0);
164:               
165:                   /* Limit the output */
166:                   if(out_Buffer > state->outMax)
167:                   {
168:                       output = state->outMax;
169:                   }
170:                   else if(out_Buffer < state->outMin)
171:                   {
172:                       output = state->outMin;
173:                   }
174:                   else
175:                   {
176:                       output = out_Buffer;
177:                   }
178:                   *out = output;    
179:               
180:                   /* Calculate (error * Ki) and store in A */
181:                   a_Reg = __builtin_mpy(error, state->ki,0,0,0,0,0,0);
182:               
183:                   /* Calculate (excess * Kc), subtract from (error * Ki) and store in A */
184:                   error = out_Buffer - output;
185:                   a_Reg = __builtin_msc(a_Reg, error, state->kc,0,0,0,0,0,0,0,0);
186:               
187:                   /* Add (error * Ki)-(excess * Kc) to the integrator value in B */
188:                   a_Reg = __builtin_addab(a_Reg,b_Reg);
189:                   asm volatile ("" : "+w"(a_Reg):); // Prevent optimization from re-ordering/ignoring this sequence of operations
190:               
191:                   /* Store the integrator result */
192:                   state->integrator = MC_UTIL_readAccA32();
193:                   CORCON = mcCorconSave;
194:                   
195:                   return 1;
196:               }
197:               
198:               
199:               static inline uint16_t MC_TransformClarke_InlineC( const MC_ABC_T *abc, MC_ALPHABETA_T *alphabeta)
200:               {
201:                   const uint16_t MC_ONEBYSQ3 = 18919u;
202:                   uint16_t mcCorconSave = CORCON;
006C22  800220     MOV CORCON, W0
203:                   CORCON = MC_CORECONTROL;
006C24  200E21     MOV #0xE2, W1
006C26  880221     MOV W1, CORCON
204:               
205:                   /* alpha = a */
206:                   alphabeta->alpha = abc->a;
006C28  900268     MOV [W8+12], W4
006C2A  980C14     MOV W4, [W8+18]
207:               
208:                   /* beta = a/sqrt(3) + 2*b/sqrt(3) */
209:                   a_Reg = __builtin_mpy(abc->a, MC_ONEBYSQ3,0,0,0,0,0,0);
006C2C  249E75     MOV #0x49E7, W5
006C2E  C00113     MPY W4*W5, A
210:                   a_Reg = __builtin_mac(a_Reg, MC_ONEBYSQ3, abc->b,0,0,0,0,0,0,0,0);
006C30  900378     MOV [W8+14], W6
006C32  C40112     MAC W5*W6, A
211:                   a_Reg = __builtin_mac(a_Reg, MC_ONEBYSQ3, abc->b,0,0,0,0,0,0,0,0);
006C34  C40112     MAC W5*W6, A
212:                   alphabeta->beta = __builtin_sacr(a_Reg,0);
006C36  CD0005     SAC.R A, W5
006C38  980C25     MOV W5, [W8+20]
213:               
214:                   CORCON = mcCorconSave;
006C3A  880220     MOV W0, CORCON
215:                   return 1;
216:               }
217:               
218:               
219:               static inline void MC_TransformClarkeABC_InlineC(const MC_ABC_T *abc, MC_ALPHABETA_T *alphabeta)
220:               {
221:                   const int16_t tan30Q16      = 37837U;  // 1/sqrt(3) Q16
222:                   const int16_t one_thirdQ16  = 21845U;  // 1/3 Q16
223:                   const int16_t two_thirdsQ16 = 43690U;  // 2/3 Q16 
224:                   /* note that 43691 would be more accurate but this maintains equal gain among the phases */
225:                   
226:                   /* alpha = a*2/3 - b/3- c/3 */
227:                   alphabeta->alpha = MC_UTIL_mulus16(two_thirdsQ16, abc->a)
006A96  98AC02     MOV W2, [W8+208]
228:                                    - MC_UTIL_mulus16(one_thirdQ16, abc->b)
006A92  52020B     SUB W4, W11, W4
229:                                    - MC_UTIL_mulus16(one_thirdQ16, abc->c);
006A94  520107     SUB W4, W7, W2
230:                   
231:                   /* beta = b/sqrt(3) - c/sqrt(3) */   
232:                   alphabeta->beta  = MC_UTIL_mulus16(tan30Q16, abc->b)
006AA0  98AC10     MOV W0, [W8+210]
233:                                    - MC_UTIL_mulus16(tan30Q16, abc->c);
006A9E  538005     SUB W7, W5, W0
234:               }
235:               
236:               static inline uint16_t MC_TransformParkInverse_InlineC(const MC_DQ_T *dq, const MC_SINCOS_T *sincos, MC_ALPHABETA_T *alphabeta)
237:               {
238:                   uint16_t mcCorconSave = CORCON;
00696C  800220     MOV CORCON, W0
239:                   CORCON = MC_CORECONTROL;
00696E  200E21     MOV #0xE2, W1
006970  880221     MOV W1, CORCON
240:               
241:                   /* alphabeta->alpha = (dq->d * sincos->cos) - (dq->q * sincos->sin) */
242:                   a_Reg = __builtin_mpy(dq->d, sincos->cos,0,0,0,0,0,0);
006972  909358     MOV [W8+170], W6
006974  90BA08     MOV [W8+240], W4
006976  C10113     MPY W4*W6, A
243:                   a_Reg = __builtin_msc(a_Reg, dq->q, sincos->sin,0,0,0,0,0,0,0,0);
006978  9092E8     MOV [W8+172], W5
00697A  90BB98     MOV [W8+242], W7
00697C  C54112     MSC W5*W7, A
244:                   alphabeta->alpha = __builtin_sacr(a_Reg,0);
00697E  CD0001     SAC.R A, W1
006980  989471     MOV W1, [W8+174]
245:               
246:                   /* alphabeta->beta = (dq->d * sincos->sin) + (dq->q * sincos->cos) */
247:                   a_Reg = __builtin_mpy(dq->d, sincos->sin,0,0,0,0,0,0);
006982  C60113     MPY W6*W7, A
248:                   a_Reg = __builtin_mac(a_Reg, dq->q, sincos->cos,0,0,0,0,0,0,0,0);
006984  C00112     MAC W4*W5, A
249:                   alphabeta->beta = __builtin_sacr(a_Reg,0);
006986  CD0003     SAC.R A, W3
006988  989C03     MOV W3, [W8+176]
250:               
251:                   CORCON = mcCorconSave;
00698A  880220     MOV W0, CORCON
252:                   return 1;
253:               }
254:               
255:               
256:               static inline uint16_t MC_TransformClarkeInverseSwappedInput_InlineC( const MC_ALPHABETA_T *alphabeta, MC_ABC_T *abc)
257:               {
258:                   const int16_t MC_SQ3OV2 = 28378u;  
259:                   const int16_t MC_POINT5 = 0x4000;
260:                   uint16_t mcCorconSave = CORCON;
261:                   CORCON = MC_CORECONTROL;
262:               
263:                   /* a = beta */
264:                   abc->a = alphabeta->beta;
265:               
266:                   /* b = (-beta/2) + (Sqrt(3)/2)*alpha */
267:                   a_Reg = __builtin_clr();
268:                   a_Reg = __builtin_msc(a_Reg, alphabeta->beta, MC_POINT5,0,0,0,0,0,0,0,0);
269:                   a_Reg = __builtin_mac(a_Reg, alphabeta->alpha, MC_SQ3OV2,0,0,0,0,0,0,0,0);
270:                   abc->b = __builtin_sacr(a_Reg,0);
271:               
272:                   /* c = (-beta/2) - (Sqrt(3)/2)*alpha */
273:                   a_Reg = __builtin_clr();
274:                   a_Reg = __builtin_msc(a_Reg, alphabeta->beta, MC_POINT5,0,0,0,0,0,0,0,0);
275:                   a_Reg = __builtin_msc(a_Reg, alphabeta->alpha, MC_SQ3OV2,0,0,0,0,0,0,0,0);
276:                   abc->c = __builtin_sacr(a_Reg,0);
277:               
278:                   CORCON = mcCorconSave;
279:                   return 1;
280:               }
281:               
282:               static inline uint16_t MC_TransformClarkeInverse_InlineC( const MC_ALPHABETA_T *alphabeta, MC_ABC_T *abc)
283:               {
284:                   const int16_t MC_SQ3OV2 = 28378u; 
285:                   const int16_t MC_NEGPOINT5 = 0xC000; 
286:                   uint16_t mcCorconSave = CORCON;
287:                   CORCON = MC_CORECONTROL;
288:               
289:                   /* a = alpha */
290:                   abc->a = alphabeta->alpha;
291:                   
292:                   /* b = (-alpha/2) + (Sqrt(3)/2)*beta */
293:                   a_Reg = __builtin_mpy(alphabeta->alpha, MC_NEGPOINT5,0,0,0,0,0,0);
294:                   a_Reg = __builtin_mac(a_Reg, alphabeta->beta, MC_SQ3OV2,0,0,0,0,0,0,0,0);
295:                   abc->b = __builtin_sacr(a_Reg,0);
296:               
297:                   /* c = (-alpha/2) - (Sqrt(3)/2)*beta */
298:                   a_Reg = __builtin_mpy(alphabeta->alpha, MC_NEGPOINT5,0,0,0,0,0,0);
299:                   a_Reg = __builtin_msc(a_Reg, alphabeta->beta, MC_SQ3OV2,0,0,0,0,0,0,0,0);
300:                   abc->c = __builtin_sacr(a_Reg,0);
301:               
302:                   CORCON = mcCorconSave;
303:                   return 1;
304:               }
305:               
306:               static inline void MC_TransformClarkeInverseNoAccum_InlineC( const MC_ALPHABETA_T *alphabeta, MC_ABC_T *abc)
307:               {
308:                   /* cos 30 deg = sqrt(3)/2 */
309:                   const uint16_t cos30Q16 = 56756u;
310:               
311:               	const int16_t alpha_sin30 = alphabeta->alpha >> 1;
006990  D18301     ASR W1, W6
312:               	const int16_t beta_cos30 = MC_UTIL_mulus16(cos30Q16, alphabeta->beta);
313:               
314:                   /* a = alpha */
315:                   abc->a = alphabeta->alpha;	
006996  989C31     MOV W1, [W8+182]
316:                   /* b = -(alpha/2) + (Sqrt(3)/2)*beta */
317:                   abc->b = -alpha_sin30 + beta_cos30;
006998  528506     SUB W5, W6, W10
00699A  989C4A     MOV W10, [W8+184]
318:                   /* c = -(alpha/2) - (Sqrt(3)/2)*beta */
319:                   abc->c = -alpha_sin30 - beta_cos30;
00699C  EA0306     NEG W6, W6
00699E  530305     SUB W6, W5, W6
0069A0  989C56     MOV W6, [W8+186]
320:               }
321:               
322:               static inline uint16_t MC_CalculateSpaceVectorPhaseShifted_InlineC( const MC_ABC_T *abc, uint16_t period, MC_DUTYCYCLEOUT_T *pdcout)
323:               {
324:                   int16_t T1, T2, Ta, Tb, Tc;
325:                   
326:                   uint16_t mcCorconSave = CORCON;
327:                   CORCON = MC_CORECONTROL;
328:               
329:                   if (abc->a >= 0)
330:                   {
331:                       // (xx1)
332:                       if (abc->b >= 0)
333:                       {
334:                           // (x11)
335:                           // Must be Sector 3 since Sector 7 not allowed
336:                           // Sector 3: (0,1,1)  0-60 degrees
337:                           T1 = abc->a;
338:                           T2 = abc->b;
339:                               /* T1 = period * T1 */
340:                               a_Reg = __builtin_mulus(period, T1);
341:                               T1 = __builtin_sacr(a_Reg,0);
342:                               /* T2 = period * T2 */
343:                               a_Reg = __builtin_mulus(period, T2);
344:                               T2 = __builtin_sacr(a_Reg,0);
345:                               Tc = period-T1-T2;
346:                               Tc = Tc >> 1;
347:                               Tb = Tc + T1;
348:                               Ta = Tb + T2;
349:                           pdcout->dutycycle1 = Ta;
350:                           pdcout->dutycycle2 = Tb;
351:                           pdcout->dutycycle3 = Tc;
352:                       }
353:                       else
354:                       {
355:                           // (x01)
356:                           if (abc->c >= 0)
357:                           {
358:                               // Sector 5: (1,0,1)  120-180 degrees
359:                               T1 = abc->c;
360:                               T2 = abc->a;
361:                                   /* T1 = period * T1 */
362:                                   a_Reg = __builtin_mulus(period, T1);
363:                                   T1 = __builtin_sacr(a_Reg,0);
364:                                   /* T2 = period * T2 */
365:                                   a_Reg = __builtin_mulus(period, T2);
366:                                   T2 = __builtin_sacr(a_Reg,0);
367:                                   Tc = period-T1-T2;
368:                                   Tc = Tc >> 1;
369:                                   Tb = Tc + T1;
370:                                   Ta = Tb + T2;
371:                               pdcout->dutycycle1 = Tc;
372:                               pdcout->dutycycle2 = Ta;
373:                               pdcout->dutycycle3 = Tb;
374:                           }
375:                           else
376:                           {
377:                               // Sector 1: (0,0,1)  60-120 degrees
378:                               T1 = -abc->c;
379:                               T2 = -abc->b;
380:                                   /* T1 = period * T1 */
381:                                   a_Reg = __builtin_mulus(period, T1);
382:                                   T1 = __builtin_sacr(a_Reg,0);
383:                                   /* T2 = period * T2 */
384:                                   a_Reg = __builtin_mulus(period, T2);
385:                                   T2 = __builtin_sacr(a_Reg,0);
386:                                   Tc = period-T1-T2;
387:                                   Tc = Tc >> 1;
388:                                   Tb = Tc + T1;
389:                                   Ta = Tb + T2;
390:                               pdcout->dutycycle1 = Tb;
391:                               pdcout->dutycycle2 = Ta;
392:                               pdcout->dutycycle3 = Tc;
393:                           }
394:                       }
395:                   }
396:                   else
397:                   {
398:                       // (xx0)
399:                       if (abc->b >= 0)
400:                       {
401:                           // (x10)
402:                           if (abc->c >= 0)
403:                           {
404:                               // Sector 6: (1,1,0)  240-300 degrees
405:                               T1 = abc->b;
406:                               T2 = abc->c;
407:                                   /* T1 = period * T1 */
408:                                   a_Reg = __builtin_mulus(period, T1);
409:                                   T1 = __builtin_sacr(a_Reg,0);
410:                                   /* T2 = period * T2 */
411:                                   a_Reg = __builtin_mulus(period, T2);
412:                                   T2 = __builtin_sacr(a_Reg,0);
413:                                   Tc = period-T1-T2;
414:                                   Tc = Tc >> 1;
415:                                   Tb = Tc + T1;
416:                                   Ta = Tb + T2;
417:                               pdcout->dutycycle1 = Tb;
418:                               pdcout->dutycycle2 = Tc;
419:                               pdcout->dutycycle3 = Ta;
420:                           }
421:                           else
422:                           {
423:                               // Sector 2: (0,1,0)  300-0 degrees
424:                               T1 = -abc->a;
425:                               T2 = -abc->c;
426:                                   /* T1 = period * T1 */
427:                                   a_Reg = __builtin_mulus(period, T1);
428:                                   T1 = __builtin_sacr(a_Reg,0);
429:                                   /* T2 = period * T2 */
430:                                   a_Reg = __builtin_mulus(period, T2);
431:                                   T2 = __builtin_sacr(a_Reg,0);
432:                                   Tc = period-T1-T2;
433:                                   Tc = Tc >> 1;
434:                                   Tb = Tc + T1;
435:                                   Ta = Tb + T2;
436:                               pdcout->dutycycle1 = Ta;
437:                               pdcout->dutycycle2 = Tc;
438:                               pdcout->dutycycle3 = Tb;
439:                           }
440:                       }
441:                       else
442:                       {
443:                           // (x00)
444:                           // Must be Sector 4 since Sector 0 not allowed
445:                           // Sector 4: (1,0,0)  180-240 degrees
446:                           T1 = -abc->b;
447:                           T2 = -abc->a;
448:                               /* T1 = period * T1 */
449:                               a_Reg = __builtin_mulus(period, T1);
450:                               T1 = __builtin_sacr(a_Reg,0);
451:                               /* T2 = period * T2 */
452:                               a_Reg = __builtin_mulus(period, T2);
453:                               T2 = __builtin_sacr(a_Reg,0);
454:                               Tc = period-T1-T2;
455:                               Tc = Tc >> 1;
456:                               Tb = Tc + T1;
457:                               Ta = Tb + T2;
458:                           pdcout->dutycycle1 = Tc;
459:                           pdcout->dutycycle2 = Tb;
460:                           pdcout->dutycycle3 = Ta;
461:                       }
462:                   }
463:               
464:                   CORCON = mcCorconSave;
465:                   return 1;
466:               }
467:               
468:               static inline void MC_CalculateZeroSequenceModulation_InlineC(const MC_ABC_T *pabc_in, MC_ABC_T *pabc_out, int16_t min, int16_t max)
469:               {
470:                   const int16_t center_out = MC_UTIL_AverageS16(min, max);    
471:                   const MC_minmax16_t minmax_in = MC_UTIL_MinMax3_S16(pabc_in->a, pabc_in->b, pabc_in->c);
000008  000B4A     NOP
472:                   const int16_t center_in = MC_UTIL_AverageS16(minmax_in.min, minmax_in.max);
473:                   pabc_out->a = MC_adjust_zero_sequence(pabc_in->a - center_in, center_out, min, max);
00002E  000920     NOP
000042  000920     NOP
0069EE  538380     SUB W7, W0, W7
006A02  98A451     MOV W1, [W8+202]
474:                   pabc_out->b = MC_adjust_zero_sequence(pabc_in->b - center_in, center_out, min, max);
000044  000C16     NOP
000052  000920     NOP
006A04  520200     SUB W4, W0, W4
006A12  98A461     MOV W1, [W8+204]
475:                   pabc_out->c = MC_adjust_zero_sequence(pabc_in->c - center_in, center_out, min, max);
000054  000920     NOP
000062  000920     NOP
000064  000920     NOP
006A14  530300     SUB W6, W0, W6
006A22  98A471     MOV W1, [W8+206]
006A24  370018     BRA MCAF_FocStepIsrForwardPath::MCAF_ScaleQ15
476:               }
477:               
478:               static inline uint16_t MC_CalculateSineCosine_InlineC_Ram( int16_t angle, MC_SINCOS_T *sincos )
479:               {
480:                   uint16_t remainder, index, y0, y1, delta, return_value;
481:                   uint32_t result;
482:               
483:                   return_value = 0;
484:                   
485:                   /* Index = (Angle*128)/65536 */
486:                   result = __builtin_muluu(128,angle);
005E6C  903120     MOV [W0+100], W2
005E6E  200801     MOV #0x80, W1
005E70  B80902     MUL.UU W1, W2, W2
006CD8  90B168     MOV [W8+236], W2
006CDA  200800     MOV #0x80, W0
006CDC  B80102     MUL.UU W0, W2, W2
487:                   index = result >> 16;
005E72  780083     MOV W3, W1
006CDE  780003     MOV W3, W0
488:                   remainder = (uint16_t) result ;
006CE0  780082     MOV W2, W1
489:               
490:                   /* Check if interpolation is required or not */
491:                   if(remainder == 0)
005E74  E00002     CP0 W2
005E76  3A0010     BRA NZ, .L18
006CE2  E00001     CP0 W1
006CE4  3A0010     BRA NZ, .L12
492:                   {
493:                       /* No interpolation required, use index only */
494:                       sincos->sin = MC_SineTableInRam[index];
005E78  408101     ADD W1, W1, W2
005E7A  235003     MOV #0x3500, W3
005E7C  418102     ADD W3, W2, W2
005E7E  780112     MOV [W2], W2
005E80  982842     MOV W2, [W0+88]
006CE6  400080     ADD W0, W0, W1
006CE8  235002     MOV #0x3500, W2
006CEA  410081     ADD W2, W1, W1
006CEC  780091     MOV [W1], W1
006CEE  98BC11     MOV W1, [W8+242]
495:                       index = index+32;
005E82  B00201     ADD #0x20, W1
006CF0  B00200     ADD #0x20, W0
496:                       if (index > 127)
005E84  2007F2     MOV #0x7F, W2
005E86  508F82     SUB W1, W2, [W15]
005E88  360001     BRA LEU, .L19
006CF2  2007F1     MOV #0x7F, W1
006CF4  500F81     SUB W0, W1, [W15]
006CF6  360001     BRA LEU, .L13
497:                       {
498:                           index = index - 128;
005E8A  B10801     SUB #0x80, W1
006CF8  B10800     SUB #0x80, W0
499:                       }    
500:                       sincos->cos = MC_SineTableInRam[index];
005E8C  408081     ADD W1, W1, W1
005E8E  235002     MOV #0x3500, W2
005E90  410081     ADD W2, W1, W1
005E92  780091     MOV [W1], W1
005E94  982831     MOV W1, [W0+86]
005E96  370025     BRA .LBE122, .LBE123, .L20
006CFA  400000     ADD W0, W0, W0
006CFC  235001     MOV #0x3500, W1
006CFE  408000     ADD W1, W0, W0
006D00  780010     MOV [W0], W0
006D02  98BC00     MOV W0, [W8+240]
006D04  370025     BRA .LBE412, .LBE413, .L2
501:                       return_value = 1;
502:                   }
503:                   else
504:                   {
505:                       /* Interpolation required. Determine the delta between indexed value
506:                        * and the next value from the mcSineTableInRam and scale the remainder 
507:                        * with delta to get the linear interpolated value. */
508:               
509:                       y0 = MC_SineTableInRam[index];
005E98  408181     ADD W1, W1, W3
005E9A  235004     MOV #0x3500, W4
005E9C  420183     ADD W4, W3, W3
005E9E  780193     MOV [W3], W3
006D06  400100     ADD W0, W0, W2
006D08  235003     MOV #0x3500, W3
006D0A  418102     ADD W3, W2, W2
006D0C  780112     MOV [W2], W2
510:                       index = index+1;
005EA0  E80081     INC W1, W1
006D0E  E80000     INC W0, W0
511:                       if (index > 127)
005EA2  2007F4     MOV #0x7F, W4
005EA4  508F84     SUB W1, W4, [W15]
005EA6  360001     BRA LEU, .L21
006D10  2007F3     MOV #0x7F, W3
006D12  500F83     SUB W0, W3, [W15]
006D14  360001     BRA LEU, .L15
512:                       {
513:                           index = index - 128;
005EA8  B10801     SUB #0x80, W1
006D16  B10800     SUB #0x80, W0
514:                       }
515:                       y1 = MC_SineTableInRam[index];
005EAA  408201     ADD W1, W1, W4
005EAC  235005     MOV #0x3500, W5
005EAE  428204     ADD W5, W4, W4
006D18  400180     ADD W0, W0, W3
006D1A  235004     MOV #0x3500, W4
006D1C  420183     ADD W4, W3, W3
516:                       delta = y1 - y0;
005EB0  118214     SUBR W3, [W4], W4
006D1E  110213     SUBR W2, [W3], W4
517:                       result = __builtin_mulus(remainder,delta);
005EB2  B89204     MUL.US W2, W4, W4
006D20  B88A04     MUL.US W1, W4, W4
518:                       sincos->sin = y0 + ( result >>16 );
005EB4  418185     ADD W3, W5, W3
005EB6  982843     MOV W3, [W0+88]
006D22  410105     ADD W2, W5, W2
006D24  98BC12     MOV W2, [W8+242]
519:               
520:                       /* Increment by 32 for cosine index. Increment by 31 here
521:                        * since index has already been incremented once. */
522:                       index = index+31;
005EB8  4080FF     ADD W1, #0x1F, W1
006D26  40007F     ADD W0, #0x1F, W0
523:                       if (index > 127)
005EBA  2007F3     MOV #0x7F, W3
005EBC  508F83     SUB W1, W3, [W15]
005EBE  360001     BRA LEU, .L22
006D28  2007F2     MOV #0x7F, W2
006D2A  500F82     SUB W0, W2, [W15]
006D2C  360001     BRA LEU, .L16
524:                       {
525:                           index = index - 128;
005EC0  B10801     SUB #0x80, W1
006D2E  B10800     SUB #0x80, W0
526:                       }
527:                       
528:                       y0 = MC_SineTableInRam[index];
005EC2  408181     ADD W1, W1, W3
005EC4  235004     MOV #0x3500, W4
005EC6  420183     ADD W4, W3, W3
005EC8  780193     MOV [W3], W3
006D30  400100     ADD W0, W0, W2
006D32  235003     MOV #0x3500, W3
006D34  418102     ADD W3, W2, W2
006D36  780112     MOV [W2], W2
529:                       index = index+1;
005ECA  E80081     INC W1, W1
006D38  E80000     INC W0, W0
530:                       if (index > 127)
005ECC  2007F4     MOV #0x7F, W4
005ECE  508F84     SUB W1, W4, [W15]
005ED0  360001     BRA LEU, .L23
006D3A  2007F3     MOV #0x7F, W3
006D3C  500F83     SUB W0, W3, [W15]
006D3E  360001     BRA LEU, .L17
531:                       {
532:                           index = index - 128;
005ED2  B10801     SUB #0x80, W1
006D40  B10800     SUB #0x80, W0
533:                       }
534:                       y1 = MC_SineTableInRam[index];
005ED4  408081     ADD W1, W1, W1
005ED6  235004     MOV #0x3500, W4
005ED8  420081     ADD W4, W1, W1
006D42  400000     ADD W0, W0, W0
006D44  235003     MOV #0x3500, W3
006D46  418000     ADD W3, W0, W0
535:                       delta = y1 - y0;
005EDA  118211     SUBR W3, [W1], W4
006D48  110010     SUBR W2, [W0], W0
536:                       result = __builtin_mulus(remainder,delta);
005EDC  B89204     MUL.US W2, W4, W4
006D4A  B88800     MUL.US W1, W0, W0
537:                       sincos->cos = y0 + ( result >>16);
005EDE  418185     ADD W3, W5, W3
005EE0  982833     MOV W3, [W0+86]
006D4C  410101     ADD W2, W1, W2
006D4E  98BC02     MOV W2, [W8+240]
538:                       return_value = 2;
539:                   }
540:                   return  return_value ;
541:               }
542:               
543:               #ifdef __cplusplus  // Provide C++ Compatibility
544:                   }
545:               #endif
546:               
547:               #endif // _MOTOR_CONTROL_INLINE_DSPIC_H_
548:               
549:               
550:               
551:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/isr.c
1:                 /**
2:                  * isr.c
3:                  * 
4:                  * Interrupt Service Routine entry points
5:                  * 
6:                  * Component: main application
7:                  */
8:                 
9:                 /* ********************************************************************
10:                *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include "system_state.h"
49:                #include "state_machine.h"
50:                #include "diagnostics.h"
51:                #include "hal.h"
52:                #include "monitor.h"
53:                #include "mcaf_watchdog.h"
54:                #include "test_harness.h"
55:                #include "ui.h"
56:                #include "mcapi_internal.h"
57:                #include "current_measure.h"
58:                /**
59:                 * motor state variables, accessed directly
60:                 * 
61:                 * The ISR does not receive any arguments so we need access to this somehow.
62:                 * One alternative: we keep a private pointer here and provide an accessor
63:                 * function (declared in an isr.h file), for example:
64:                 * 
65:                 * <code>
66:                 * static MCAF_MOTOR_DATA *pmotor_state;
67:                 * 
68:                 * void MCAF_RegisterISRState(MCAF_MOTOR_DATA *pstate)
69:                 * {
70:                 *    pmotor_state = pstate;
71:                 * }
72:                 * 
73:                 * // ISR now accesses *pmotor_state instead 
74:                 * </code>
75:                 */
76:                extern MCAF_MOTOR_DATA motor;
77:                /** system data, accessed directly */
78:                extern MCAF_SYSTEM_DATA systemData;
79:                /** watchdog state, accessed directly */
80:                extern volatile MCAF_WATCHDOG_T watchdog;
81:                
82:                extern volatile int8_t flag_read;
83:                
84:                /**
85:                 * Executes tasks in the ISR for ADC interrupts.
86:                 * 
87:                 * This is the primary ISR for high-speed computation.
88:                 * It occurs at the same frequency as the PWM waveforms,
89:                 * and is triggered after the ADC acquisition completes.
90:                 * 
91:                 * GPIO test point output is activated during this ISR for timing purposes.
92:                 */
93:                void __attribute__((interrupt, auto_psv)) HAL_ADC_ISR(void)
94:                {
00092A  F80036     PUSH RCOUNT
95:                    if (MCAF_AdcIsrPrologEnabled())
96:                    {
97:                        MCAPI_AdcIsrProlog();
98:                    }
99:                    HAL_TestpointGp1_Activate();
100:               #ifdef MCAF_TEST_PROFILING   
101:                   motor.testing.timestampReference = HAL_ProfilingCounter_Get();
000944  800820     MOV TMR1, W0
000946  898770     MOV W0, 0x30EE
102:               #endif
103:               #if MCAF_SINGLE_CHANNEL_SUPPORT    
104:                   motor.currentMeasure.adcTriggerState = MCAF_SINGLE_CHANNEL_FIRST_TRIGGER;   // resetting the trigger state next time DC link current ISR is triggered                                     
105:               #endif
106:                   MCAF_SystemStateMachine_StepIsr(&motor); // data is read from ADC buffer every ISR
000948  22E000     MOV #0x2E00, W0
00094A  072023     RCALL MCAF_SystemStateMachine_StepIsr
107:                   HAL_ADC_InterruptFlag_Clear(); // interrupt flag must be cleared after data is read from ADC buffer
108:                   MCAF_UiStepIsr(&motor.ui);
000950  22FEC0     MOV #0x2FEC, W0
000952  074A4B     RCALL MCAF_UiStepIsr
109:                   MCAF_MonitorStepIsr(&motor);
110:                   MCAF_WatchdogManageIsr(&watchdog);
111:                   HAL_ADC_StepIsrCallback();
000964  074B2D     RCALL HAL_ADC_StepIsrCallback
112:                   MCAF_CalculateFilteredCurrent(&motor);
113:                   MCAF_ApiServiceIsr(&motor);
114:               
115:                   /* Test and diagnostics code are always the lowest-priority routine within 
116:                    * this ISR; diagnostics code should always be last.
117:                    */
118:                   MCAF_TestHarnessStepIsr(&systemData.testing);
119:                   MCAF_CaptureTimestamp(&motor.testing, MCTIMESTAMP_DIAGNOSTICS);
120:                   MCAF_DiagnosticsStepIsr();
000AEE  074A31     RCALL MCAF_DiagnosticsStepIsr
121:                   MCAF_CaptureTimestamp(&motor.testing, MCTIMESTAMP_END_OF_ISR);
122:                   HAL_TestpointGp1_Deactivate();
123:                   if (MCAF_AdcIsrEpilogEnabled())
124:                   {
125:                       MCAPI_AdcIsrEpilog();
126:                   }
127:                   
128:                   flag_read  =1;
000AF8  B3C010     MOV.B #0x1, W0
000AFA  B7F226     MOV.B WREG, flag_read
129:               }
000AFC  F90034     POP DSWPAG
000AFE  F90032     POP DSRPAG
000B00  BE044F     MOV.D [--W15], W8
000B02  BE034F     MOV.D [--W15], W6
000B04  BE024F     MOV.D [--W15], W4
000B06  BE014F     MOV.D [--W15], W2
000B08  BE004F     MOV.D [--W15], W0
000B0A  F90036     POP RCOUNT
000B0C  064000     RETFIE
130:               
131:               #if MCAF_SINGLE_CHANNEL_SUPPORT   
132:               void __attribute__((interrupt, auto_psv)) HAL_ADC_SINGLE_CHANNEL_ISR(void)
133:               {
134:                   MCAF_SingleChannelCurrentMeasure(&motor);
135:                   
136:                   ADC1_IndividualChannelInterruptFlagClear(MCAF_ADC_DCLINK_CURRENT);
137:               }
138:               #endif
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/hal/mcaf_pin_manager.c
1:                 /**
2:                   @File Name:
3:                     mcaf_pin_manager.c
4:                 
5:                   @Summary:
6:                     This module configures the IO pins and their functionality.
7:                 
8:                   @Description:
9:                     This module configures the IO pins and their functionality.
10:                 */ /* 
11:                 *
12:                 * Motor Control Application Framework
13:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
14:                 *
15:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
16:                 * this software and any derivatives exclusively with Microchip products.
17:                 *
18:                 * This software and any accompanying information is for suggestion only.
19:                 * It does not modify Microchip's standard warranty for its products.
20:                 * You agree that you are solely responsible for testing the software and
21:                 * determining its suitability.  Microchip has no obligation to modify,
22:                 * test, certify, or support the software.
23:                 *
24:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
25:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
26:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
27:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
28:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
29:                 * APPLICATION.
30:                 *
31:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
32:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
33:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
34:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
35:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
36:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
37:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                 * SOFTWARE.
42:                 *
43:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
44:                 * THESE TERMS.
45:                 *
46:                 *
47:                 * *****************************************************************************/
48:                
49:                #include <xc.h>
50:                #include "mcaf_pin_manager.h"
51:                
52:                /**
53:                  Section: Driver Interface
54:                 */ 
55:                
56:                void MCAF_PIN_MANAGER_Initialize(void)
57:                {   
58:                    // already configured in SYSTEM_Initialize()
59:                }
009FBE  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/hal/hardware_access_functions.h
1:                 /**
2:                  *   hardware_access_functions.h
3:                  *
4:                  *  This module provides hardware access function support.
5:                  *
6:                  *  Component: HAL
7:                  */
8:                  
9:                 /*
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 *
46:                 ******************************************************************************/
47:                 
48:                #ifndef __HAF_H
49:                #define __HAF_H
50:                
51:                #define MCC_MELODY
52:                
53:                #include <xc.h>
54:                #include <stdint.h>
55:                #include <stdbool.h>
56:                #include "hardware_access_functions_types.h"
57:                #include "hardware_access_functions_params.h"
58:                #include "../parameters/hal_params.h"
59:                #include "../parameters/options.h"
60:                
61:                #ifdef MCC_MELODY
62:                #include "adc/adc1.h"
63:                #include "cmp/cmp1.h"
64:                #include "adc/adc_features.h"
65:                #include "system/clock.h"
66:                #include "system/interrupt.h"
67:                #include "system/pins.h"
68:                #include "pwm_hs/pwm.h"
69:                #include "pwm_hs/pwm_features.h"
70:                #include "system/reset.h"
71:                #include "system/reset_types.h"
72:                
73:                #include "adc/adc1.h"
74:                #include "pwm_hs/pwm.h"
75:                #include "qei/qei1.h"
76:                #include "timer/tmr1.h"
77:                #include "timer/sccp1.h"
78:                #include "uart/uart1.h"
79:                #include "opa/opa1.h"
80:                #include "opa/opa2.h"
81:                #include "opa/opa3.h"
82:                
83:                #include "system/system.h"
84:                #include "system/system_types.h"
85:                #include "system/traps.h"
86:                #include "system/watchdog.h"
87:                
88:                #else
89:                
90:                #include "adc1.h"
91:                #include "adc_module_features.h"
92:                #include "clock.h"
93:                #include "interrupt_manager.h"
94:                #include "mcaf_button1.h"
95:                #include "mcaf_button2.h"
96:                #include "mcaf_led1.h"
97:                #include "mcaf_led2.h"
98:                #include "pin_manager.h"
99:                #include "pwm.h"
100:               #include "pwm_module_features.h"
101:               #include "reset.h"
102:               #include "reset_types.h"
103:               #include "sccp1_tmr.h"
104:               #include "system.h"
105:               #include "system_types.h"
106:               #include "tmr1.h"
107:               #include "traps.h"
108:               #include "uart1.h"
109:               #include "watchdog.h"
110:               #include "qei1.h"
111:               #include "qei_temp_hal.h"
112:               #include "opa.h"
113:               
114:               #endif
115:               
116:               #ifdef __cplusplus  // Provide C++ Compatibility
117:               extern "C" {
118:               #endif
119:               
120:               // This is the instruction cycle frequency required for libpic30.h
121:               #define FCY  CLOCK_InstructionFrequencyGet()
122:               
123:               /**
124:                 Section: ISR helper macros
125:                */
126:               #define HAL_ADC_ISR                     _ADCAN15Interrupt
127:               #define MCAF_ADC_CHANNEL_USED_FOR_ISR   MCAF_ADC_DCLINK_VOLTAGE
128:               
129:               /** Interrupt priorities used in MCAF */
130:               enum {
131:                   MCAF_PRIORITY_ADC = 6,                /** Primary motor control ISR priority */
132:                   MCAF_PRIORITY_ADC_SINGLECHANNEL = 5,  /** ISR priority for DC link current measurement(single-channel) */
133:                   MCAF_PRIORITY_TMR = 4                 /** Periodic timer tick ISR priority */
134:               };
135:               
136:               /**
137:                 Section: Hardware Access Functions
138:                */
139:               
140:               /**
141:                 Sub-section: PWM Module Access Functions
142:               */
143:               
144:               /**
145:                * Enables the PWM module.
146:                * Summary: Enables the whole of the PWM module.
147:                * @example
148:                * <code>
149:                * HAL_PWM_ModuleEnable();
150:                * </code>
151:                */
152:               inline static void HAL_PWM_ModuleEnable(void) { 
153:               #ifdef MCC_MELODY
154:                   MCC_PWM_Enable();
155:               #else
156:                   PWM_Enable();
157:               #endif
158:               }
159:               
160:               /**
161:                * Sets the master period cycle for all PWM to synchronize.
162:                * @param period PWM period value, expressed as pwm max counts
163:                * @example
164:                * <code>
165:                * HAL_PWM_SetPeriodIdentical(3500);
166:                * </code>
167:                * Note the use of (period-1)
168:                * FRM DS70005320D formula,  PGxPER = (Fpgx_clk/Fpwm) - 1
169:                */
170:               inline static void HAL_PWM_SetPeriodIdentical(uint16_t period)
171:               {
172:               #ifdef MCC_MELODY
173:                   MCC_PWM_MasterPeriodSet(period-1);
174:               #else
175:                   PWM_MasterPeriodSet(period-1);
176:               #endif    
177:               }
178:               
179:               /**
180:                * Sets identical PWM deadtime values for Centeraligned PWM mode on all three phases of Motor #1.
181:                * @param dt PWM deadtime value
182:                * @example
183:                * <code>
184:                * HAL_PWM_SetDeadtimeIdentical_Motor1(140);
185:                * </code>
186:                */
187:               inline static void HAL_PWM_SetDeadtimeIdentical_Motor1(uint16_t dt)
188:               {
189:               #ifdef MCC_MELODY
190:                   MCC_PWM_DeadTimeSet(MOTOR1_PHASE_A, dt);
191:                   MCC_PWM_DeadTimeSet(MOTOR1_PHASE_B, dt);
192:                   MCC_PWM_DeadTimeSet(MOTOR1_PHASE_C, dt);    
193:               #else
194:                   PWM_DeadTimeSet(MOTOR1_PHASE_A,dt);
195:                   PWM_DeadTimeSet(MOTOR1_PHASE_B,dt);
196:                   PWM_DeadTimeSet(MOTOR1_PHASE_C,dt);
197:               #endif    
198:               }
199:               
200:               /**
201:                * Clears the PWM fault interrupt status for Motor #1.
202:                * @example
203:                * <code>
204:                * HAL_PWM_FaultStatus_Clear();
205:                * </code>
206:                */
207:               inline static void HAL_PWM_FaultStatus_Clear(void)
208:               {
209:               #ifdef MCC_MELODY
210:                   MCC_PWM_GeneratorEventStatusClear(MOTOR1_PHASE_A, PWM_GENERATOR_INTERRUPT_FAULT);
211:                   MCC_PWM_GeneratorEventStatusClear(MOTOR1_PHASE_B, PWM_GENERATOR_INTERRUPT_FAULT);
212:                   MCC_PWM_GeneratorEventStatusClear(MOTOR1_PHASE_C, PWM_GENERATOR_INTERRUPT_FAULT);
213:               #else
214:                   PWM_GeneratorEventStatusClear(MOTOR1_PHASE_A,PWM_GENERATOR_INTERRUPT_FAULT);
215:                   PWM_GeneratorEventStatusClear(MOTOR1_PHASE_B,PWM_GENERATOR_INTERRUPT_FAULT);
216:                   PWM_GeneratorEventStatusClear(MOTOR1_PHASE_C,PWM_GENERATOR_INTERRUPT_FAULT);
217:               #endif    
218:               }
219:               
220:               /**
221:                * Gets the status of PWM fault interrupt for Motor #1.
222:                * @example
223:                * <code>
224:                * HAL_PWM_FaultStatus_Get();
225:                * </code>
226:                */
227:               inline static bool HAL_PWM_FaultStatus_Get(void)
228:               {
229:               #ifdef MCC_MELODY
230:                   return MCC_PWM_GeneratorEventStatusGet(MOTOR1_PHASE_A,PWM_GENERATOR_INTERRUPT_FAULT);
231:               #else
232:                   return PWM_GeneratorEventStatusGet(MOTOR1_PHASE_A,PWM_GENERATOR_INTERRUPT_FAULT);
233:               #endif    
234:               }
235:               
236:               /**
237:                * Sets up the trigger designated to initiate sampling of analog channels. The trigger is
238:                * set such that the sampling of motor currents occurs at the center of the low side pulse.
239:                * @example
240:                * <code>
241:                * HAL_PWM_SetADCTrigger();
242:                * </code>
243:                */
244:               inline static void HAL_PWM_SetADCTrigger()
245:               {
246:               #ifdef MCC_MELODY
247:                   MCC_PWM_TriggerACompareValueSet(MOTOR1_PHASE_A,
248:                                               (HAL_PARAM_DEADTIME_COUNTS >> 1) + HAL_PARAM_ADC_TRIGGER_DELAY);
249:               #else
250:                   PWM_TriggerACompareValueSet(MOTOR1_PHASE_A,
251:                                               (HAL_PARAM_DEADTIME_COUNTS >> 1) + HAL_PARAM_ADC_TRIGGER_DELAY);
252:               #endif
253:               }
254:               
255:               /**
256:                * Disables PWM override on the three low-side transistors for Motor #1.
257:                * Summary: Disables PWM override on the three low-side transistors for Motor #1.
258:                * @example
259:                * <code>
260:                * HAL_PWM_LowerTransistorsOverride_Disable();
261:                * </code>
262:                */
263:               inline static void HAL_PWM_LowerTransistorsOverride_Disable(void)
264:               {
265:               #ifdef MCC_MELODY
266:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_A);
267:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_B);
268:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_C);
269:               #else
270:                   PWM_OverrideLowDisable(MOTOR1_PHASE_A);
271:                   PWM_OverrideLowDisable(MOTOR1_PHASE_B);
272:                   PWM_OverrideLowDisable(MOTOR1_PHASE_C);
273:               #endif
274:               }
275:               
276:               /**
277:                * Enables PWM override to state LOW on the three low-side transistors for Motor #1.
278:                * Summary: Enables PWM override to state LOW on the three low-side transistors for Motor #1.
279:                * @example
280:                * <code>
281:                * HAL_PWM_LowerTransistorsOverride_Low();
282:                * </code>
283:                */
284:               inline static void HAL_PWM_LowerTransistorsOverride_Low(void)
285:               {
286:               #ifdef MCC_MELODY
287:                   /* Set PWM override data to 0b00 */
288:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
289:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
290:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
291:                   
292:                   /* Enable PWM override */    
293:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_A);
294:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_B);
295:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_C);
296:               #else
297:                   /* Set PWM override data to 0b00 */
298:                   PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
299:                   PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
300:                   PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
301:                   
302:                   /* Enable PWM override */    
303:                   PWM_OverrideLowEnable(MOTOR1_PHASE_A);
304:                   PWM_OverrideLowEnable(MOTOR1_PHASE_B);
305:                   PWM_OverrideLowEnable(MOTOR1_PHASE_C);
306:               #endif    
307:               }
308:               
309:                   
310:               /**
311:                * Disables PWM override on the three high-side transistors for Motor #1.
312:                * Summary: Disables PWM override on the three high-side transistors for Motor #1.
313:                * @example
314:                * <code>
315:                * HAL_PWM_UpperTransistorsOverride_Disable();
316:                * </code>
317:                */
318:               inline static void HAL_PWM_UpperTransistorsOverride_Disable(void)
319:               {
320:               #ifdef MCC_MELODY
321:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_A);
322:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_B);
323:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_C);
324:               #else
325:                   PWM_OverrideHighDisable(MOTOR1_PHASE_A);
326:                   PWM_OverrideHighDisable(MOTOR1_PHASE_B);
327:                   PWM_OverrideHighDisable(MOTOR1_PHASE_C);
328:               #endif
329:               }
330:               
331:               /**
332:                * Enables PWM override to state LOW on the three high-side transistors for Motor #1.
333:                * Summary: Enables PWM override to state LOW on the three high-side transistors for Motor #1.
334:                * @example
335:                * <code>
336:                * HAL_PWM_UpperTransistorsOverride_Low();
337:                * </code>
338:                */
339:               inline static void HAL_PWM_UpperTransistorsOverride_Low(void)
340:               {
341:               #ifdef MCC_MELODY
342:                   /* Set PWM override data to 0b00 */
343:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
344:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
345:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
346:               
347:                   /* Enable PWM override */
348:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_A);
349:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_B);
350:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_C);
351:               #else
352:                   /* Set PWM override data to 0b00 */
353:                   PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
354:                   PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
355:                   PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
356:               
357:                   /* Enable PWM override */
358:                   PWM_OverrideHighEnable(MOTOR1_PHASE_A);
359:                   PWM_OverrideHighEnable(MOTOR1_PHASE_B);
360:                   PWM_OverrideHighEnable(MOTOR1_PHASE_C);
361:               #endif
362:               }
363:               
364:               /**
365:                * Sets identical duty cycle values on three phases of Motor #1.
366:                * Summary: Sets identical duty cycle values on three phases of Motor #1.
367:                * @param dc Duty cycle value
368:                * @example
369:                * <code>
370:                * HAL_PWM_DutyCycle_SetIdentical(500);
371:                * </code>
372:                */
373:               inline static void HAL_PWM_DutyCycle_SetIdentical(uint16_t dc)
374:               {
375:               #ifdef MCC_MELODY
376:                   #if MCAF_SINGLE_CHANNEL_SUPPORT 
377:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_A,dc);
378:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_B,dc);
379:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_C,dc);
380:                   #endif
381:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_A,dc);
382:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_B,dc);
383:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_C,dc);
384:               #else
385:                   #if MCAF_SINGLE_CHANNEL_SUPPORT 
386:                   PWM_PhaseSet(MOTOR1_PHASE_A,dc);
387:                   PWM_PhaseSet(MOTOR1_PHASE_B,dc);
388:                   PWM_PhaseSet(MOTOR1_PHASE_C,dc);
389:                   #endif
390:                   PWM_DutyCycleSet(MOTOR1_PHASE_A,dc);
391:                   PWM_DutyCycleSet(MOTOR1_PHASE_B,dc);
392:                   PWM_DutyCycleSet(MOTOR1_PHASE_C,dc);
393:               #endif
394:               }
395:               
396:               /**
397:                * Writes three unique duty cycle values to the PWM duty cycle registers
398:                * corresponding to Motor #1.
399:                * Summary: Writes to the PWM duty cycle registers corresponding to Motor #1.
400:                * @param pdc Pointer to the array that holds duty cycle values
401:                * @example
402:                * <code>
403:                * HAL_PWM_DutyCycleRegister_Set(&pdcMotor1);
404:                * </code>
405:                */
406:               inline static void HAL_PWM_DutyCycleRegister_Set(const uint16_t *pdc)
407:               {
408:               #ifdef MCC_MELODY
409:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_A,pdc[0]);
410:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_B,pdc[1]);
411:                   MCC_PWM_DutyCycleSet(MOTOR1_PHASE_C,pdc[2]);
412:               #else
413:                   PWM_DutyCycleSet(MOTOR1_PHASE_A,pdc[0]);
414:                   PWM_DutyCycleSet(MOTOR1_PHASE_B,pdc[1]);
415:                   PWM_DutyCycleSet(MOTOR1_PHASE_C,pdc[2]);
416:               #endif
417:               }
418:               
419:               /**
420:                * Writes three unique phase values to the PWM phase registers
421:                * corresponding to Motor #1.
422:                * Summary: Writes to the PWM phase registers corresponding to Motor #1.
423:                * @param phase Pointer to the array that holds phase values
424:                * @example
425:                * <code>
426:                * HAL_PWM_PhaseRegister_Set(&phaseMotor1);
427:                * </code>
428:                */
429:               inline static void HAL_PWM_PhaseRegister_Set(const uint16_t *phase)
430:               {
431:               #ifdef MCC_MELODY
432:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_A,phase[0]);
433:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_B,phase[1]);
434:                   MCC_PWM_PhaseSet(MOTOR1_PHASE_C,phase[2]);
435:               #else
436:                   PWM_PhaseSet(MOTOR1_PHASE_A,phase[0]);
437:                   PWM_PhaseSet(MOTOR1_PHASE_B,phase[1]);
438:                   PWM_PhaseSet(MOTOR1_PHASE_C,phase[2]);
439:               #endif
440:               }
441:               
442:               /**
443:                * Writes three unique duty cycle values to both halves of the PWM duty cycles corresponding to Motor #1.
444:                * Summary: Writes to both halves of the PWM duty cycles corresponding to Motor #1.
445:                * @param pdc Pointer to the array that holds duty cycle values
446:                * @example
447:                * <code>
448:                * HAL_PWM_DutyCycle_Set(*pdc);
449:                * </code>
450:                */
451:               inline static void HAL_PWM_DutyCycle_Set(const uint16_t *pdc)
452:               {
453:                   #if MCAF_SINGLE_CHANNEL_SUPPORT
454:                   HAL_PWM_PhaseRegister_Set(pdc);
455:                   #endif 
456:                   HAL_PWM_DutyCycleRegister_Set(pdc);
457:               }
458:               
459:               /**
460:                * Writes six unique duty cycle values to the first half and second half of PWM duty cycles
461:                * corresponding to Motor #1.
462:                * Summary: Writes to the first-half and second-half of PWM duty cycles corresponding to Motor #1.
463:                * @param firstHalf Pointer to the array that holds information to set the first half of PWM duty cycle.
464:                * @param secondHalf Pointer to the array that holds information to set the second half of PWM duty cycle.
465:                * @example
466:                * <code>
467:                * HAL_PWM_DutyCycleDualEdge_Set(&firstHalf, &secondHalf);
468:                * </code>
469:                */
470:               inline static void HAL_PWM_DutyCycleDualEdge_Set(const uint16_t *firstHalf, const uint16_t *secondHalf)
471:               {
472:                   HAL_PWM_PhaseRegister_Set(firstHalf);
473:                   HAL_PWM_DutyCycleRegister_Set(secondHalf);
474:               }
475:               
476:               /**
477:               * Begins the PWM fault clearing process for all PWM instances 
478:               * Summary: Begins fault clearing process.
479:               * <code>
480:               * HAL_PWM_FaultClearBegin();
481:               * </code>
482:               */
483:               inline static void HAL_PWM_FaultClearBegin(void)
484:               {
485:               #ifdef MCC_MELODY
486:                   #if (PWM_FAULT_LATCH_SOFTWARE_CLEAR_FEATURE_AVAILABLE)
487:                   {
488:                       MCC_PWM_FaultModeLatchClear(MOTOR1_PHASE_A);
489:                       MCC_PWM_FaultModeLatchClear(MOTOR1_PHASE_B);
490:                       MCC_PWM_FaultModeLatchClear(MOTOR1_PHASE_C);
491:                   }
492:                   #else
493:                   {
494:                       MCC_PWM_FaultModeLatchDisable(MOTOR1_PHASE_A);
495:                       MCC_PWM_FaultModeLatchDisable(MOTOR1_PHASE_B);
496:                       MCC_PWM_FaultModeLatchDisable(MOTOR1_PHASE_C);
497:                   }
498:                   #endif
499:               #else
500:                   #if (PWM_FAULT_LATCH_SOFTWARE_CLEAR_FEATURE_AVAILABLE)
501:                   {
502:                       PWM_FaultModeLatchClear(MOTOR1_PHASE_A);
503:                       PWM_FaultModeLatchClear(MOTOR1_PHASE_B);
504:                       PWM_FaultModeLatchClear(MOTOR1_PHASE_C);
505:                   }
506:                   #else
507:                   {
508:                       PWM_FaultModeLatchDisable(MOTOR1_PHASE_A);
509:                       PWM_FaultModeLatchDisable(MOTOR1_PHASE_B);
510:                       PWM_FaultModeLatchDisable(MOTOR1_PHASE_C);
511:                   }
512:                   #endif
513:               #endif
514:               }
515:               
516:               /**
517:               * Ends the PWM fault clearing process for all PWM instances 
518:               * Summary: Ends fault clearing process.
519:               * <code>
520:               * HAL_PWM_FaultClearEnd();
521:               * </code>
522:               */
523:               inline static void HAL_PWM_FaultClearEnd(void)
524:               {
525:               #ifdef MCC_MELODY
526:                   #if (PWM_FAULT_LATCH_SOFTWARE_CLEAR_FEATURE_AVAILABLE)
527:                   {
528:                       // no action required
529:                   }
530:                   #else
531:                   {
532:                       MCC_PWM_FaultModeLatchEnable(MOTOR1_PHASE_A);
533:                       MCC_PWM_FaultModeLatchEnable(MOTOR1_PHASE_B);
534:                       MCC_PWM_FaultModeLatchEnable(MOTOR1_PHASE_C);
535:                   }
536:                   #endif
537:               #else
538:                   #if (PWM_FAULT_LATCH_SOFTWARE_CLEAR_FEATURE_AVAILABLE)
539:                   {
540:                       // no action required
541:                   }
542:                   #else
543:                   {
544:                       PWM_FaultModeLatchEnable(MOTOR1_PHASE_A);
545:                       PWM_FaultModeLatchEnable(MOTOR1_PHASE_B);
546:                       PWM_FaultModeLatchEnable(MOTOR1_PHASE_C);
547:                   }
548:                   #endif
549:               #endif
550:               }
551:               
552:               
553:               /**
554:                * Maintains the Motor #1 low-side transistors at the requested duty cycle while
555:                * keeping high-side transistors OFF.
556:                * Summary: Maintains the Motor #1 PWM outputs to an idle state with minimal impact to the motor.
557:                * @param pwmPeriodCount PWM period count
558:                * @param dc Duty cycle value for the low-side transistors
559:                * @example
560:                * <code>
561:                * HAL_PWM_LowerTransistorsDutyCycle_Set(3500,220);
562:                * </code>
563:                */
564:               inline static void HAL_PWM_LowerTransistorsDutyCycle_Set(uint16_t pwmPeriodCount, uint16_t dc)
565:               {
566:                   HAL_PWM_UpperTransistorsOverride_Low();
567:               
568:                   uint16_t dutyCycleLowSide = pwmPeriodCount;
569:                   dutyCycleLowSide -= dc;
570:               
571:                   HAL_PWM_DutyCycle_SetIdentical(dutyCycleLowSide);
572:               }
573:               
574:               /**
575:                * Disable the PWM channels assigned for Motor #1 by overriding them to low state.
576:                * Summary: Disable the PWM channels assigned for Motor #1 by overriding them to low state.
577:                * @example
578:                * <code>
579:                * HAL_PWM_Outputs_Disable();
580:                * </code>
581:                */
582:               inline static void HAL_PWM_Outputs_Disable(void)
583:               {
584:               #ifdef MCC_MELODY
585:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
586:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
587:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_C,0);   
588:                   
589:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_A);
590:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_A);    
591:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_B);
592:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_B);    
593:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_C);
594:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_C);    
595:               #else
596:                   PWM_OverrideDataSet(MOTOR1_PHASE_A,0);
597:                   PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
598:                   PWM_OverrideDataSet(MOTOR1_PHASE_C,0);   
599:                   
600:                   PWM_OverrideHighEnable(MOTOR1_PHASE_A);
601:                   PWM_OverrideLowEnable(MOTOR1_PHASE_A);    
602:                   PWM_OverrideHighEnable(MOTOR1_PHASE_B);
603:                   PWM_OverrideLowEnable(MOTOR1_PHASE_B);    
604:                   PWM_OverrideHighEnable(MOTOR1_PHASE_C);
605:                   PWM_OverrideLowEnable(MOTOR1_PHASE_C);    
606:               #endif
607:               }
608:               
609:               /**
610:                * Disable the PWM channels assigned for Phase-A of Motor #1 by overriding them to low state.
611:                * Summary: Disable the PWM channels assigned for Phase-A of Motor #1 by overriding them to low state.
612:                * @example
613:                * <code>
614:                * HAL_PWM_PhaseAOutput_Disable();
615:                * </code>
616:                */
617:               inline static void HAL_PWM_PhaseAOutput_Disable(void)
618:               {
619:               #ifdef MCC_MELODY
620:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_A,0);  
621:                   
622:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_A);
623:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_A);
624:               #else
625:                   PWM_OverrideDataSet(MOTOR1_PHASE_A,0);  
626:                   
627:                   PWM_OverrideHighEnable(MOTOR1_PHASE_A);
628:                   PWM_OverrideLowEnable(MOTOR1_PHASE_A);
629:               #endif    
630:               }
631:               
632:               /**
633:                * Enable the PWM channels assigned for Phase-A of Motor #1.
634:                * Summary: Enable the PWM channels assigned for Phase-A of Motor #1.
635:                * @example
636:                * <code>
637:                * HAL_PWM_PhaseAOutput_Enable();
638:                * </code>
639:                */
640:               inline static void HAL_PWM_PhaseAOutput_Enable(void)
641:               {
642:               #ifdef MCC_MELODY
643:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_A);
644:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_A);
645:               #else
646:                   PWM_OverrideHighDisable(MOTOR1_PHASE_A);
647:                   PWM_OverrideLowDisable(MOTOR1_PHASE_A);
648:               #endif
649:               }
650:               
651:               /**
652:                * Disable the PWM channels assigned for Phase-B of Motor #1 by overriding them to low state.
653:                * Summary: Disable the PWM channels assigned for Phase-B of Motor #1 by overriding them to low state.
654:                * @example
655:                * <code>
656:                * HAL_PWM_PhaseBOutput_Disable();
657:                * </code>
658:                */
659:               inline static void HAL_PWM_PhaseBOutput_Disable(void)
660:               {
661:               #ifdef MCC_MELODY
662:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
663:                   
664:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_B);
665:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_B);
666:               #else
667:                   PWM_OverrideDataSet(MOTOR1_PHASE_B,0);
668:                   
669:                   PWM_OverrideHighEnable(MOTOR1_PHASE_B);
670:                   PWM_OverrideLowEnable(MOTOR1_PHASE_B);
671:               #endif
672:               }
673:               
674:               /**
675:                * Enable the PWM channels assigned for Phase-B of Motor #1.
676:                * Summary: Enable the PWM channels assigned for Phase-B of Motor #1.
677:                * @example
678:                * <code>
679:                * HAL_PWM_PhaseBOutput_Enable();
680:                * </code>
681:                */
682:               inline static void HAL_PWM_PhaseBOutput_Enable(void)
683:               {
684:               #ifdef MCC_MELODY
685:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_B);
686:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_B);
687:               #else
688:                   PWM_OverrideHighDisable(MOTOR1_PHASE_B);
689:                   PWM_OverrideLowDisable(MOTOR1_PHASE_B);
690:               #endif
691:               }
692:               
693:               /**
694:                * Disable the PWM channels assigned for Phase-C of Motor #1 by overriding them to low state.
695:                * Summary: Disable the PWM channels assigned for Phase-C of Motor #1 by overriding them to low state.
696:                * @example
697:                * <code>
698:                * HAL_PWM_PhaseCOutput_Disable();
699:                * </code>
700:                */
701:               inline static void HAL_PWM_PhaseCOutput_Disable(void)
702:               {
703:               #ifdef MCC_MELODY
704:                   MCC_PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
705:                   
706:                   MCC_PWM_OverrideHighEnable(MOTOR1_PHASE_C);
707:                   MCC_PWM_OverrideLowEnable(MOTOR1_PHASE_C);
708:               #else
709:                   PWM_OverrideDataSet(MOTOR1_PHASE_C,0);
710:                   
711:                   PWM_OverrideHighEnable(MOTOR1_PHASE_C);
712:                   PWM_OverrideLowEnable(MOTOR1_PHASE_C);
713:               #endif
714:               }
715:               
716:               /**
717:                * Enable the PWM channels assigned for Phase-C of Motor #1.
718:                * Summary: Enable the PWM channels assigned for Phase-C of Motor #1.
719:                * @example
720:                * <code>
721:                * HAL_PWM_PhaseCOutput_Enable();
722:                * </code>
723:                */
724:               inline static void HAL_PWM_PhaseCOutput_Enable(void)
725:               {
726:               #ifdef MCC_MELODY
727:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_C);
728:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_C);
729:               #else
730:                   PWM_OverrideHighDisable(MOTOR1_PHASE_C);
731:                   PWM_OverrideLowDisable(MOTOR1_PHASE_C);
732:               #endif
733:               }
734:               
735:               /**
736:                * Enables the PWM channels assigned for Motor #1 by disabling the PWM override function.
737:                * Summary: Enables the PWM channels assigned for Motor #1 by disabling the PWM override function.
738:                * @example
739:                * <code>
740:                * HAL_PWM_Outputs_Enable();
741:                * </code>
742:                */
743:               inline static void HAL_PWM_Outputs_Enable(void)
744:               {
745:               #ifdef MCC_MELODY
746:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_A);
747:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_A);
748:               
749:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_B);
750:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_B);
751:                   
752:                   MCC_PWM_OverrideHighDisable(MOTOR1_PHASE_C);
753:                   MCC_PWM_OverrideLowDisable(MOTOR1_PHASE_C);
754:               #else
755:                   PWM_OverrideHighDisable(MOTOR1_PHASE_A);
756:                   PWM_OverrideLowDisable(MOTOR1_PHASE_A);
757:               
758:                   PWM_OverrideHighDisable(MOTOR1_PHASE_B);
759:                   PWM_OverrideLowDisable(MOTOR1_PHASE_B);
760:                   
761:                   PWM_OverrideHighDisable(MOTOR1_PHASE_C);
762:                   PWM_OverrideLowDisable(MOTOR1_PHASE_C);
763:               #endif
764:               }
765:               
766:               /**
767:                 Sub-section: GPIO Module Access Functions
768:               */
769:               
770:               void HAL_Initialize(void);
771:               
772:               /**
773:                * This function is generated and returns whether or not a development board has two buttons.
774:                * @return true = two buttons are present, false = two buttons are not present
775:                */
776:               inline static bool HAL_hasTwoButtons(void)
777:               {
778:                   return true;
779:               }
780:               
781:               /**
782:                * Activates LED-GP1.
783:                * Summary: Activates LED-GP1.
784:                * @example
785:                * <code>
786:                * HAL_LedGp1_Activate();
787:                * </code>
788:                */
789:               inline static void HAL_LedGp1_Activate(void)
790:               {
791:               #ifdef MCC_MELODY
792:                   MCAF_LED1_SetHigh();
008894  A8CE76     BSET LATE, #6
008896  370001     BRA .LBE123, .L23
0094D4  A8CE76     BSET LATE, #6
0094D6  370001     BRA .LBE87, .L18
793:               #else
794:                   MCAF_LED1_On();
795:               #endif    
796:               }
797:               
798:               /**
799:                * Deactivates LED-GP1.
800:                * Summary: Deactivates LED-GP1.
801:                * @example
802:                * <code>
803:                * HAL_LedGp1_Deactivate();
804:                * </code>
805:                */
806:               inline static void HAL_LedGp1_Deactivate(void)
807:               {
808:               #ifdef MCC_MELODY
809:                   MCAF_LED1_SetLow();
008898  A9CE76     BCLR LATE, #6
0094D8  A9CE76     BCLR LATE, #6
810:               #else
811:                   MCAF_LED1_Off();
812:               #endif    
813:               }
814:               
815:               /**
816:                * Activates LED-GP2.
817:                * Summary: Activates LED-GP2.
818:                * @example
819:                * <code>
820:                * HAL_LedGp2_Activate();
821:                * </code>
822:                */
823:               inline static void HAL_LedGp2_Activate(void)
824:               {
825:               #ifdef MCC_MELODY
826:                   MCAF_LED2_SetHigh();
00889E  A8EE76     BSET LATE, #7
0088A0  370001     BRA .LBE118, .LBE119, .L25
0094DE  A8EE76     BSET LATE, #7
0094E0  370001     BRA .LBE84, .LBE91, .L15
827:               #else
828:                   MCAF_LED2_On();
829:               #endif  
830:               }
831:               
832:               /**
833:                * Deactivates LED-GP2.
834:                * Summary: Deactivates LED-GP2.
835:                * @example
836:                * <code>
837:                * HAL_LedGp2_Deactivate();
838:                * </code>
839:                */
840:               inline static void HAL_LedGp2_Deactivate(void)
841:               {
842:               #ifdef MCC_MELODY
843:                   MCAF_LED2_SetLow();
0088A2  A9EE76     BCLR LATE, #7
0094E2  A9EE76     BCLR LATE, #7
844:               #else
845:                   MCAF_LED2_Off();
846:               #endif    
847:               }
848:               
849:               /**
850:                * Activates Testpoint-GP1.
851:                * Summary: Activates Testpoint-GP1.
852:                * @example
853:                * <code>
854:                * HAL_TestpointGp1_Activate();
855:                * </code>
856:                */
857:               inline static void HAL_TestpointGp1_Activate(void) { MCAF_TESTPOINT1_SetHigh(); }
000942  A88E76     BSET LATE, #4
008DC2  A88E76     BSET LATE, #4
858:               
859:               /**
860:                * Deactivates Testpoint-GP1.
861:                * Summary: Deactivates Testpoint-GP1.
862:                * @example
863:                * <code>
864:                * HAL_TestpointGp1_Deactivate();
865:                * </code>
866:                */
867:               inline static void HAL_TestpointGp1_Deactivate(void) { MCAF_TESTPOINT1_SetLow(); }
000AF6  A98E76     BCLR LATE, #4
008DCA  A98E76     BCLR LATE, #4
868:               
869:               /**
870:                * Get the raw GPIO input from button1.
871:                * @return bool raw GPIO state where true = button is pressed, false = button is not pressed
872:                */
873:               inline static bool HAL_ButtonGp1RawInput(void)
874:               {
875:               #ifdef MCC_MELODY    
876:                   return !MCAF_BUTTON1_GetValue();
009636  208001     MOV #0x800, W1
009638  8073A0     MOV PORTE, W0
00963A  608080     AND W1, W0, W1
00963C  E90081     DEC W1, W1
00963E  DE08CF     LSR W1, #15, W1
877:               #else
878:                   return MCAF_BUTTON1_IsPressed(); 
879:               #endif
880:               }
881:               
882:               /**
883:                * Get the raw GPIO input from button2.
884:                * @return bool raw GPIO state where true = button is pressed, false = button is not pressed
885:                */
886:               inline static bool HAL_ButtonGp2RawInput(void)
887:               {
888:               #ifdef MCC_MELODY    
889:                   return !MCAF_BUTTON2_GetValue();
009644  210001     MOV #0x1000, W1
009646  8073A0     MOV PORTE, W0
009648  608080     AND W1, W0, W1
00964A  E90081     DEC W1, W1
00964C  DE08CF     LSR W1, #15, W1
890:               #else
891:                   return MCAF_BUTTON2_IsPressed();
892:               #endif
893:               }
894:               
895:               /**
896:                 Sub-section: ADC Module Access Functions
897:               */
898:               
899:               
900:               /**
901:                * This routine is a call back function to be called every ADC ISR.
902:                */
903:               void HAL_ADC_StepIsrCallback(void);
904:               
905:               /**
906:                * Get the ADC channel number corresponding to the potentiometer analog input for motor #1.
907:                * @return ADC channel number
908:                */
909:               inline static uint16_t HAL_ADC_ChannelPotentiometer(void) { return MCAF_ADC_POTENTIOMETER; }
910:               
911:               /**
912:                * Get the ADC channel number corresponding to the DC link voltage sense analog input for motor #1.
913:                * @return ADC channel number
914:                */
915:               inline static uint16_t HAL_ADC_ChannelDclink(void) { return MCAF_ADC_DCLINK_VOLTAGE; }
916:               
917:               /**
918:                * Get the ADC channel number corresponding to phase current A analog input for motor #1.
919:                * @return ADC channel number
920:                */
921:               inline static uint16_t HAL_ADC_ChannelIphaseA(void) { return MCAF_ADC_PHASEA_CURRENT; }
922:               
923:               /**
924:                * Get the ADC channel number corresponding to phase current B analog input for motor #1.
925:                * @return ADC channel number
926:                */
927:               inline static uint16_t HAL_ADC_ChannelIphaseB(void) { return MCAF_ADC_PHASEB_CURRENT; }
928:               
929:               /**
930:                * @deprecated as of MCAF R6
931:                * Get the ADC channel number corresponding to sum phase/DC link current analog input for motor #1.
932:                * @return ADC channel number
933:                */
934:               inline static uint16_t HAL_ADC_ChannelIphaseSum(void) { return 0; }
935:               
936:               /**
937:                * Is the phase A current analog input available?
938:                * @return whether the phase A current analog input is available
939:                */
940:               inline static bool HAL_ADC_IsAvailableIphaseA(void)
941:               {
942:                   return true;
943:               }
944:               
945:               /**
946:                * Get the ADC result corresponding to the phase A current analog input for motor #1.
947:                * @return ADC result value
948:                */
949:               inline static uint16_t HAL_ADC_ValueIphaseA(void)
950:               { 
951:               #ifdef MCC_MELODY
952:                   return MCC_ADC_ConversionResultGet(MCAF_ADC_PHASEA_CURRENT);
953:               #else
954:                   return ADC1_ConversionResultGet(MCAF_ADC_PHASEA_CURRENT);
955:               #endif
956:               }
957:               
958:               /**
959:                * Is the phase B current analog input available?
960:                * @return whether the phase B current analog input is available
961:                */
962:               inline static bool HAL_ADC_IsAvailableIphaseB(void)
963:               {
964:                   return true;
965:               }
966:               
967:               /**
968:                * Get the ADC result corresponding to the phase B current analog input for motor #1.
969:                * @return ADC result value
970:                */
971:               inline static uint16_t HAL_ADC_ValueIphaseB(void)
972:               { 
973:               #ifdef MCC_MELODY
974:                   return MCC_ADC_ConversionResultGet(MCAF_ADC_PHASEB_CURRENT);
975:               #else
976:                   return ADC1_ConversionResultGet(MCAF_ADC_PHASEB_CURRENT);
977:               #endif
978:               }
979:               
980:               /**
981:                * Is the phase C current analog input available?
982:                * @return whether the phase C current analog input is available
983:                */
984:               inline static bool HAL_ADC_IsAvailableIphaseC(void)
985:               {
986:                   return false;
987:               }
988:               
989:               /**
990:                * Get the ADC result corresponding to the phase C current analog input for motor #1.
991:                * @return ADC result value
992:                */
993:               inline static uint16_t HAL_ADC_ValueIphaseC(void)
994:               { 
995:                   return 0;
996:               }
997:               
998:               /**
999:                * Is the phase A voltage analog input available?
1000:               * @return whether the phase A voltage analog input is available
1001:               */
1002:              inline static bool HAL_ADC_IsAvailableVphaseA(void)
1003:              {
1004:                  return false;
1005:              }
1006:              
1007:              /**
1008:               * Get the ADC result corresponding to the phase A voltage analog input for motor #1.
1009:               * @return ADC result value
1010:               */
1011:              inline static uint16_t HAL_ADC_ValueVphaseA(void)
1012:              { 
1013:                  return 0;
1014:              }
1015:              
1016:              /**
1017:               * Is the phase B voltage analog input available?
1018:               * @return whether the phase B voltage analog input is available
1019:               */
1020:              inline static bool HAL_ADC_IsAvailableVphaseB(void)
1021:              {
1022:                  return false;
1023:              }
1024:              
1025:              /**
1026:               * Get the ADC result corresponding to the phase B voltage analog input for motor #1.
1027:               * @return ADC result value
1028:               */
1029:              inline static uint16_t HAL_ADC_ValueVphaseB(void)
1030:              { 
1031:                  return 0;
1032:              }
1033:              
1034:              /**
1035:               * Is the phase C voltage analog input available?
1036:               * @return whether the phase C voltage analog input is available
1037:               */
1038:              inline static bool HAL_ADC_IsAvailableVphaseC(void)
1039:              {
1040:                  return false;
1041:              }
1042:              
1043:              /**
1044:               * Get the ADC result corresponding to the phase C voltage analog input for motor #1.
1045:               * @return ADC result value
1046:               */
1047:              inline static uint16_t HAL_ADC_ValueVphaseC(void)
1048:              { 
1049:                  return 0;
1050:              }
1051:              
1052:              /**
1053:               * Is the DC link current analog input available?
1054:               * @return whether the DC link current analog input is available
1055:               */
1056:              inline static bool HAL_ADC_IsAvailableIbus(void)
1057:              {
1058:                  return false;
1059:              }
1060:              
1061:              /**
1062:               * Get the ADC result corresponding to the DC link current analog input for motor #1.
1063:               * @return ADC result value
1064:               */
1065:              inline static uint16_t HAL_ADC_ValueIbus(void)
1066:              { 
1067:                  return 0;
1068:              }
1069:              
1070:              /**
1071:               * Is the DC link voltage analog input available?
1072:               * @return whether the DC link voltage analog input is available
1073:               */
1074:              inline static bool HAL_ADC_IsAvailableDclink(void)
1075:              {
1076:                  return true;
1077:              }
1078:              
1079:              /**
1080:               * Get the ADC result corresponding to the DC link voltage analog input for motor #1.
1081:               * @return ADC result value
1082:               */
1083:              inline static uint16_t HAL_ADC_ValueDclink(void)
1084:              { 
1085:              #ifdef MCC_MELODY
1086:                  return MCC_ADC_ConversionResultGet(MCAF_ADC_DCLINK_VOLTAGE);
1087:              #else
1088:                  return ADC1_ConversionResultGet(MCAF_ADC_DCLINK_VOLTAGE);
1089:              #endif
1090:              }
1091:              
1092:              /**
1093:               * Is the potentiometer voltage analog input available?
1094:               * @return whether the potentiometer voltage analog input is available
1095:               */
1096:              inline static bool HAL_ADC_IsAvailablePotentiometer(void)
1097:              {
1098:                  return true;
1099:              }
1100:              
1101:              /**
1102:               * Get the ADC result corresponding to the potentiometer voltage analog input for motor #1.
1103:               * @return ADC result value
1104:               */
1105:              inline static uint16_t HAL_ADC_ValuePotentiometer(void)
1106:              { 
1107:              #ifdef MCC_MELODY
1108:                  return MCC_ADC_ConversionResultGet(MCAF_ADC_POTENTIOMETER);
1109:              #else
1110:                  return ADC1_ConversionResultGet(MCAF_ADC_POTENTIOMETER);
1111:              #endif
1112:              }
1113:              
1114:              /**
1115:               * Is the bridge temperature voltage analog input available?
1116:               * @return whether the bridge temperature voltage analog input is available
1117:               */
1118:              inline static bool HAL_ADC_IsAvailableBridgeTemperature(void)
1119:              {
1120:                  return false;
1121:              }
1122:              
1123:              /**
1124:               * Get the ADC result corresponding to the bridge temperature voltage analog input for motor #1.
1125:               * @return ADC result value
1126:               */
1127:              inline static uint16_t HAL_ADC_ValueBridgeTemperature(void)
1128:              { 
1129:                  return 0;
1130:              }
1131:              
1132:              /**
1133:               * Is the absolute reference voltage analog input available?
1134:               * @return whether the absolute reference voltage analog input is available
1135:               */
1136:              inline static bool HAL_ADC_IsAvailableAbsoluteReferenceVoltage(void)
1137:              {
1138:                  return false;
1139:              }
1140:              
1141:              /**
1142:               * Get the ADC result corresponding to the absolute reference voltage analog input for motor #1.
1143:               * @return ADC result value
1144:               */
1145:              inline static uint16_t HAL_ADC_ValueAbsoluteReferenceVoltage(void)
1146:              { 
1147:                  return 0;
1148:              }
1149:              
1150:              /**
1151:               * @deprecated as of MCAF R6
1152:               * Get the ADC result corresponding to sum phase analog input for motor #1.
1153:               * @return ADC result value
1154:               */
1155:              inline static uint16_t HAL_ADC_ValueIphaseSum(void) { return 0; }
1156:              
1157:              /**
1158:              * Enables the ADC module.
1159:              * Summary: Enables the whole of the ADC module.
1160:              * @example
1161:              * <code>
1162:              * HAL_ADC_Enable();
1163:              * </code>
1164:              */
1165:              inline static void HAL_ADC_Enable(void)
1166:              {
1167:              #ifdef MCC_MELODY
1168:                  MCC_ADC_Enable();
1169:              #else
1170:                  ADC1_Enable();
1171:              #endif
1172:              }
1173:              
1174:              /**
1175:              * Clears the ADC interrupt flag.
1176:              * @example
1177:              * <code>
1178:              * HAL_ADC_InterruptFlag_Clear();
1179:              * </code>
1180:              */
1181:              inline static void HAL_ADC_InterruptFlag_Clear(void)
1182:              {
1183:              #ifdef MCC_MELODY
1184:                  #if (ADC_INDIVIDUAL_CHANNEL_INTERRUPT_FEATURE_AVAILABLE)
1185:                      // In order to clear the ADC ISR flag one must read the associated
1186:                      // ADC buffer. This dummy read is to ensure the ISR flag will be cleared.
1187:                      MCC_ADC_ConversionResultGet(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1188:                      MCC_ADC_IndividualChannelInterruptFlagClear(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1189:                  #else
1190:                      MCC_ADC_InterruptFlagClear();
1191:                  #endif
1192:              #else
1193:                  #if (ADC_INDIVIDUAL_CHANNEL_INTERRUPT_FEATURE_AVAILABLE)
1194:                      // In order to clear the ADC ISR flag one must read the associated
1195:                      // ADC buffer. This dummy read is to ensure the ISR flag will be cleared.
1196:                      ADC1_ConversionResultGet(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1197:                      ADC1_IndividualChannelInterruptFlagClear(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1198:                  #else
1199:                      ADC1_InterruptFlagClear();   
1200:                  #endif
1201:              #endif
1202:              }
1203:              
1204:              /**
1205:              * Enables the ADC interrupt flag.
1206:              * @example
1207:              * <code>
1208:              * HAL_ADC_Interrupt_Enable();
1209:              * </code>
1210:              */
1211:              inline static void HAL_ADC_Interrupt_Enable(void)
1212:              {
1213:              #ifdef MCC_MELODY
1214:                  #if (ADC_INDIVIDUAL_CHANNEL_INTERRUPT_FEATURE_AVAILABLE)
1215:                      MCC_ADC_IndividualChannelInterruptEnable(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1216:                  #else
1217:                      MCC_ADC_InterruptEnable(); 
1218:                  #endif
1219:              #else
1220:                  #if (ADC_INDIVIDUAL_CHANNEL_INTERRUPT_FEATURE_AVAILABLE)
1221:                      ADC1_IndividualChannelInterruptEnable(MCAF_ADC_CHANNEL_USED_FOR_ISR);
1222:                  #else
1223:                      ADC1_InterruptEnable(); 
1224:                  #endif
1225:              #endif
1226:              }
1227:              
1228:              /**
1229:               * Sets the ADC interrupt priority value.
1230:               */
1231:              inline static void HAL_ADC_IndividualChannelInterruptPrioritySet(void)
1232:              {
1233:              #ifdef MCC_MELODY
1234:                  MCC_ADC_IndividualChannelInterruptPrioritySet(MCAF_ADC_CHANNEL_USED_FOR_ISR, MCAF_PRIORITY_ADC);
1235:              #else
1236:                  // already configured in SYSTEM_Initialize()
1237:              #endif
1238:              }
1239:              
1240:              /**
1241:               * Converts a signed input to an unsigned value.
1242:               * Adding 0x8000 to input maps -32k to 32k -> 0 to 65k.
1243:               * @param input input to be converted to unsigned value
1244:               * @return unsigned value
1245:              */
1246:              inline static int16_t HAL_ADC_UnsignedFromSignedInput(int16_t input) { return input + 0x8000; }
007F50  280000     MOV #0x8000, W0
007F52  B40C22     ADD ADCBUF11, WREG
008B98  280000     MOV #0x8000, W0
008B9A  B40C2A     ADD ADCBUF15, WREG
009DA4  280000     MOV #0x8000, W0
009DA6  B40C22     ADD ADCBUF11, WREG
1247:              
1248:              /**
1249:                Sub-section: Interrupt Module Access Functions
1250:              */
1251:              
1252:              /**
1253:              * Returns the interrupt vector number.
1254:              * @example
1255:              * <code>
1256:              * vecNum = HAL_InterruptVector_Get();
1257:              * </code>
1258:              */
1259:              inline static uint16_t HAL_InterruptVector_Get(void) { return _VECNUM; }
000922  BFC8C8     MOV.B INTTREG, WREG
000924  FB8000     ZE W0, W0
1260:              
1261:              /**
1262:                Sub-section: DMA Module Access Functions
1263:              */
1264:              
1265:              /**
1266:               * Handles the DMA Error trap and returns whether or not it was properly handled
1267:               * @return true = DMA Error was handled, false = DMA Error was not handled
1268:               */
1269:              bool HAL_DMA_ErrorHandler(void);
1270:              
1271:              /**
1272:                Sub-section: UART Module Access Functions
1273:              */
1274:              
1275:              /**
1276:              * Initializes the UART module
1277:              */
1278:              inline static void HAL_UART_Initialize(void) 
1279:              {
1280:              #ifdef MCC_MELODY
1281:                  MCC_UART_Initialize();
009EAA  07FCC8     RCALL UART1_Initialize
1282:              #else
1283:                  UART1_Initialize();
1284:              #endif
1285:              }
1286:              
1287:              /**
1288:               * Writes data to the UART tx buffer
1289:               * @param data data to be written to the buffer
1290:               */
1291:              inline static void HAL_UART_Write(uint8_t data)
1292:              {
1293:              #ifdef MCC_MELODY
1294:                  MCC_UART_Write(data);
009F4A  07FF35     RCALL UART1_Write
1295:              #else
1296:                  UART1_Write(data);
1297:              #endif
1298:              }
1299:              
1300:              /**
1301:               * Reads data from the UART rx buffer
1302:               * @return data received from the UART rx buffer
1303:               */
1304:              inline static uint8_t HAL_UART_Read(void)
1305:              {
1306:              #ifdef MCC_MELODY
1307:                  return MCC_UART_Read();
009F46  07FEED     RCALL UART1_Read
1308:              #else
1309:                  return UART1_Read();
1310:              #endif
1311:              }
1312:              
1313:              /**
1314:               * States whether or not the UART rx buffer contains data
1315:               * @return true = UART rx buffer has data false = UART rx buffer does not have data
1316:               */
1317:              inline static bool HAL_UART_IsRxReady(void)
1318:              {
1319:              #ifdef MCC_MELODY
1320:                  return MCC_UART_IsRxReady();
009F42  07FF3E     RCALL UART1_IsRxReady
1321:              #else
1322:                  return UART1_IsRxReady();
1323:              #endif
1324:              }
1325:              
1326:              /**
1327:               * States whether or not the UART tx buffer is ready for more data
1328:               * @return true = UART tx buffer can accept more data false = UART tx buffer can not accept more data
1329:               */
1330:              inline static bool HAL_UART_IsTxReady(void)
1331:              {
1332:              #ifdef MCC_MELODY
1333:                  return MCC_UART_IsTxReady();
009F3E  07FEB7     RCALL UART1_IsTxReady
1334:              #else
1335:                  return UART1_IsTxReady();
1336:              #endif
1337:              }
1338:              
1339:              
1340:              /**
1341:                Sub-section: Watchdog Module Access Functions
1342:              */
1343:              
1344:              /**
1345:              * Clears the Watchdog timer
1346:              */
1347:              inline static void HAL_WATCHDOG_Timer_Clear(void) { WATCHDOG_TimerClear(); }
1348:              
1349:              /**
1350:              * Enables the Watchdog timer
1351:              */
1352:              inline static void HAL_WATCHDOG_Timer_Enable(void) { WATCHDOG_TimerSoftwareEnable(); }
1353:              
1354:              /**
1355:                Sub-section: CORCON Module Access Functions
1356:              */
1357:              
1358:              /**
1359:               * Gets the CORCON register value
1360:               * @return CORCON register value
1361:               */
1362:              inline static uint16_t HAL_CORCON_RegisterValue_Get(void) { return SYSTEM_CORCONRegisterValueGet(); }
1363:              
1364:              /**
1365:               * Sets the value of the CORCON register
1366:               * @param reg_value register value to be set for the CORCON register
1367:               */
1368:              inline static void HAL_CORCON_RegisterValue_Set(uint16_t reg_value) { SYSTEM_CORCONRegisterValueSet(reg_value); }
1369:              
1370:              /**
1371:              * Initializes the CORCON module
1372:              */
1373:              inline static void HAL_CORCON_Initialize(void) { SYSTEM_CORCONModeOperatingSet(CORCON_MODE_ENABLEALLSATNORMAL_ROUNDBIASED); }
1374:              
1375:              /**
1376:                Sub-section: TMR Module Access Functions
1377:              */
1378:              
1379:              /**
1380:              * Starts the profiling timer used to time the various operations
1381:              */
1382:              inline static void HAL_ProfilingCounter_Start(void) {
1383:              #ifdef MCC_MELODY
1384:                  MCC_TMR_PROFILE_Start();
007A50  0712A6     RCALL TMR1_Start
1385:              #else
1386:                  SCCP1_TMR_Start(); 
1387:              #endif    
1388:              }
1389:              
1390:              /**
1391:               * Gets the timer value of the profiling timer
1392:               * @return profiling timer counter value
1393:               */
1394:              inline static uint16_t HAL_ProfilingCounter_Get(void)
1395:              {
1396:              #ifdef MCC_MELODY
1397:                  return MCC_TMR_PROFILE_Counter16BitGet();
1398:              #else
1399:                  return SCCP1_TMR_Counter16BitPrimaryGet();
1400:              #endif    
1401:              }
1402:              
1403:              /**
1404:               * Sets the MCC_TMR_TICK interrupt priority value.
1405:               */
1406:              inline static void HAL_TMR_TICK_InterruptPrioritySet(void)
1407:              {
1408:              #ifdef MCC_MELODY
1409:                  MCC_TMR_TICK_InterruptPrioritySet(MCAF_PRIORITY_TMR);
008226  200040     MOV #0x4, W0
008228  070D2A     RCALL SCCP1_Timer_InterruptPrioritySet
1410:              #else
1411:                  // already configured in SYSTEM_Initialize()
1412:              #endif
1413:              }
1414:              
1415:              /**
1416:               * Overrides the default callback function for the application timer
1417:               * interrupt.
1418:               * @param callback function handle
1419:               */
1420:              inline static void HAL_TMR_TICK_SetCallbackFunction(void (*handler)(void))
1421:              {
1422:              #ifdef MCC_MELODY
1423:                  MCC_TMR_TICK_TimeoutCallbackRegister(handler);
0092A6  29D840     MOV #0x9D84, W0
0092A8  0705D0     RCALL SCCP1_Timer_TimeoutCallbackRegister
1424:              #else
1425:                  // no action required
1426:              #endif
1427:              }
1428:              
1429:              /**
1430:               * Starts the application timer.
1431:               */
1432:              inline static void HAL_TMR_TICK_Start(void)
1433:              {
1434:              #ifdef MCC_MELODY
1435:                  MCC_TMR_TICK_Start();
0080D8  070EB0     RCALL SCCP1_Timer_Start
1436:              #else
1437:                  TMR1_Start();
1438:              #endif
1439:              }
1440:              
1441:              /**
1442:                Sub-section: QEI Module Access Functions
1443:              */
1444:              
1445:              /**
1446:              * Initializes the QEI module
1447:              */
1448:              inline static void HAL_QEI_Initialize(void)
1449:              {
1450:              #ifdef MCC_MELODY
1451:                  // already initialized in SYSTEM_Initialize()
1452:              #else
1453:                  QEI1_Initialize();
1454:              #endif
1455:              }
1456:              
1457:              /**
1458:              * Initializes the QEI position capture mode. This is only used
1459:              * when an encoder index signal is present. 
1460:              */
1461:              inline static void HAL_QEI_PositionCaptureInit(void)
1462:              {
1463:              #ifdef MCC_MELODY        
1464:                  MCC_QEI_CounterModeSet(QEI_MODE_FREE_RUNNING);
1465:                  MCC_QEI_PositionCaptureEnable();
1466:                  MCC_QEI_PositionCaptureSet(0);
1467:              #else
1468:                  QEI_FreeRunningCounterModeSet();
1469:                  QEI_PositionCaptureEventEnable();
1470:                  QEI_PositionCaptureInit();
1471:              #endif    
1472:              }
1473:              
1474:              /**
1475:               * Sets the QEI module range between 0 and (counts_per_rev - 1).
1476:               * 
1477:               */
1478:              inline static void HAL_QEI_CountsPerRevolutionSet(uint16_t counts_per_rev)
1479:              {
1480:              #ifdef MCC_MELODY            
1481:                  MCC_QEI_ModuloRangeSet(counts_per_rev);
1482:              #else    
1483:                  QEI1_ModuloMode16bitSet(counts_per_rev);
1484:              #endif
1485:              }
1486:              
1487:              /**
1488:               * Enables the QEI module.
1489:               */
1490:              inline static void HAL_QEI_Enable(void)
1491:              {
1492:              #ifdef MCC_MELODY
1493:                  MCC_QEI_Enable();
1494:              #else
1495:                  QEI1_ModuleEnable();
1496:              #endif
1497:                  
1498:              }
1499:              
1500:              /**
1501:               * Reads the QEI position count.
1502:               * @return position count value
1503:               */
1504:              inline static uint16_t HAL_QEI_PositionCountGet(void)
1505:              {
1506:              #ifdef MCC_MELODY
1507:                  return MCC_QEI_PositionCount16bitRead();
1508:              #else
1509:                  return QEI1_PositionCount16bitRead();
1510:              #endif    
1511:              }
1512:              
1513:              /**
1514:               * Reads the QEI position capture value. In Capture mode, the input signal is
1515:               * used to capture the contents of the position register into the QEIxIC register.
1516:               * When QEIxIC is used for position capture, an Index match event (QCAPEN = 1)
1517:               * or a Home event (HCAPEN = 1) causes the QEIxIC register to store a copy of
1518:               * the current Position Counter contents.
1519:               * @return position capture value
1520:               */
1521:              inline static uint16_t HAL_QEI_PositionCaptureGet(void)
1522:              {
1523:              #ifdef MCC_MELODY
1524:                  return MCC_QEI_PositionCapture16bitGet();
1525:              #else
1526:                  return QEI_PositionCaptureGet();
1527:              #endif    
1528:              }
1529:              
1530:              
1531:              /**
1532:               * Selects input voltage range for all op-amps.
1533:               */
1534:              inline static void HAL_OpAmpsInputVoltageRangeSelect(void)
1535:              {
1536:              }
1537:              
1538:              
1539:              /**
1540:               * Enables all op-amps
1541:               */
1542:              inline static void HAL_OpAmpsEnable(void) {
1543:              #ifdef MCC_MELODY
1544:                  MCC_OPA_IA_Enable();
1545:                  MCC_OPA_IB_Enable();
1546:                  MCC_OPA_IDC_Enable();
1547:              #else
1548:                  OPA1_Enable();
1549:                  OPA2_Enable();
1550:                  OPA3_Enable();
1551:                  OPA_Enable();
1552:              #endif    
1553:              }
1554:              
1555:              /**
1556:                Sub-section: CMP/DAC Module Access Functions
1557:              */
1558:              
1559:              /**
1560:               * Sets the DAC data value.
1561:               */
1562:              inline static void HAL_CMP_SetComparatorOvercurrentThreshold(const uint16_t dacValue)
1563:              {
1564:              #ifdef MCC_MELODY
1565:                  MCC_CMP_DACDataWrite(dacValue);
008236  20F310     MOV #0xF31, W0
008238  070E2F     RCALL CMP1_DACDataWrite
1566:              #else
1567:                  // already configured in SYSTEM_Initialize()
1568:              #endif
1569:              }
1570:              
1571:              /**
1572:               * Initializes ADC signals
1573:               */
1574:              inline static void HAL_ADC_SignalsInit(void)
1575:              {
1576:                  volatile uint8_t * const trig_sources = (volatile uint8_t *)&ADTRIG0L;
1577:                  
1578:                  enum {
1579:                      NO_TRIGGER = 0x00,
1580:                      PWM1_TRIGGER1 = 0x04,   // DS70005349H page 322
1581:                      PWM1_TRIGGER2 = 0x05    // DS70005349H page 322, trigger source used for reading single channel current
1582:                  };
1583:              
1584:                  trig_sources[10] = NO_TRIGGER;  // MCAF_ADC_PHASEC_CURRENT
00823A  EF6B8A     CLR.B ADTRIG2H
1585:                  trig_sources[22] = NO_TRIGGER;  // MCAF_ADC_PHASEC_VOLTAGE
00823C  EF6B96     CLR.B ADTRIG5H
1586:                  trig_sources[17] = NO_TRIGGER;  // MCAF_ADC_PHASEA_VOLTAGE
00823E  EF6B91     CLR.B 0xB91
1587:                  trig_sources[23] = NO_TRIGGER;  // MCAF_ADC_PHASEB_VOLTAGE
008240  EF6B97     CLR.B 0xB97
1588:                  trig_sources[ 4] = NO_TRIGGER;  // MCAF_ADC_DCLINK_CURRENT
008242  EF6B84     CLR.B ADTRIG1L
1589:                  trig_sources[12] = NO_TRIGGER;  // MCAF_ADC_BRIDGE_TEMPERATURE
008244  EF6B8C     CLR.B ADTRIG3L
1590:                  trig_sources[ 0] = PWM1_TRIGGER1;  // MCAF_ADC_PHASEA_CURRENT
008246  B3C040     MOV.B #0x4, W0
008248  B7EB80     MOV.B WREG, ADTRIG0L
00824A  B7EB81     MOV.B WREG, model_0_features_tree_25
00824C  B7EB8F     MOV.B WREG, 0xB8F
00824E  B7EB8B     MOV.B WREG, 0xB8B
1591:                  trig_sources[ 1] = PWM1_TRIGGER1;  // MCAF_ADC_PHASEB_CURRENT
1592:                  trig_sources[15] = PWM1_TRIGGER1;  // MCAF_ADC_DCLINK_VOLTAGE
1593:                  trig_sources[11] = PWM1_TRIGGER1;  // MCAF_ADC_POTENTIOMETER
1594:              }
1595:              
1596:              #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
1597:              // Suppress warning for use of deprecated functions here
1598:              
1599:              /**
1600:               * Initializes ADC resolution
1601:               */
1602:              inline static void HAL_ADC_ResolutionInit(void) {
1603:                  // 12-bit ADC
1604:                  const uint16_t resolution_id = 3;
1605:              #ifdef MCC_MELODY
1606:                  MCC_ADC_ResolutionSet(resolution_id);
1607:              #else    
1608:                  ADC1_Core0ResolutionModeSet(resolution_id);
1609:                  ADC1_Core1ResolutionModeSet(resolution_id);
1610:                  ADC1_SharedCoreResolutionModeSet(resolution_id);
1611:              #endif
1612:              }
1613:              
1614:              #pragma GCC diagnostic warning "-Wdeprecated-declarations"
1615:              
1616:              // Internal use only within this file: set PWM mode of a PWM generator from PG1-PG4
1617:              inline static void HAL_PWM_ModeSetGenerator(uint16_t generator, uint16_t mode)
1618:              {
1619:                  switch (generator)
1620:                  {
1621:                      case 1:
1622:                          PG1CONLbits.MODSEL = mode;
1623:                          break;
1624:                      case 2:
1625:                          PG2CONLbits.MODSEL = mode;
1626:                          break;
1627:                      case 3:
1628:                          PG3CONLbits.MODSEL = mode;
1629:                          break;
1630:                      case 4:
1631:                          PG4CONLbits.MODSEL = mode;
1632:                          break;
1633:                  }
1634:              }
1635:              
1636:              /**
1637:               * Set PWM mode bits
1638:               *
1639:               *
1640:               * @param mode desired MODSEL value
1641:               */
1642:              inline static void HAL_PWM_ModeSet(uint16_t mode)
1643:              {
1644:              #ifdef MCC_MELODY
1645:                  MCC_PWM_ModeSet(MOTOR1_PHASE_A, mode);
1646:                  MCC_PWM_ModeSet(MOTOR1_PHASE_B, mode);
1647:                  MCC_PWM_ModeSet(MOTOR1_PHASE_C, mode);
1648:              #else
1649:                  HAL_PWM_ModeSetGenerator(MOTOR1_PHASE_A, mode);
1650:                  HAL_PWM_ModeSetGenerator(MOTOR1_PHASE_B, mode);
1651:                  HAL_PWM_ModeSetGenerator(MOTOR1_PHASE_C, mode);
1652:              #endif    
1653:              }
1654:              
1655:              /** Set PWM mode to center-aligned single update */
1656:              inline static void HAL_PWM_ModeSingleUpdate(void)
1657:              {    
1658:                  const uint16_t mode = 0x4;
1659:                  HAL_PWM_ModeSet(mode);
1660:              }
1661:              
1662:              /** Set PWM mode to center-aligned double update */
1663:              inline static void HAL_PWM_ModeDoubleUpdate(void)
1664:              {
1665:                  const uint16_t mode = 0x5;
1666:                  HAL_PWM_ModeSet(mode);
1667:              }
1668:              
1669:              /** Set PWM mode to dual edge center-aligned updated once per cycle*/
1670:              inline static void HAL_PWM_ModeDualEdgeSingleUpdate(void)
1671:              {
1672:                  const uint16_t mode = 0x6;
1673:                  HAL_PWM_ModeSet(mode);
1674:              }
1675:              
1676:              // Internal use only within this file: set PWM master phase select of a PWM generator from PG1-PG4
1677:              inline static void HAL_PWM_MasterPhaseSelectGenerator(uint16_t generator, uint16_t select)
1678:              {
1679:                  switch (generator)
1680:                  {
1681:                      case 1:
1682:                          PG1CONHbits.MPHSEL = select;
1683:                          break;
1684:                      case 2:
1685:                          PG2CONHbits.MPHSEL = select;
1686:                          break;
1687:                      case 3:
1688:                          PG3CONHbits.MPHSEL = select;
1689:                          break;
1690:                      case 4:
1691:                          PG4CONHbits.MPHSEL = select;
1692:                          break;
1693:                  }
1694:              }
1695:              
1696:              /** 
1697:               * Controls PWM phase either from master or local data
1698:               * @param select master(1) or local(0) phase control
1699:               */
1700:              inline static void HAL_PWM_MasterPhaseSelect(uint16_t select)
1701:              {
1702:              #ifdef MCC_MELODY
1703:                  MCC_PWM_PhaseSelect(MOTOR1_PHASE_A, select);
1704:                  MCC_PWM_PhaseSelect(MOTOR1_PHASE_B, select);
1705:                  MCC_PWM_PhaseSelect(MOTOR1_PHASE_C, select);
1706:              #else
1707:                  HAL_PWM_MasterPhaseSelectGenerator(MOTOR1_PHASE_A, select);
1708:                  HAL_PWM_MasterPhaseSelectGenerator(MOTOR1_PHASE_B, select);
1709:                  HAL_PWM_MasterPhaseSelectGenerator(MOTOR1_PHASE_C, select);
1710:              #endif
1711:              }
1712:              
1713:              /** Enable PWM phase control from master (common) register*/
1714:              inline static void HAL_PWM_SelectMasterPhase(void)
1715:              {
1716:                  HAL_PWM_MasterPhaseSelect(1);
1717:              }
1718:              
1719:              /** Enable PWM phase control from local (independent) register */
1720:              inline static void HAL_PWM_SelectLocalPhase(void)
1721:              {
1722:                  HAL_PWM_MasterPhaseSelect(0);
1723:              }
1724:              
1725:              /** Enable ADC Trigger 1 for compare event with PGxTRIGA */
1726:              inline static void HAL_PWM_ADCTrigger1AEnable(void)
1727:              {
1728:              #ifdef MCC_MELODY
1729:                  MCC_PWM_Trigger1Enable(MOTOR1_PHASE_A, PWM_TRIGGER_COMPARE_A);
1730:              #else
1731:                  PG1EVTLbits.ADTR1EN1 = 1;
1732:              #endif
1733:              }
1734:              
1735:              /** Enable ADC Trigger 2 for compare event with PGxTRIGB */
1736:              inline static void HAL_PWM_ADCTrigger2BEnable(void)
1737:              {
1738:              #ifdef MCC_MELODY
1739:                  MCC_PWM_Trigger2Enable(MOTOR1_PHASE_A, PWM_TRIGGER_COMPARE_B);
1740:              #else
1741:                  PG1EVTHbits.ADTR2EN2 = 1;
1742:              #endif
1743:              }
1744:              
1745:              /** Disable ADC Trigger 2 for compare event with PGxTRIGB */
1746:              inline static void HAL_PWM_ADCTrigger2BDisable(void)
1747:              {
1748:              #ifdef MCC_MELODY
1749:                  MCC_PWM_Trigger2Disable(MOTOR1_PHASE_A, PWM_TRIGGER_COMPARE_B);
1750:              #else
1751:                  PG1EVTHbits.ADTR2EN2 = 0;
1752:              #endif
1753:              }
1754:              
1755:              /** Enable ADC Trigger 2 for compare event with PGxTRIGC */
1756:              inline static void HAL_PWM_ADCTrigger2CEnable(void)
1757:              {
1758:              #ifdef MCC_MELODY
1759:                  MCC_PWM_Trigger2Enable(MOTOR1_PHASE_A, PWM_TRIGGER_COMPARE_C);
1760:              #else
1761:                  PG1EVTHbits.ADTR2EN3 = 1;
1762:              #endif
1763:              }
1764:              
1765:              /** Disable ADC Trigger 2 for compare event with PGxTRIGC */
1766:              inline static void HAL_PWM_ADCTrigger2CDisable(void)
1767:              {
1768:              #ifdef MCC_MELODY
1769:                  MCC_PWM_Trigger2Disable(MOTOR1_PHASE_A, PWM_TRIGGER_COMPARE_C);
1770:              #else
1771:                  PG1EVTHbits.ADTR2EN3 = 0;
1772:              #endif
1773:              }
1774:              
1775:              /** Set Priority for Bus Current AN Interrupt */
1776:              inline static void HAL_ADC_BusCurrentInterruptPrioritySet(void)
1777:              {
1778:                  // no action required
1779:              }
1780:              
1781:              inline static void HAL_PWM_SetADCDualTrigger(int16_t a, int16_t b)
1782:              {
1783:              #ifdef MCC_MELODY
1784:                  MCC_PWM_TriggerBCompareValueSet(MOTOR1_PHASE_A, a);
1785:                  MCC_PWM_TriggerCCompareValueSet(MOTOR1_PHASE_A, b);
1786:              #else
1787:                  PWM_TriggerBCompareValueSet(MOTOR1_PHASE_A, a);
1788:                  PWM_TriggerCCompareValueSet(MOTOR1_PHASE_A, b);
1789:              #endif
1790:              }
1791:              
1792:              /**
1793:              * Re-configures UART IO
1794:              * <code>
1795:              * HAL_UART_ReconfigureIoMapping();
1796:              * </code>
1797:              */
1798:              inline static void HAL_UART_ReconfigureIoMapping(void)
1799:              {
1800:                  // no action required
1801:              }
1802:              
1803:              /**
1804:               * Set all interrupt priorities.
1805:               */
1806:              inline static void HAL_InterruptPrioritySet(void)
1807:              {
1808:                  HAL_TMR_TICK_InterruptPrioritySet();
1809:                  HAL_ADC_IndividualChannelInterruptPrioritySet();
1810:                  if (MCAF_SingleChannelEnabled())
1811:                  {
1812:                      HAL_ADC_BusCurrentInterruptPrioritySet();
1813:                  }
1814:              }
1815:              
1816:              #ifdef __cplusplus
1817:              }
1818:              #endif
1819:              
1820:              #endif /* __HAF_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/hal/hardware_access_functions.c
1:                 /**
2:                  *  hardware_access_functions.c
3:                  *
4:                  *  This module provides hardware access function support.
5:                  *
6:                  *  Component: HAL
7:                  */
8:                  
9:                 /*
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 *
46:                 ******************************************************************************/
47:                 
48:                #include <string.h>
49:                #include <stdbool.h>
50:                #include "hardware_access_functions.h"
51:                
52:                volatile HAL_DATA_T halData;
53:                
54:                /*****************************************************************************/
55:                /* Section: HAF board functions                                              */
56:                /*****************************************************************************/
57:                
58:                void HAL_ADC_StepIsrCallback(void)
59:                {
60:                 
61:                    
62:                }
009FC0  060000     RETURN
63:                
64:                void HAL_Initialize(void)
65:                {
66:                }
009FC2  060000     RETURN
009FC4  060000     RETURN
67:                
68:                bool HAL_DMA_ErrorHandler(void)
69:                {  
70:                    static uint16_t DMA_ErrorCount = 0;
71:                    
72:                    ++DMA_ErrorCount;
000000  040200     GOTO __resetPRI, __reset
73:                    return false;
74:                }
000002  000000     NOP
000006  000B2E     NOP
000008  000B4A     NOP
75:                
76:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/foc.h
1:                 /**
2:                  * foc.h
3:                  * 
4:                  * Module to include field-oriented-control functions
5:                  * 
6:                  * Component: FOC
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __FOC_H
48:                #define __FOC_H
49:                
50:                #include <stdbool.h>
51:                #include "system_state.h"
52:                #include "hal.h"
53:                
54:                #ifdef __cplusplus
55:                extern "C" {
56:                #endif
57:                
58:                /**
59:                 * Initialize FOC state variables
60:                 * 
61:                 * @param pmotor motor state
62:                 * @return <code>true</code> if the function succeeds
63:                 */
64:                bool MCAF_FocInit(MCAF_MOTOR_DATA *pmotor);
65:                
66:                /**
67:                 * Executes forward-path signal calculations of field-oriented control.
68:                 * Includes control loops and forward modulation (Park, Clarke, SVM/ZSM)
69:                 * 
70:                 * @param pmotor motor state
71:                 */
72:                void MCAF_FocStepIsrForwardPath(MCAF_MOTOR_DATA *pmotor);
73:                
74:                /**
75:                 * Executes feedback-path signal calculations of field-oriented control.
76:                 * Includes Park, Clarke transforms, estimators, and sine/cosine calculations.
77:                 * 
78:                 * @param pmotor motor state 
79:                 */
80:                void MCAF_FocStepIsrFeedbackPath(MCAF_MOTOR_DATA *pmotor);
81:                
82:                /**
83:                 * Executes non-critical tasks towards the end of the ISR
84:                 * 
85:                 * @param pmotor motor state
86:                 */
87:                void MCAF_FocStepIsrNonCriticalTask(MCAF_MOTOR_DATA *pmotor);
88:                
89:                /**
90:                 * Executes required calculations for FOC in the main loop.
91:                 * 
92:                 * @param pmotor motor state.
93:                 */
94:                void MCAF_FocStepMain(MCAF_MOTOR_DATA *pmotor);
95:                
96:                /**
97:                 * Executes one step of offset calibration
98:                 * 
99:                 * @param pmotor motor data
100:                */
101:               void MCAF_FocCalibrateCurrentOffsets(MCAF_MOTOR_DATA *pmotor);
102:               
103:               /**
104:                * Reads the ADC channels for FOC.
105:                * 
106:                * This should occur at the beginning of the ADC ISR.
107:                * Reads the dedicated S&H for A- and B-phase currents,
108:                * then the mux'd ADC channel.
109:                * 
110:                * @param pmotor motor data structure
111:                */
112:               void MCAF_FocReadADC(MCAF_MOTOR_DATA *pmotor);
113:               
114:               /**
115:                * Initialize integrators at startup
116:                * 
117:                * @param pmotor motor data structure
118:                */
119:               inline static void MCAF_FocInitializeIntegrators(MCAF_MOTOR_DATA *pmotor)
120:               {
121:                   /* zero out integrators */
122:                   pmotor->idCtrl.integrator = 0;
004CC0  B80060     MUL.UU W0, #0x0, W0
004CC2  980C60     MOV W0, [W8+28]
004CC4  980C71     MOV W1, [W8+30]
004E10  B80060     MUL.UU W0, #0x0, W0
004E12  980C60     MOV W0, [W8+28]
004E14  980C71     MOV W1, [W8+30]
123:                   pmotor->iqCtrl.integrator = 0;
004CC6  981470     MOV W0, [W8+46]
004CC8  981C01     MOV W1, [W8+48]
004E16  981470     MOV W0, [W8+46]
004E18  981C01     MOV W1, [W8+48]
124:                   pmotor->omegaCtrl.integrator = 0;    
004CCA  993400     MOV W0, [W8+352]
004CCC  993411     MOV W1, [W8+354]
004E1A  993400     MOV W0, [W8+352]
004E1C  993411     MOV W1, [W8+354]
004E1E  370065     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
125:               }
126:               
127:               /**
128:                * Reinitialize motor controllers on restart
129:                * (when exiting error / debug states)
130:                * @param pmotor motor data structure
131:                */
132:               inline static void MCAF_FocRestart(MCAF_MOTOR_DATA *pmotor)
133:               {
134:                   pmotor->initialization.ready = false;
004B7E  203440     MOV #0x344, W0
004B80  400008     ADD W0, W8, W0
004B82  EB4800     CLR.B [W0]
004E00  203441     MOV #0x344, W1
004E02  408088     ADD W1, W8, W1
004E04  784880     MOV.B W0, [W1]
0079DE  203440     MOV #0x344, W0
0079E0  400008     ADD W0, W8, W0
0079E2  784809     MOV.B W9, [W0]
135:                   if (pmotor->initialization.faultLatchDelay == 0)
004B84  932018     MOV [W8+834], W0
004B86  E00000     CP0 W0
004B88  3A0002     BRA NZ, MCAF_UiRestart
004E06  932018     MOV [W8+834], W0
004E08  E00000     CP0 W0
004E0A  3A0002     BRA NZ, MCAF_FocInitializeIntegrators
0079E4  932018     MOV [W8+834], W0
0079E6  E00000     CP0 W0
0079E8  3A0002     BRA NZ, MCAF_UiRestart
136:                   {
137:                       pmotor->initialization.faultLatchDelay = 1;
004B8A  200010     MOV #0x1, W0
004B8C  9B2410     MOV W0, [W8+834]
004E0C  200010     MOV #0x1, W0
004E0E  9B2410     MOV W0, [W8+834]
0079EA  200010     MOV #0x1, W0
0079EC  9B2410     MOV W0, [W8+834]
138:                   }
139:               }
140:               
141:               /**
142:                * Returns whether the ADC initialization is ready
143:                *
144:                * @param pmotor motor data structure
145:                * @return true if ADC initialization is ready
146:                */
147:               inline static bool MCAF_ADCInitializationReady(const MCAF_MOTOR_DATA *pmotor)
148:               {
149:                   return pmotor->initialization.ready;
004A5C  203440     MOV #0x344, W0
004A5E  400008     ADD W0, W8, W0
004B0C  203440     MOV #0x344, W0
004B0E  400008     ADD W0, W8, W0
0092AC  203443     MOV #0x344, W3
0092AE  418181     ADD W3, W1, W3
150:               }
151:               
152:               /**
153:                * Returns whether the HW overcurrent flag is valid
154:                * 
155:                * @param pmotor motor state data
156:                * @return true if HW overcurrent flag is valid
157:                */
158:               inline static bool MCAF_OvercurrentHWFlagValid(const MCAF_MOTOR_DATA *pmotor)
159:               {
160:                   return pmotor->initialization.faultLatchDelay == 0;
004BEC  932018     MOV [W8+834], W0
004E20  932018     MOV [W8+834], W0
161:               }
162:               /**
163:                * Clears HW flag when it is possible to do so.
164:                * This requires a delay straddling one or more PWM cycles.
165:                * Call only once per PWM cycle.
166:                * 
167:                * @param pmotor motor state data
168:                */
169:               inline static void MCAF_OvercurrentHWFlagAttemptClear(MCAF_MOTOR_DATA *pmotor)
170:               {
171:                   if (--pmotor->initialization.faultLatchDelay == 0)
004BF2  E90000     DEC W0, W0
004BF4  9B2410     MOV W0, [W8+834]
004BF6  3A0179     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004E26  E90000     DEC W0, W0
004E28  9B2410     MOV W0, [W8+834]
004E2A  3A005F     BRA NZ, MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
172:                   {
173:                       /* Two step fault clearing process is required for EP devices. 
174:                          Occurs during PWM cycle at which fault was detected
175:                          Step 1: Disable fault mode latch
176:                          Occurs at the next PWM period
177:                          Step 2: Enable fault mode latch and clear fault interrupt flag
178:                       */
179:                       HAL_PWM_FaultStatus_Clear();
180:                       HAL_PWM_FaultClearEnd();
181:                   }    
182:               }
183:               
184:               
185:               #ifdef __cplusplus
186:               }
187:               #endif
188:               
189:               #endif /* __FOC_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/foc.c
1:                 /**
2:                  * foc.c
3:                  * 
4:                  * main field-oriented-control code
5:                  * 
6:                  * Component: FOC
7:                  */
8:                 
9:                 #include "filter.h"
10:                
11:                
12:                /* *********************************************************************
13:                 *
14:                 * Motor Control Application Framework
15:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
16:                 *
17:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
18:                 * this software and any derivatives exclusively with Microchip products.
19:                 *
20:                 * This software and any accompanying information is for suggestion only.
21:                 * It does not modify Microchip's standard warranty for its products.
22:                 * You agree that you are solely responsible for testing the software and
23:                 * determining its suitability.  Microchip has no obligation to modify,
24:                 * test, certify, or support the software.
25:                 *
26:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
27:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
28:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
29:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
30:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
31:                 * APPLICATION.
32:                 *
33:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
34:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
35:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
36:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
37:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
38:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
39:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
41:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
42:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
43:                 * SOFTWARE.
44:                 *
45:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
46:                 * THESE TERMS.
47:                 *
48:                 * *****************************************************************************/
49:                
50:                #include <stdint.h>
51:                #include <stddef.h>
52:                #include "util.h"
53:                #include "adc_compensation.h"
54:                #include "parameters/sat_PI_params.h"
55:                #include "parameters/foc_params.h"
56:                #include "parameters/hal_params.h"
57:                #include "parameters/motor_params.h"
58:                #include "parameters/timing_params.h"
59:                #include "parameters/outerloop_params.h"
60:                #include "parameters/options.h"
61:                #include "motor_control.h"
62:                #include "motor_control_function_mapping.h"
63:                #include "system_state.h"
64:                #include "foc.h"
65:                #include "commutation.h"
66:                #include "startup.h"
67:                #include "math_asm.h"
68:                #include "sat_PI.h"
69:                #include "hal.h"
70:                #include "deadtimecomp.h"
71:                #include "flux_control.h"
72:                #include "dyn_current.h"
73:                #include "test_harness.h"
74:                #include "mcapi_internal.h"
75:                #include "commutation_excitation.h"
76:                #include "current_measure.h"
77:                
78:                /* ------------------------- Initialization ------------------------- */
79:                
80:                int16_t MCAF_ComputeReciprocalDCLinkVoltage(int16_t vdc);
81:                
82:                /** 
83:                 * Initializes required parameters 
84:                 * 
85:                 * @param pmotor motor data
86:                 */
87:                inline static void initStateParameters(MCAF_MOTOR_DATA *pmotor)
88:                {
89:                
90:                    /* ============= Open Loop Startup ====================== */
91:                    MCAF_StartupTransitioningInit(&pmotor->startup);
007CA4  2019C0     MOV #0x19C, W0
007CA6  400008     ADD W0, W8, W0
007CA8  0708F0     RCALL MCAF_StartupTransitioningInit
92:                
93:                    MCAF_ADCCompensationInit(&pmotor->initialization,
007CAA  2031C1     MOV #0x31C, W1
007CAC  408088     ADD W1, W8, W1
007CAE  203300     MOV #0x330, W0
007CB0  400008     ADD W0, W8, W0
007CB2  070C2C     RCALL MCAF_ADCCompensationInit
94:                                             &pmotor->currentCalibration); 
95:                    MCAF_FluxControlInit(&pmotor->fluxControl);        
96:                
97:                    pmotor->rVdc = MCAF_ComputeReciprocalDCLinkVoltage(INT16_MAX);
007CBC  989C60     MOV W0, [W8+188]
98:                    
99:                    MCAF_InitializeCurrentFilter(pmotor);
100:               #if MCAF_TRIGGERED_AVERAGE_EXAMPLE == 1
101:                   const uint16_t sampleCount = 256;  // Take 256 samples per averaging routine
102:                   const uint16_t shiftCount = 8;     // Right-shift by 8 (equivalent to dividing by 256)
103:                   MCAF_TriggeredAverage_Init(&pmotor->iqAverage, sampleCount, shiftCount);
104:               #endif
105:               }
106:               
107:               /**
108:                * Initialize controller state
109:                * 
110:                * @param pmotor motor data
111:                */
112:               inline static void initControlLoopState(MCAF_MOTOR_DATA *pmotor)
113:               {
114:                   pmotor->idCtrl.integrator = 0;
007C88  B85560     MUL.UU W10, #0x0, W10
007C8A  980C6A     MOV W10, [W8+28]
007C8C  980C7B     MOV W11, [W8+30]
115:                   pmotor->iqCtrl.integrator = 0;
007C8E  98147A     MOV W10, [W8+46]
007C90  981C0B     MOV W11, [W8+48]
116:                   pmotor->omegaCtrl.integrator = 0;
007C92  99340A     MOV W10, [W8+352]
007C94  99341B     MOV W11, [W8+354]
117:                   pmotor->vdqCmd.d = 0;
007C96  989439     MOV W9, [W8+166]
118:                   pmotor->vdqCmd.q = 0;
007C98  989449     MOV W9, [W8+168]
119:                   pmotor->idqCmdRaw.d = 0;
007C9A  780C09     MOV W9, [W8]
120:                   pmotor->idqCmdRaw.q = 0;
007C9C  980419     MOV W9, [W8+2]
121:               }
122:               
123:               
124:               /**
125:                * Initialize motor parameters
126:                * 
127:                * @param pparam motor parameters
128:                */
129:               inline static void initMotorParameters(MCAF_MOTOR_PARAMETERS_T *pparam)
130:               {
131:                   pparam->rs = MCAF_MOTOR_RS;
007C48  22E470     MOV #0x2E47, W0
007C4A  983C00     MOV W0, [W8+112]
132:                   
133:                   pparam->ldBaseDt = MCAF_MOTOR_LD_BASE_DT;
007C4C  236C20     MOV #0x36C2, W0
007C4E  983C30     MOV W0, [W8+118]
134:                   pparam->lqBaseDt = MCAF_MOTOR_LQ_BASE_DT;
007C50  233290     MOV #0x3329, W0
007C52  983C40     MOV W0, [W8+120]
135:                   pparam->l0BaseDt = MCAF_MOTOR_L0_BASE_DT;
007C54  234F60     MOV #0x34F6, W0
007C56  983C10     MOV W0, [W8+114]
136:                   pparam->l1BaseDt = MCAF_MOTOR_L1_BASE_DT;
007C58  201CC0     MOV #0x1CC, W0
007C5A  983C20     MOV W0, [W8+116]
137:                   
138:                   pparam->ldBaseOmegaE = MCAF_MOTOR_LD_BASE_OMEGA_E;
007C5C  235C20     MOV #0x35C2, W0
007C5E  983C70     MOV W0, [W8+126]
139:                   pparam->lqBaseOmegaE = MCAF_MOTOR_LQ_BASE_OMEGA_E;
007C60  2323A0     MOV #0x323A, W0
007C62  988400     MOV W0, [W8+128]
140:                   pparam->l0BaseOmegaE = MCAF_MOTOR_L0_BASE_OMEGA_E;
007C64  233FE0     MOV #0x33FE, W0
007C66  983C50     MOV W0, [W8+122]
141:                   pparam->l1BaseOmegaE = MCAF_MOTOR_L1_BASE_OMEGA_E;
007C68  201C40     MOV #0x1C4, W0
007C6A  983C60     MOV W0, [W8+124]
142:                   
143:                   pparam->ke = MCAF_MOTOR_KE;
007C6C  204A60     MOV #0x4A6, W0
007C6E  988410     MOV W0, [W8+130]
144:                   pparam->keInverse = MCAF_MOTOR_KE_INVERSE;
007C70  237110     MOV #0x3711, W0
007C72  988420     MOV W0, [W8+132]
145:               }
146:               
147:               bool MCAF_FocInit(MCAF_MOTOR_DATA *pmotor)
148:               {
007C42  BE9F88     MOV.D W8, [W15++]
007C44  BE9F8A     MOV.D W10, [W15++]
007C46  780400     MOV W0, W8
149:                   initMotorParameters(&pmotor->motorParameters);
150:                       
151:                   pmotor->config.deadTimeCompensationVoltageDelay = MCAF_DEAD_TIME_COMPENSATION_VOLTAGE_DELAY;
007C74  EB0480     CLR W9
007C76  9B2439     MOV W9, [W8+838]
152:                   // delay for matching current and voltage timeskew
153:                   
154:                   MCAF_DeadTimeCompensationInit(&pmotor->deadTimeCompensation);
155:                   MCAF_DynamicCurrentLimitInit(&pmotor->dynLimit);
156:                   
157:                   int i;
158:                   for (i = 0; i < 3; ++i)
159:                   {
160:                       pmotor->dalphabetaOut[i].alpha = 0;
007C7C  98AC09     MOV W9, [W8+208]
007C80  98AC29     MOV W9, [W8+212]
007C84  98AC49     MOV W9, [W8+216]
161:                       pmotor->dalphabetaOut[i].beta  = 0;
007C7E  98AC19     MOV W9, [W8+210]
007C82  98AC39     MOV W9, [W8+214]
007C86  98AC59     MOV W9, [W8+218]
162:                   }
163:               
164:                   initControlLoopState(pmotor);
165:               
166:                   pmotor->controlFlags = 0;    
007C9E  998419     MOV W9, [W8+386]
167:                   pmotor->standardInputs.stateFlags = 0;
007CA0  983469     MOV W9, [W8+108]
168:                   
169:                   /* initialize the mux'd channel (doesn't matter which setting is first) */
170:                   pmotor->adcSelect = HADC_POTENTIOMETER;
007CA2  998439     MOV W9, [W8+390]
171:                   
172:                   initStateParameters(pmotor);
173:                   
174:                   MCAF_SatInit(&pmotor->sat);
007CD6  203020     MOV #0x302, W0
007CD8  400008     ADD W0, W8, W0
007CDA  070F91     RCALL MCAF_SatInit
175:                   return true;
176:               }
007CDC  B3C010     MOV.B #0x1, W0
007CDE  BE054F     MOV.D [--W15], W10
007CE0  BE044F     MOV.D [--W15], W8
007CE2  060000     RETURN
177:               
178:               /* ------------------------- Runtime ------------------------- */
179:               
180:               /*
181:                * 1. Feedback path
182:                */
183:               
184:               inline static void estimateBackEMF(MCAF_MOTOR_DATA *pmotor)
185:               {
186:                   MC_ALPHABETA_T  fluxAlphaBeta;     /* Flux in alpha-beta */
187:                   MCAF_STANDARD_INPUT_SIGNALS_T  *pinput     = &pmotor->standardInputs;
188:                   MCAF_BACKEMF_CALCULATION_T     *pemf       = &pmotor->backEMF;
189:                   const MCAF_U_CURRENT_ALPHABETA *ialphabeta = &pinput->ialphabeta;
190:                   const MCAF_U_VOLTAGE_ALPHABETA *valphabeta = &pinput->valphabeta;
191:               
192:                   const MCAF_U_STATOR_RESISTANCE rs = pmotor->motorParameters.rs;
193:                   const MCAF_U_STATOR_RESISTANCE l0 = pmotor->motorParameters.l0BaseDt;
194:                   const MCAF_U_STATOR_RESISTANCE l1 = pmotor->motorParameters.l1BaseDt;
195:                   
196:                   if (MCAF_IsMotorSaliencySignificant())
197:                   {
198:                       const int16_t twoTheta = pmotor->thetaElectrical << 1;
199:                       MC_CalculateSineCosine_InlineC_Ram(twoTheta, &pemf->sincos2Theta);
200:                       pemf->l1Cos2Theta = UTIL_MulQ15(l1, pemf->sincos2Theta.cos);
201:                       pemf->l1Sin2Theta = UTIL_MulQ15(l1, pemf->sincos2Theta.sin);
202:               
203:                       pemf->laa = l0 + pemf->l1Cos2Theta;
204:                       pemf->lab = pemf->l1Sin2Theta;
205:                       pemf->lba = pemf->l1Sin2Theta;
206:                       pemf->lbb = l0 - pemf->l1Cos2Theta;
207:                   }
208:               
209:                   /*
210:                    * Stator voltage equations:
211:                    * Valpha = Rs * Ialpha + d/dt(Ls * Ialpha) + BEMFalpha
212:                    * Vbeta = Rs * Ibeta + d/dt(Ls * Ibeta) + BEMFbeta
213:                    *
214:                    * For motors with saliency, this is a matrix equation:
215:                    *
216:                    *   Vs = Rs*Is + d/dt(Ls*Is) + BEMFs
217:                    * 
218:                    * where Vs, Is, and BEMFs are vectors with alpha and beta components;
219:                    * Ls is a 2x2 matrix.
220:                    */
221:                   /* The stator voltages are scaled down with a factor of two to avoid 
222:                    * overflow/saturation of BEMF calculations in a few corner cases.
223:                    * Accordingly, the shift count for flux and voltage calculations is
224:                    * increased by 1 to match the number system */
225:               
226:                   pemf->lastValphabeta.alpha = valphabeta->alpha >> 1;
227:                   pemf->lastValphabeta.beta = valphabeta->beta >> 1;
228:               
229:                   /*
230:                    * Compute flux linkage L*I in stationary (alpha-beta) frame
231:                    * due to inductance and the current vector.
232:                    *
233:                    * For motors with significant saliency, L is a 2x2 matrix.
234:                    * 
235:                    * Otherwise just assume isotropic inductance
236:                    * and multiply the current vector by the scalar L0.
237:                    * (This saves CPU cycles.)
238:                    *
239:                    * The check for significant saliency is performed at compile-time
240:                    * and the compiler can optimize out the branch not taken, 
241:                    * to reduce CPU and program memory usage.
242:                    */
243:                   if (MCAF_IsMotorSaliencySignificant())
244:                   {
245:                       fluxAlphaBeta.alpha = UTIL_SatShrS16((__builtin_mulss(pemf->laa, ialphabeta->alpha) +
246:                                       __builtin_mulss(pemf->lab, ialphabeta->beta)), (MCAF_MOTOR_LMAX_BASE_DT_Q + 1));
247:               
248:                       fluxAlphaBeta.beta = UTIL_SatShrS16((__builtin_mulss(pemf->lba, ialphabeta->alpha) +
249:                                       __builtin_mulss(pemf->lbb, ialphabeta->beta)), (MCAF_MOTOR_LMAX_BASE_DT_Q + 1));
250:                   }
251:                   else
252:                   {
253:                       fluxAlphaBeta.alpha =
254:                       UTIL_SatShrS16(__builtin_mulss(l0, ialphabeta->alpha), (MCAF_MOTOR_LMAX_BASE_DT_Q + 1));
255:               
256:                       fluxAlphaBeta.beta =
257:                       UTIL_SatShrS16(__builtin_mulss(l0, ialphabeta->beta), (MCAF_MOTOR_LMAX_BASE_DT_Q + 1));
258:                   }
259:                   
260:                   /* 
261:                    * Calculate voltage drop in stationary (alpha-beta) frame
262:                    * due to inductance and change in current.
263:                    *
264:                    *   vInductance = d/dt(Ls*Is)
265:                    *
266:                    * The discrete-time calculation of this voltage is
267:                    *
268:                    *   vInductance = (fluxAlphaBeta[k] - fluxAlphaBeta[k-1]) / delta_t
269:                    *
270:                    * where fluxAlphaBeta = Ls*Is.
271:                    *
272:                    * When evaluating this expression in fixed-point,
273:                    * we use an implicit factor of delta_t = 1 (per-unit)
274:                    * to eliminate the need for an additional divide by delta_t.
275:                    * This adds constraints on the fixed-point representations 
276:                    * current, flux, voltage, and inductance.
277:                    *
278:                    * For example, suppose the normalization factors are
279:                    *
280:                    *   current (I):      8.8  A
281:                    *   time:            50.0  us    (= timestep)
282:                    *   voltage (V):     52.8  V
283:                    *   dI/dt:          176.0  A/ms   = 8.8A / 50us
284:                    *   inductance (L): 300.0  uH     = (52.8V * 50us)/8.8A
285:                    *   L/t:              6.0  ohm    = 52.8V / 8.8A
286:                    *   flux (V*t):       2.64 mVs    = 52.8V * 50us
287:                    *
288:                    * and the motor has Ls = 450uH with no saliency.
289:                    * Furthermore, suppose Ialpha changes from 0.44A to 0.99A in one timestep.
290:                    *   
291:                    * Normalized (or "per-unit") calculations are:
292:                    *
293:                    * Ls              = 1.5
294:                    *                 = 450uH (= 1.5 * 300uH)
295:                    * Ialpha[k-1]     = 0.05
296:                    *                 = 0.44A (= 0.05 * 8.8A)
297:                    * Ialpha[k]       = 0.1125
298:                    *                 = 0.99A (= 0.1125 * 8.8A)
299:                    * flux[k-1]       = 0.075
300:                    *                 = 0.198mVs (= 0.075*2.64mVs = 450uH*0.44A)
301:                    * flux[k]         = 0.16875
302:                    *                 = 0.4455mVs (= 0.16875*2.64mVs = 450uH*0.99A)
303:                    * delta_flux      = 0.09375  (= 0.16875-0.075)
304:                    *                 = 247.5uVs (= 0.09375 * 2.64mVs)
305:                    * vInductance     = 0.09375
306:                    *                 = 4.95V (= 0.09375 * 52.8V = 247.5uVs / 50us)
307:                    *
308:                    *                 = (flux[k] - flux[k-1]) / delta_t
309:                    *                 = (flux[k] - flux[k-1])
310:                    *
311:                    * (flux and vInductance in this contrived example
312:                    *  are the alpha components)
313:                    *
314:                    * Note that calculations that vary by a factor of delta_t
315:                    * have identical per-unit values, even though
316:                    * their actual units are different.
317:                    * (For example vInductance = 0.09375 = delta_flux)
318:                    */ 
319:                   pemf->vInductance.alpha = fluxAlphaBeta.alpha - 
320:                                                       pemf->lastFluxalphabeta.alpha;
321:               
322:                   pemf->vInductance.beta = fluxAlphaBeta.beta - 
323:                                                       pemf->lastFluxalphabeta.beta;
324:               
325:                   pemf->irDrop.alpha = UTIL_SatShrS16(__builtin_mulss(rs, ialphabeta->alpha),
326:                                                                                      (MCAF_MOTOR_RS_Q + 1));
327:               
328:                   pemf->irDrop.beta = UTIL_SatShrS16(__builtin_mulss(rs, ialphabeta->beta),
329:                                                                                      (MCAF_MOTOR_RS_Q + 1));
330:               
331:                   pinput->ealphabeta.alpha = pemf->lastValphabeta.alpha -
332:                                              pemf->vInductance.alpha -
333:                                              pemf->irDrop.alpha;
334:               
335:                   pinput->ealphabeta.beta = pemf->lastValphabeta.beta -
336:                                             pemf->vInductance.beta -
337:                                             pemf->irDrop.beta;
338:               
339:                   /* update  LastIalpha and LastIbeta */
340:               
341:                   pemf->lastFluxalphabeta.alpha = fluxAlphaBeta.alpha;
342:                   pemf->lastFluxalphabeta.beta  = fluxAlphaBeta.beta;    
343:               }
344:               
345:               /*
346:                * ----- Calculation of standard inputs -----
347:                * 
348:                * To make a more uniform interface among motor control algorithms,
349:                * we calculate some standard input signals and make them available
350:                * to most algorithms in MCAF.
351:                * 
352:                * Because there are feedback loops, there are cyclical dependencies
353:                * between certain quantities, and in some special cases it is important
354:                * to minimize time delays and avoid using stale data.
355:                * 
356:                * Standard inputs are therefore calculated in several stages.
357:                * (See doc comments in the following functions.)
358:                */
359:               
360:               /**
361:                * Calculate standard inputs just prior to a commutation update
362:                * 
363:                * This updates input signals that are needed by commutation tasks
364:                * (angle/velocity estimators and startup state machines, for example)
365:                * so they contain fresh data.
366:                * 
367:                * @param pmotor motor control state variables
368:                */
369:               inline static void calculateStandardInputsPreCommutation(MCAF_MOTOR_DATA *pmotor)
370:               {
371:                   MCAF_STANDARD_INPUT_SIGNALS_T *pstdinputs = &pmotor->standardInputs;
372:                   
373:                   pstdinputs->valphabeta = pmotor->valphabetaOut;
006C56  90A868     MOV [W8+220], W0
006C58  90A8F8     MOV [W8+222], W1
006C5A  982460     MOV W0, [W8+76]
006C5C  982471     MOV W1, [W8+78]
374:                   pstdinputs->ialphabeta = pmotor->ialphabeta;
006C5E  900818     MOV [W8+18], W0
006C60  9008A8     MOV [W8+20], W1
006C62  982440     MOV W0, [W8+72]
006C64  982451     MOV W1, [W8+74]
375:                   pstdinputs->idq = pmotor->idq;
006C66  900848     MOV [W8+24], W0
006C68  9008D8     MOV [W8+26], W1
006C6A  982C40     MOV W0, [W8+88]
006C6C  982C51     MOV W1, [W8+90]
376:                   pstdinputs->omegaElectricalCommand = pmotor->omegaCmd;    
006C6E  9128F8     MOV [W8+350], W1
006C70  983401     MOV W1, [W8+96]
377:                   pstdinputs->vDC = pmotor->psys->vDC;
006C72  930008     MOV [W8+768], W0
006C74  780010     MOV [W0], W0
006C76  982C60     MOV W0, [W8+92]
378:                   if (MCAF_BackEmfAlphaBetaCalculationNeeded())
379:                   {
380:                       estimateBackEMF(pmotor);
381:                   }
382:               }
383:               
384:               /**
385:                * Calculate standard inputs just after a commutation update
386:                * 
387:                * This updates input signals that are produced by commutation tasks
388:                * (angle/velocity estimators and startup state machines, for example)
389:                * so they contain fresh data.
390:                * 
391:                * @param pmotor motor control state variables
392:                */
393:               inline static void calculateStandardInputsPostCommutation(MCAF_MOTOR_DATA *pmotor)
394:               {
395:                   MCAF_STANDARD_INPUT_SIGNALS_T *pstdinputs = &pmotor->standardInputs;
396:               
397:                   pstdinputs->omegaElectricalEstimated = pmotor->omegaElectrical;
006C7C  90B078     MOV [W8+238], W0
006C7E  982C70     MOV W0, [W8+94]
398:                   pstdinputs->startupStatus = MCAF_StartupGetStatus(&pmotor->startup);
006CB0  983411     MOV W1, [W8+98]
399:                   pstdinputs->thetaForcedCommutation = MCAF_StartupGetIdqCmdAngle(&pmotor->startup);
006CBA  983420     MOV W0, [W8+100]
400:                   pstdinputs->iqCmd = pmotor->idqCmdRaw.q;
006CBC  900098     MOV [W8+2], W1
006CBE  983431     MOV W1, [W8+102]
401:                   const MCAF_U_CURRENT iCmdLimit = MCAF_DynamicCurrentLimitGet(&pmotor->dynLimit);
402:                   pstdinputs->iCmdLimit = iCmdLimit;
006CC2  983442     MOV W2, [W8+104]
403:                   pstdinputs->rICmdLimit = UTIL_DivQ15SatPos(MCAF_RECIPROCAL_CURRENT_NUMERATOR,
006CCE  983450     MOV W0, [W8+106]
404:                                                              iCmdLimit);
405:                   const int16_t motorDirection = UTIL_SignFromHighBit(pmotor->velocityControl.velocityCmd);
406:                   pstdinputs->direction = motorDirection;
006CD6  983470     MOV W0, [W8+110]
407:               }
408:               
409:               /**
410:                * Calculate standard inputs just after all velocity/current control loops
411:                * have executed.
412:                * 
413:                * This updates input signals that are produced by the control loops
414:                * and may be needed later.
415:                * 
416:                * @param pmotor motor control state variables
417:                */
418:               inline static void calculateStandardInputsPostControlLoops(MCAF_MOTOR_DATA *pmotor)
419:               {
420:                   MCAF_STANDARD_INPUT_SIGNALS_T *pstdinputs = &pmotor->standardInputs;
421:               
422:                   pstdinputs->vdq = pmotor->vdq;
006956  909058     MOV [W8+170], W0
006958  9090E8     MOV [W8+172], W1
00695A  982C20     MOV W0, [W8+84]
00695C  982C31     MOV W1, [W8+86]
423:               }
424:               
425:               inline static int16_t calculateZeroSequence(MC_ABC_T *pabc)
426:               {
427:                   asm volatile (";calculateZeroSequence\n");
428:                   const int16_t one_thirdQ16  = 21845U;  // 1/3 Q16
429:                   const int16_t result = 
430:                          MC_UTIL_mulus16(one_thirdQ16, pabc->a)
431:                        + MC_UTIL_mulus16(one_thirdQ16, pabc->b)
432:                        + MC_UTIL_mulus16(one_thirdQ16, pabc->c);
433:                   return result;
434:               }
435:               
436:               void MCAF_FocStepIsrFeedbackPath(MCAF_MOTOR_DATA *pmotor)
437:               {
006C1E  781F88     MOV W8, [W15++]
006C20  780400     MOV W0, W8
438:                   /* Clarke transform */
439:                   if (MCAF_TripleChannelEnabled() && HAL_ADC_IsAvailableIphaseC())
440:                   {
441:                       MC_TransformClarkeABC(&pmotor->iabc, &pmotor->ialphabeta);
442:                       pmotor->i0 = calculateZeroSequence(&pmotor->iabc);
443:                   }
444:                   else
445:                   {
446:                       MC_TransformClarke(&pmotor->iabc, &pmotor->ialphabeta);
447:                   }
448:               
449:                   /* Park transform */
450:                   MC_TransformPark(&pmotor->ialphabeta, &pmotor->sincos, &pmotor->idq);
451:                   
452:                   calculateStandardInputsPreCommutation(pmotor);
453:                   
454:                   /* Calculate commutation angle using estimator */
455:                   MCAF_CommutationStep(pmotor);
006C78  780008     MOV W8, W0
006C7A  0702B7     RCALL MCAF_CommutationStep
456:               
457:                   calculateStandardInputsPostCommutation(pmotor);
458:                   
459:                   /* Calculate Sine and Cosine from pmotor->theta_e */
460:                   MC_CalculateSineCosine(pmotor->thetaElectrical, &pmotor->sincos);
461:               }
006D50  78044F     MOV [--W15], W8
006D52  060000     RETURN
006D54  4787F6     ADD W15, #0x16, W15
006D56  BE9F88     MOV.D W8, [W15++]
006D58  BE9F8A     MOV.D W10, [W15++]
006D5A  BE9F8C     MOV.D W12, [W15++]
006D5C  781F8E     MOV W14, [W15++]
006D5E  BE0202     MOV.D W2, W4
006D60  9FAFF2     MOV W2, [W15-34]
006D62  9FB783     MOV W3, [W15-32]
462:               
463:               /*
464:                * 2. Controllers for current/velocity/etc.
465:                */
466:               
467:               /**
468:                * Limits the slew rate of current commands.
469:                * (For now, does nothing.)
470:                * 
471:                * @param pidqCmdRaw raw dq-axis current command
472:                * @param pidqCmd slew-rate limited dq-axis current command
473:                */
474:               inline void MCAF_RateLimitCurrentCommand(const MC_DQ_T *pidqCmdRaw, MC_DQ_T *pidqCmd)
475:               {
476:                   /* Placeholder method. For now, just copy. */
477:                   pidqCmd->d = pidqCmdRaw->d;
00689A  980440     MOV W0, [W8+8]
478:                   pidqCmd->q = pidqCmdRaw->q;
00689C  980451     MOV W1, [W8+10]
479:               }
480:               
481:               /**
482:                * Compute alpha-axis voltage perturbation
483:                * 
484:                * @param pmotor motor state data
485:                * @return voltage including perturbation
486:                */
487:               inline static MCAF_U_VOLTAGE MCAF_ComputeValphaPerturbation(const MCAF_MOTOR_DATA *pmotor)
488:               {
489:                   return pmotor->valphabeta.alpha 
490:                           + MCAF_CommutationExcitationValpha(pmotor);
491:               }
492:               
493:               /**
494:                * Compute beta-axis voltage perturbation
495:                * 
496:                * @param pmotor motor state data
497:                * @return voltage including perturbation
498:                */
499:               inline static MCAF_U_VOLTAGE MCAF_ComputeVbetaPerturbation(const MCAF_MOTOR_DATA *pmotor)
500:               {
501:                   return pmotor->valphabeta.beta
502:                           + MCAF_CommutationExcitationVbeta(pmotor);
503:               }
504:               
505:               /**
506:                * Compute q-axis voltage perturbation
507:                * 
508:                * @param pmotor motor state data
509:                * @return voltage including perturbation
510:                */
511:               inline static MCAF_U_VOLTAGE MCAF_ComputeVqPerturbation(const MCAF_MOTOR_DATA *pmotor)
512:               {
513:                   return pmotor->vdqCmd.q 
514:                           + MCAF_TestPerturbationVq(&pmotor->testing)
006926  9090C8     MOV [W8+168], W1
006928  400001     ADD W0, W1, W0
006934  9090C8     MOV [W8+168], W1
006936  400001     ADD W0, W1, W0
515:                           + MCAF_CommutationExcitationVq(pmotor);
516:               }
517:               
518:               /**
519:                * Compute d-axis voltage perturbation
520:                * 
521:                * @param pmotor motor state data
522:                * @return voltage including perturbation
523:                */
524:               inline static MCAF_U_VOLTAGE MCAF_ComputeVdPerturbation(const MCAF_MOTOR_DATA *pmotor)
525:               {
526:                   return pmotor->vdqCmd.d
527:                           + MCAF_TestPerturbationVd(&pmotor->testing)
0068C2  9090B8     MOV [W8+166], W1
0068C4  400001     ADD W0, W1, W0
006940  9090B8     MOV [W8+166], W1
006942  400001     ADD W0, W1, W0
528:                           + MCAF_CommutationExcitationVd(pmotor);
529:               }
530:               
531:               
532:               /**
533:                * Executes one PI iteration for the current and velocity loops
534:                * 
535:                * @param pmotor motor state data
536:                */
537:               void MCAF_VelocityAndCurrentControllerStep(MCAF_MOTOR_DATA *pmotor)
538:               {
0067DE  BE9F88     MOV.D W8, [W15++]
0067E0  780400     MOV W0, W8
539:                   /*
540:                    * Check to see if new velocity information is available by comparing
541:                    * the number of interrupts per velocity calculation against the
542:                    * number of velocity count samples taken.  If new velocity info
543:                    * is available, calculate the new velocity value and execute
544:                    * the speed control loop. "Velocity" in this context may either be 
545:                    * the estimated velocity OR a substitute for it such as voltage.
546:                    */
547:               
548:                   if (pmotor->subsampleCounter == 0)
0067E2  91B058     MOV [W8+490], W0
0067E4  E00000     CP0 W0
0067E6  3A004B     BRA NZ, MCAF_VelocityAndCurrentControllerStep::MCAF_OperatingModeCurrentLoopActive
549:                   {
550:                       /*
551:                        * Execute the velocity control loop
552:                        */
553:                       pmotor->omegaElectrical = pmotor->estimator.omega;
0067E8  9128E8     MOV [W8+348], W1
0067EA  98B471     MOV W1, [W8+238]
554:                       
555:                       const bool executeVelocityControlLoop =
556:                           MCAF_OperatingModeNormal(&pmotor->testing) && MCAF_IsClosedLoopVelocity(pmotor);
0067EE  500FE3     SUB W0, #0x3, [W15]
0067F0  3A0046     BRA NZ, MCAF_VelocityAndCurrentControllerStep::MCAF_OperatingModeCurrentLoopActive
0067F4  A33800     BTST.Z W0, #3
0067F6  320043     BRA Z, MCAF_VelocityAndCurrentControllerStep::MCAF_OperatingModeCurrentLoopActive
557:               
558:                       if (executeVelocityControlLoop)
559:                       {
560:                           const int16_t velocityCmdPerturbed = 
006800  913828     MOV [W8+372], W0
006802  430000     ADD W6, W0, W0
561:                                 pmotor->velocityControl.velocityCmd
562:                               + MCAF_TestPerturbationVelocity(&pmotor->testing);
563:               
564:                           pmotor->velocityControl.velocityCmdRateLimited =
006828  993C30     MOV W0, [W8+374]
565:                               UTIL_LimitSlewRateSymmetrical(
0067FC  913958     MOV [W8+378], W2
566:                                   velocityCmdPerturbed,                /* input */
567:                                   pmotor->omegaElectrical,             /* reference used as previousOutput */
568:                                   pmotor->velocityControl.slewRateLimit1); /* slew rate limit */
569:               
570:                           int16_t limitPos, limitNeg;
571:                           if (pmotor->omegaCmd > 0)
00682A  912978     MOV [W8+350], W2
00682C  E00002     CP0 W2
00682E  340003     BRA LE, .L24
572:                           {
573:                               limitPos = pmotor->velocityControl.slewRateLimitAccel;
006830  9139E8     MOV [W8+380], W3
574:                               limitNeg = pmotor->velocityControl.slewRateLimitDecel;
006832  913CF8     MOV [W8+382], W9
006834  370002     BRA UTIL_LimitSlewRate
575:                           }
576:                           else
577:                           {
578:                               limitPos = pmotor->velocityControl.slewRateLimitDecel;
006836  9139F8     MOV [W8+382], W3
579:                               limitNeg = pmotor->velocityControl.slewRateLimitAccel;
006838  913CE8     MOV [W8+380], W9
580:                           }
581:                           pmotor->omegaCmd =
00685E  992C70     MOV W0, [W8+350]
582:                               UTIL_LimitSlewRate(
583:                                   pmotor->velocityControl.velocityCmdRateLimited, /* input */
584:                                   pmotor->omegaCmd,                             /* previousOutput */
585:                                   limitPos,   /* positive limit */
586:                                   limitNeg);  /* negative limit */
587:                     
588:                           /* Antiwindup feedback for the velocity controller should include
589:                            * - both current and voltage saturation, if flux-weakening is not enabled,
590:                            * - only current saturation,             if flux-weakening is enabled.
591:                            *
592:                            * The reason for disallowing voltage saturation as antiwindup feedback
593:                            * when FW is enabled, is that the entire FW region is roughly equal in
594:                            * output voltage requirement. This makes the upper speed end of FW 
595:                            * effectively indistinguishable from the lower speed end of FW
596:                            * from looking at the voltage required from the current loop.
597:                            */
598:                           const MCAF_SAT_STATE_T satState = pmotor->sat.state;
599:                           const MCAF_SAT_STATE_T satStateMasked =
600:                               MCAF_FluxWeakEnabled()
601:                               ? MCAF_SatMask(satState, MCAF_SAT_CURRENT)
602:                               : satState;
603:                               
604:                           const int16_t velocityReference =
605:                               (MCAF_OuterLoopType() == MCAF_OLT_VOLTAGE)
606:                               ? UTIL_MulQ15(pmotor->omegaCmd, pmotor->velocityControl.velocityCmdGain)
607:                               : pmotor->omegaCmd;
608:                           const int16_t velocityFeedback =
609:                               (MCAF_OuterLoopType() == MCAF_OLT_VOLTAGE)
610:                             ? MCAF_FilterLowPassS16Output(&pmotor->vqFiltered)
611:                             : pmotor->omegaElectrical;
612:                           // only the sign of omegaCmd matters
613:                           const int16_t direction = pmotor->omegaCmd;
614:                           MCAF_ControllerPIUpdate(
006860  201602     MOV #0x160, W2
006862  410108     ADD W2, W8, W2
006864  780280     MOV W0, W5
006866  E88208     INC2 W8, W4
006868  930198     MOV [W8+770], W3
00686A  070C3A     RCALL MCAF_ControllerPIUpdate
615:                               velocityReference,
616:                               velocityFeedback,
617:                               &pmotor->omegaCtrl,
618:                               satStateMasked,
619:                               &pmotor->idqCmdRaw.q,
620:                               direction);
621:                       
622:                           if (!MCAF_OverrideFluxControl(&pmotor->testing))
00686E  A36800     BTST.Z W0, #6
006870  3A0006     BRA NZ, MCAF_VelocityAndCurrentControllerStep::MCAF_OperatingModeCurrentLoopActive
623:                           {
624:                               // Apply d-axis current command and q-axis current limit
625:                               
626:                               pmotor->idqCmdRaw.d = MCAF_FluxControlGetIdCommand(&pmotor->fluxControl);
006872  EB0C00     CLR [W8]
627:                               const MCAF_U_CURRENT iCmdLimit = MCAF_DynamicCurrentLimitGet(&pmotor->dynLimit);
628:                               const MCAF_U_CURRENT iqLimit = 
629:                                   MCAF_FluxControlGetIqLimit(&pmotor->fluxControl, iCmdLimit);
630:                               pmotor->iqCmdLimit = iqLimit;
006876  982430     MOV W0, [W8+70]
631:                               pmotor->omegaCtrl.outMax = iqLimit;
006878  993470     MOV W0, [W8+366]
632:                               pmotor->omegaCtrl.outMin = -iqLimit;
00687A  EA0000     NEG W0, W0
00687C  993C00     MOV W0, [W8+368]
633:                           }
634:                       }
635:                   }
636:               
637:                   if (MCAF_OperatingModeCurrentLoopActive(&pmotor->testing))
006880  500FE1     SUB W0, #0x1, [W15]
006882  360055     BRA LEU, MCAF_VelocityAndCurrentControllerStep::MCAF_ComputeVqPerturbation
638:                   {
639:                       /* 
640:                        * In certain cases, the electrical angle is adjusted
641:                        * and the PI loop integrator values are inverted.
642:                        * 
643:                        * Some startup methods do not use this, and the following
644:                        * if-statement is optimized out at compile-time.
645:                        */
646:                       if (MCAF_StartupReferenceFrameFlip(&pmotor->startup))
647:                       {
648:                           MCAF_ControllerPIIntegratorInvert(&pmotor->idCtrl);
649:                           MCAF_ControllerPIIntegratorInvert(&pmotor->iqCtrl);
650:                       }
651:                       
652:                       pmotor->idqCmdPerturbed.q = 
00688E  980431     MOV W1, [W8+6]
653:                                 pmotor->idqCmdRaw.q
654:                               + MCAF_TestPerturbationIq(&pmotor->testing);
00688A  900018     MOV [W8+2], W0
00688C  410080     ADD W2, W0, W1
655:                       pmotor->idqCmdPerturbed.d = 
006898  980420     MOV W0, [W8+4]
656:                                 pmotor->idqCmdRaw.d
657:                               + MCAF_TestPerturbationId(&pmotor->testing);
006896  400018     ADD W0, [W8], W0
658:                       
659:                       MCAF_RateLimitCurrentCommand(&pmotor->idqCmdPerturbed, &pmotor->idqCmd);
660:               
661:                       const int16_t vlim_d = UTIL_MulQ15(pmotor->idqCtrlOutLimit.d,
662:                                                          pmotor->psys->vDC);
0068A0  930088     MOV [W8+768], W1
663:                       pmotor->idCtrl.outMax =  vlim_d;
0068A8  981455     MOV W5, [W8+42]
664:                       pmotor->idCtrl.outMin = -vlim_d;
0068AA  EA0105     NEG W5, W2
0068AC  981462     MOV W2, [W8+44]
665:                       /* PI control for D-axis */
666:                       MCAF_ControllerPIUpdate(
0068AE  44017C     ADD W8, #0x1C, W2
0068B0  9008C8     MOV [W8+24], W1
0068B2  EB0280     CLR W5
0068B4  200A64     MOV #0xA6, W4
0068B6  420208     ADD W4, W8, W4
0068B8  780185     MOV W5, W3
0068BA  070C12     RCALL MCAF_ControllerPIUpdate
667:                               pmotor->idqCmd.d, 
668:                               pmotor->idq.d, 
669:                               &pmotor->idCtrl,
670:                               MCAF_SAT_NONE, 
671:                               &pmotor->vdqCmd.d,
672:                               0);
673:                       
674:                       pmotor->vdq.d = MCAF_ComputeVdPerturbation(pmotor);
0068C6  989450     MOV W0, [W8+170]
675:               
676:                       if (MCAF_OverrideDAxisVoltagePriority(&pmotor->testing))
0068CA  A34801     BTST.Z W1, #4
0068CC  320018     BRA Z, UTIL_MulQ15
677:                       {
678:                           /*
679:                            * Vector limitation
680:                            * Vd is not limited
681:                            * Vq is limited so the vector Vs is less than a specified maximum.
682:                            * Vs = SQRT(Vd^2 + Vq^2) < VDQ_SQUARED_LIMIT
683:                            * Vq = SQRT(VDQ_SQUARED_LIMIT - Vd^2)
684:                            * 
685:                            * here VDQ_SQUARED_LIMIT is calculated as
686:                            * Vdc * MCAF_CURRENT_CTRL_DQ_MAGNITUDE_LIMIT
687:                            */
688:                           const int16_t vdSquared = UTIL_SignedSqr(pmotor->vdq.d);
689:                           const int16_t vdqSquaredLimit = UTIL_SignedSqr(UTIL_MulQ15(pmotor->psys->vDC, MCAF_CURRENT_CTRL_DQ_MAGNITUDE_LIMIT));
0068DA  930088     MOV [W8+768], W1
690:                           pmotor->iqCtrl.outMax = Q15SQRT(vdqSquaredLimit - vdSquared);
0068F2  508000     SUB W1, W0, W0
0068F4  070A91     RCALL .LFE21, _Q15SQRT, Q15SQRT
0068F6  981C60     MOV W0, [W8+60]
691:                           pmotor->iqCtrl.outMin = -pmotor->iqCtrl.outMax;
0068F8  EA0000     NEG W0, W0
0068FA  981C70     MOV W0, [W8+62]
0068FC  370008     BRA .LBE557, .L31
692:                       }
693:                       else
694:                       {
695:                           const int16_t vlim_q = UTIL_MulQ15(pmotor->idqCtrlOutLimit.q,
696:                                                              pmotor->psys->vDC);            
006900  930008     MOV [W8+768], W0
697:                           pmotor->iqCtrl.outMax =  vlim_q;
006908  981C63     MOV W3, [W8+60]
698:                           pmotor->iqCtrl.outMin = -vlim_q;
00690A  EA0003     NEG W3, W0
00690C  981C70     MOV W0, [W8+62]
699:                       }
700:               
701:                       /* PI control for Q-axis */
702:                       MCAF_ControllerPIUpdate(
00690E  2002E2     MOV #0x2E, W2
006910  410108     ADD W2, W8, W2
006912  9008D8     MOV [W8+26], W1
006914  900058     MOV [W8+10], W0
006916  EB0280     CLR W5
006918  200A84     MOV #0xA8, W4
00691A  420208     ADD W4, W8, W4
00691C  780185     MOV W5, W3
00691E  070BE0     RCALL MCAF_ControllerPIUpdate
703:                               pmotor->idqCmd.q,
704:                               pmotor->idq.q,
705:                               &pmotor->iqCtrl,
706:                               MCAF_SAT_NONE, 
707:                               &pmotor->vdqCmd.q,
708:                               0);
709:               
710:                       pmotor->vdq.q = MCAF_ComputeVqPerturbation(pmotor);
00692A  989460     MOV W0, [W8+172]
00692C  37000C     BRA .L32
711:                   } /* end of OM_FORCE_CURRENT section */
712:                   else  /* in raw Vd, Vq mode */
713:                   {
714:                       pmotor->vdq.q = MCAF_ComputeVqPerturbation(pmotor);
006938  989460     MOV W0, [W8+172]
715:                       pmotor->vdq.d = MCAF_ComputeVdPerturbation(pmotor);
006944  989450     MOV W0, [W8+170]
716:                   }
717:               
718:                   MCAF_SatDetect(&pmotor->sat, &pmotor->idq, &pmotor->vdq, pmotor->psys->vDC);
006946  930188     MOV [W8+768], W3
006948  200AA2     MOV #0xAA, W2
00694A  410108     ADD W2, W8, W2
00694C  4400F8     ADD W8, #0x18, W1
00694E  203020     MOV #0x302, W0
006950  400008     ADD W0, W8, W0
006952  780193     MOV [W3], W3
006954  0704BA     RCALL MCAF_SatDetect
719:                   calculateStandardInputsPostControlLoops(pmotor);
720:               }
00695E  BE044F     MOV.D [--W15], W8
006960  060000     RETURN
006962  BE9F88     MOV.D W8, [W15++]
721:               
722:               /*
723:                * 3. Forward modulation path
724:                */
725:               
726:               inline static void MCAF_ApplyDCLinkVoltageCompensation(const MC_ABC_T *pvabc,
727:                                                                       MC_ABC_T *pdabc,
728:                                                                       int16_t rVdc,
729:                                                                       int16_t rVdc_q)
730:               {
731:                   pdabc->a = (int16_t) (UTIL_mulss(pvabc->a, rVdc) >> rVdc_q);
0069A6  DD18C4     SL W3, #4, W1
0069A8  DE124C     LSR W2, #12, W4
0069AA  708204     IOR W1, W4, W4
0069AC  989C74     MOV W4, [W8+190]
732:                   pdabc->b = (int16_t) (UTIL_mulss(pvabc->b, rVdc) >> rVdc_q);
0069B0  DD5CC4     SL W11, #4, W9
0069B2  DE514C     LSR W10, #12, W2
0069B4  748102     IOR W9, W2, W2
0069B6  98A402     MOV W2, [W8+192]
733:                   pdabc->c = (int16_t) (UTIL_mulss(pvabc->c, rVdc) >> rVdc_q);
0069BA  DD3CC4     SL W7, #4, W9
0069BC  DE304C     LSR W6, #12, W0
0069BE  748000     IOR W9, W0, W0
0069C0  780300     MOV W0, W6
0069C2  98A410     MOV W0, [W8+194]
734:               }
735:               
736:               inline int16_t MCAF_ComputeReciprocalDCLinkVoltage(int16_t vdc)
737:               {
738:                   if (vdc <= MCAF_RVDC_MIN_VDC)
000000  040200     GOTO __resetPRI, __reset
0090A8  210000     MOV #0x1000, W0
0090AA  510F80     SUB W2, W0, [W15]
0090AC  340003     BRA LE, .L44
739:                   {
740:                       return MCAF_RVDC_MIN;
00000E  000920     NOP
000010  000B66     NOP
0090B4  27FFF0     MOV #0x7FFF, W0
741:                   }
742:                   else
743:                   {
744:                       return __builtin_divf(MCAF_RVDC_MIN_VDC, vdc);
000006  000B2E     NOP
007CB4  27FFF2     MOV #0x7FFF, W2
007CB6  210000     MOV #0x1000, W0
007CB8  090005     REPEAT #0x5
007CBA  D90002     DIVF W0, W2
0090AE  090005     REPEAT #0x5
0090B0  D90002     DIVF W0, W2
0090B2  370001     BRA .LBE740, .L42
745:                   }
746:               }
000010  000B66     NOP
000012  00091A     NOP
747:               
748:               inline static void MCAF_ScaleQ15(const MC_ABC_T *pabc_in, MC_ABC_T *pabc_out, int16_t k)
749:               {
750:                   pabc_out->a = UTIL_MulQ15(pabc_in->a, k);
751:                   pabc_out->b = UTIL_MulQ15(pabc_in->b, k);
752:                   pabc_out->c = UTIL_MulQ15(pabc_in->c, k);
753:               }
754:               
755:               /**
756:                * Add dead-time compensation duty cycles to output duty cycles, if appropriate
757:                *
758:                * @param pdabcIn input duty cycles
759:                * @param pdabcOut output duty cycles
760:                * @param pdtc_abc pointer to dead-time compensation duty cycles,
761:                *        or NULL if no dead-time compensation
762:                */
763:               inline static void MCAF_ApplyDeadTimeCompensationForwardPath(
764:                   const MCAF_U_DUTYCYCLE_ABC *pdabcIn,
765:                   MCAF_U_DUTYCYCLE_ABC *pdabcOut,
766:                   const MCAF_U_DUTYCYCLE_ABC *pdtc_abc)
767:               {
768:                   if (pdtc_abc == NULL)
769:                   {
770:                       // No dead-time compensation
771:                       pdabcOut->a = pdabcIn->a;
0069C4  780384     MOV W4, W7
0069C6  98A424     MOV W4, [W8+196]
772:                       pdabcOut->b = pdabcIn->b;
0069C8  780202     MOV W2, W4
0069CA  98A432     MOV W2, [W8+198]
773:                       pdabcOut->c = pdabcIn->c;            
0069CC  98A440     MOV W0, [W8+200]
774:                   }
775:                   else
776:                   {
777:                       pdabcOut->a = pdabcIn->a + pdtc_abc->a;
778:                       pdabcOut->b = pdabcIn->b + pdtc_abc->b;
779:                       pdabcOut->c = pdabcIn->c + pdtc_abc->c;
780:                   }
781:               }
782:               
783:               inline static void calculateManualZeroSequenceModulation(
784:                   const MC_ABC_T *pabc_in, MC_ABC_T *pabc_out, int16_t delta,
785:                   int16_t min, int16_t max)
786:               {
787:                   pabc_out->a = MC_adjust_zero_sequence(pabc_in->a, delta, min, max);
006A38  98A453     MOV W3, [W8+202]
788:                   pabc_out->b = MC_adjust_zero_sequence(pabc_in->b, delta, min, max);
006A46  98A463     MOV W3, [W8+204]
789:                   pabc_out->c = MC_adjust_zero_sequence(pabc_in->c, delta, min, max);    
006A54  98A473     MOV W3, [W8+206]
790:               }
791:               
792:               void MCAF_FocStepIsrForwardPath(MCAF_MOTOR_DATA *pmotor)
793:               {
006962  BE9F88     MOV.D W8, [W15++]
006964  BE9F8A     MOV.D W10, [W15++]
006966  780400     MOV W0, W8
794:                   /* Calculate control values */
795:                   MCAF_VelocityAndCurrentControllerStep(pmotor);
006968  780008     MOV W8, W0
00696A  07FF39     RCALL MCAF_VelocityAndCurrentControllerStep
796:               
797:                   /* Calculate vAlpha, Vbeta from Sine, Cosine, Vd and Vq */
798:                   MC_TransformParkInverse(&pmotor->vdq, &pmotor->sincos, &pmotor->valphabeta);
799:                   
800:                   pmotor->valphabetaPerturbed.alpha = MCAF_ComputeValphaPerturbation(pmotor);
00698C  989C11     MOV W1, [W8+178]
801:                   pmotor->valphabetaPerturbed.beta  = MCAF_ComputeVbetaPerturbation(pmotor);
00698E  989C23     MOV W3, [W8+180]
802:               
803:                   /* Calculate Va,Vb,Vc from vAlpha and Vbeta */
804:                   MC_TransformClarkeInverse(&pmotor->valphabetaPerturbed, &pmotor->vabc);
805:                   
806:                   MCAF_ApplyDCLinkVoltageCompensation(&pmotor->vabc, &pmotor->dabcRaw, pmotor->rVdc, MCAF_RVDC_Q);
0069A2  909868     MOV [W8+188], W0
807:                   
808:                   /* Dead-time compensation, forward path */
809:                   const MCAF_U_DUTYCYCLE_ABC *pdtc_abc = 
810:                       MCAF_DeadTimeCompensationForwardPathCompute(&pmotor->deadTimeCompensation,
811:                                                                   &pmotor->iabc);
812:                   MCAF_ApplyDeadTimeCompensationForwardPath(&pmotor->dabcRaw,
813:                                                             &pmotor->dabcUnshifted,
814:                                                             pdtc_abc);
815:                       
816:                   /* Calculate scaled PWM duty cycles from Va,Vb,Vc and PWM period */
817:                   if (!MCAF_OverrideZeroSequenceModulation(&pmotor->testing))
0069D0  A37800     BTST.Z W0, #7
0069D2  3A0029     BRA NZ, MCAF_FocStepIsrForwardPath::MCAF_GetOverrideZeroSequenceOffset
818:                   {
819:                       MC_CalculateZeroSequenceModulation(&pmotor->dabcUnshifted,
820:                           &pmotor->dabc,
821:                           HAL_PARAM_MIN_DUTY_Q15, HAL_PARAM_MAX_DUTY_Q15);
822:                   }
823:                   else
824:                   {
825:                       calculateManualZeroSequenceModulation(&pmotor->dabcUnshifted, &pmotor->dabc,
826:                               MCAF_GetOverrideZeroSequenceOffset(&pmotor->testing),
827:                               HAL_PARAM_MIN_DUTY_Q15, HAL_PARAM_MAX_DUTY_Q15);
828:                   }
829:               
830:               #if MCAF_SINGLE_CHANNEL_SUPPORT 
831:                   /* Calculate the adjusted duty cycles and the necessary triggers for current measurement */
832:                   MCAF_ComputeSingleChannelVectors(&pmotor->currentMeasure, &pmotor->vabc, 
833:                           &pmotor->dabc, HAL_PARAM_PWM_PERIOD_COUNTS);
834:                   
835:                   MCAF_ScaleQ15(&pmotor->currentMeasure.pwmDutyCycle[0], 
836:                           &pmotor->currentMeasure.pwmDutyCycleOut.rising, HAL_PARAM_PWM_PERIOD_COUNTS);
837:                   MCAF_ScaleQ15(&pmotor->currentMeasure.pwmDutyCycle[1], 
838:                           &pmotor->currentMeasure.pwmDutyCycleOut.falling, HAL_PARAM_PWM_PERIOD_COUNTS); 
839:               #else    
840:                   MCAF_ScaleQ15(&pmotor->dabc, &pmotor->pwmDutycycle, 
841:                       HAL_PARAM_PWM_PERIOD_COUNTS);
842:               #endif
843:                   
844:                    /* Feedback path to estimators */
845:                   {
846:                       MCAF_U_DUTYCYCLE_ALPHABETA dalphabeta_compensated;
847:               
848:                       // Update history of voltage provided as output
849:                       pmotor->dalphabetaOut[2].alpha = pmotor->dalphabetaOut[1].alpha;
006A76  90ACA8     MOV [W8+212], W9
006A78  98AC49     MOV W9, [W8+216]
850:                       pmotor->dalphabetaOut[2].beta  = pmotor->dalphabetaOut[1].beta;
006A7A  90A938     MOV [W8+214], W2
006A7C  98AC52     MOV W2, [W8+218]
851:                       pmotor->dalphabetaOut[1].alpha = pmotor->dalphabetaOut[0].alpha;
006A7E  90AA88     MOV [W8+208], W5
006A80  98AC25     MOV W5, [W8+212]
852:                       pmotor->dalphabetaOut[1].beta  = pmotor->dalphabetaOut[0].beta;
006A82  90AC98     MOV [W8+210], W9
006A84  98AC39     MOV W9, [W8+214]
853:                      
854:                       const MCAF_U_DUTYCYCLE_ABC *pDabc =
855:                       MCAF_DutyCycleFeedbackIncludesClipping() ? &pmotor->dabc 
856:                                                                : &pmotor->dabcUnshifted;
857:                       MC_TransformClarkeABC(pDabc, &pmotor->dalphabetaOut[0]);
858:                       
859:                       // We use a delay=2 to match current and duty cycle signals properly
860:                       uint16_t kdelay = pmotor->config.deadTimeCompensationVoltageDelay;
006AA2  932038     MOV [W8+838], W0
006AA4  500FE2     SUB W0, #0x2, [W15]
006AA6  360001     BRA LEU, .L39
006AA8  200020     MOV #0x2, W0
861:                       if (kdelay > 2)
862:                           kdelay = 2;
863:               
864:                       const MCAF_U_DUTYCYCLE_ALPHABETA *pdtc_alphabeta = MCAF_DeadTimeCompensationFeedbackPathCompute(&pmotor->deadTimeCompensation);
865:                       
866:                       if (pdtc_alphabeta == NULL)
867:                       {
868:                           dalphabeta_compensated.alpha = pmotor->dalphabetaOut[kdelay].alpha;
006AB4  B00340     ADD #0x34, W0
006AB6  DD0042     SL W0, #2, W0
006AB8  440000     ADD W8, W0, W0
869:                           dalphabeta_compensated.beta  = pmotor->dalphabetaOut[kdelay].beta;            
006AAA  DD00C2     SL W0, #2, W1
006AAC  440081     ADD W8, W1, W1
006AAE  90A991     MOV [W1+210], W3
870:                       }
871:                       else
872:                       {
873:                           dalphabeta_compensated.alpha = pmotor->dalphabetaOut[kdelay].alpha - pdtc_alphabeta->alpha;
874:                           dalphabeta_compensated.beta  = pmotor->dalphabetaOut[kdelay].beta  - pdtc_alphabeta->beta;
875:                       }
876:                       
877:                       const MCAF_U_VOLTAGE vDC = pmotor->psys->vDC;
006AB0  930088     MOV [W8+768], W1
006AB2  780111     MOV [W1], W2
878:                       pmotor->valphabetaOut.alpha = UTIL_MulQ15(dalphabeta_compensated.alpha, vDC);
879:                       pmotor->valphabetaOut.beta  = UTIL_MulQ15(dalphabeta_compensated.beta, vDC);
880:                   }
881:               }
006ACC  BE054F     MOV.D [--W15], W10
006ACE  BE044F     MOV.D [--W15], W8
006AD0  060000     RETURN
006AD2  4787F2     ADD W15, #0x12, W15
882:               
883:               /*
884:                * 4. Non-critical tasks
885:                */
886:               
887:               void MCAF_FocStepIsrNonCriticalTask(MCAF_MOTOR_DATA* pmotor)
888:               {
009096  781F88     MOV W8, [W15++]
009098  780400     MOV W0, W8
889:                   MCAF_ADCReadNonCritical(pmotor);
00909A  780008     MOV W8, W0
00909C  070682     RCALL MCAF_ADCReadNonCritical
890:                   if (!MCAF_OverrideDCLinkCompensation(&pmotor->testing))
0090A0  A32800     BTST.Z W0, #2
0090A2  3A000A     BRA NZ, .L41
891:                   {
892:                       pmotor->rVdc = MCAF_ComputeReciprocalDCLinkVoltage(pmotor->psys->vDC);
0090A4  930008     MOV [W8+768], W0
0090A6  780110     MOV [W0], W2
0090B6  989C60     MOV W0, [W8+188]
893:                   }
894:                   MCAF_DynamicCurrentLimitUpdate(&pmotor->dynLimit, &pmotor->idq);
895:                   
896:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_FLUX_CONTROL_START);
897:                   MCAF_FluxControlStep(&pmotor->fluxControl,
898:                                        &pmotor->standardInputs,
899:                                        &pmotor->motorParameters);
900:                   MCAF_CaptureTimestamp(&pmotor->testing, MCTIMESTAMP_FLUX_CONTROL_END);
901:               
902:                   if (++pmotor->subsampleCounter >= MCAF_ISR_SUBSAMPLE_DIVIDER)
0090B8  91B058     MOV [W8+490], W0
0090BA  E80000     INC W0, W0
0090BC  99B450     MOV W0, [W8+490]
0090BE  500FF3     SUB W0, #0x13, [W15]
0090C0  360002     BRA LEU, .L40
903:                   {
904:                       pmotor->subsampleCounter = 0;
0090C2  EB0000     CLR W0
0090C4  99B450     MOV W0, [W8+490]
905:                   }
906:                   
907:                   if (MCAF_OuterLoopType() == MCAF_OLT_VOLTAGE)
908:                   {
909:                       MCAF_FilterLowPassS16Update(&pmotor->vqFiltered, pmotor->vdqCmd.q);
910:                   }
911:               #if MCAF_TRIGGERED_AVERAGE_EXAMPLE == 1
912:                   MCAF_TriggeredAverage_Step(&pmotor->iqAverage, pmotor->idq.q);
913:               #endif
914:               }
0090C6  78044F     MOV [--W15], W8
0090C8  060000     RETURN
0090CA  781F88     MOV W8, [W15++]
0090CC  780400     MOV W0, W8
915:               
916:               /*
917:                * 5. Miscellaneous
918:                */
919:               
920:               void MCAF_FocStepMain(MCAF_MOTOR_DATA *pmotor)
921:               {
922:                   /* do nothing for now */
923:               }
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
924:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/filter.h
1:                 /**
2:                  * filter.h
3:                  *
4:                  * Module to perform first order low-pass and high-pass filters
5:                  *
6:                  * Component: miscellaneous
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __FILTER_H
48:                #define __FILTER_H
49:                
50:                #include <stdint.h>
51:                #include "filter_types.h"
52:                
53:                #ifdef __cplusplus
54:                extern "C" {
55:                #endif
56:                
57:                
58:                /**
59:                 * Initialize state variables of LPF
60:                 *
61:                 * @param piirfilter LPF state
62:                 */
63:                inline static void MCAF_LpfFilterInitx16(MCAF_LPF_FILTER_X16_T *pfilterx16)
64:                {
65:                    pfilterx16->stateVar = 0;
007CBE  9B3C4A     MOV W10, [W8+888]
007CC0  9B3C5B     MOV W11, [W8+890]
007CC4  9B3C0A     MOV W10, [W8+880]
007CC6  9B3C1B     MOV W11, [W8+882]
009224  B81160     MUL.UU W2, #0x0, W2
009226  980012     MOV W2, [W0+2]
009228  980023     MOV W3, [W0+4]
00922E  980052     MOV W2, [W0+10]
009230  980063     MOV W3, [W0+12]
009234  980812     MOV W2, [W0+18]
009236  980823     MOV W3, [W0+20]
00923A  980852     MOV W2, [W0+26]
00923C  980863     MOV W3, [W0+28]
009C1E  B81160     MUL.UU W2, #0x0, W2
009C20  980012     MOV W2, [W0+2]
009C22  980023     MOV W3, [W0+4]
66:                    pfilterx16->output = 0;
007CC2  9B3C69     MOV W9, [W8+892]
007CC8  9B3C29     MOV W9, [W8+884]
00922A  EB0080     CLR W1
00922C  980031     MOV W1, [W0+6]
009232  980071     MOV W1, [W0+14]
009238  980831     MOV W1, [W0+22]
00923E  980871     MOV W1, [W0+30]
009C24  EB0080     CLR W1
009C26  980031     MOV W1, [W0+6]
67:                }
68:                
69:                /**
70:                 * Initialize state variables of 16-bit low-pass filter
71:                 *
72:                 * @param pfilter LPF state
73:                 * @param pfilter filter coefficient
74:                 */ 
75:                inline static void MCAF_FilterLowPassS16Init(MCAF_FILTER_LOW_PASS_S16_T *pfilter, uint16_t coeff)
76:                {
77:                    pfilter->state.x32 = 0;
0086C6  98B032     MOV W2, [W0+230]
0086C8  98B043     MOV W3, [W0+232]
78:                    pfilter->coeff     = coeff;
0086CA  206661     MOV #0x666, W1
0086CC  98B051     MOV W1, [W0+234]
79:                }
80:                
81:                 /**
82:                 * Initialize state variables of HPF
83:                 *
84:                 * @param piirfilter HPF state
85:                 */
86:                inline static void MCAF_HpfFilterInitx16(MCAF_HPF_FILTER_X16_T *pfilterx16)
87:                {
88:                    pfilterx16->stateVar = 0;
009240  981022     MOV W2, [W0+36]
009242  981033     MOV W3, [W0+38]
009246  981062     MOV W2, [W0+44]
009248  981073     MOV W3, [W0+46]
89:                    pfilterx16->output = 0;
009244  981011     MOV W1, [W0+34]
00924A  981051     MOV W1, [W0+42]
90:                }
91:                    
92:                /**
93:                 * 16 bit implementation of low pass filter
94:                 * y[n] += (x[n]-y[n-1])*coeff
95:                 *
96:                 * @param pfilterx16 LPF state
97:                 * @param input 1.15 fixed point
98:                 * @return Output of low pass filter
99:                 */
100:               inline static int16_t MCAF_LpfFilterx16(MCAF_LPF_FILTER_X16_T *pfilterx16, int16_t input)
101:               {
102:                   pfilterx16->stateVar += __builtin_mulss(input, pfilterx16->coeff);
000000  040200     GOTO __resetPRI, __reset
000020  000920     NOP
000022  000BF6     NOP
000068  000920     NOP
00006E  000B0E     NOP
0000A6  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
000966  231700     MOV #0x3170, W0
000968  8170D2     MOV 0x2E1A, W2
00096A  2316E1     MOV #0x316E, W1
00096C  B99311     MUL.SS W2, [W1], W6
00096E  430230     ADD W6, [W0++], W4
000970  4B82A0     ADDC W7, [W0--], W5
000972  BE0304     MOV.D W4, W6
0009A8  231781     MOV #0x3178, W1
0009AA  231763     MOV #0x3176, W3
0009AC  B99413     MUL.SS W2, [W3], W8
0009AE  440231     ADD W8, [W1++], W4
0009B0  4C82A1     ADDC W9, [W1--], W5
0009B2  BE0404     MOV.D W4, W8
005934  90235E     MOV [W14+74], W6
005936  9023EE     MOV [W14+76], W7
005938  9021CE     MOV [W14+72], W3
00593A  B99203     MUL.SS W2, W3, W4
00593C  430204     ADD W6, W4, W4
00593E  4B8285     ADDC W7, W5, W5
005A7A  90140E     MOV [W14+32], W8
005A7C  90149E     MOV [W14+34], W9
005A80  900BFE     MOV [W14+30], W7
005A82  B99107     MUL.SS W2, W7, W2
005A84  440102     ADD W8, W2, W2
005A86  4C8183     ADDC W9, W3, W3
005AB4  900B0E     MOV [W14+16], W6
005AB6  900B9E     MOV [W14+18], W7
005ABA  9002FE     MOV [W14+14], W5
005ABC  B99105     MUL.SS W2, W5, W2
005ABE  430102     ADD W6, W2, W2
005AC0  4B8183     ADDC W7, W3, W3
005C5A  90114E     MOV [W14+40], W2
005C5C  9011DE     MOV [W14+42], W3
005C5E  90122E     MOV [W14+36], W4
005C60  9010BE     MOV [W14+38], W1
005C62  B9A201     MUL.SS W4, W1, W4
005C64  410204     ADD W2, W4, W4
005C66  498285     ADDC W3, W5, W5
005C7C  900A4E     MOV [W14+24], W4
005C7E  900ADE     MOV [W14+26], W5
005C80  900B2E     MOV [W14+20], W6
005C82  9008BE     MOV [W14+22], W1
005C84  B9B301     MUL.SS W6, W1, W6
005C86  420306     ADD W4, W6, W6
005C88  4A8387     ADDC W5, W7, W7
103:                   pfilterx16->stateVar -= __builtin_mulss(pfilterx16->output, pfilterx16->coeff);
00000E  000920     NOP
00002A  000C36     NOP
000030  000920     NOP
000076  000920     NOP
0000B2  000920     NOP
000974  231743     MOV #0x3174, W3
000976  780213     MOV [W3], W4
000978  B9A211     MUL.SS W4, [W1], W4
00097A  530204     SUB W6, W4, W4
00097C  5B8285     SUBB W7, W5, W5
00097E  BE8804     MOV.D W4, [W0]
0009B4  2317C4     MOV #0x317C, W4
0009B6  780114     MOV [W4], W2
0009B8  B99313     MUL.SS W2, [W3], W6
0009BA  540106     SUB W8, W6, W2
0009BC  5C8187     SUBB W9, W7, W3
0009BE  BE8882     MOV.D W2, [W1]
005940  90237E     MOV [W14+78], W6
005942  B9B303     MUL.SS W6, W3, W6
005944  520206     SUB W4, W6, W4
005946  5A8287     SUBB W5, W7, W5
005948  982754     MOV W4, [W14+74]
00594A  982765     MOV W5, [W14+76]
005A88  90142E     MOV [W14+36], W8
005A8A  B9C407     MUL.SS W8, W7, W8
005A8C  510308     SUB W2, W8, W6
005A8E  598389     SUBB W3, W9, W7
005A90  981706     MOV W6, [W14+32]
005A92  981717     MOV W7, [W14+34]
005AC2  900B2E     MOV [W14+20], W6
005AC4  B9B305     MUL.SS W6, W5, W6
005AC6  510206     SUB W2, W6, W4
005AC8  598287     SUBB W3, W7, W5
005ACA  980F04     MOV W4, [W14+16]
005ACC  980F15     MOV W5, [W14+18]
005C68  90116E     MOV [W14+44], W2
005C6A  B99101     MUL.SS W2, W1, W2
005C6C  520202     SUB W4, W2, W4
005C6E  5A8283     SUBB W5, W3, W5
005C70  981744     MOV W4, [W14+40]
005C72  981755     MOV W5, [W14+42]
005C8A  900A6E     MOV [W14+28], W4
005C8C  B9A201     MUL.SS W4, W1, W4
005C8E  530304     SUB W6, W4, W6
005C90  5B8385     SUBB W7, W5, W7
005C92  980F46     MOV W6, [W14+24]
005C94  980F57     MOV W7, [W14+26]
104:                   const int16_t output = (int16_t) (pfilterx16->stateVar >> 15);
00001A  000920     NOP
000036  000920     NOP
00003C  000920     NOP
000082  000920     NOP
0000BE  000920     NOP
000980  DD2B41     SL W5, #1, W6
000982  DE204F     LSR W4, #15, W0
000984  730000     IOR W6, W0, W0
0009C0  DD1AC1     SL W3, #1, W5
0009C2  DE104F     LSR W2, #15, W0
0009C4  728000     IOR W5, W0, W0
00594C  DD2841     SL W5, #1, W0
00594E  DE214F     LSR W4, #15, W2
005950  700102     IOR W0, W2, W2
005952  780302     MOV W2, W6
005A94  DD3C41     SL W7, #1, W8
005A96  DE314F     LSR W6, #15, W2
005A98  740102     IOR W8, W2, W2
005A9A  981722     MOV W2, [W14+36]
005ACE  DD2841     SL W5, #1, W0
005AD0  DE214F     LSR W4, #15, W2
005AD2  700102     IOR W0, W2, W2
005AD4  980F22     MOV W2, [W14+20]
005C74  DD2B41     SL W5, #1, W6
005C76  DE214F     LSR W4, #15, W2
005C78  730102     IOR W6, W2, W2
005C7A  981762     MOV W2, [W14+44]
005C96  DD3C41     SL W7, #1, W8
005C98  DE324F     LSR W6, #15, W4
005C9A  740204     IOR W8, W4, W4
105:                   pfilterx16->output = output;
00003E  000920     NOP
000042  000920     NOP
000986  780980     MOV W0, [W3]
0009C6  780A00     MOV W0, [W4]
005954  982772     MOV W2, [W14+78]
005C9C  980F64     MOV W4, [W14+28]
106:                   return output;
107:               }
108:               
109:               /**
110:                * 16 bit implementation of low pass filter
111:                * y[n] += (x[n]-y[n-1])*coeff where coeff is represented as Q0.16 unsigned
112:                *
113:                * @param pfilter LPF state
114:                * @param input any 16-bit fixed-point representation
115:                * @return Output of low pass filter, same representation as input
116:                */
117:               inline static int16_t MCAF_FilterLowPassS16Update(MCAF_FILTER_LOW_PASS_S16_T *pfilter, int16_t input)
118:               {
119:                   /* This is an efficient implementation of a low-pass filter that is not
120:                    * subject to overflow. It uses an unsigned Q16 coefficient for execution
121:                    * speed, to avoid the shift required for Q15, etc.
122:                    * 
123:                    * The state update is computed with two separate multiplies rather than
124:                    * the easier y[k] = y[k-1] + coeff * (x[k]-y[k-1]) with a single multiply,
125:                    * so that it supports the case where x[k] and y[k-1] are different by more
126:                    * than 32767 counts (example: x[k] = +20000 and y[k-1] = -20000).
127:                    */
128:                   const int16_t previousOutput = pfilter->state.x16.hi;
129:                   pfilter->state.x32 -= __builtin_mulus(pfilter->coeff, previousOutput);
130:                   pfilter->state.x32 += __builtin_mulus(pfilter->coeff, input);
131:                   const int16_t newOutput = pfilter->state.x16.hi;
132:                   return newOutput;
133:               }
134:               
135:               /**
136:                * Get low-pass filter output
137:                *
138:                * @return Output of low pass filter
139:                */
140:               inline static int16_t MCAF_FilterLowPassS16Output(const MCAF_FILTER_LOW_PASS_S16_T *pfilter)
141:               {
142:                   return pfilter->state.x16.hi;
143:               }
144:               
145:               /**
146:                * 16 bit implementation of high pass filter
147:                * L[n] += (x[n]-L[n-1])*coeff
148:                * y[n] = x[n]-L[n]
149:                *
150:                * @param pfilterx16 HPF state
151:                * @param input 1.15 fixed point
152:                * @return Output of high pass filter
153:                */
154:               inline static int16_t MCAF_HpfFilterx16(MCAF_HPF_FILTER_X16_T *pfilterx16, int16_t input)
155:               {
156:                   // Perform a low pass filter and subtract it from the input.
157:                   const int16_t lpf_shift_prev = (int16_t) (pfilterx16->stateVar >> 16);
000006  000B2E     NOP
00002E  000920     NOP
005A16  901B1E     MOV [W14+50], W6
005A18  901BAE     MOV [W14+52], W7
005A3E  901B5E     MOV [W14+58], W6
005A40  901BEE     MOV [W14+60], W7
158:                   pfilterx16->stateVar -= __builtin_mulss(lpf_shift_prev, pfilterx16->coeff);
00000A  000BD2     NOP
000032  000920     NOP
005A1A  9011FE     MOV [W14+46], W3
005A1C  B9BC03     MUL.SS W7, W3, W8
005A1E  530308     SUB W6, W8, W6
005A20  5B8389     SUBB W7, W9, W7
005A42  90193E     MOV [W14+54], W2
005A44  B9BC02     MUL.SS W7, W2, W8
005A46  530408     SUB W6, W8, W8
005A48  5B8489     SUBB W7, W9, W9
159:                   pfilterx16->stateVar += __builtin_mulss(input, pfilterx16->coeff);
000012  00091A     NOP
00003A  000920     NOP
005A22  B9AD03     MUL.SS W5, W3, W10
005A24  450106     ADD W10, W6, W2
005A26  4D8187     ADDC W11, W7, W3
005A28  981F12     MOV W2, [W14+50]
005A2A  981F23     MOV W3, [W14+52]
005A4A  B9A602     MUL.SS W4, W2, W12
005A4C  460408     ADD W12, W8, W8
005A4E  4E8489     ADDC W13, W9, W9
005A50  981F58     MOV W8, [W14+58]
005A52  981F69     MOV W9, [W14+60]
160:                   const int16_t lpf_shift = (int16_t) (pfilterx16->stateVar >> 16);
00001C  000920     NOP
005A2C  780303     MOV W3, W6
161:                   const int16_t output = UTIL_SatSubS16(input, lpf_shift);
162:                   pfilterx16->output = output;
00002A  000C36     NOP
00004E  000920     NOP
005A3A  981F03     MOV W3, [W14+48]
005A60  981F42     MOV W2, [W14+56]
163:                   return output;
164:               }
165:               
166:               #ifdef __cplusplus
167:               }
168:               #endif
169:               
170:               #endif /* __FILTER_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/fault_detect.h
1:                 /**
2:                  * fault_detect.h
3:                  *
4:                  * Module to detect when motor fault happened
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __FAULT_DETECT_H
48:                #define __FAULT_DETECT_H
49:                
50:                #include "fault_detect_types.h"
51:                #include "system_state.h"
52:                #include "hal.h"
53:                
54:                #ifdef __cplusplus
55:                extern "C" {
56:                #endif
57:                
58:                
59:                /**
60:                 * This function initializes the Fault Detect function
61:                 *
62:                 * Summary : Inits the non recoverable faults module
63:                 *
64:                 * @param pFaultDetect This parameter is pointer to MCAF_FAULT_DETECT_T structure
65:                 */
66:                void MCAF_FaultDetectInit(MCAF_FAULT_DETECT_T *pFaultDetect);
67:                
68:                /**
69:                 * This function reset the Fault Detect function
70:                 *
71:                 * Summary : Reset the non recoverable faults module
72:                 *
73:                 * @param pFaultDetect This parameter is pointer to MCAF_FAULT_DETECT_T structure
74:                 */
75:                void MCAF_FaultDetectReset(MCAF_FAULT_DETECT_T *pFaultDetect);
76:                
77:                
78:                /**
79:                 * This function returns whether an fault fault occurred
80:                 *
81:                 * Summary : Returns whether a fault happened
82:                 *
83:                 * @param pfaultDetect This parameter is pointer to MCAF_FAULT_DETECT_T structure
84:                 * @return whether a fault has been detected
85:                 */
86:                
87:                static inline bool MCAF_Fault_IsFaultDetected(MCAF_FAULT_DETECT_T *pfaultDetect)
88:                {
89:                    return pfaultDetect->faultDetectFlag != 0;
90:                }
91:                
92:                /**
93:                 * This function returns whether an overvoltage fault occurred
94:                 *
95:                 * Summary : Returns whether an overvoltage happened
96:                 *
97:                 * @param pVoltageDetect This parameter is pointer to MCAF_DCLINKVOLTAGE_DETECT_T structure
98:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
99:                 * @return whether an overvoltage fault has been detected
100:                */
101:               inline static bool MCAF_OvervoltageDetect(const MCAF_DCLINKVOLTAGE_DETECT_T *pVoltageDetect,
102:                       const MCAF_MOTOR_DATA *pmotor)
103:               {
104:                   return pmotor->psys->vDC > pVoltageDetect->vDCOvervoltageThreshold;
0092B6  930101     MOV [W1+768], W2
0092B8  780192     MOV [W2], W3
105:               }
106:               
107:               /**
108:                * Returns whether an undervoltage fault occurred
109:                *
110:                * @param pVoltageDetect pointer to voltage detection thresholds
111:                * @param pmotor motor state 
112:                * @return true if an undervoltage fault has been detected
113:                */
114:               inline static bool MCAF_UndervoltageDetect(const MCAF_DCLINKVOLTAGE_DETECT_T *pVoltageDetect,
115:                       const MCAF_MOTOR_DATA *pmotor)
116:               {
117:                   return pmotor->psys->vDC < pVoltageDetect->vDCUndervoltageThreshold;
118:               }
119:               
120:               /**
121:                * This function returns whether a hardware overcurrent fault occurred
122:                *
123:                * Summary : Returns whether a hardware overcurrent happened
124:                *
125:                * @return whether a hardware overcurrent fault has been detected
126:                */
127:               
128:               inline static bool MCAF_OvercurrentHWDetect(void)
129:               {
130:                   return HAL_PWM_FaultStatus_Get();
131:               }
132:               
133:               /**
134:                * Returns whether an overtemperature fault occurred
135:                *
136:                * @param pfaultDetect pointer to fault detect state
137:                * @param pmotor motor state 
138:                * @return true if an overtemperature fault has been detected 
139:                */
140:               inline static bool MCAF_OvertemperatureDetect(MCAF_U_TEMPERATURE threshold,
141:                                                             const MCAF_MOTOR_DATA *pmotor)
142:               {
143:                   bool faultActive = HAL_ADC_IsAvailableBridgeTemperature() && 
144:                                       pmotor->bridgeTemperature.filter.output > threshold;
145:                   return faultActive;
146:               }
147:               
148:               /**
149:                * This function updates the fault status in special designated status registers
150:                *
151:                * Summary : Updates the fault detection flags for each specific fault detected
152:                *
153:                * @param pfaultDetect This parameter is pointer to MCAF_FAULT_DETECT_T structure
154:                * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
155:                */
156:               void MCAF_FaultDetect(MCAF_FAULT_DETECT_T *pfaultDetect, const MCAF_MOTOR_DATA *pmotor);
157:               
158:               /**
159:                * Returns whether the overvoltage flag is set
160:                * @param pfaultinfo fault info 
161:                * @return true if overvoltage flag is set
162:                */
163:               inline static bool MCAF_IsOvervoltageFlagSet(const MCAF_FAULT_DETECT_T *pfaultinfo)
164:               {
165:                   return pfaultinfo->faultDetectFlag & MCAF_OVERVOLTAGE_FAULT_DETECT;
0049DA  929848     MOV [W8+696], W0
166:               }
167:               
168:               /**
169:                * Returns whether the undervoltage flag is set
170:                * @param pfaultinfo fault info 
171:                * @return true if undervoltage flag is set
172:                */
173:               inline static bool MCAF_IsUndervoltageFlagSet(const MCAF_FAULT_DETECT_T *pfaultinfo)
174:               {
175:                   return pfaultinfo->faultDetectFlag & MCAF_UNDERVOLTAGE_FAULT_DETECT;
176:               }
177:               
178:               /**
179:                * Returns whether the overcurrent flag is set
180:                * @param pfaultinfo fault info 
181:                * @return true if overcurrent flag is set
182:                */
183:               inline static bool MCAF_IsOvercurrentFlagSet(const MCAF_FAULT_DETECT_T *pfaultinfo)
184:               {
185:                   return pfaultinfo->faultDetectFlag & MCAF_OVERCURRENT_HW_FAULT_DETECT;
0009D2  8185C1     MOV 0x30B8, W1
186:               }
187:               
188:               /**
189:                * Returns whether the overvoltage flag is set
190:                * @param pfaultinfo fault info 
191:                * @return true if overvoltage flag is set
192:                */
193:               inline static bool MCAF_IsOvertemperatureFlagSet(const MCAF_FAULT_DETECT_T *pfaultinfo)
194:               {
195:                   return pfaultinfo->faultDetectFlag & MCAF_OVERTEMPERATURE_FAULT_DETECT;
196:               }
197:               
198:               /**
199:                * Returns whether any fault flag is set
200:                * @param pfaultinfo fault info 
201:                * @return true if any fault flag is set
202:                */
203:                
204:               inline static bool MCAF_IsAnyFaultFlagSet(const MCAF_FAULT_DETECT_T *pfaultinfo)
205:               {
206:                   return pfaultinfo->faultDetectFlag != 0;
004ACA  929848     MOV [W8+696], W0
207:               }
208:               
209:               #ifdef __cplusplus
210:               }
211:               #endif
212:               
213:               #endif /* __FAULT_DETECT_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/fault_detect.c
1:                 /**
2:                  * fault_detect.c
3:                  *
4:                  * Module to detect when motor is in fault condition
5:                  * 
6:                  * Component: supervisory
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                #include "fault_detect.h"
47:                #include "parameters/fault_detect_params.h"
48:                #include "util.h"
49:                #include "foc.h"
50:                
51:                void MCAF_DCLinkVoltageFaultDetectInit(MCAF_DCLINKVOLTAGE_DETECT_T *pOvervoltageDetect)
52:                {
53:                    pOvervoltageDetect->vDCOvervoltageThreshold = VDC_OVERVOLTAGE_THRESHOLD;
009D8E  259C31     MOV #0x59C3, W1
009D90  780801     MOV W1, [W0]
54:                    pOvervoltageDetect->vDCUndervoltageThreshold = VDC_UNDERVOLTAGE_THRESHOLD;
009D92  211F41     MOV #0x11F4, W1
009D94  980011     MOV W1, [W0+2]
55:                    
56:                }
009D96  060000     RETURN
57:                
58:                void MCAF_FaultDetectInit(MCAF_FAULT_DETECT_T *pFaultDetect)
59:                {
009A9E  781F88     MOV W8, [W15++]
009AA0  780400     MOV W0, W8
60:                    MCAF_DCLinkVoltageFaultDetectInit(&pFaultDetect->voltage);
009AA2  780008     MOV W8, W0
009AA4  070174     RCALL MCAF_DCLinkVoltageFaultDetectInit
61:                    pFaultDetect->overtemperatureThreshold = MCAF_OVERTEMPERATURE_THRESHOLD;
009AA6  213880     MOV #0x1388, W0
009AA8  980420     MOV W0, [W8+4]
62:                    MCAF_FaultDetectReset(pFaultDetect);
009AAA  780008     MOV W8, W0
009AAC  0701F8     RCALL MCAF_FaultDetectReset
63:                }
009AAE  78044F     MOV [--W15], W8
009AB0  060000     RETURN
009AB2  200951     MOV #0x95, W1
009AB4  780801     MOV W1, [W0]
64:                
65:                void MCAF_FaultDetectReset(MCAF_FAULT_DETECT_T *pFaultDetect)
66:                {
67:                    pFaultDetect->faultDetectFlag = 0;
009E9E  EB0080     CLR W1
009EA0  980031     MOV W1, [W0+6]
68:                }
009EA2  060000     RETURN
009EA4  B3C011     MOV.B #0x1, W1
009EA6  784801     MOV.B W1, [W0]
69:                
70:                void MCAF_FaultDetect(MCAF_FAULT_DETECT_T *pfaultDetect, const MCAF_MOTOR_DATA *pmotor)
71:                {
72:                    uint16_t flags = 0;
0092B0  EB0100     CLR W2
0092BA  200012     MOV #0x1, W2
0092BC  518F90     SUB W3, [W0], [W15]
0092BE  3C0001     BRA GT, .LBE35, .L6
0092C0  EB0100     CLR W2
73:                    
74:                    if (MCAF_ADCInitializationReady(pmotor))
0092B2  E00413     CP0.B [W3]
0092B4  32000A     BRA Z, .LBE37, .L5
75:                    {
76:                        if (MCAF_OvervoltageDetect(&pfaultDetect->voltage, pmotor))
77:                        {
78:                            flags = UTIL_SetBits(flags, MCAF_OVERVOLTAGE_FAULT_DETECT);
79:                        }
80:                        if (MCAF_UndervoltageDetect(&pfaultDetect->voltage, pmotor))
0092C2  900210     MOV [W0+2], W4
0092C4  518F84     SUB W3, W4, [W15]
0092C6  3D0001     BRA GE, .LBE37, .L5
81:                        {
82:                            flags = UTIL_SetBits(flags, MCAF_UNDERVOLTAGE_FAULT_DETECT);
83:                        }        
84:                        if (MCAF_OvertemperatureDetect(pfaultDetect->overtemperatureThreshold, pmotor))
85:                        {
86:                            flags = UTIL_SetBits(flags, MCAF_OVERTEMPERATURE_FAULT_DETECT);
87:                        }
88:                    }
89:                    if (MCAF_OvercurrentHWFlagValid(pmotor) && MCAF_OvercurrentHWDetect())
0092CA  932091     MOV [W1+834], W1
0092CC  E00001     CP0 W1
0092CE  3A0002     BRA NZ, .LBE39, .L7
90:                    {
91:                        flags = UTIL_SetBits(flags, MCAF_OVERCURRENT_HW_FAULT_DETECT);
92:                    }
93:                
94:                    pfaultDetect->faultDetectFlag = flags;
0092D4  980032     MOV W2, [W0+6]
95:                }
0092D6  060000     RETURN
0092D8  EF2950     CLR CCP1CON1L
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/dyn_current.h
1:                 /**
2:                  * dyn_current.h
3:                  *
4:                  * Dynamic current limit: none (empty placeholder implementation)
5:                  * 
6:                  * Component: FOC
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __DYN_CURRENT_H
48:                #define __DYN_CURRENT_H
49:                
50:                #include <stddef.h>
51:                #include "dyn_current_types.h"
52:                #include "units.h"
53:                #include "parameters/foc_params.h"
54:                
55:                #ifdef __cplusplus
56:                extern "C" {
57:                #endif
58:                
59:                /**
60:                 * Initialize dynamic current limit
61:                 * @param pdynlim dynamic current limit state
62:                 */    
63:                inline static void MCAF_DynamicCurrentLimitInit(MCAF_DYNAMIC_CURRENT_LIMIT *pdynlim)
64:                {
65:                    pdynlim->iLimit = MCAF_VELOCITY_CTRL_IQ_OUT_LIMIT;
007C78  203670     MOV #0x367, W0
007C7A  982420     MOV W0, [W8+68]
66:                }
67:                /**
68:                 * Get dynamic current limit
69:                 * 
70:                 * @param pdynlim dynamic current limit state
71:                 * @return current limit
72:                 */
73:                inline static MCAF_U_CURRENT MCAF_DynamicCurrentLimitGet(MCAF_DYNAMIC_CURRENT_LIMIT *pdynlim)
74:                {
75:                    return pdynlim->iLimit;
006874  902028     MOV [W8+68], W0
006CC0  902128     MOV [W8+68], W2
76:                }
77:                /**
78:                 * Update dynamic current limit
79:                 * 
80:                 * Outside critical-path code.
81:                 * 
82:                 * @param pdynlim dynamic current limit state
83:                 * @param pIdq measured dq current
84:                 */
85:                inline static void MCAF_DynamicCurrentLimitUpdate(MCAF_DYNAMIC_CURRENT_LIMIT *pdynlim,
86:                                                                  const MCAF_U_CURRENT_DQ *pIdq)
87:                {
88:                    // do nothing
89:                }
90:                #ifdef __cplusplus
91:                }
92:                #endif
93:                
94:                #endif /* __DYN_CURRENT_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/diagnostics.c
1:                 /**
2:                  * diagnostics.c
3:                  * 
4:                  * Diagnostics code
5:                  * 
6:                  * Component: diagnostics
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include "X2CScope.h"
48:                #include "hal.h"
49:                #include <stdint.h>
50:                
51:                #define X2C_DATA __attribute__((section("x2cscope_data_buf")))
52:                #define X2C_BUFFER_SIZE 4900
53:                X2C_DATA static uint8_t X2C_BUFFER[X2C_BUFFER_SIZE];
54:                    /*
55:                     * baud rate = 70MHz/16/(1+baudrate_divider) for highspeed = false
56:                     * baud rate = 70MHz/4/(1+baudrate_divider) for highspeed = true
57:                     * 
58:                     * 4375kbaud => 0 (for DIAG_BAUDRATE_DIVIDER with highspeed = false)
59:                     * 2188kbaud => 1
60:                     * 1458kbaud => 2
61:                     * 1094kbaud => 3
62:                     *  875kbaud => 4
63:                     *  729kbaud => 5
64:                     *  625kbaud => 6
65:                     *  547kbaud => 7
66:                     *  486kbaud => 8
67:                     *  437kbaud => 9
68:                     *  397kbaud => 10
69:                     *  364.6kbaud => 11
70:                     *  336.5kbaud => 12
71:                     *  312.5kbaud => 13
72:                     *  291.7kbaud => 14
73:                     *  273.4kbaud => 15
74:                     *  257.3kbaud => 16
75:                     *  243.1kbaud => 17
76:                     *  230.2kbaud => 18
77:                     *  115.1kbaud => 37
78:                     *   57.6kbaud => 75
79:                     */
80:                
81:                void X2CScope_Init(void);
82:                
83:                void MCAF_DiagnosticsInit(void)
84:                {
85:                    HAL_UART_Initialize();
86:                    
87:                    X2CScope_Init();
009EAC  07FE5A     RCALL X2CScope_Init
88:                }
009EAE  060000     RETURN
009EB0  8892F0     MOV W0, 0x125E
89:                
90:                void MCAF_DiagnosticsStepMain(void)
91:                {
92:                    X2CScope_Communicate();
009F4E  07EFE6     RCALL X2CScope_Communicate
93:                }
009F50  060000     RETURN
94:                
95:                void MCAF_DiagnosticsStepIsr(void)
96:                {
97:                    X2CScope_Update();
009F52  07EFE7     RCALL X2CScope_Update
98:                }
009F54  060000     RETURN
009F56  905020     MOV.B [W0+18], W0
99:                
100:               /* ---------- communication primitives used by X2CScope library ---------- */
101:               
102:               static void X2CScope_sendSerial(uint8_t data)
103:               {
104:                   HAL_UART_Write(data);
105:               }
009F4C  060000     RETURN
009F4E  07EFE6     RCALL X2CScope_Communicate
009F4E  07EFE6     RCALL X2CScope_Communicate
106:               
107:               static uint8_t X2CScope_receiveSerial()
108:               {
109:                   return HAL_UART_Read();
110:               }
009F48  060000     RETURN
009F4A  07FF35     RCALL UART1_Write
111:               
112:               static uint8_t X2CScope_isReceiveDataAvailable()
113:               {
114:                   return HAL_UART_IsRxReady();
115:               }
009F44  060000     RETURN
009F46  07FEED     RCALL UART1_Read
116:               
117:               static uint8_t X2CScope_isSendReady()
118:               {
119:                   return HAL_UART_IsTxReady();
120:               }
009F40  060000     RETURN
121:               
122:               void X2CScope_Init(void)
123:               {
124:                   X2CScope_HookUARTFunctions(
009B62  29F3E3     MOV #0x9F3E, W3
009B64  29F422     MOV #0x9F42, W2
009B66  29F461     MOV #0x9F46, W1
009B68  29F4A0     MOV #0x9F4A, W0
009B6A  07F1DC     RCALL X2CScope_HookUARTFunctions
125:                       X2CScope_sendSerial,
126:                       X2CScope_receiveSerial,
127:                       X2CScope_isReceiveDataAvailable,
128:                       X2CScope_isSendReady);
129:                   X2CScope_Initialise(X2C_BUFFER,sizeof(X2C_BUFFER));
009B6C  213241     MOV #0x1324, W1
009B6E  212700     MOV #0x1270, W0
009B70  07F1A6     RCALL X2CScope_Initialise
130:               }
009B72  060000     RETURN
009B74  800A62     MOV POS1CNTL, W2
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/current_measure.h
1:                 /**
2:                  * current_measure.h
3:                  *
4:                  * Current measurement routines: multi-channel
5:                  * 
6:                  * Component: ADC compensation
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __CURRENT_MEASURE_H
48:                #define __CURRENT_MEASURE_H
49:                
50:                #include <stdint.h>
51:                #include "units.h"
52:                #include "current_measure_types.h"
53:                #include "system_state.h"
54:                #include "parameters/adc_params.h"
55:                
56:                #ifdef __cplusplus
57:                extern "C" {
58:                #endif
59:                
60:                inline static int16_t applyOffset(int16_t measurement, int16_t offset, bool invert)
61:                {
62:                    if (invert)
63:                    {
64:                        return offset - measurement;
008B66  931281     MOV [W1+800], W5
008B68  528282     SUB W5, W2, W5
008B6A  931231     MOV [W1+806], W4
008B6C  520000     SUB W4, W0, W0
65:                    }
66:                    else
67:                    {
68:                        return measurement - offset;
69:                    }
70:                }
71:                
72:                inline static void MCAF_ADCApplyCurrentCompensation(const MCAF_CURRENT_COMPENSATION_PARAMETERS *pcal,
73:                                                             MC_ABC_T *piabc)
74:                {
75:                    const int16_t a1 = applyOffset(piabc->a, pcal->offseta, MCAF_ADCIsPhaseACurrentInverted());
76:                    const int16_t b1 = applyOffset(piabc->b, pcal->offsetb, MCAF_ADCIsPhaseBCurrentInverted());
77:                    
78:                    piabc->a =  (UTIL_mulss(a1, pcal->qKaa)
008B80  9800E2     MOV W2, [W1+12]
79:                                +UTIL_mulss(b1, pcal->qKab)) >> 15;
008B76  410306     ADD W2, W6, W6
008B78  498387     ADDC W3, W7, W7
008B7A  DD3A41     SL W7, #1, W4
008B7C  DE314F     LSR W6, #15, W2
008B7E  720102     IOR W4, W2, W2
80:                    piabc->b =  (UTIL_mulss(a1, pcal->qKba)
008B94  9800F2     MOV W2, [W1+14]
81:                                +UTIL_mulss(b1, pcal->qKbb)) >> 15;
008B8A  410204     ADD W2, W4, W4
008B8C  498285     ADDC W3, W5, W5
008B8E  DD2841     SL W5, #1, W0
008B90  DE214F     LSR W4, #15, W2
008B92  700102     IOR W0, W2, W2
82:                
83:                    if (HAL_ADC_IsAvailableIphaseC())
84:                    {
85:                        const int16_t c1 = applyOffset(piabc->c, pcal->offsetc, MCAF_ADCIsPhaseCCurrentInverted());
86:                        piabc->c = (UTIL_mulss(c1, pcal->qKcc)) >> 15;
87:                    }
88:                }
89:                
90:                /**
91:                 * Obtains motor phase current information from appropriate sources.
92:                 * @param currentMeasure MCAF current measurement
93:                 * @param iabc abc current vector
94:                 */
95:                inline static void MCAF_ADCCurrentRead(const MCAF_CURRENT_MEASUREMENT *currentMeasure, MCAF_U_CURRENT_ABC *iabc)
96:                {
97:                    iabc->a = HAL_ADC_ValueIphaseA();
008B62  9800E2     MOV W2, [W1+12]
98:                    iabc->b = HAL_ADC_ValueIphaseB(); 
99:                    
100:                   if (HAL_ADC_IsAvailableIphaseC())
101:                   {
102:                       iabc->c = HAL_ADC_ValueIphaseC();
103:                   }
104:               }
105:               
106:               /**
107:                * Executes one step of current offset calibration.
108:                * During the calibration interval, integrates filtered offset
109:                * based on the compensated measurement value, but only if it is within
110:                * range.
111:                * 
112:                * @param pLPF pointer to low-pass-filter integrator
113:                * @param measurement compensated measurement
114:                * @param k integrator gain
115:                */
116:               inline static void MCAF_ADCCalibrateCurrentOffset(sx1632_t *pLPF, int16_t measurement, int16_t k, bool invert)
117:               {
118:                   if ((measurement > -MCAF_CAL_RANGE) && (measurement < MCAF_CAL_RANGE))
004C16  203FF2     MOV #0x3FF, W2
004C18  410100     ADD W2, W0, W2
004C1A  207FE1     MOV #0x7FE, W1
004C1C  510F81     SUB W2, W1, [W15]
004C1E  3E0008     BRA GTU, .LBE1660, .LBE1662, .L47
004C34  203FF2     MOV #0x3FF, W2
004C36  410100     ADD W2, W0, W2
004C38  207FE1     MOV #0x7FE, W1
004C3A  510F81     SUB W2, W1, [W15]
004C3C  3E0008     BRA GTU, .LBE1665, .LBE1667, .L48
004E50  203FF2     MOV #0x3FF, W2
004E52  410100     ADD W2, W0, W2
004E54  207FE1     MOV #0x7FE, W1
004E56  510F81     SUB W2, W1, [W15]
004E58  3E0008     BRA GTU, .LBE1890, .LBE1892, .L63
004E6E  203FF2     MOV #0x3FF, W2
004E70  410100     ADD W2, W0, W2
004E72  207FE1     MOV #0x7FE, W1
004E74  510F81     SUB W2, W1, [W15]
004E76  3E0008     BRA GTU, .LBE1895, .LBE1897, .L64
119:                   {
120:                       asm volatile ("; BEGIN MCAF_ADCCalibrateCurrentOffset" ::);
121:                       const int32_t delta = UTIL_mulss(measurement << MCAF_CAL_SHIFT, k);
004C20  DD0045     SL W0, #5, W0
004C3E  DD0045     SL W0, #5, W0
004E5A  DD0045     SL W0, #5, W0
004E78  DD0045     SL W0, #5, W0
122:                       if (invert)
123:                       {
124:                           pLPF->x32 -= delta;
004C24  931918     MOV [W8+818], W2
004C26  9319A8     MOV [W8+820], W3
004C28  510000     SUB W2, W0, W0
004C2A  598081     SUBB W3, W1, W1
004C2C  9B1C10     MOV W0, [W8+818]
004C2E  9B1C21     MOV W1, [W8+820]
004C42  931938     MOV [W8+822], W2
004C44  9319C8     MOV [W8+824], W3
004C46  510000     SUB W2, W0, W0
004C48  598081     SUBB W3, W1, W1
004C4A  9B1C30     MOV W0, [W8+822]
004C4C  9B1C41     MOV W1, [W8+824]
004E5E  931918     MOV [W8+818], W2
004E60  9319A8     MOV [W8+820], W3
004E62  510000     SUB W2, W0, W0
004E64  598081     SUBB W3, W1, W1
004E66  9B1C10     MOV W0, [W8+818]
004E68  9B1C21     MOV W1, [W8+820]
004E7C  931938     MOV [W8+822], W2
004E7E  9319C8     MOV [W8+824], W3
004E80  510000     SUB W2, W0, W0
004E82  598081     SUBB W3, W1, W1
004E84  9B1C30     MOV W0, [W8+822]
004E86  9B1C41     MOV W1, [W8+824]
125:                       }
126:                       else
127:                       {
128:                           pLPF->x32 += delta;
129:                       }
130:                       asm volatile ("; END MCAF_ADCCalibrateCurrentOffset" ::);
131:                   }
132:               }
133:               
134:               /**
135:                * Executes one step of ADC current compensation
136:                * 
137:                * @param pinit motor initialization state data
138:                * @param pcal current compensation gains
139:                * @param piabc measured currents
140:                */
141:               inline static void MCAF_ADCCalibrateCurrentOffsets(MCAF_MOTOR_INITIALIZATION *pinit, 
142:                                                    MCAF_CURRENT_COMPENSATION_PARAMETERS *pcal,
143:                                                    const MCAF_U_CURRENT_ABC *piabc,
144:                                                    const MCAF_U_CURRENT pidc)
145:               {
146:                   if (pinit->sampleCount < pinit->sampleCountLimit)
004C0A  932088     MOV [W8+832], W1
004C0C  931878     MOV [W8+830], W0
004C0E  508F80     SUB W1, W0, [W15]
004C10  310028     BRA C, .L46
004E44  932088     MOV [W8+832], W1
004E46  931878     MOV [W8+830], W0
004E48  508F80     SUB W1, W0, [W15]
004E4A  310028     BRA C, .L62
147:                   {
148:                       MCAF_ADCCalibrateCurrentOffset(&pinit->offsetLPF[0],
004C12  931988     MOV [W8+816], W3
004C14  900068     MOV [W8+12], W0
004E4C  931988     MOV [W8+816], W3
004E4E  900068     MOV [W8+12], W0
149:                                                       piabc->a,
150:                                                       pinit->kfilter,
151:                                                       MCAF_ADCIsPhaseACurrentInverted());
152:                       MCAF_ADCCalibrateCurrentOffset(&pinit->offsetLPF[1],
004C30  931988     MOV [W8+816], W3
004C32  900078     MOV [W8+14], W0
004E6A  931988     MOV [W8+816], W3
004E6C  900078     MOV [W8+14], W0
153:                                                       piabc->b,
154:                                                       pinit->kfilter,
155:                                                       MCAF_ADCIsPhaseBCurrentInverted());
156:                       if (HAL_ADC_IsAvailableIphaseC())
157:                       {
158:                           MCAF_ADCCalibrateCurrentOffset(&pinit->offsetLPF[2],
159:                                                           piabc->c,
160:                                                           pinit->kfilter,
161:                                                           MCAF_ADCIsPhaseCCurrentInverted());
162:                       }
163:                   
164:                       pcal->offseta = pinit->offsetLPF[0].x16.hi >> MCAF_CAL_SHIFT;
004C4E  931828     MOV [W8+820], W0
004C50  DE8045     ASR W0, #5, W0
004C52  9B1400     MOV W0, [W8+800]
004E88  931828     MOV [W8+820], W0
004E8A  DE8045     ASR W0, #5, W0
004E8C  9B1400     MOV W0, [W8+800]
165:                       pcal->offsetb = pinit->offsetLPF[1].x16.hi >> MCAF_CAL_SHIFT;
004C54  931848     MOV [W8+824], W0
004C56  DE8045     ASR W0, #5, W0
004C58  9B1430     MOV W0, [W8+806]
004E8E  931848     MOV [W8+824], W0
004E90  DE8045     ASR W0, #5, W0
004E92  9B1430     MOV W0, [W8+806]
166:                       if (HAL_ADC_IsAvailableIphaseC())
167:                       {
168:                           pcal->offsetc = pinit->offsetLPF[2].x16.hi >> MCAF_CAL_SHIFT;
169:                       }
170:                       ++pinit->sampleCount;
004C5A  932008     MOV [W8+832], W0
004C5C  E80000     INC W0, W0
004C5E  9B2400     MOV W0, [W8+832]
004C60  370144     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004E94  932008     MOV [W8+832], W0
004E96  E80000     INC W0, W0
004E98  9B2400     MOV W0, [W8+832]
004E9A  370027     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
171:                   }
172:                   else
173:                   {
174:                       pinit->ready = true;
004C62  203440     MOV #0x344, W0
004C64  400008     ADD W0, W8, W0
004C66  B3C011     MOV.B #0x1, W1
004C68  784801     MOV.B W1, [W0]
004C6A  37013F     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
004E9C  203440     MOV #0x344, W0
004E9E  400008     ADD W0, W8, W0
004EA0  B3C011     MOV.B #0x1, W1
004EA2  784801     MOV.B W1, [W0]
004EA4  370022     BRA MCAF_SystemStateMachine_StepIsr::MCAF_CaptureTimestamp
175:                   }
176:               }
177:               /**
178:                * Initializes state variables for ADC compensation
179:                * 
180:                * @param pinit motor initialization state data
181:                * @param pcal current compensation gains
182:                */
183:               void MCAF_ADCCompensationInit(MCAF_MOTOR_INITIALIZATION *pinit, 
184:                                             MCAF_CURRENT_COMPENSATION_PARAMETERS *pcal);
185:               
186:               /**
187:                * Calculate scaled PWM duty cycles from Va,Vb,Vc and the PWM period
188:                * @param pmotor motor data
189:                */
190:               void MCAF_ComputeDutyCycleOutputs(MCAF_MOTOR_DATA *pmotor);
191:               
192:               /**
193:                 * Initialize multi channel state
194:                 * @param pmultiChannel multi channel state
195:                 */        
196:                inline static void MCAF_CurrentMeasureInit(MCAF_CURRENT_MEASUREMENT *pmultiChannel) {}
197:                
198:                /**
199:                 * Reinitialize multi channel state on restart
200:                 * @param pmultiChannel single channel state
201:                 */        
202:                inline static void MCAF_CurrentMeasureRestart(MCAF_CURRENT_MEASUREMENT *pmultiChannel) {}
203:                
204:               #ifdef __cplusplus
205:               }
206:               #endif
207:               
208:               #endif /* __CURRENT_MEASURE_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/current_measure.c
1:                 /**
2:                  * current_measure.c
3:                  * 
4:                  * Current measurement: multi-channel
5:                  *
6:                  * Enables FOC with currents read from phase current sensors
7:                  * 
8:                  * Component: ADC compensation
9:                  */
10:                
11:                /* *********************************************************************
12:                 *
13:                 * Motor Control Application Framework
14:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
15:                 *
16:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
17:                 * this software and any derivatives exclusively with Microchip products.
18:                 *
19:                 * This software and any accompanying information is for suggestion only.
20:                 * It does not modify Microchip's standard warranty for its products.
21:                 * You agree that you are solely responsible for testing the software and
22:                 * determining its suitability.  Microchip has no obligation to modify,
23:                 * test, certify, or support the software.
24:                 *
25:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
26:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
27:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
28:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
29:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
30:                 * APPLICATION.
31:                 *
32:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
33:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
34:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
35:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
36:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
37:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
38:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
40:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
41:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
42:                 * SOFTWARE.
43:                 *
44:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
45:                 * THESE TERMS.
46:                 *
47:                 * *****************************************************************************/
48:                
49:                #include <stdint.h>
50:                #include "util.h"
51:                #include "current_measure.h"
52:                #include "system_state.h"
53:                #include "hal.h"
54:                #include "motor_control.h"
55:                #include "motor_control_function_mapping.h"
56:                #include "parameters/hal_params.h"
57:                #include "parameters/adc_params.h"
58:                #include "parameters/options.h"
59:                
60:                void MCAF_ADCCompensationInit(MCAF_MOTOR_INITIALIZATION *pinit, 
61:                                              MCAF_CURRENT_COMPENSATION_PARAMETERS *pcal)
62:                {
63:                    /* Scaling constants: Determined by calibration or hardware design. */
64:                                   
65:                    pcal->qKaa = CURRENT_KAA;
00950C  240002     MOV #0x4000, W2
00950E  780882     MOV W2, [W1]
66:                    pcal->qKab = CURRENT_KAB;         /* cross-axis gain compensation terms */
009510  EB0180     CLR W3
009512  980093     MOV W3, [W1+2]
67:                    pcal->qKba = CURRENT_KBA;         /* cross-axis gain compensation terms */
009514  9800B3     MOV W3, [W1+6]
68:                    pcal->qKbb = CURRENT_KBB;
009516  9800C2     MOV W2, [W1+8]
69:                    pcal->qKcc = CURRENT_KCC;
009518  9800E2     MOV W2, [W1+12]
70:                
71:                    pinit->sampleCount = 0;
00951A  980803     MOV W3, [W0+16]
72:                    pinit->sampleCountLimit = MCAF_CAL_COUNT;
00951C  200801     MOV #0x80, W1
00951E  980071     MOV W1, [W0+14]
73:                    pinit->offsetLPF[0].x32 = 0;
009520  B82260     MUL.UU W4, #0x0, W4
009522  980014     MOV W4, [W0+2]
009524  980025     MOV W5, [W0+4]
74:                    pinit->offsetLPF[1].x32 = 0;
009526  980034     MOV W4, [W0+6]
009528  980045     MOV W5, [W0+8]
75:                    pinit->offsetLPF[2].x32 = 0;
00952A  980054     MOV W4, [W0+10]
00952C  980065     MOV W5, [W0+12]
76:                    
77:                    pinit->kfilter = MCAF_CAL_FILTER_GAIN;
00952E  780802     MOV W2, [W0]
78:                }
009530  060000     RETURN
79:                
80:                inline static void MCAF_ScaleQ15(const MC_ABC_T *pabc_in, MC_ABC_T *pabc_out, int16_t k)
81:                {
82:                    pabc_out->a = UTIL_MulQ15(pabc_in->a, k);
83:                    pabc_out->b = UTIL_MulQ15(pabc_in->b, k);
84:                    pabc_out->c = UTIL_MulQ15(pabc_in->c, k);
85:                }
86:                
87:                inline static void calculateManualZeroSequenceModulation(
88:                    const MC_ABC_T *pabc_in, MC_ABC_T *pabc_out, int16_t delta, 
89:                    int16_t min, int16_t max)
90:                {
91:                    pabc_out->a = MC_adjust_zero_sequence(pabc_in->a, delta, min, max);
00007A  000920     NOP
92:                    pabc_out->b = MC_adjust_zero_sequence(pabc_in->b, delta, min, max);
00008A  000920     NOP
93:                    pabc_out->c = MC_adjust_zero_sequence(pabc_in->c, delta, min, max);    
00009A  000920     NOP
94:                }
95:                
96:                void MCAF_ComputeDutyCycleOutputs(MCAF_MOTOR_DATA *pmotor)
97:                {
000000  040200     GOTO __resetPRI, __reset
98:                    /* Calculate scaled PWM duty cycles from Va,Vb,Vc and PWM period */
99:                    if (!MCAF_OverrideZeroSequenceModulation(&pmotor->testing))
000004  000B9A     NOP
100:                   {
101:                       MC_CalculateZeroSequenceModulation(&pmotor->dabcUnshifted,
102:                           &pmotor->dabc,
103:                           HAL_PARAM_MIN_DUTY_Q15, HAL_PARAM_MAX_DUTY_Q15);
104:                   }
105:                   else
106:                   {
107:                       calculateManualZeroSequenceModulation(&pmotor->dabcUnshifted, &pmotor->dabc,
108:                               MCAF_GetOverrideZeroSequenceOffset(&pmotor->testing),
109:                               HAL_PARAM_MIN_DUTY_Q15, HAL_PARAM_MAX_DUTY_Q15);
110:                   }
111:                   MCAF_ScaleQ15(&pmotor->dabc, &pmotor->pwmDutycycle, 
112:                       HAL_PARAM_PWM_PERIOD_COUNTS);
113:               }
0000BC  000920     NOP
0000C0  000920     NOP
114:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/commutation/pll.h
1:                 /**
2:                  * pll.h
3:                  * 
4:                  * Hosts components of the PLL estimator
5:                  * 
6:                  * Component: commutation
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __PLL_H
48:                #define __PLL_H
49:                
50:                #include <stdint.h>
51:                #include "motor_control_types.h"
52:                #include "foc_types.h"
53:                #include "units.h"
54:                #include "commutation/common.h"
55:                #include "parameters/pll_params.h"
56:                #include "startup_types.h"
57:                
58:                #ifdef __cplusplus
59:                extern "C" {
60:                #endif
61:                    
62:                /**
63:                 * State variables for PLL estimator
64:                 */
65:                typedef struct tagMCAF_ESTIMATOR_PLL
66:                {
67:                    /*
68:                     * Runtime-adjustable parameters
69:                     *
70:                     * These values are typically set once, at startup,
71:                     * but may be adjusted using real-time diagnostic tools.
72:                     */
73:                    
74:                    int16_t dtAngular;          /** Integration scaling factor dt from electrical frequency to electrical angle */
75:                    int16_t rhoOffset;          /** Offset angle used to compensate the estimated rotor angle */
76:                    int16_t dIlimitLS;          /** Delta current limit used for low velocity range */
77:                    int16_t dIlimitHS;          /** Delta current limit used for high velocity range */
78:                    int16_t kEsdqFilter;        /** Filter constant used for filtering BEMF voltage */
79:                    int16_t kVelEstimFilter;    /** Filter constant used for filtering estimated velocity */
80:                    MCAF_U_VELOCITY_ELEC omegaFilterThreshold;    /** Velocity below which we use slow filtering */
81:                    MCAF_U_BACKEMF_INVERSE keInverse;             /** Inverse of back-EMF constant */
82:                
83:                    /*
84:                     * State variables
85:                     *
86:                     * The state of the estimator at any given instant 
87:                     * is completely determined by its state variables.
88:                     *
89:                     * At each new step of the estimator, the state variables can theoretically
90:                     * be expressed as a deterministic function of the following values:
91:                     *
92:                     *   - state variables at the previous step
93:                     *   - runtime-adjustable parameters
94:                     *   - inputs to the estimator step function
95:                     */
96:                    int32_t rhoStateVar;        /** Internal state variable for rotor angle */
97:                    int16_t rho;                /** Estimated rotor angle prior to offset compensation */
98:                    int16_t diCounter;          /** Counter index used to track current sample history */
99:                    MCAF_U_VOLTAGE_DQ_Q14 esdqFiltered;       /** Filtered value of BEMF in d-q reference frame */
100:                   struct
101:                   {
102:                       int32_t d;
103:                       int32_t q;
104:                   } esdqStateVar;             /** State variable for BEMF in d-q reference frame */
105:                   int32_t velEstimStateVar;   /** State Variable for estimated velocity */
106:                   MCAF_U_VOLTAGE_ALPHABETA lastValphabeta;     /** Value of Valphabeta from previous control step */
107:                   MCAF_U_CURRENT_ALPHABETA lastIalphabeta[PLL_LOWSPEED_DIBYDT_PRESCALER];  /** Array storing a history of
108:                                                                                    * previous Ialphabeta values */
109:                   
110:                   /*
111:                    * Auxiliary variables
112:                    *
113:                    * These values can be derived from the state variables
114:                    * using memory-less calculations. 
115:                    *
116:                    * They are usually output or intermediate variables,
117:                    * and are typically retained in RAM to support data logging 
118:                    * with real-time diagnostic tools.
119:                    */
120:                   int16_t omegaMr;            /** Estimated velocity that is unscaled and unfiltered */
121:                   MCAF_U_VOLTAGE_ALPHABETA_Q14 esalphabeta; /** Calculated BEMF in alpha-beta reference frame */
122:                   MCAF_U_VOLTAGE_DQ_Q14 esdq;               /** Calculated BEMF in d-q reference frame */
123:                   MCAF_U_DIMENSIONLESS_SINCOS sincos;   /** Sine and cosine component of calculated rotor angle */
124:                   MCAF_U_VOLTAGE_ALPHABETA vInductance; /** Calculated value of voltage across stator inductance */
125:                   MCAF_U_VOLTAGE irDropAlpha;           /** Calculated value of voltage across stator resistance */
126:                   MCAF_U_VOLTAGE irDropBeta;            /** Calculated value of voltage across stator resistance */
127:                   
128:                   MCAF_ESTIMATOR_OUTPUTS_T output;      /** Output velocity and angle */
129:               } MCAF_ESTIMATOR_PLL_T;
130:               
131:               /**
132:                * Initializes PLL state variables on reset.
133:                * Summary: Initializes PLL state variables.
134:                * @param pll PLL state variable structure
135:                * @param pmotor Motor parameters
136:                */
137:               void MCAF_EstimatorPllInit(MCAF_ESTIMATOR_PLL_T *pll, const MCAF_MOTOR_PARAMETERS_T *pmotor);
138:               
139:               /**
140:                * Initializes PLL state variables prior to starting motor.
141:                * 
142:                * @param pll PLL state variable structure
143:                */
144:               void MCAF_EstimatorPllStartupInit(MCAF_ESTIMATOR_PLL_T *pll);
145:               
146:               /**
147:                * Executes one control step of the PLL estimator.
148:                * Summary: Executes one control step of the PLL estimator.
149:                * @param pll PLL state variable structure
150:                * @param pinput Standard algorithm inputs (e.g. stationary-frame voltage and current)
151:                * @param pmotor Motor parameters
152:                */
153:               void MCAF_EstimatorPllStep(MCAF_ESTIMATOR_PLL_T *pll,
154:                                          const MCAF_STANDARD_INPUT_SIGNALS_T *pinput,
155:                                          const MCAF_MOTOR_PARAMETERS_T *pmotor);
156:               
157:               /**
158:                * Returns commutation angle
159:                * 
160:                * @param pll state
161:                * @return commutation angle
162:                */
163:               inline static MCAF_U_ANGLE_ELEC MCAF_EstimatorPllCommutationAngle(const MCAF_ESTIMATOR_PLL_T *pll)
164:               {
165:                   return pll->output.thetaElectrical;
0071FC  9128C8     MOV [W8+344], W1
166:               }
167:               
168:               /**
169:                * Sets commutation angle
170:                * 
171:                * This should be used sparingly and only to initialize the PLL,
172:                * when there is very high confidence in an angle obtained from another source,
173:                * and the PLL may be operating at a low speed and get stuck.
174:                * 
175:                * @param pll state
176:                * @param theta desired angle
177:                */
178:               inline static void MCAF_EstimatorPllSetAngle(MCAF_ESTIMATOR_PLL_T *pll, MCAF_U_ANGLE_ELEC theta)
179:               {
180:                   MCAF_U_ANGLE_ELEC rho = theta - pll->rhoOffset;
181:                   pll->rhoStateVar = (int32_t)rho << 15;
182:               }
183:               
184:               /**
185:                * Updates commutation angle and velocity
186:                * 
187:                * This should be used sparingly and only to initialize the PLL,
188:                * when there is very high confidence in an angle obtained from another source,
189:                * and the PLL may be operating at a low speed and get stuck.
190:                * 
191:                * This type signature (with typeless void *) is designed to be compatible with 
192:                * MCAF_ESTIMATOR_OUTPUT_UPDATE_FUNCTION, for interaction with other code
193:                * modules that should not have a code dependency on this estimator.
194:                *
195:                * @param obj PLL state
196:                * @param pout desired angle and velocity
197:                */
198:               inline static void MCAF_EstimatorPllUpdateOutput(void *obj, const MCAF_ESTIMATOR_OUTPUTS_T *pout)
199:               {
200:                   MCAF_ESTIMATOR_PLL_T *pll = (MCAF_ESTIMATOR_PLL_T *)obj;
201:                   MCAF_EstimatorPllSetAngle(pll, pout->thetaElectrical);
202:                   /* MCAF R7 will not update the velocity at this time. */
203:               }
204:               
205:               /**
206:                * Returns electrical frequency
207:                * 
208:                * @param pll state
209:                * @return electrical frequency
210:                */
211:               inline static MCAF_U_VELOCITY_ELEC MCAF_EstimatorPllElectricalFrequency(const MCAF_ESTIMATOR_PLL_T *pll)
212:               {
213:                   return pll->output.omegaElectrical;
007200  912838     MOV [W8+342], W0
214:               }
215:               
216:               /**
217:                * Determine whether startup delay is requested
218:                * 
219:                * @param pll state
220:                * @param startupStatus startup status
221:                * @return whether a startup delay is requested
222:                */
223:               inline static bool MCAF_EstimatorPllStartupDelayRequested(const MCAF_ESTIMATOR_PLL_T *pll, MCAF_STARTUP_STATUS_T startupStatus)
224:               {
225:                   return false;
226:               }
227:               
228:               
229:               
230:               #ifdef __cplusplus
231:               }
232:               #endif
233:               
234:               #endif /* __PLL_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/commutation/pll.c
1:                 /**
2:                  * pll.c
3:                  * 
4:                  * Hosts components of the PLL estimator
5:                  * 
6:                  * Component: commutation
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                
49:                #include "util.h"
50:                #include "parameters/pll_params.h"
51:                #include "parameters/operating_params.h"
52:                #include "parameters/motor_params.h"
53:                #include "motor_control.h"
54:                #include "motor_control_function_mapping.h"
55:                #include "pll.h"
56:                #include "system_state.h"
57:                #include "math_asm.h"
58:                #include "commutation/common.h"
59:                
60:                inline static bool useNegatedEsd(const MCAF_ESTIMATOR_PLL_T *pll)
61:                {
62:                    const MCAF_U_VELOCITY_ELEC omega = pll->output.omegaElectrical;
005F3C  903110     MOV [W0+98], W2
63:                    if (UTIL_Abs16(omega) > DECIMATE_BASE_SPEED)
005F48  208893     MOV #0x889, W3
005F4A  508F83     SUB W1, W3, [W15]
005F4C  340005     BRA LE, .L24
64:                    {
65:                        /* At speed greater than decimation speed, calculate the estimated
66:                         * velocity based on:
67:                         *  OmegaMr = (1/ke) * (Eqfiltered - sgn(Eqfiltered) * Edfiltered)
68:                         */
69:                        return pll->esdqFiltered.q > 0;
005F4E  B3C011     MOV.B #0x1, W1
005F50  E00005     CP0 W5
005F52  3C0006     BRA GT, .LBE136, .LBE137, .L26
005F54  EB4080     CLR.B W1
005F56  370004     BRA .LBE136, .LBE137, .L26
70:                    }
71:                    else
72:                    {
73:                        /* At speed lower than or equal to decimation speed, calculate the estimated
74:                         * velocity based on:
75:                         *  OmegaMr = (1/ke) * (Eqfiltered - sgn(omega) * Edfiltered)
76:                         * to improve stability.
77:                         */        
78:                        return omega > 0;
005F58  B3C011     MOV.B #0x1, W1
005F5A  E00002     CP0 W2
005F5C  3C0001     BRA GT, .LBE136, .LBE137, .L26
005F5E  EB4080     CLR.B W1
79:                    }
80:                }
81:                
82:                inline static int16_t computeDeltaEs(const MCAF_ESTIMATOR_PLL_T *pll)
83:                {
84:                    /* Calculate the estimated velocity based on the filtered value of BEMF
85:                     * voltage. Up-scale the velocity by a factor of two in order to compensate for
86:                     * the down-scaled BEMF voltage. This scale-down + scale-up arrangement is required to
87:                     * avoid overflow/saturation of BEMF calculation in a few corner cases. 
88:                     * 
89:                     * Compute Eqfiltered - s*Edfilterend,
90:                     * where s is +/- 1 and is determined either from Eqfiltered or omega.
91:                     */
92:                    if (useNegatedEsd(pll))
005F60  E00401     CP0.B W1
005F62  320003     BRA Z, .L28
93:                    {
94:                        return pll->esdqFiltered.q - pll->esdqFiltered.d;
005F64  9008C0     MOV [W0+24], W1
005F66  520201     SUB W4, W1, W4
005F68  370002     BRA UTIL_mulss
95:                    }
96:                    else
97:                    {
98:                        return pll->esdqFiltered.q + pll->esdqFiltered.d;
005F6A  9008C0     MOV [W0+24], W1
005F6C  420201     ADD W4, W1, W4
99:                    }
100:               }
101:               
102:               inline static int16_t computeOmegaMr(const MCAF_ESTIMATOR_PLL_T *pll,
103:                                                    const MCAF_MOTOR_PARAMETERS_T *pmotor)
104:               {
105:                   const int16_t deltaEs = computeDeltaEs(pll);
106:                   
107:                   /* Adjusting the shift count by 1 to compensate for Q14 scaling of the estimated back EMF */
108:                   return UTIL_SatShrS16(UTIL_mulss(pll->keInverse, deltaEs), MCAF_MOTOR_KE_INVERSE_Q - 1);
109:               }
110:               
111:               void MCAF_EstimatorPllStep(MCAF_ESTIMATOR_PLL_T *pll, 
112:                                          const MCAF_STANDARD_INPUT_SIGNALS_T *pinput,
113:                                          const MCAF_MOTOR_PARAMETERS_T *pmotor)
114:               {
005CE0  BE9F88     MOV.D W8, [W15++]
005CE2  BE9F8A     MOV.D W10, [W15++]
115:                   MC_ALPHABETA_T deltaI;
116:                   const MCAF_U_CURRENT_ALPHABETA *ialphabeta = &pinput->ialphabeta;
117:                   const MCAF_U_VOLTAGE_ALPHABETA *valphabeta = &pinput->valphabeta;
118:                       
119:                   /* 
120:                    * Calculate voltage drop in stationary (alpha-beta) frame
121:                    * due to inductance and change in current.
122:                    *
123:                    *   vInductance = Ls * (dI/dt)
124:                    *
125:                    * The discrete-time calculation of this voltage is
126:                    *
127:                    *   delta_I = (I[k] - I[k-1])
128:                    *   vInductance = Ls * delta_I / delta_t
129:                    *
130:                    * When evaluating this expression in fixed-point,
131:                    * we use an implicit factor of delta_t = 1 (per-unit)
132:                    * to eliminate the need for an additional divide by delta_t
133:                    * (or multiplication by 1/delta_t). This adds constraints
134:                    * on the fixed-point representations of delta_I, vInductance,
135:                    * and Ls, and as a result, there are several equivalent ways
136:                    * of interpreting the calculation:
137:                    *   
138:                    * Without implicit delta_t = 1 (per-unit):
139:                    *
140:                    *   vInductance = (Ls/delta_t) * delta_I
141:                    *   vInductance = (Ls * delta_I) / delta_t
142:                    *   vInductance = Ls * (delta_I / delta_t)
143:                    *
144:                    * With implicit delta_t = 1 (per-unit):
145:                    *
146:                    *   vInductance = Ls*delta_I
147:                    *
148:                    * For example, suppose the normalization factors are
149:                    *
150:                    *   current (I):      8.8  A
151:                    *   time:            50.0  us    (= timestep)
152:                    *   voltage (V):     52.8  V
153:                    *   dI/dt:          176.0  A/ms   = 8.8A / 50us
154:                    *   inductance (L): 300.0  uH     = (52.8V * 50us)/8.8A
155:                    *   L/t:              6.0  ohm    = 52.8V / 8.8A
156:                    *   flux (V*t):       2.64 mVs    = 52.8V * 50us
157:                    *
158:                    * If Ls = 450uH and delta_I = 0.55A, then the inductive drop is
159:                    * Ls*delta_I/delta_t = 4.95V.
160:                    *   
161:                    * Normalized (or "per-unit") calculations are:
162:                    *
163:                    * Ls              = 1.5
164:                    *                 = 450uH (= 1.5 * 300uH)
165:                    * Ls/delta_t      = 1.5
166:                    *                 = 9 ohm (= 1.5 * 6 ohm = 450uH / 50us)
167:                    * delta_I         = 0.0625
168:                    *                 = 0.55A (= 0.0625*8.8A)
169:                    * delta_I/delta_t = 0.0625
170:                    *                 = 11A/msec (= 0.0625*176A/ms = 0.55A/50us)
171:                    * Ls*delta_I      = 0.09375
172:                    *                 = 247.5uVs (= 0.09375 * 2.64mVs = 450uH*0.55A)
173:                    * vInductance     = 0.09375
174:                    *                 = 4.95V (= 0.09375 * 52.8V)
175:                    *
176:                    *                 = (Ls/delta_t) * delta_I = 1.5 * 0.0625
177:                    *                 = (Ls*delta_I) / delta_t = 0.09375 / 1
178:                    *                 = Ls*(delta_I/delta_t)   = 1.5 * 0.0625
179:                    *                 = Ls*delta_I             = 1.5 * 0.0625
180:                    *
181:                    * Note that calculations that vary by a factor of delta_t
182:                    * have identical per-unit values, even though
183:                    * their actual units are different.
184:                    * (For example Ls = 1.5 = Ls/delta_t,
185:                    * delta_I = 0.0625 = delta_I/delta_t,
186:                    * Ls*delta_I = 0.09375 = vInductance)
187:                    */
188:                   if (UTIL_Abs16(pll->output.omegaElectrical) < pll->omegaFilterThreshold)
005CEE  900260     MOV [W0+12], W4
005CF0  520F83     SUB W4, W3, [W15]
005CF2  34003C     BRA LE, .LBE88, .LBB101, .L2
189:                   {
190:                       /* At lower speed the granularity of change is higher. Hence, the difference
191:                        * is calculated between two sampled values that are PLL_LOWSPEED_DIBYDT_PRESCALER 
192:                        * number of PLL execution steps apart */
193:                       const MC_ALPHABETA_T *lastIalphabeta = 
194:                               &pll->lastIalphabeta[(pll->diCounter-(PLL_LOWSPEED_DIBYDT_PRESCALER-1))&
005CF4  9009B0     MOV [W0+22], W3
005CF6  5181E7     SUB W3, #0x7, W3
005CF8  6181E7     AND W3, #0x7, W3
195:                               (PLL_LOWSPEED_DIBYDT_PRESCALER-1)];
196:                       deltaI.alpha = (ialphabeta->alpha - lastIalphabeta->alpha);
005CFA  41826B     ADD W3, #0xB, W4
005CFC  DD2242     SL W4, #2, W4
005CFE  400204     ADD W0, W4, W4
005D00  780311     MOV [W1], W6
005D02  530294     SUB W6, [W4], W5
197:                       deltaI.beta = (ialphabeta->beta - lastIalphabeta->beta);
005D04  DD19C2     SL W3, #2, W3
005D06  B002E3     ADD #0x2E, W3
005D08  400183     ADD W0, W3, W3
005D0A  900211     MOV [W1+2], W4
005D0C  520213     SUB W4, [W3], W4
198:                       
199:                       /* Limit the change in current to dIlimitLS in order to
200:                        * reduce the effect of noisy current measurements */
201:                       deltaI.alpha = UTIL_LimitS16(deltaI.alpha, -pll->dIlimitLS, pll->dIlimitLS);
005D0E  9001A0     MOV [W0+4], W3
005D10  EA0383     NEG W3, W7
202:                       deltaI.beta = UTIL_LimitS16(deltaI.beta, -pll->dIlimitLS, pll->dIlimitLS);
203:                       
204:                       /* 
205:                        * vInductance = Ls * (dI/dt) with implicit dt=1 (per-unit)
206:                        */
207:                       pll->vInductance.alpha = UTIL_SatShrS16(__builtin_mulss(pmotor->l0BaseDt, deltaI.alpha),
005D2E  900212     MOV [W2+2], W4
005D30  B9A306     MUL.SS W4, W6, W6
005D4A  98285A     MOV W10, [W0+90]
208:                                                   MCAF_MOTOR_L0_BASE_DT_Q+PLL_LOWSPEED_DIBYDT_PRESCALER_SHIFTCOUNT);
209:                       pll->vInductance.beta = UTIL_SatShrS16(__builtin_mulss(pmotor->l0BaseDt, deltaI.beta),
005D4C  900312     MOV [W2+2], W6
005D4E  B9B303     MUL.SS W6, W3, W6
005D68  982863     MOV W3, [W0+92]
005D6A  370039     BRA .LBE101, .L9
210:                                                   MCAF_MOTOR_L0_BASE_DT_Q+PLL_LOWSPEED_DIBYDT_PRESCALER_SHIFTCOUNT);
211:                   }
212:                   else
213:                   {
214:                       /* At higher speed the granularity of change is insignificant. Hence, the
215:                        * difference can be calculated between two sampled values that are one PLL
216:                        * execution steps apart */
217:                       const MC_ALPHABETA_T *lastIalphabeta = &pll->lastIalphabeta[pll->diCounter];
005D6C  9009B0     MOV [W0+22], W3
218:                       deltaI.alpha = (ialphabeta->alpha - lastIalphabeta->alpha);
005D6E  41826B     ADD W3, #0xB, W4
005D70  DD2242     SL W4, #2, W4
005D72  400204     ADD W0, W4, W4
005D74  780311     MOV [W1], W6
005D76  530294     SUB W6, [W4], W5
219:                       deltaI.beta = (ialphabeta->beta - lastIalphabeta->beta);  
005D78  DD19C2     SL W3, #2, W3
005D7A  B002E3     ADD #0x2E, W3
005D7C  400183     ADD W0, W3, W3
005D7E  900211     MOV [W1+2], W4
005D80  520213     SUB W4, [W3], W4
220:               
221:                       /* Limit the change in current to dIlimitHS in order to
222:                        * reduce the effect of noisy current measurements */        
223:                       deltaI.alpha = UTIL_LimitS16(deltaI.alpha, -pll->dIlimitHS, pll->dIlimitHS);
005D82  9001B0     MOV [W0+6], W3
005D84  EA0383     NEG W3, W7
224:                       deltaI.beta = UTIL_LimitS16(deltaI.beta, -pll->dIlimitHS, pll->dIlimitHS);        
225:                               
226:                       /* 
227:                        * vInductance = Ls * (dI/dt) with implicit dt=1 (per-unit)
228:                        */
229:                       pll->vInductance.alpha = UTIL_SatShrS16(__builtin_mulss(pmotor->l0BaseDt, deltaI.alpha),
005DA2  900212     MOV [W2+2], W4
005DA4  B9A306     MUL.SS W4, W6, W6
005DBE  98285A     MOV W10, [W0+90]
230:                                                           MCAF_MOTOR_L0_BASE_DT_Q);
231:                       pll->vInductance.beta = UTIL_SatShrS16(__builtin_mulss(pmotor->l0BaseDt, deltaI.beta),
005DC0  900312     MOV [W2+2], W6
005DC2  B9B303     MUL.SS W6, W3, W6
005DDC  982863     MOV W3, [W0+92]
232:                                                           MCAF_MOTOR_L0_BASE_DT_Q);
233:                   }
234:               
235:                   /* Update the sample history of Ialpha and Ibeta */
236:                   pll->diCounter = (pll->diCounter+1) & (PLL_LOWSPEED_DIBYDT_PRESCALER-1);
005DDE  9009B0     MOV [W0+22], W3
005DE0  E80183     INC W3, W3
005DE2  6181E7     AND W3, #0x7, W3
005DE4  980833     MOV W3, [W0+22]
237:                   MC_ALPHABETA_T *pialphabetaHistory = &pll->lastIalphabeta[pll->diCounter];
238:                   pialphabetaHistory->alpha = ialphabeta->alpha;
005DE6  41826B     ADD W3, #0xB, W4
005DE8  DD2242     SL W4, #2, W4
005DEA  400204     ADD W0, W4, W4
005DEC  780A11     MOV [W1], [W4]
239:                   pialphabetaHistory->beta  = ialphabeta->beta;
005DEE  DD19C2     SL W3, #2, W3
005DF0  400183     ADD W0, W3, W3
005DF2  900211     MOV [W1+2], W4
005DF4  9811F4     MOV W4, [W3+46]
240:               
241:                   /*
242:                    * If delay matching is desired, add a one-cycle delay for Valphabeta
243:                    * to match the delay in the phase current samples.
244:                    */
245:                   const MCAF_U_VOLTAGE_ALPHABETA *valphabetaCompensated =
246:                        (MCAF_PLL_DELAY_MATCH)
247:                      ? &pll->lastValphabeta
248:                      : valphabeta;
249:                   
250:                   /* Calculate the BEMF voltage:
251:                    *  Ealphabeta = Valphabeta - Rs*Ialphabeta - Ls*(dIalphabeta/dt)
252:                    * and scale it down by a factor of two. This scaling is required 
253:                    * to prevent overflow/saturation of BEMF calculation in a few corner cases.
254:                    */
255:                   pll->irDropAlpha = UTIL_SatShrS16(__builtin_mulss(pmotor->rs, ialphabeta->alpha),
005DF6  780312     MOV [W2], W6
005DF8  B9B311     MUL.SS W6, [W1], W6
005E12  982873     MOV W3, [W0+94]
256:                                                     MCAF_MOTOR_RS_Q);
257:                   pll->esalphabeta.alpha = (((int32_t)valphabetaCompensated->alpha) - pll->irDropAlpha
005E14  901240     MOV [W0+40], W4
005E16  DEA2CF     ASR W4, #15, W5
005E18  B91B61     MUL.SU W3, #0x1, W6
005E1A  520206     SUB W4, W6, W4
005E1C  5A8287     SUBB W5, W7, W5
005E2A  982074     MOV W4, [W0+78]
258:                                                                - pll->vInductance.alpha) >> 1;
005E1E  902B50     MOV [W0+90], W6
005E20  DEB3CF     ASR W6, #15, W7
005E22  520206     SUB W4, W6, W4
005E24  5A8287     SUBB W5, W7, W5
005E26  D18285     ASR W5, W5
005E28  D38204     RRC W4, W4
259:                   pll->irDropBeta = UTIL_SatShrS16(__builtin_mulss(pmotor->rs, ialphabeta->beta ),
005E2C  780112     MOV [W2], W2
005E2E  900311     MOV [W1+2], W6
005E30  B99306     MUL.SS W2, W6, W6
005E4A  983004     MOV W4, [W0+96]
260:                                                    MCAF_MOTOR_RS_Q);
261:                   pll->esalphabeta.beta = (((int32_t)valphabetaCompensated->beta) - pll->irDropBeta
005E4C  901150     MOV [W0+42], W2
005E4E  DE91CF     ASR W2, #15, W3
005E50  DEA2CF     ASR W4, #15, W5
005E52  510204     SUB W2, W4, W4
005E54  598285     SUBB W3, W5, W5
005E62  982804     MOV W4, [W0+80]
262:                                                                 - pll->vInductance.beta) >> 1;
005E56  902960     MOV [W0+92], W2
005E58  DE91CF     ASR W2, #15, W3
005E5A  520202     SUB W4, W2, W4
005E5C  5A8283     SUBB W5, W3, W5
005E5E  D18285     ASR W5, W5
005E60  D38204     RRC W4, W4
263:               
264:                   if (MCAF_PLL_DELAY_MATCH)
265:                   {
266:                       /* Update previous values of Valphabeta to be used in the next control step */
267:                       pll->lastValphabeta.alpha = valphabeta->alpha;
005E64  900321     MOV [W1+4], W6
005E66  981046     MOV W6, [W0+40]
268:                       pll->lastValphabeta.beta = valphabeta->beta;
005E68  9000B1     MOV [W1+6], W1
005E6A  981051     MOV W1, [W0+42]
269:                   }
270:               
271:                   /* Calculate sine and cosine components of the rotor angle */
272:                   MC_CalculateSineCosine(pll->output.thetaElectrical, &pll->sincos);
273:               
274:                   /* Transform the calculated BEMF voltage into rotor reference frame using:
275:                    *  Esd =  Ealpha*cos(Angle) + Ebeta*sin(Angle)
276:                    *  Esq = -Ealpha*sin(Angle) + Ebeta*cos(Angle)
277:                    * i.e. equivalent to Park transform
278:                    */
279:                   pll->esdq.d = UTIL_Shr15(__builtin_mulss(pll->esalphabeta.alpha, pll->sincos.cos) + 
005EE2  9020F0     MOV [W0+78], W1
005EE4  902B30     MOV [W0+86], W6
005EE6  B98A06     MUL.SS W1, W6, W4
005EEE  420408     ADD W4, W8, W8
005EF0  4A8489     ADDC W5, W9, W9
280:                                       __builtin_mulss(pll->esalphabeta.beta, pll->sincos.sin));
005EE8  902980     MOV [W0+80], W3
005EEA  902940     MOV [W0+88], W2
005EEC  B99C02     MUL.SS W3, W2, W8
281:                   pll->esdq.q = UTIL_Shr15(__builtin_mulss(pll->esalphabeta.beta, pll->sincos.cos) - 
005EF8  B99B06     MUL.SS W3, W6, W6
005EFC  530102     SUB W6, W2, W2
005EFE  5B8183     SUBB W7, W3, W3
282:                                       __builtin_mulss(pll->esalphabeta.alpha, pll->sincos.sin));    
005EFA  B98902     MUL.SS W1, W2, W2
283:                   
284:                   /* Filter the BEMF voltage using a first order low pass filter:
285:                    *  Edqfiltered = 1/TFilterd * Integral{ (Esd-EsdFilter).dt }
286:                    */
287:                   const int16_t ddiff = pll->esdq.d - pll->esdqFiltered.d;
005F0C  9008C0     MOV [W0+24], W1
005F0E  548201     SUB W9, W1, W4
288:                   pll->esdqStateVar.d += __builtin_mulss(ddiff, pll->kEsdqFilter);
005F08  900B60     MOV [W0+28], W6
005F0A  900BF0     MOV [W0+30], W7
005F10  9000C0     MOV [W0+8], W1
005F12  B9A201     MUL.SS W4, W1, W4
005F14  430204     ADD W6, W4, W4
005F16  4B8285     ADDC W7, W5, W5
005F18  980864     MOV W4, [W0+28]
005F1A  980875     MOV W5, [W0+30]
289:                   pll->esdqFiltered.d = UTIL_Shr15(pll->esdqStateVar.d);
290:                   const int16_t qdiff = pll->esdq.q - pll->esdqFiltered.q;
005F26  900A50     MOV [W0+26], W4
005F28  510104     SUB W2, W4, W2
291:                   pll->esdqStateVar.q += __builtin_mulss(qdiff, pll->kEsdqFilter);
005F22  901300     MOV [W0+32], W6
005F24  901390     MOV [W0+34], W7
005F2A  B99101     MUL.SS W2, W1, W2
005F2C  430102     ADD W6, W2, W2
005F2E  4B8183     ADDC W7, W3, W3
005F30  981002     MOV W2, [W0+32]
005F32  981013     MOV W3, [W0+34]
292:                   pll->esdqFiltered.q = UTIL_Shr15(pll->esdqStateVar.q);
005F3A  980855     MOV W5, [W0+26]
293:               
294:                   pll->omegaMr = computeOmegaMr(pll, pmotor);
005F8A  982061     MOV W1, [W0+76]
295:                   
296:                   /* Integrate the estimated velocity to get estimated rotor angle */
297:                   pll->rhoStateVar += __builtin_mulss(pll->omegaMr, pll->dtAngular);
005F8C  900900     MOV [W0+16], W2
005F8E  900990     MOV [W0+18], W3
005F90  B98A10     MUL.SS W1, [W0], W4
005F92  410204     ADD W2, W4, W4
005F94  498285     ADDC W3, W5, W5
005F96  980804     MOV W4, [W0+16]
005F98  980815     MOV W5, [W0+18]
298:                   pll->rho = UTIL_Shr15(pll->rhoStateVar);
005F9E  980825     MOV W5, [W0+20]
299:                   /* Compensate the estimated rotor angle with predetermined offset value */
300:                   pll->output.thetaElectrical = pll->rho + pll->rhoOffset;
005FA0  900210     MOV [W0+2], W4
005FA2  420105     ADD W4, W5, W2
005FA4  983022     MOV W2, [W0+100]
301:                   /* Filter the estimated velocity using a first order low-pass filter */
302:                   const int16_t omegadiff = pll->omegaMr - pll->output.omegaElectrical;
005FAA  903210     MOV [W0+98], W4
005FAC  508084     SUB W1, W4, W1
303:                   pll->velEstimStateVar += __builtin_mulss(omegadiff, pll->kVelEstimFilter);
005FA6  901120     MOV [W0+36], W2
005FA8  9011B0     MOV [W0+38], W3
005FAE  900250     MOV [W0+10], W4
005FB0  B98A04     MUL.SS W1, W4, W4
005FB2  410204     ADD W2, W4, W4
005FB4  498285     ADDC W3, W5, W5
005FB6  981024     MOV W4, [W0+36]
005FB8  981035     MOV W5, [W0+38]
304:                   pll->output.omegaElectrical = UTIL_Shr15(pll->velEstimStateVar);
305:               
306:               }
005FC0  BE054F     MOV.D [--W15], W10
005FC2  BE044F     MOV.D [--W15], W8
005FC4  060000     RETURN
307:               
308:               void MCAF_EstimatorPllInit(MCAF_ESTIMATOR_PLL_T *pll, 
309:                       const MCAF_MOTOR_PARAMETERS_T *pmotor)
310:               {
311:                   pll->rhoStateVar = 0;
008D34  B81160     MUL.UU W2, #0x0, W2
008D36  980802     MOV W2, [W0+16]
008D38  980813     MOV W3, [W0+18]
312:                   pll->omegaMr = 0;
008D3A  EB0080     CLR W1
008D3C  982061     MOV W1, [W0+76]
313:                   pll->diCounter = 0;
008D3E  980831     MOV W1, [W0+22]
314:                   pll->esdqStateVar.d = 0;
008D40  980862     MOV W2, [W0+28]
008D42  980873     MOV W3, [W0+30]
315:                   pll->esdqStateVar.q = 0;
008D44  981002     MOV W2, [W0+32]
008D46  981013     MOV W3, [W0+34]
316:                   pll->esdq.d = 0;
008D48  982811     MOV W1, [W0+82]
317:                   pll->esdq.q = 0;
008D4A  982821     MOV W1, [W0+84]
318:                   pll->dIlimitHS = D_ILIMIT_HS;
008D4C  203BC2     MOV #0x3BC, W2
008D4E  980032     MOV W2, [W0+6]
319:                   pll->dIlimitLS = D_ILIMIT_LS;
008D50  21AAB2     MOV #0x1AAB, W2
008D52  980022     MOV W2, [W0+4]
320:                   pll->kEsdqFilter = KFILTER_ESDQ;
008D54  204AF2     MOV #0x4AF, W2
008D56  980042     MOV W2, [W0+8]
321:                   pll->kVelEstimFilter = KFILTER_VELESTIM;
008D58  202EC2     MOV #0x2EC, W2
008D5A  980052     MOV W2, [W0+10]
322:                   pll->omegaFilterThreshold = MCAF_PLL_VELOCITY_FILTER_THRESHOLD;
008D5C  255552     MOV #0x5555, W2
008D5E  980062     MOV W2, [W0+12]
323:               
324:                   pll->dtAngular = MCAF_PLL_DT_ANGULAR;
008D60  205002     MOV #0x500, W2
008D62  780802     MOV W2, [W0]
325:                   pll->rhoOffset = INITOFFSET_TRANS_OPEN_CLSD;
008D64  980011     MOV W1, [W0+2]
326:                   pll->output.thetaElectrical = 0;
008D66  983021     MOV W1, [W0+100]
327:                   pll->output.omegaElectrical = 0;
008D68  983011     MOV W1, [W0+98]
328:                   pll->rho = 0;
008D6A  980821     MOV W1, [W0+20]
329:                   
330:                   pll->keInverse = UTIL_MulQ14(MCAF_MOTOR_KE_INVERSE, MCAF_PLL_KE_INVERSE_SCALING);
331:               }
008D7A  060000     RETURN
008D7C  EB0080     CLR W1
332:               
333:               void MCAF_EstimatorPllStartupInit(MCAF_ESTIMATOR_PLL_T *pll)
334:               {
335:                   // do nothing, at least not right now
336:               }
009FBC  060000     RETURN
009FBE  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/commutation.h
1:                 /**
2:                  * commutation.h
3:                  *
4:                  * Module to include commutation functions
5:                  * 
6:                  * Component: commutation
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #ifndef __COMMUTATION_H
48:                #define __COMMUTATION_H
49:                
50:                #include "system_state.h"
51:                #include "startup.h"
52:                #include "parameters/operating_params.h"
53:                
54:                #ifdef __cplusplus
55:                extern "C" {
56:                #endif
57:                
58:                /**
59:                 * This function initializes commutation
60:                 *
61:                 * Summary : Commutation initialization
62:                 *
63:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
64:                 */
65:                 void MCAF_CommutationInit(MCAF_MOTOR_DATA *pmotor);
66:                
67:                /**
68:                 * This function initializes the commutation upon beginning open-loop startup
69:                 *
70:                 * Summary : Commutation restart
71:                 *
72:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
73:                 */
74:                 void MCAF_CommutationStartupInit(MCAF_MOTOR_DATA *pmotor);
75:                
76:                /**
77:                 * This function calculate commutation angle each processing step
78:                 *
79:                 * Summary : Commutation angle calculator
80:                 *
81:                 * @param pmotor This parameter is pointer to MCAF_MOTOR_DATA structure
82:                 */
83:                 void MCAF_CommutationStep(MCAF_MOTOR_DATA *pmotor);
84:                
85:                 /**
86:                  * Adjusts controller state on transition from open-loop commutation
87:                  * to closed-loop commutation.
88:                  *
89:                  * @param pmotor motor controller state
90:                  */
91:                 inline static void MCAF_CommutationTransitionToClosedLoop(MCAF_MOTOR_DATA *pmotor)
92:                 {
93:                    /*
94:                     * The first time the velocity controller is executed, we want the output
95:                     * to be continuous with the existing current command.
96:                     */
97:                    pmotor->omegaCtrl.integrator = (int32_t) pmotor->idqCmdRaw.q << 16;
004D1E  900118     MOV [W8+2], W2
004D20  DE91CF     ASR W2, #15, W3
004D22  DD11C0     SL W2, #0, W3
004D24  200002     MOV #0x0, W2
004D26  993402     MOV W2, [W8+352]
004D28  993413     MOV W3, [W8+354]
98:                    pmotor->startup.counter = 0;
004D2A  B81160     MUL.UU W2, #0x0, W2
004D2C  99B402     MOV W2, [W8+480]
004D2E  99B413     MOV W3, [W8+482]
99:                                
100:                   /* 
101:                    * 
102:                    * Set flags to notify other parts of MCAF that the velocity loop and commutation
103:                    * are both in closed loop.
104:                    */
105:                   MCAF_SetClosedLoopCommutation(pmotor);
106:                   MCAF_SetClosedLoopVelocity(pmotor);
107:               }
108:               
109:                /**
110:                * Reinitializes startup information, when first entering motor startup state.
111:                * Used both in normal mode (going from STOP to STARTING)
112:                * and in exceptional conditions (exiting error or debug state)
113:                *
114:                * @param pmotor motor controller state
115:                */
116:               inline static void MCAF_CommutationStartupReinit(MCAF_MOTOR_DATA *pmotor)
117:               {
118:                   const int16_t motorDirection = UTIL_SignFromHighBit(pmotor->velocityControl.velocityCmd);
119:                   MCAF_StartupReinit(&pmotor->startup, motorDirection);
120:                   pmotor->standardInputs.startupStatus = MCAF_StartupGetStatus(&pmotor->startup);
004BCE  983410     MOV W0, [W8+98]
007A2E  983410     MOV W0, [W8+98]
008F00  983011     MOV W1, [W0+98]
121:               }
122:                
123:               /**
124:                * Reinitializes commutation state information at motor restart.
125:                * (upon exiting error or debug state)
126:                *
127:                * @param pmotor motor controller state
128:                */
129:               inline static void MCAF_CommutationRestart(MCAF_MOTOR_DATA *pmotor)
130:               {
131:                   pmotor->velocityControl.slewRateLimit1     = VELOCITY_SLEWRATE_LIMIT1;
004B9E  27D000     MOV #0x7D00, W0
004BA0  993C50     MOV W0, [W8+378]
0079FE  27D000     MOV #0x7D00, W0
007A00  993C50     MOV W0, [W8+378]
132:                   pmotor->velocityControl.slewRateLimitAccel = VELOCITY_SLEWRATE_LIMIT_ACCEL;
004BA2  201980     MOV #0x198, W0
004BA4  993C60     MOV W0, [W8+380]
007A02  201980     MOV #0x198, W0
007A04  993C60     MOV W0, [W8+380]
133:                   pmotor->velocityControl.slewRateLimitDecel = VELOCITY_SLEWRATE_LIMIT_DECEL;
004BA6  200240     MOV #0x24, W0
004BA8  993C70     MOV W0, [W8+382]
007A06  200240     MOV #0x24, W0
007A08  993C70     MOV W0, [W8+382]
134:                   MCAF_CommutationStartupReinit(pmotor);
135:               }
136:                
137:               /**
138:                * Copy commutation information from estimator to stall detect inputs
139:                * @param pmotor motor controller state
140:                */
141:               void MCAF_CommutationPrepareStallDetectInputs(MCAF_MOTOR_DATA *pmotor);
142:               
143:               #ifdef __cplusplus
144:               }
145:               #endif
146:               
147:               #endif  /* __COMMUTATION_H */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/commutation.c
1:                 /**
2:                  * commutation.c
3:                  *
4:                  * Module to include commutation
5:                  * 
6:                  * Component: commutation
7:                  */ /*
8:                  *
9:                  * Motor Control Application Framework
10:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
11:                 *
12:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
13:                 * this software and any derivatives exclusively with Microchip products.
14:                 *
15:                 * This software and any accompanying information is for suggestion only.
16:                 * It does not modify Microchip's standard warranty for its products.
17:                 * You agree that you are solely responsible for testing the software and
18:                 * determining its suitability.  Microchip has no obligation to modify,
19:                 * test, certify, or support the software.
20:                 *
21:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
22:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
23:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
24:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
25:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
26:                 * APPLICATION.
27:                 *
28:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
29:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
30:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
31:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
32:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
33:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
34:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
36:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
37:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
38:                 * SOFTWARE.
39:                 *
40:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
41:                 * THESE TERMS.
42:                 *
43:                 *
44:                 ******************************************************************************/
45:                
46:                #include <stdint.h>
47:                #include "units.h"
48:                #include "hal.h"
49:                
50:                #include "system_state.h"
51:                #include "commutation.h"
52:                #include "commutation_types.h"
53:                #include "commutation/common.h"
54:                #include "startup.h"
55:                #include "stall_detect_types.h"
56:                #include "test_harness.h"
57:                
58:                
59:                #include "commutation/pll.h"
60:                
61:                
62:                void MCAF_CommutationStep(MCAF_MOTOR_DATA *pmotor)
63:                {
0071EA  781F88     MOV W8, [W15++]
0071EC  780400     MOV W0, W8
64:                    MCAF_ESTIMATOR_T *pestimator = &pmotor->estimator;
65:                
66:                
67:                
68:                    /* ---- sensorless, phase-locked loop (AN1292 PLL) ---- */
69:                    MCAF_EstimatorPllStep(
0071F6  200F40     MOV #0xF4, W0
0071F8  400008     ADD W0, W8, W0
0071FA  07F572     RCALL MCAF_EstimatorPllStep
70:                                  &pestimator->pll,         // state
71:                                  &pmotor->standardInputs,                   // common inputs
0071F2  200481     MOV #0x48, W1
0071F4  408088     ADD W1, W8, W1
72:                                  &pmotor->motorParameters                   // motorParameters
0071EE  200702     MOV #0x70, W2
0071F0  410108     ADD W2, W8, W2
73:                    );
74:                    if (MCAF_EstimatorPllIsActive(pestimator))
75:                    {
76:                        pestimator->theta = MCAF_EstimatorPllCommutationAngle(&pestimator->pll);
0071FE  992C51     MOV W1, [W8+346]
77:                        pestimator->omega = MCAF_EstimatorPllElectricalFrequency(&pestimator->pll);
007202  992C60     MOV W0, [W8+348]
78:                    }
79:                    /* ---- sensorless, phase-locked loop (AN1292 PLL) ---- */
80:                
81:                    pmotor->startup.thetaElectricalEstimated = pmotor->estimator.theta;
007204  999411     MOV W1, [W8+418]
82:                    pmotor->startup.omegaElectricalEstimated = pmotor->estimator.omega;
007206  999420     MOV W0, [W8+420]
83:                
84:                    /*
85:                     * Estimators and the test harness are allowed to request
86:                     * a pause in the startup sequence in certain cases.
87:                     *
88:                     * For example, during forced commutation with
89:                     * known fixed current amplitude and commutation frequency,
90:                     * estimators may need to perform a calibration step.
91:                     *
92:                     * The test harness also has a startup pause feature
93:                     * that can delay entering closed-loop operation,
94:                     * to allow diagnosis or troubleshooting.
95:                     */
96:                    const MCAF_STARTUP_STATUS_T startupStatus = MCAF_StartupGetStatus(&pmotor->startup);
97:                    if (startupStatus == MSST_SPIN && MCAF_OverrideStartupPause(&pmotor->testing))
007210  A35800     BTST.Z W0, #5
007212  320002     BRA Z, MCAF_CommutationStep::MCAF_OverrideCommutation
98:                    {
99:                        MCAF_StartupRequestDelay(&pmotor->startup);
100:                   }
101:                   if (MCAF_StartupDelayPermitted(&pmotor->startup))
102:                   {
103:                       if (MCAF_EstimatorPllStartupDelayRequested(&pestimator->pll, startupStatus))
104:                       {
105:                           MCAF_StartupRequestDelay(&pmotor->startup);
106:                       }
107:                   }
108:                   
109:                   MCAF_U_ANGLE_ELEC deltatheta;
110:                   if (MCAF_OverrideCommutation(&pmotor->testing))
00721A  A31800     BTST.Z W0, #1
00721C  320010     BRA Z, UTIL_SignFromHighBit
111:                   {
112:                       deltatheta = MCAF_GetOverrideCommutationFrequency(&pmotor->testing);
113:                   }
114:                   else
115:                   {
116:                       const int16_t motorDirection = UTIL_SignFromHighBit(pmotor->velocityControl.velocityCmd);
117:                       MCAF_StartupTransitioningStep(&pmotor->startup,
007244  2019C0     MOV #0x19C, W0
007246  400008     ADD W0, W8, W0
007248  780088     MOV W8, W1
00724A  07F81D     RCALL MCAF_StartupTransitioningStep
118:                           &pmotor->idqCmdRaw, 
119:                           motorDirection
120:                       );
121:               
122:                       if (MCAF_StartupInOpenLoopCommutation(&pmotor->startup))
00724C  91A858     MOV [W8+474], W0
00724E  500FE6     SUB W0, #0x6, [W15]
007250  3E0011     BRA GTU, .LBE127, .LBB136, .L8
123:                       {
124:                           MCAF_U_ANGLE_ELEC thetaElecStartup = MCAF_StartupCalcNextElectricalAngle(&pmotor->startup);
125:                           deltatheta = thetaElecStartup - pmotor->thetaElectrical;
007266  90B068     MOV [W8+236], W0
007268  510000     SUB W2, W0, W0
126:                           MCAF_StartupSetThetaError(&pmotor->startup, thetaElecStartup - pmotor->estimator.theta);
00726A  9129D8     MOV [W8+346], W3
00726C  510103     SUB W2, W3, W2
127:                           pmotor->omegaCmd = MCAF_StartupGetElectricalFrequency(&pmotor->startup);
007270  992C71     MOV W1, [W8+350]
007272  370005     BRA .LBE124, .LBE136, .L7
128:                       }
129:                       else
130:                       {
131:                           /* Normal closed-loop commutation. We add a compensating factor
132:                            * thetaError during the first part of closed-loop operation;
133:                            * this creates a bumpless transition and thetaError decays toward zero.
134:                            * (See documentation on startup for more information.)
135:                            */
136:                           const MCAF_U_ANGLE_ELEC thetaAdjusted = pmotor->estimator.theta + MCAF_StartupGetThetaError(&pmotor->startup);
007274  91A898     MOV [W8+466], W1
007276  912858     MOV [W8+346], W0
007278  408000     ADD W1, W0, W0
137:                           deltatheta = thetaAdjusted - pmotor->thetaElectrical;
00727A  90B0E8     MOV [W8+236], W1
00727C  500001     SUB W0, W1, W0
138:                       }
139:                   }
140:                   
141:                   pmotor->thetaElectrical += deltatheta;
00727E  90B0E8     MOV [W8+236], W1
007280  408000     ADD W1, W0, W0
007282  98B460     MOV W0, [W8+236]
142:               
143:                   {
144:                       // Update required input signals after the estimator step and before QEI sync.
145:                       MCAF_STANDARD_INPUT_SIGNALS_T *pinputs = &pmotor->standardInputs;
146:                       pinputs->startupStatus = MCAF_StartupGetStatus(&pmotor->startup);
0072B4  983411     MOV W1, [W8+98]
147:                       pinputs->thetaForcedCommutation = MCAF_StartupGetIdqCmdAngle(&pmotor->startup);
0072BE  983420     MOV W0, [W8+100]
148:                   }
149:               
150:               
151:                  pmotor->standardInputs.stateFlags &= ~MSF_CLEAN_STARTUP_SIGNAL;
0072C0  903068     MOV [W8+108], W0
0072C2  A10000     BCLR W0, #0
0072C4  983460     MOV W0, [W8+108]
152:               }
0072C6  78044F     MOV [--W15], W8
0072C8  060000     RETURN
153:               
154:               void MCAF_CommutationInit(MCAF_MOTOR_DATA *pmotor)
155:               {
156:                   MCAF_EstimatorPllInit(&pmotor->estimator.pll, &pmotor->motorParameters);
009D98  200701     MOV #0x70, W1
009D9A  408080     ADD W1, W0, W1
009D9C  B00F40     ADD #0xF4, W0
009D9E  07F7CA     RCALL MCAF_EstimatorPllInit
157:               }
009DA0  060000     RETURN
009DA2  780080     MOV W0, W1
158:               
159:               void MCAF_CommutationStartupInit(MCAF_MOTOR_DATA *pmotor)
160:               {
161:                   pmotor->estimator.theta = 0;
008ECA  EB0080     CLR W1
008ECC  992851     MOV W1, [W0+346]
162:                   pmotor->thetaElectrical = 0;
008ECE  98B061     MOV W1, [W0+236]
163:               
164:                   pmotor->idqCmdRaw.q = MCAF_STARTUP_CURRENT_INITIAL;
008ED0  980011     MOV W1, [W0+2]
165:                   pmotor->idqCmdRaw.d = 0;
008ED2  780801     MOV W1, [W0]
166:                   pmotor->velocityControl.velocityCmdRateLimited = 0;
008ED4  993831     MOV W1, [W0+374]
167:                   pmotor->omegaCmd = 0;
008ED6  992871     MOV W1, [W0+350]
168:                   
169:                
170:                   /* Provide a clean startup signal for one cycle.
171:                    * This will be cleared at the end of the following commutation step,
172:                    * and allows estimators to reinitialize themselves synchronously
173:                    * to their commutation logic.
174:                    */     
175:                   pmotor->standardInputs.stateFlags |= MSF_CLEAN_STARTUP_SIGNAL;
008ED8  903160     MOV [W0+108], W2
008EDA  A00002     BSET W2, #0
008EDC  983062     MOV W2, [W0+108]
176:                   MCAF_CommutationStartupReinit(pmotor);
177:                   MCAF_StartupEnable(&pmotor->startup);
178:               
179:                   /* Allow estimators to re-initialize on startup */
180:                   MCAF_EstimatorPllStartupInit(&pmotor->estimator.pll);
008F04  B00F40     ADD #0xF4, W0
008F06  07085A     RCALL MCAF_EstimatorPllStartupInit
181:               }
008F08  060000     RETURN
008F0A  809160     MOV tickcounter, W0
008F0C  809171     MOV 0x122E, W1
008F0E  400061     ADD W0, #0x1, W0
008F10  4880E0     ADDC W1, #0x0, W1
008F12  889160     MOV W0, tickcounter
008F14  889171     MOV W1, 0x122E
182:               
183:               void MCAF_CommutationPrepareStallDetectInputs(MCAF_MOTOR_DATA *pmotor)
184:               {
185:               #if MCAF_INCLUDE_STALL_DETECT      
186:                   MCAF_STALL_DETECT_INPUT_T *pinputs = &pmotor->stallDetect.inputs;
187:                   const MCAF_ESTIMATOR_PLL_T *pll = &pmotor->estimator.pll;
188:               
189:                   pinputs->esdq            = pll->esdq;
00973A  912130     MOV [W0+326], W2
190:                   pinputs->esdqFiltered    = pll->esdqFiltered;
009742  910160     MOV [W0+268], W2
009744  9101F0     MOV [W0+270], W3
009746  9A0022     MOV W2, [W0+516]
009748  9A0033     MOV W3, [W0+518]
191:                   pinputs->valphabeta      = pll->lastValphabeta;
00974A  910960     MOV [W0+284], W2
00974C  9109F0     MOV [W0+286], W3
00974E  9A0042     MOV W2, [W0+520]
009750  9A0053     MOV W3, [W0+522]
192:                   pinputs->omegaElectrical = pll->output.omegaElectrical;
009752  9129B0     MOV [W0+342], W3
009754  9A0063     MOV W3, [W0+524]
193:               #endif
194:               }
009756  060000     RETURN
009758  500FE2     SUB W0, #0x2, [W15]
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/board_service.c
1:                 /**
2:                  * board_service.c
3:                  * 
4:                  * Provides hardware-independent board service components with interfaces
5:                  * extending into the HAL.
6:                  * 
7:                  * Component: HAL
8:                  */
9:                 
10:                /* *********************************************************************
11:                 * 
12:                 * Motor Control Application Framework
13:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
14:                 *
15:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
16:                 * this software and any derivatives exclusively with Microchip products.
17:                 *
18:                 * This software and any accompanying information is for suggestion only.
19:                 * It does not modify Microchip's standard warranty for its products.
20:                 * You agree that you are solely responsible for testing the software and
21:                 * determining its suitability.  Microchip has no obligation to modify,
22:                 * test, certify, or support the software.
23:                 *
24:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
25:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
26:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
27:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
28:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
29:                 * APPLICATION.
30:                 *
31:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
32:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
33:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
34:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
35:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
36:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
37:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                 * SOFTWARE.
42:                 *
43:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
44:                 * THESE TERMS.
45:                 *
46:                 * *****************************************************************************/
47:                
48:                #include <stdbool.h>
49:                #include "board_service.h"
50:                #include "error_codes.h"
51:                #include "ui.h"
52:                #include "parameters/hal_params.h"
53:                #include "parameters/timing_params.h"
54:                
55:                /**
56:                 * Initializes the state variables for a given button.
57:                 * @param pButtonData pointer to a BOARD_BUTTON_DATA_T struct
58:                 */
59:                static void MCAF_ButtonInit(volatile BOARD_BUTTON_DATA_T *pButtonData)
60:                {
61:                    pButtonData->buttonState = BOARD_BUTTON_UNPRESSED;
009C2E  200011     MOV #0x1, W1
009C30  780801     MOV W1, [W0]
62:                    pButtonData->shortButtonPress = false;
009C32  EB4080     CLR.B W1
009C34  984021     MOV.B W1, [W0+2]
63:                    pButtonData->longButtonPress = false;
009C36  984031     MOV.B W1, [W0+3]
64:                    pButtonData->counterC1 = 0;
009C38  EB0080     CLR W1
009C3A  980021     MOV W1, [W0+4]
65:                }
009C3C  060000     RETURN
66:                
67:                /**
68:                 * Runs the button handler to debounce button inputs and 
69:                 * check for short and long press events.
70:                 * @param pButtonData pointer to a BOARD_BUTTON_DATA_T struct
71:                 * @param rawInput is the raw GPIO signal from the board switch
72:                 */
73:                static void MCAF_ButtonService(volatile BOARD_BUTTON_DATA_T *pButtonData, bool rawInput)
74:                {   
75:                    switch(pButtonData->buttonState)
008736  780110     MOV [W0], W2
008738  E00002     CP0 W2
00873A  320013     BRA Z, .L4
00873C  510FE2     SUB W2, #0x2, [W15]
00873E  320026     BRA Z, .L5
76:                    {
77:                        default:
78:                        case BOARD_BUTTON_UNPRESSED:
79:                        pButtonData->counterC1++;
008740  900120     MOV [W0+4], W2
008742  E80102     INC W2, W2
008744  980022     MOV W2, [W0+4]
80:                        if (rawInput)
008746  E00401     CP0.B W1
008748  320007     BRA Z, .L6
81:                        {
82:                            if (pButtonData->counterC1 >= MCAF_BUTTON_DEBOUNCE_TIME)
00874A  9000A0     MOV [W0+4], W1
00874C  508FE6     SUB W1, #0x6, [W15]
00874E  360024     BRA LEU, .L2
83:                            {
84:                                pButtonData->buttonState = BOARD_BUTTON_PRESSED;
008750  EB0080     CLR W1
008752  780801     MOV W1, [W0]
85:                                pButtonData->counterC1 = 0;
008754  980021     MOV W1, [W0+4]
008756  370020     BRA .L2
86:                            }
87:                        }
88:                        else
89:                        {
90:                            pButtonData->buttonState = BOARD_BUTTON_UNPRESSED;
008758  200011     MOV #0x1, W1
00875A  780801     MOV W1, [W0]
91:                            pButtonData->counterC1 = 0;
00875C  EB0080     CLR W1
00875E  980021     MOV W1, [W0+4]
008760  37001B     BRA .L2
92:                        }
93:                        break;
94:                        
95:                        case BOARD_BUTTON_PRESSED:
96:                        pButtonData->counterC1++;
008762  900120     MOV [W0+4], W2
008764  E80102     INC W2, W2
008766  980022     MOV W2, [W0+4]
97:                        if (pButtonData->counterC1 >= MCAF_BUTTON_LONG_PRESS_TIME)
008768  9001A0     MOV [W0+4], W3
00876A  209C32     MOV #0x9C3, W2
00876C  518F82     SUB W3, W2, [W15]
00876E  360005     BRA LEU, .L8
98:                        {
99:                            pButtonData->longButtonPress = true;
008770  B3C011     MOV.B #0x1, W1
008772  984031     MOV.B W1, [W0+3]
100:                           pButtonData->buttonState = BOARD_BUTTON_LONGPRESS;
008774  200021     MOV #0x2, W1
008776  780801     MOV W1, [W0]
008778  37000F     BRA .L2
101:                       }
102:                       else if (!rawInput)
00877A  E00401     CP0.B W1
00877C  3A000D     BRA NZ, .L2
103:                       {
104:                           pButtonData->shortButtonPress = true;
00877E  B3C011     MOV.B #0x1, W1
008780  984021     MOV.B W1, [W0+2]
105:                           pButtonData->counterC1 = 0;
008782  EB0080     CLR W1
008784  980021     MOV W1, [W0+4]
106:                           pButtonData->buttonState = BOARD_BUTTON_UNPRESSED;
008786  200011     MOV #0x1, W1
008788  780801     MOV W1, [W0]
00878A  370006     BRA .L2
107:                       }
108:                       break;
109:                       
110:                       case BOARD_BUTTON_LONGPRESS:
111:                       if (!rawInput)
00878C  E00401     CP0.B W1
00878E  3A0004     BRA NZ, .L2
112:                       {
113:                           pButtonData->counterC1 = 0;
008790  EB0080     CLR W1
008792  980021     MOV W1, [W0+4]
114:                           pButtonData->buttonState = BOARD_BUTTON_UNPRESSED;
008794  200011     MOV #0x1, W1
008796  780801     MOV W1, [W0]
115:                       }
116:                       break;
117:                   }
118:               }
008798  060000     RETURN
00879A  780100     MOV W0, W2
119:               
120:               void MCAF_BoardServiceInit(MCAF_BOARD_DATA *pboard)
121:               {
0097B0  781F88     MOV W8, [W15++]
0097B2  780400     MOV W0, W8
122:                   pboard->configComplete = true;
0097B4  B3C010     MOV.B #0x1, W0
0097B6  784C00     MOV.B W0, [W8]
123:                   pboard->runtimeState = HAL_BOARD_READY;
0097B8  200040     MOV #0x4, W0
0097BA  980410     MOV W0, [W8+2]
124:                   pboard->isrCount = 0;
0097BC  EB0000     CLR W0
0097BE  980420     MOV W0, [W8+4]
125:                   MCAF_ButtonInit(&pboard->sw1);
0097C0  440070     ADD W8, #0x10, W0
0097C2  070235     RCALL MCAF_ButtonInit
126:                   MCAF_ButtonInit(&pboard->sw2);
0097C4  440076     ADD W8, #0x16, W0
0097C6  070233     RCALL MCAF_ButtonInit
127:               }
0097C8  78044F     MOV [--W15], W8
0097CA  060000     RETURN
0097CC  ABA950     BTST CCP1CON1L, #5
128:               
129:               void MCAF_BoardServiceStepMain(MCAF_BOARD_DATA *pboard)
130:               {
131:                   
132:               }
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
133:               
134:               void MCAF_BoardServiceTasks(MCAF_BOARD_DATA *pboard)
135:               {
009632  781F88     MOV W8, [W15++]
009634  780400     MOV W0, W8
136:                   MCAF_ButtonService(&pboard->sw1, HAL_ButtonGp1RawInput());
009640  440070     ADD W8, #0x10, W0
009642  07F879     RCALL MCAF_ButtonService
137:                   MCAF_ButtonService(&pboard->sw2, HAL_ButtonGp2RawInput());
00964E  440076     ADD W8, #0x16, W0
009650  07F872     RCALL MCAF_ButtonService
138:               }
009652  78044F     MOV [--W15], W8
009654  060000     RETURN
009656  FA0002     LNK #0x2
139:               
140:               bool MCAF_ButtonGp1_EventGet(const MCAF_BOARD_DATA *pboard)
141:               {
009F56  905020     MOV.B [W0+18], W0
142:                   return pboard->sw1.shortButtonPress;
143:               }
009F58  060000     RETURN
144:               
145:               bool MCAF_ButtonGp2_EventGet(const MCAF_BOARD_DATA *pboard)
146:               {
009F5A  905800     MOV.B [W0+24], W0
147:                   if (HAL_hasTwoButtons())
148:                   {
149:                       return pboard->sw2.shortButtonPress;
150:                   }
151:                   else
152:                   {
153:                       return pboard->sw2.longButtonPress;
154:                   }
155:               }
009F5C  060000     RETURN
009F5E  9B0001     MOV W1, [W0+768]
156:               
157:               void MCAF_ButtonGp1_EventClear(MCAF_BOARD_DATA *pboard)
158:               {
159:                   pboard->sw1.shortButtonPress = false;
009EB6  EB4080     CLR.B W1
009EB8  985021     MOV.B W1, [W0+18]
160:               }
009EBA  060000     RETURN
161:               
162:               void MCAF_ButtonGp2_EventClear(MCAF_BOARD_DATA *pboard)
163:               {
164:                   if (HAL_hasTwoButtons())
165:                   {
166:                       pboard->sw2.shortButtonPress = false;
009EBC  EB4080     CLR.B W1
009EBE  985801     MOV.B W1, [W0+24]
167:                   }
168:                   else
169:                   {
170:                       pboard->sw2.longButtonPress = false;
171:                   }
172:               }
009EC0  060000     RETURN
009EC2  A9E8DD     BCLR 0x8DD, #7
173:               
174:               void MCAF_BootstrapChargeInit(MCAF_BOARD_DATA *pboard)
175:               {
176:                   pboard->bootstrapDutycycle[0] = 0;
009CEA  EB0080     CLR W1
009CEC  980041     MOV W1, [W0+8]
177:                   pboard->bootstrapDutycycle[1] = 0;
009CEE  980051     MOV W1, [W0+10]
178:                   pboard->bootstrapDutycycle[2] = 0;
009CF0  980061     MOV W1, [W0+12]
179:                   pboard->delayCount = 0;
009CF2  980071     MOV W1, [W0+14]
180:                   pboard->bootstrapState = 0;
009CF4  980031     MOV W1, [W0+6]
181:               }
009CF6  060000     RETURN
009CF8  600061     AND W0, #0x1, W0
009CFA  DD0042     SL W0, #2, W0
009CFC  8046F1     MOV AMPCON1H, W1
009CFE  A12001     BCLR W1, #2
009D00  700081     IOR W0, W1, W1
009D02  8846F1     MOV W1, AMPCON1H
182:               
183:               static inline uint16_t minimumDutyCycleForBootstrapCharging(void)
184:               {
185:                   return HAL_PARAM_PWM_PERIOD_COUNTS - HAL_PARAM_MIN_LOWER_DUTY_COUNTS;
186:               }
187:               
188:               bool MCAF_BootstrapChargeStepIsr(MCAF_BOARD_DATA *pboard)
189:               {
190:                   bool returnState = false;
006E72  EB4100     CLR.B W2
006E74  370055     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
006EB6  EB4100     CLR.B W2
006EBC  EB4100     CLR.B W2
006ED4  EB4100     CLR.B W2
006EDA  EB4100     CLR.B W2
006EF2  EB4100     CLR.B W2
006EF8  EB4100     CLR.B W2
006F10  EB4100     CLR.B W2
006F16  EB4100     CLR.B W2
191:                   
192:                   switch(pboard->bootstrapState)
006E4A  9000B0     MOV [W0+6], W1
006E4C  508FE4     SUB W1, #0x4, [W15]
006E4E  32004B     BRA Z, .L23
006E50  3E0008     BRA GTU, .L28
006E52  508FE1     SUB W1, #0x1, [W15]
006E54  320032     BRA Z, .L20
006E56  39000F     BRA NC, MCAF_BootstrapChargeStepIsr::HAL_PWM_Outputs_Disable
006E58  508FE2     SUB W1, #0x2, [W15]
006E5A  320036     BRA Z, .L21
006E5C  508FE3     SUB W1, #0x3, [W15]
006E5E  3A0009     BRA NZ, .L18
006E60  37003B     BRA .L35
006E62  508FE6     SUB W1, #0x6, [W15]
006E64  32004F     BRA Z, .L25
006E66  390047     BRA NC, .L24
006E68  508FE7     SUB W1, #0x7, [W15]
006E6A  320054     BRA Z, .L26
006E6E  508FE8     SUB W1, #0x8, [W15]
006E70  320057     BRA Z, MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
193:                   {
194:                       case MCBS_IDLE_START:
195:                           /* Override high-side PWMx to LOW and set 
196:                            * low-side PWMx to 0% duty cycle */
197:                           HAL_PWM_Outputs_Disable();
198:                           pboard->bootstrapDutycycle[0] = HAL_PARAM_PWM_PERIOD_COUNTS;
006E90  213882     MOV #0x1388, W2
006E92  980042     MOV W2, [W0+8]
199:                           pboard->bootstrapDutycycle[1] = HAL_PARAM_PWM_PERIOD_COUNTS;
006E94  980052     MOV W2, [W0+10]
200:                           pboard->bootstrapDutycycle[2] = HAL_PARAM_PWM_PERIOD_COUNTS;
006E96  980062     MOV W2, [W0+12]
201:                           HAL_PWM_UpperTransistorsOverride_Low();
202:                           HAL_PWM_LowerTransistorsOverride_Disable();
203:                           
204:                           pboard->delayCount = MCAF_BOARD_BOOTSTRAP_INITIAL_DELAY;
006EB0  200011     MOV #0x1, W1
006EB2  980071     MOV W1, [W0+14]
205:                           pboard->bootstrapState = MCBS_WAIT_INITIAL;
006EB4  980031     MOV W1, [W0+6]
206:                           break;
006EB8  370033     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
207:                           
208:                       case MCBS_WAIT_INITIAL:
209:                           /* Wait for a preset duration of time before starting to
210:                            * charge the Phase-A bootstrap */
211:                           if (pboard->delayCount == 0)
006EBA  9000F0     MOV [W0+14], W1
006EBE  E00001     CP0 W1
006EC0  3A002F     BRA NZ, MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
212:                           {   
213:                               pboard->bootstrapState = MCBS_PHASE_A_SETUP_CHARGING;
006EC2  200021     MOV #0x2, W1
006EC4  980031     MOV W1, [W0+6]
006EC6  37002C     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
214:                           }
215:                           break;
216:               
217:                       case MCBS_PHASE_A_SETUP_CHARGING:
218:                           pboard->bootstrapDutycycle[0] = minimumDutyCycleForBootstrapCharging();
006EC8  212A71     MOV #0x12A7, W1
006ECA  980041     MOV W1, [W0+8]
219:                           pboard->delayCount = MCAF_BOARD_BOOTSTRAP_PHASE_DELAY;
006ECC  200641     MOV #0x64, W1
006ECE  980071     MOV W1, [W0+14]
220:                           pboard->bootstrapState = MCBS_PHASE_A_CHARGING;
006ED0  200031     MOV #0x3, W1
006ED2  980031     MOV W1, [W0+6]
221:                           break;
006ED6  370024     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
222:                           
223:                       case MCBS_PHASE_A_CHARGING:
224:                           /* Wait for a preset duration of time to let the bootstrap drive
225:                            * charge the Phase-A bootstrap capacitor */
226:                           if (pboard->delayCount == 0)
006ED8  9000F0     MOV [W0+14], W1
006EDC  E00001     CP0 W1
006EDE  3A0020     BRA NZ, MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
227:                           {
228:                               pboard->bootstrapState = MCBS_PHASE_B_SETUP_CHARGING;
006EE0  200041     MOV #0x4, W1
006EE2  980031     MOV W1, [W0+6]
006EE4  37001D     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
229:                           }
230:                           break;
231:                           
232:                       case MCBS_PHASE_B_SETUP_CHARGING:
233:                           pboard->bootstrapDutycycle[1] = minimumDutyCycleForBootstrapCharging();
006EE6  212A71     MOV #0x12A7, W1
006EE8  980051     MOV W1, [W0+10]
234:                           pboard->delayCount = MCAF_BOARD_BOOTSTRAP_PHASE_DELAY;
006EEA  200641     MOV #0x64, W1
006EEC  980071     MOV W1, [W0+14]
235:                           pboard->bootstrapState = MCBS_PHASE_B_CHARGING;
006EEE  200051     MOV #0x5, W1
006EF0  980031     MOV W1, [W0+6]
236:                           break;
006EF4  370015     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
237:                           
238:                       case MCBS_PHASE_B_CHARGING:
239:                           /* Wait for a preset duration of time to let the bootstrap drive
240:                            * charge the Phase-B bootstrap capacitor */
241:                           if (pboard->delayCount == 0)
006EF6  9000F0     MOV [W0+14], W1
006EFA  E00001     CP0 W1
006EFC  3A0011     BRA NZ, MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
242:                           {
243:                               pboard->bootstrapState = MCBS_PHASE_C_SETUP_CHARGING;
006EFE  200061     MOV #0x6, W1
006F00  980031     MOV W1, [W0+6]
006F02  37000E     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
244:                           }
245:                           break;
246:               
247:                       case MCBS_PHASE_C_SETUP_CHARGING:
248:                           pboard->bootstrapDutycycle[2] = minimumDutyCycleForBootstrapCharging();
006F04  212A71     MOV #0x12A7, W1
006F06  980061     MOV W1, [W0+12]
249:                           pboard->delayCount = MCAF_BOARD_BOOTSTRAP_PHASE_DELAY;
006F08  200641     MOV #0x64, W1
006F0A  980071     MOV W1, [W0+14]
250:                           pboard->bootstrapState = MCBS_PHASE_C_CHARGING;
006F0C  200071     MOV #0x7, W1
006F0E  980031     MOV W1, [W0+6]
251:                           break;
006F12  370006     BRA MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
252:                           
253:                       case MCBS_PHASE_C_CHARGING:
254:                           /* Wait for a preset duration of time to let the bootstrap drive
255:                            * charge the Phase-C bootstrap capacitor */
256:                           if (pboard->delayCount == 0)
006F14  9000F0     MOV [W0+14], W1
006F18  E00001     CP0 W1
006F1A  3A0002     BRA NZ, MCAF_BootstrapChargeStepIsr::HAL_PWM_DutyCycle_Set
257:                           {
258:                               pboard->bootstrapState = MCBS_BOOTSTRAP_COMPLETE;
006F1C  200081     MOV #0x8, W1
006F1E  980031     MOV W1, [W0+6]
259:                           }
260:                           break;
261:                           
262:                       case MCBS_BOOTSTRAP_COMPLETE:
263:                           /* Bootstap sequence is complete, wait in this state */
264:                           returnState = true;
006E6C  B3C012     MOV.B #0x1, W2
265:                           break;
266:                   }
267:                   HAL_PWM_DutyCycle_Set(pboard->bootstrapDutycycle);
268:                   
269:                   if (pboard->delayCount > 0)
006F2C  9000F0     MOV [W0+14], W1
006F2E  E00001     CP0 W1
006F30  320002     BRA Z, .L29
270:                   {
271:                       pboard->delayCount--;
006F32  E90081     DEC W1, W1
006F34  980071     MOV W1, [W0+14]
272:                   }
273:                   
274:                   return returnState;
275:               }
006F36  784002     MOV.B W2, W0
006F38  060000     RETURN
006F3A  EF2B00     CLR ADCON1L
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/motorBench/adc_compensation.c
1:                 /**
2:                  * adc_compensation.c
3:                  * 
4:                  * ADC compensation
5:                  * 
6:                  * Component: ADC compensation
7:                  */
8:                 
9:                 /* *********************************************************************
10:                 *
11:                 * Motor Control Application Framework
12:                 * R7/RC37 (commit 116330, build on 2023 Feb 09)
13:                 *
14:                 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
15:                 * this software and any derivatives exclusively with Microchip products.
16:                 *
17:                 * This software and any accompanying information is for suggestion only.
18:                 * It does not modify Microchip's standard warranty for its products.
19:                 * You agree that you are solely responsible for testing the software and
20:                 * determining its suitability.  Microchip has no obligation to modify,
21:                 * test, certify, or support the software.
22:                 *
23:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
24:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
25:                 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
26:                 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
27:                 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
28:                 * APPLICATION.
29:                 *
30:                 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
31:                 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
32:                 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
33:                 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
34:                 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
35:                 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
36:                 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
38:                 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
39:                 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
40:                 * SOFTWARE.
41:                 *
42:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
43:                 * THESE TERMS.
44:                 *
45:                 * *****************************************************************************/
46:                
47:                #include <stdint.h>
48:                #include "util.h"
49:                #include "adc_compensation.h"
50:                #include "system_state.h"
51:                #include "parameters/adc_params.h"
52:                #include "hal.h"
53:                #include "current_measure.h"
54:                
55:                inline static uint16_t adcScaleVdc(uint16_t raw)
56:                {
57:                    const uint32_t vdcscaled = UTIL_muluu(raw, MCAF_VDC_SCALING_FACTOR);
58:                    // Saturate if we can't shift right into a uint16_t
59:                    return UTIL_SatShrU16(vdcscaled, MCAF_VDC_SCALING_FACTOR_Q);
60:                }
61:                
62:                /**
63:                 * Reads ADC samples for current phases, auxiliary analog inputs,
64:                 * and routes results to appropriate area in motor data structure.
65:                 *
66:                 * @param pmotor motor data
67:                */
68:                void MCAF_ADCRead(MCAF_MOTOR_DATA *pmotor)
69:                {
008B5E  780080     MOV W0, W1
70:                    MCAF_ADCCurrentRead(&pmotor->currentMeasure, &pmotor->iabc);
71:                    
72:                    MCAF_ADCApplyCurrentCompensation(&pmotor->currentCalibration, &pmotor->iabc);
73:                
74:                    uint16_t unipolarADCResult = HAL_ADC_UnsignedFromSignedInput(HAL_ADC_ValueDclink());
75:                    if (MCAF_ADCIsVdcScaled())
76:                    {
77:                        unipolarADCResult = adcScaleVdc(unipolarADCResult);
78:                    }
79:                    pmotor->psys->vDC = unipolarADCResult >> 1;    
008B96  930101     MOV [W1+768], W2
008B9C  D10900     LSR W0, [W2]
80:                    pmotor->vDC = pmotor->psys->vDC;
008B9E  930001     MOV [W1+768], W0
008BA0  780010     MOV [W0], W0
008BA2  9B38F0     MOV W0, [W1+894]
81:                
82:                    if (!MCAF_OverrideVelocityCommand(&pmotor->testing))
008BA6  A30800     BTST.Z W0, #0
008BA8  3A0002     BRA NZ, .L1
83:                    {
84:                        pmotor->velocityControl.velocityCmd = pmotor->velocityControl.velocityCmdApi;
008BAA  913A11     MOV [W1+370], W4
008BAC  9938A4     MOV W4, [W1+372]
85:                    }
86:                }
008BAE  060000     RETURN
87:                
88:                /**
89:                 * Reads ADC samples that are not time critical
90:                 * and routes results to appropriate area in motor data structure.
91:                 *
92:                 * @param pmotor motor data
93:                */
94:                void MCAF_ADCReadNonCritical(MCAF_MOTOR_DATA *pmotor)
95:                {    
009DA2  780080     MOV W0, W1
96:                    pmotor->potInput = HAL_ADC_UnsignedFromSignedInput(HAL_ADC_ValuePotentiometer());
009DA8  9980C0     MOV W0, [W1+392]
97:                    /* The default ADC result is bipolar with 0 counts =
98:                     * the middle of the input voltage range.
99:                     * VDC sensing is an exception to this rule.
100:                    */
101:                
102:                   if (HAL_ADC_IsAvailableBridgeTemperature())
103:                   {
104:                       const uint16_t raw = HAL_ADC_ValueBridgeTemperature();
105:                       
106:                       MCAF_BRIDGE_TEMPERATURE *pbtemp = &pmotor->bridgeTemperature;
107:                       pbtemp->raw = raw;
108:                       pbtemp->processed = UTIL_MulUUQ16(raw, pbtemp->gain) - pbtemp->offset;
109:                       const int32_t dT = UTIL_mulus(pbtemp->filter.gain, pbtemp->processed)
110:                                        - UTIL_mulus(pbtemp->filter.gain, pbtemp->filter.state.x16.hi);
111:                       const int16_t dT_limited = UTIL_LimitS32ToS16(dT, pbtemp->filter.slewRate);
112:                       pbtemp->filter.state.x32 += dT_limited;
113:                       pbtemp->filter.output = pbtemp->filter.state.x16.hi;                
114:                   }
115:                   if (HAL_ADC_IsAvailableAbsoluteReferenceVoltage())
116:                   {
117:                       pmotor->vAbsRef = HAL_ADC_ValueAbsoluteReferenceVoltage();
118:                   }
119:               }
009DAA  060000     RETURN
009DAC  0700FA     RCALL TMR1_Stop
120:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/cmp/src/cmp1.c
1:                 /**
2:                  * CMP1 Generated Driver Source File
3:                  * 
4:                  * @file      cmp1.c
5:                  *            
6:                  * @ingroup   cmpdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for CMP1 driver
9:                  *            
10:                 * @version   Firmware Driver Version 1.2.0
11:                 *
12:                 * @version   PLIB Version 1.3.0
13:                 *            
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                
18:                /*
19:                © [2023] Microchip Technology Inc. and its subsidiaries.
20:                
21:                    Subject to your compliance with these terms, you may use Microchip 
22:                    software and any derivatives exclusively with Microchip products. 
23:                    You are responsible for complying with 3rd party license terms  
24:                    applicable to your use of 3rd party software (including open source  
25:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
26:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
27:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
28:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
29:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
30:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
31:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
32:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
33:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
34:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
35:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
36:                    THIS SOFTWARE.
37:                */
38:                
39:                // Section: Included Files
40:                
41:                #include <xc.h>
42:                #include "../cmp1.h"
43:                
44:                // Section: File specific functions
45:                
46:                static void (*CMP1_EventHandler)(void) = NULL;
47:                
48:                // Section: Driver Interface
49:                const struct DAC_DC_INTERFACE dac1_dc_interface = {
50:                    .Enable = &CMP1_DACEnable,
51:                    .Disable = &CMP1_DACDisable,
52:                    .DataWrite = &CMP1_DACDataWrite,
53:                };
54:                
55:                const struct CMP_INTERFACE MCC_CMP = {
56:                    .Initialize = &CMP1_Initialize,
57:                    .Deinitialize = &CMP1_Deinitialize,
58:                    .Enable = &CMP1_Enable,
59:                    .Disable = &CMP1_Disable,
60:                    .StatusGet = &CMP1_StatusGet,
61:                    
62:                    .EventCallbackRegister = &CMP1_EventCallbackRegister,
63:                    .Tasks = &CMP1_Tasks,
64:                    .cmp_dac_dc_interface = &dac1_dc_interface
65:                };
66:                
67:                // Section: CMP1 Module APIs
68:                
69:                void CMP1_Initialize(void)
70:                {           
71:                    // Comparator Register settings
72:                    DACCTRL1L = 0x40; //FCLKDIV 1:1; CLKDIV 1:1; CLKSEL FVCO/2; DACSIDL disabled; DACON disabled; 
0095C6  200400     MOV #0x40, W0
0095C8  886400     MOV W0, DACCTRL1L
73:                    DACCTRL2H = 0x0; //SSTIME 0; 
0095CA  EF2C86     CLR DACCTRL2H
74:                    DACCTRL2L = 0x0; //TMODTIME 0; 
0095CC  EF2C84     CLR DACCTRL2L
75:                    DAC1CONH = 0x0; //TMCB 0; 
0095CE  EF2C8A     CLR DAC1CONH
76:                    DAC1CONL = 0x8010; //HYSSEL None; HYSPOL Rising Edge; INSEL CMP1C; CMPPOL Non Inverted; FLTREN disabled; DACOEN disabled; CBE disabled; IRQM Interrupts are disabled; DACEN enabled; 
0095D0  280100     MOV #0x8010, W0
0095D2  886440     MOV W0, DAC1CONL
77:                
78:                    //Slope Settings
79:                    DAC1DATH = 0xC85; //DACDATH 3205; 
0095D4  20C850     MOV #0xC85, W0
0095D6  886470     MOV W0, DAC1DATH
80:                    DAC1DATL = 0xCD; //DACDATL 205; 
0095D8  200CD0     MOV #0xCD, W0
0095DA  886460     MOV W0, DAC1DATL
81:                    SLP1CONH = 0x0; //PSE Negative; TWME disabled; HME disabled; SLOPEN disabled; 
0095DC  EF2C92     CLR SLP1CONH
82:                    SLP1CONL = 0x0; //SLPSTRT None; SLPSTOPB None; SLPSTOPA None; HCFSEL None; 
0095DE  EF2C90     CLR SLP1CONL
83:                    SLP1DAT = 0x0; //SLPDAT 0; 
0095E0  EF2C94     CLR SLP1DAT
84:                    
85:                    CMP1_EventCallbackRegister(&CMP1_EventCallback);
0095E2  29FBA0     MOV #0x9FBA, W0
0095E4  0703FE     RCALL CMP1_EventCallbackRegister
86:                    
87:                    
88:                    DACCTRL1Lbits.DACON = 1;
0095E6  A8EC81     BSET 0xC81, #7
89:                }
0095E8  060000     RETURN
0095EA  EB0080     CLR W1
90:                
91:                void CMP1_Deinitialize(void)
92:                { 
93:                    DACCTRL1Lbits.DACON = 0;
009794  A9EC81     BCLR 0xC81, #7
94:                    
95:                    
96:                    // Comparator Register settings
97:                    DACCTRL1L = 0x0;
009796  EF2C80     CLR DACCTRL1L
98:                    DACCTRL2H = 0x8A;
009798  2008A0     MOV #0x8A, W0
00979A  886430     MOV W0, DACCTRL2H
99:                    DACCTRL2L = 0x55;
00979C  200550     MOV #0x55, W0
00979E  886420     MOV W0, DACCTRL2L
100:                   DAC1CONH = 0x0;
0097A0  EF2C8A     CLR DAC1CONH
101:                   DAC1CONL = 0x0;
0097A2  EF2C88     CLR DAC1CONL
102:               
103:                   //Slope Settings
104:                   DAC1DATH = 0x0;
0097A4  EF2C8E     CLR DAC1DATH
105:                   DAC1DATL = 0x0;
0097A6  EF2C8C     CLR DAC1DATL
106:                   SLP1CONH = 0x0;
0097A8  EF2C92     CLR SLP1CONH
107:                   SLP1CONL = 0x0;
0097AA  EF2C90     CLR SLP1CONL
108:                   SLP1DAT = 0x0;
0097AC  EF2C94     CLR SLP1DAT
109:               }
0097AE  060000     RETURN
110:               
111:               bool CMP1_StatusGet(void)
112:               {
113:                   return (DAC1CONLbits.CMPSTAT);
009E92  0AA077     BFEXT #0x7, #0x1, DAC1CONL, W0
009E94  000C88     NOP
114:               }
009E96  060000     RETURN
009E98  0A20B0     BFINS #0x0, #0xc, W0, DAC1DATH
115:               
116:               void CMP1_Enable(void)
117:               {
118:                   DACCTRL1Lbits.DACON = 1;
009F2A  A8EC81     BSET 0xC81, #7
119:               }
009F2C  060000     RETURN
120:               
121:               void CMP1_Disable(void)
122:               {
123:                   DACCTRL1Lbits.DACON = 0;
009F2E  A9EC81     BCLR 0xC81, #7
124:               }
009F30  060000     RETURN
125:               
126:               void CMP1_DACEnable(void)
127:               {
128:                   DAC1CONLbits.DACEN = 1;
009F32  A8EC89     BSET 0xC89, #7
129:               }
009F34  060000     RETURN
130:               
131:               void CMP1_DACDisable(void)
132:               {
133:                   DAC1CONLbits.DACEN = 0;
009F36  A9EC89     BCLR 0xC89, #7
134:               }
009F38  060000     RETURN
009F3A  07FE69     RCALL stack_overflow_helper
135:               
136:               void CMP1_DACDataWrite(size_t value)
137:               {
138:                   DAC1DATHbits.DACDATH = value;
009E98  0A20B0     BFINS #0x0, #0xc, W0, DAC1DATH
009E9A  000C8E     NOP
139:               }
009E9C  060000     RETURN
009E9E  EB0080     CLR W1
140:               
141:               void CMP1_EventCallbackRegister(void (*handler)(void))
142:               {
143:                   if(NULL != handler)
009DE2  E00000     CP0 W0
144:                   {
145:                       CMP1_EventHandler = handler;
009DE6  8892C0     MOV W0, CMP1_EventHandler
146:                   }
147:               }
009DE8  060000     RETURN
009DEA  9000A0     MOV [W0+4], W1
148:               
149:               void __attribute__ ((weak)) CMP1_EventCallback(void)
150:               { 
151:                  
152:               } 
009FBA  060000     RETURN
009FBC  060000     RETURN
153:               
154:               void CMP1_Tasks(void)
155:               {
156:                   if(IFS4bits.CMP1IF == 1)
009BEE  ABA809     BTST 0x809, #5
009BF0  320005     BRA Z, .L12
157:                   {
158:                       // CMP1 callback function 
159:                       if(NULL != CMP1_EventHandler)
009BF2  8092C0     MOV CMP1_EventHandler, W0
009BF4  E00000     CP0 W0
009BF6  320001     BRA Z, .L14
160:                       {
161:                           (*CMP1_EventHandler)();
009BF8  010000     CALL W0
162:                       }
163:                   
164:                       // clear the CMP1 interrupt flag
165:                       IFS4bits.CMP1IF = 0;
009BFA  A9A809     BCLR 0x809, #5
166:                   }
167:               }
009BFC  060000     RETURN
009BFE  781F88     MOV W8, [W15++]
168:               
169:               /**
170:                End of File
171:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/adc/src/adc1.c
1:                 /**
2:                  * ADC1 Generated Driver Source File
3:                  * 
4:                  * @file      adc1.c
5:                  *            
6:                  * @ingroup   adcdriver
7:                  *            
8:                  * @brief     This is the generated driver source file for ADC1 driver
9:                  *            
10:                 * @version   Firmware Driver Version 1.4.3
11:                 *
12:                 * @version   PLIB Version 2.3.0
13:                 *           
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                // Section: Included Files
39:                #include <stddef.h>
40:                #include "../adc1.h"
41:                
42:                // Section: File specific functions
43:                
44:                static void (*ADC1_CommonHandler)(void) = NULL;
45:                static void (*ADC1_ChannelHandler)(enum ADC_CHANNEL channel, uint16_t adcVal) = NULL;
46:                static void (*ADC1_ComparatorHandler)(enum ADC_CMP comparator) = NULL;
47:                
48:                // Section: File specific data type definitions
49:                
50:                /**
51:                 @ingroup  adcdriver
52:                 @enum     ADC_PWM_TRIG_SRCS
53:                 @brief    Defines the PWM ADC TRIGGER sources available for the module to use.
54:                */
55:                enum ADC_PWM_TRIG_SRCS {
56:                    PWM8_TRIGGER2 = 0x13, 
57:                    PWM8_TRIGGER1 = 0x12, 
58:                    PWM7_TRIGGER2 = 0x11, 
59:                    PWM7_TRIGGER1 = 0x10, 
60:                    PWM6_TRIGGER2 = 0xf, 
61:                    PWM6_TRIGGER1 = 0xe, 
62:                    PWM5_TRIGGER2 = 0xd, 
63:                    PWM5_TRIGGER1 = 0xc, 
64:                    PWM4_TRIGGER2 = 0xb, 
65:                    PWM4_TRIGGER1 = 0xa, 
66:                    PWM3_TRIGGER2 = 0x9, 
67:                    PWM3_TRIGGER1 = 0x8, 
68:                    PWM2_TRIGGER2 = 0x7, 
69:                    PWM2_TRIGGER1 = 0x6, 
70:                    PWM1_TRIGGER2 = 0x5, 
71:                    PWM1_TRIGGER1 = 0x4, 
72:                };
73:                
74:                //Defines an object for ADC_MULTICORE.
75:                const struct ADC_MULTICORE adc1Multicore = {
76:                    .ChannelTasks                           = &ADC1_ChannelTasks, 
77:                    .ComparatorTasks                        = NULL,
78:                    .IndividualChannelInterruptEnable       = &ADC1_IndividualChannelInterruptEnable,
79:                    .IndividualChannelInterruptDisable      = &ADC1_IndividualChannelInterruptDisable,
80:                    .IndividualChannelInterruptFlagClear    = &ADC1_IndividualChannelInterruptFlagClear,
81:                    .IndividualChannelInterruptPrioritySet  = &ADC1_IndividualChannelInterruptPrioritySet,
82:                    .ChannelCallbackRegister                = &ADC1_ChannelCallbackRegister,
83:                    .ComparatorCallbackRegister             = &ADC1_ComparatorCallbackRegister,
84:                    .CorePowerEnable                        = &ADC1_CorePowerEnable,
85:                    .SharedCorePowerEnable                  = &ADC1_SharedCorePowerEnable,
86:                    .PWMTriggerSourceSet                    = &ADC1_PWMTriggerSourceSet
87:                };
88:                
89:                //Defines an object for ADC_INTERFACE.
90:                
91:                const struct ADC_INTERFACE MCC_ADC = {
92:                    .Initialize             = &ADC1_Initialize,
93:                    .Deinitialize           = &ADC1_Deinitialize,
94:                    .Enable                 = &ADC1_Enable,
95:                    .Disable                = &ADC1_Disable,
96:                    .SoftwareTriggerEnable  = &ADC1_SoftwareTriggerEnable,
97:                    .SoftwareTriggerDisable = &ADC1_SoftwareTriggerDisable,
98:                    .ChannelSelect          = &ADC1_ChannelSelect, 
99:                    .ConversionResultGet    = &ADC1_ConversionResultGet,
100:                   .IsConversionComplete   = &ADC1_IsConversionComplete,
101:                   .ResolutionSet          = &ADC1_ResolutionSet,
102:                   .InterruptEnable        = &ADC1_InterruptEnable,
103:                   .InterruptDisable       = &ADC1_InterruptDisable,
104:                   .InterruptFlagClear     = &ADC1_InterruptFlagClear,
105:                   .InterruptPrioritySet   = &ADC1_InterruptPrioritySet,
106:                   .CommonCallbackRegister = &ADC1_CommonCallbackRegister,
107:                   .Tasks                  = &ADC1_Tasks,
108:                   .adcMulticoreInterface = &adc1Multicore,
109:               };
110:               
111:               // Section: Driver Interface Function Definitions
112:               
113:               void ADC1_Initialize (void)
114:               {
115:                   // ADSIDL disabled; ADON enabled; 
116:                   ADCON1L = (uint16_t)0x8000 & (uint16_t)0x7FFF; //Disabling ADON bit
006F3A  EF2B00     CLR ADCON1L
117:                   // SHRRES 12-bit resolution; FORM Fractional; 
118:                   ADCON1H = 0xE0;
006F3C  200E00     MOV #0xE0, W0
006F3E  885810     MOV W0, ADCON1H
119:                   // SHRADCS 2; SHREISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; PTGEN disabled; EIEN disabled; REFERCIE disabled; REFCIE disabled; 
120:                   ADCON2L = 0x0;
006F40  EF2B04     CLR ADCON2L
121:                   // SHRSAMC 13; 
122:                   ADCON2H = 0xD;
006F42  2000D1     MOV #0xD, W1
006F44  885831     MOV W1, ADCON2H
123:                   // CNVCHSEL AN0; SWCTRG disabled; SWLCTRG disabled; SHRSAMP disabled; SUSPCIE disabled; SUSPEND disabled; REFSEL disabled; 
124:                   ADCON3L = 0x0;
006F46  EF2B08     CLR ADCON3L
125:                   // C0EN enabled; C1EN enabled; SHREN enabled; CLKDIV 1; CLKSEL FOSC/2; 
126:                   ADCON3H = (uint16_t)0x83 & (uint16_t)0xFF00; //Disabling C0EN, C1EN, C2EN, C3EN and SHREN bits
006F48  EF2B0A     CLR ADCON3H
127:                   // SAMC0EN enabled; SAMC1EN enabled; 
128:                   ADCON4L = 0x3;
006F4A  200030     MOV #0x3, W0
006F4C  885860     MOV W0, ADCON4L
129:                   // C0CHS AN0; C1CHS AN1; 
130:                   ADCON4H = 0x0;
006F4E  EF2B0E     CLR ADCON4H
131:                   // SIGN0 enabled; DIFF0 disabled; SIGN1 enabled; DIFF1 disabled; SIGN2 disabled; DIFF2 disabled; SIGN3 disabled; DIFF3 disabled; SIGN4 enabled; DIFF4 disabled; SIGN5 disabled; DIFF5 disabled; SIGN6 disabled; DIFF6 disabled; SIGN7 disabled; DIFF7 disabled; 
132:                   ADMOD0L = 0x105;
006F50  201050     MOV #0x105, W0
006F52  885880     MOV W0, ADMOD0L
133:                   // SIGN8 disabled; DIFF8 disabled; SIGN9 disabled; DIFF9 disabled; SIGN10 enabled; DIFF10 disabled; SIGN11 enabled; DIFF11 disabled; SIGN12 disabled; DIFF12 disabled; SIGN13 disabled; DIFF13 disabled; SIGN14 disabled; DIFF14 disabled; SIGN15 enabled; DIFF15 disabled; 
134:                   ADMOD0H = 0x4050;
006F54  240500     MOV #0x4050, W0
006F56  885890     MOV W0, ADMOD0H
135:                   // SIGN16 disabled; DIFF16 disabled; SIGN17 disabled; DIFF17 disabled; SIGN18 disabled; DIFF18 disabled; SIGN19 disabled; DIFF19 disabled; SIGN20 disabled; DIFF20 disabled; SIGN21 disabled; DIFF21 disabled; SIGN22 disabled; DIFF22 disabled; SIGN23 disabled; DIFF23 disabled; 
136:                   ADMOD1L = 0x0;
006F58  EF2B14     CLR ADMOD1L
137:                   // SIGN24 disabled; DIFF24 disabled; SIGN25 disabled; DIFF25 disabled; 
138:                   ADMOD1H = 0x0;
006F5A  EF2B16     CLR ADMOD1H
139:                   // IE0 disabled; IE1 disabled; IE2 disabled; IE3 disabled; IE4 disabled; IE5 disabled; IE6 disabled; IE7 disabled; IE8 disabled; IE9 disabled; IE10 disabled; IE11 disabled; IE12 disabled; IE13 disabled; IE14 disabled; IE15 disabled; 
140:                   ADIEL = 0x0;
006F5C  EF2B20     CLR ADIEL
141:                   // IE16 disabled; IE17 disabled; IE18 disabled; IE19 disabled; IE20 disabled; IE21 disabled; IE22 disabled; IE23 disabled; IE24 disabled; IE25 disabled; 
142:                   ADIEH = 0x0;
006F5E  EF2B22     CLR ADIEH
143:                   // 
144:                   ADSTATL = 0x0;
006F60  EF2B30     CLR ADSTATL
145:                   // 
146:                   ADSTATH = 0x0;
006F62  EF2B32     CLR ADSTATH
147:                   // CMPEN0 disabled; CMPEN1 disabled; CMPEN2 disabled; CMPEN3 disabled; CMPEN4 disabled; CMPEN5 disabled; CMPEN6 disabled; CMPEN7 disabled; CMPEN8 disabled; CMPEN9 disabled; CMPEN10 disabled; CMPEN11 disabled; CMPEN12 disabled; CMPEN13 disabled; CMPEN14 disabled; CMPEN15 disabled; 
148:                   ADCMP0ENL = 0x0;
006F64  EF2B38     CLR ADCMP0ENL
149:                   // CMPEN0 disabled; CMPEN1 disabled; CMPEN2 disabled; CMPEN3 disabled; CMPEN4 disabled; CMPEN5 disabled; CMPEN6 disabled; CMPEN7 disabled; CMPEN8 disabled; CMPEN9 disabled; CMPEN10 disabled; CMPEN11 disabled; CMPEN12 disabled; CMPEN13 disabled; CMPEN14 disabled; CMPEN15 disabled; 
150:                   ADCMP1ENL = 0x0;
006F66  EF2B40     CLR ADCMP1ENL
151:                   // CMPEN0 disabled; CMPEN1 disabled; CMPEN2 disabled; CMPEN3 disabled; CMPEN4 disabled; CMPEN5 disabled; CMPEN6 disabled; CMPEN7 disabled; CMPEN8 disabled; CMPEN9 disabled; CMPEN10 disabled; CMPEN11 disabled; CMPEN12 disabled; CMPEN13 disabled; CMPEN14 disabled; CMPEN15 disabled; 
152:                   ADCMP2ENL = 0x0;
006F68  EF2B48     CLR ADCMP2ENL
153:                   // CMPEN0 disabled; CMPEN1 disabled; CMPEN2 disabled; CMPEN3 disabled; CMPEN4 disabled; CMPEN5 disabled; CMPEN6 disabled; CMPEN7 disabled; CMPEN8 disabled; CMPEN9 disabled; CMPEN10 disabled; CMPEN11 disabled; CMPEN12 disabled; CMPEN13 disabled; CMPEN14 disabled; CMPEN15 disabled; 
154:                   ADCMP3ENL = 0x0;
006F6A  EF2B50     CLR ADCMP3ENL
155:                   // CMPEN16 disabled; CMPEN17 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN20 disabled; CMPEN21 disabled; CMPEN22 disabled; CMPEN23 disabled; CMPEN24 disabled; CMPEN25 disabled; 
156:                   ADCMP0ENH = 0x0;
006F6C  EF2B3A     CLR ADCMP0ENH
157:                   // CMPEN16 disabled; CMPEN17 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN20 disabled; CMPEN21 disabled; CMPEN22 disabled; CMPEN23 disabled; CMPEN24 disabled; CMPEN25 disabled; 
158:                   ADCMP1ENH = 0x0;
006F6E  EF2B42     CLR ADCMP1ENH
159:                   // CMPEN16 disabled; CMPEN17 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN20 disabled; CMPEN21 disabled; CMPEN22 disabled; CMPEN23 disabled; CMPEN24 disabled; CMPEN25 disabled; 
160:                   ADCMP2ENH = 0x0;
006F70  EF2B4A     CLR ADCMP2ENH
161:                   // CMPEN16 disabled; CMPEN17 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN20 disabled; CMPEN21 disabled; CMPEN22 disabled; CMPEN23 disabled; CMPEN24 disabled; CMPEN25 disabled; 
162:                   ADCMP3ENH = 0x0;
006F72  EF2B52     CLR ADCMP3ENH
163:                   // CMPLO 0x0; 
164:                   ADCMP0LO = 0x0;
006F74  EF2B3C     CLR ADCMP0LO
165:                   // CMPLO 0x0; 
166:                   ADCMP1LO = 0x0;
006F76  EF2B44     CLR ADCMP1LO
167:                   // CMPLO 0x0; 
168:                   ADCMP2LO = 0x0;
006F78  EF2B4C     CLR ADCMP2LO
169:                   // CMPLO 0x0; 
170:                   ADCMP3LO = 0x0;
006F7A  EF2B54     CLR ADCMP3LO
171:                   // CMPHI 0x0; 
172:                   ADCMP0HI = 0x0;
006F7C  EF2B3E     CLR ADCMP0HI
173:                   // CMPHI 0x0; 
174:                   ADCMP1HI = 0x0;
006F7E  EF2B46     CLR ADCMP1HI
175:                   // CMPHI 0x0; 
176:                   ADCMP2HI = 0x0;
006F80  EF2B4E     CLR ADCMP2HI
177:                   // CMPHI 0x0; 
178:                   ADCMP3HI = 0x0;
006F82  EF2B56     CLR ADCMP3HI
179:                   // 
180:                   ADFL0DAT = 0x0;
006F84  EF2B68     CLR ADFL0DAT
181:                   // 
182:                   ADFL1DAT = 0x0;
006F86  EF2B6C     CLR ADFL1DAT
183:                   // 
184:                   ADFL2DAT = 0x0;
006F88  EF2B70     CLR ADFL2DAT
185:                   // 
186:                   ADFL3DAT = 0x0;
006F8A  EF2B74     CLR ADFL3DAT
187:                   // FLCHSEL AN0; IE disabled; OVRSAM 4x; MODE Oversampling Mode; FLEN disabled; 
188:                   ADFL0CON = 0x400;
006F8C  204000     MOV #0x400, W0
006F8E  885B50     MOV W0, ADFL0CON
189:                   // FLCHSEL AN0; IE disabled; OVRSAM 4x; MODE Oversampling Mode; FLEN disabled; 
190:                   ADFL1CON = 0x400;
006F90  885B70     MOV W0, ADFL1CON
191:                   // FLCHSEL AN0; IE disabled; OVRSAM 4x; MODE Oversampling Mode; FLEN disabled; 
192:                   ADFL2CON = 0x400;
006F92  885B90     MOV W0, ADFL2CON
193:                   // FLCHSEL AN0; IE disabled; OVRSAM 4x; MODE Oversampling Mode; FLEN disabled; 
194:                   ADFL3CON = 0x400;
006F94  885BB0     MOV W0, ADFL3CON
195:                   // LOLO disabled; LOHI disabled; HILO disabled; HIHI disabled; BTWN disabled; IE disabled; CMPEN disabled; 
196:                   ADCMP0CON = 0x0;
006F96  EF2BA0     CLR ADCMP0CON
197:                   // LOLO disabled; LOHI disabled; HILO disabled; HIHI disabled; BTWN disabled; IE disabled; CMPEN disabled; 
198:                   ADCMP1CON = 0x0;
006F98  EF2BA4     CLR ADCMP1CON
199:                   // LOLO disabled; LOHI disabled; HILO disabled; HIHI disabled; BTWN disabled; IE disabled; CMPEN disabled; 
200:                   ADCMP2CON = 0x0;
006F9A  EF2BA8     CLR ADCMP2CON
201:                   // LOLO disabled; LOHI disabled; HILO disabled; HIHI disabled; BTWN disabled; IE disabled; CMPEN disabled; 
202:                   ADCMP3CON = 0x0;
006F9C  EF2BAC     CLR ADCMP3CON
203:                   // LVLEN0 disabled; LVLEN1 disabled; LVLEN2 disabled; LVLEN3 disabled; LVLEN4 disabled; LVLEN5 disabled; LVLEN6 disabled; LVLEN7 disabled; LVLEN8 disabled; LVLEN9 disabled; LVLEN10 disabled; LVLEN11 disabled; LVLEN12 disabled; LVLEN13 disabled; LVLEN14 disabled; LVLEN15 disabled; 
204:                   ADLVLTRGL = 0x0;
006F9E  EF2BD0     CLR ADLVLTRGL
205:                   // LVLEN16 disabled; LVLEN17 disabled; LVLEN18 disabled; LVLEN19 disabled; LVLEN20 disabled; LVLEN21 disabled; LVLEN22 disabled; LVLEN23 disabled; LVLEN24 disabled; LVLEN25 disabled; 
206:                   ADLVLTRGH = 0x0;
006FA0  EF2BD2     CLR ADLVLTRGH
207:                   // SAMC 13; 
208:                   ADCORE0L = 0xD;
006FA2  885EA1     MOV W1, ADCORE0L
209:                   // SAMC 13; 
210:                   ADCORE1L = 0xD;
006FA4  885EC1     MOV W1, ADCORE1L
211:                   // ADCS 2; RES 12-bit resolution; EISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; 
212:                   ADCORE0H = 0x300;
006FA6  203000     MOV #0x300, W0
006FA8  885EB0     MOV W0, ADCORE0H
213:                   // ADCS 2; RES 12-bit resolution; EISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; 
214:                   ADCORE1H = 0x300;
006FAA  885ED0     MOV W0, ADCORE1H
215:                   // EIEN0 disabled; EIEN1 disabled; EIEN2 disabled; EIEN3 disabled; EIEN4 disabled; EIEN5 disabled; EIEN6 disabled; EIEN7 disabled; EIEN8 disabled; EIEN9 disabled; EIEN10 disabled; EIEN11 disabled; EIEN12 disabled; EIEN13 disabled; EIEN14 disabled; EIEN15 disabled; 
216:                   ADEIEL = 0x0;
006FAC  EF2BF0     CLR ADEIEL
217:                   // EIEN16 disabled; EIEN17 disabled; EIEN18 disabled; EIEN19 disabled; EIEN20 disabled; EIEN21 disabled; EIEN22 disabled; EIEN23 disabled; EIEN24 disabled; EIEN25 disabled; 
218:                   ADEIEH = 0x0;
006FAE  EF2BF2     CLR ADEIEH
219:                   // EISTAT0 disabled; EISTAT1 disabled; EISTAT2 disabled; EISTAT3 disabled; EISTAT4 disabled; EISTAT5 disabled; EISTAT6 disabled; EISTAT7 disabled; EISTAT8 disabled; EISTAT9 disabled; EISTAT10 disabled; EISTAT11 disabled; EISTAT12 disabled; EISTAT13 disabled; EISTAT14 disabled; EISTAT15 disabled; 
220:                   ADEISTATL = 0x0;
006FB0  EF2BF8     CLR ADEISTATL
221:                   // EISTAT16 disabled; EISTAT17 disabled; EISTAT18 disabled; EISTAT19 disabled; EISTAT20 disabled; EISTAT21 disabled; EISTAT22 disabled; EISTAT23 disabled; EISTAT24 disabled; EISTAT25 disabled; 
222:                   ADEISTATH = 0x0;
006FB2  EF2BFA     CLR ADEISTATH
223:                   // C0CIE disabled; C1CIE disabled; SHRCIE disabled; WARMTIME 16 Source Clock Periods; 
224:                   ADCON5H = (uint16_t)0x400 & (uint16_t)0xF0FF; //Disabling WARMTIME bit
006FB4  EF2C02     CLR ADCON5H
225:                   // 
226:                   ADCBUF0 = 0x0;
006FB6  EF2C0C     CLR ADCBUF0
227:                   // 
228:                   ADCBUF1 = 0x0;
006FB8  EF2C0E     CLR ADCBUF1
229:                   // 
230:                   ADCBUF2 = 0x0;
006FBA  EF2C10     CLR ADCBUF2
231:                   // 
232:                   ADCBUF3 = 0x0;
006FBC  EF2C12     CLR ADCBUF3
233:                   // 
234:                   ADCBUF4 = 0x0;
006FBE  EF2C14     CLR ADCBUF4
235:                   // 
236:                   ADCBUF5 = 0x0;
006FC0  EF2C16     CLR ADCBUF5
237:                   // 
238:                   ADCBUF6 = 0x0;
006FC2  EF2C18     CLR ADCBUF6
239:                   // 
240:                   ADCBUF7 = 0x0;
006FC4  EF2C1A     CLR ADCBUF7
241:                   // 
242:                   ADCBUF8 = 0x0;
006FC6  EF2C1C     CLR ADCBUF8
243:                   // 
244:                   ADCBUF9 = 0x0;
006FC8  EF2C1E     CLR ADCBUF9
245:                   // 
246:                   ADCBUF10 = 0x0;
006FCA  EF2C20     CLR ADCBUF10
247:                   // 
248:                   ADCBUF11 = 0x0;
006FCC  EF2C22     CLR ADCBUF11
249:                   // 
250:                   ADCBUF12 = 0x0;
006FCE  EF2C24     CLR ADCBUF12
251:                   // 
252:                   ADCBUF13 = 0x0;
006FD0  EF2C26     CLR ADCBUF13
253:                   // 
254:                   ADCBUF14 = 0x0;
006FD2  EF2C28     CLR ADCBUF14
255:                   // 
256:                   ADCBUF15 = 0x0;
006FD4  EF2C2A     CLR ADCBUF15
257:                   // 
258:                   ADCBUF16 = 0x0;
006FD6  EF2C2C     CLR ADCBUF16
259:                   // 
260:                   ADCBUF17 = 0x0;
006FD8  EF2C2E     CLR ADCBUF17
261:                   // 
262:                   ADCBUF18 = 0x0;
006FDA  EF2C30     CLR ADCBUF18
263:                   // 
264:                   ADCBUF19 = 0x0;
006FDC  EF2C32     CLR ADCBUF19
265:                   // 
266:                   ADCBUF20 = 0x0;
006FDE  EF2C34     CLR ADCBUF20
267:                   // 
268:                   ADCBUF21 = 0x0;
006FE0  EF2C36     CLR ADCBUF21
269:                   // 
270:                   ADCBUF22 = 0x0;
006FE2  EF2C38     CLR ADCBUF22
271:                   // 
272:                   ADCBUF23 = 0x0;
006FE4  EF2C3A     CLR ADCBUF23
273:                   // 
274:                   ADCBUF24 = 0x0;
006FE6  EF2C3C     CLR ADCBUF24
275:                   // 
276:                   ADCBUF25 = 0x0;
006FE8  EF2C3E     CLR ADCBUF25
277:                       
278:                   ADC1_CommonCallbackRegister(&ADC1_CommonCallback);
006FEA  29FB40     MOV #0x9FB4, W0
006FEC  0716EE     RCALL ADC1_CommonCallbackRegister
279:                   ADC1_ChannelCallbackRegister(&ADC1_ChannelCallback);
006FEE  29FB60     MOV #0x9FB6, W0
006FF0  0716F0     RCALL ADC1_ChannelCallbackRegister
280:                   ADC1_ComparatorCallbackRegister(&ADC1_ComparatorCallback);
006FF2  29FB80     MOV #0x9FB8, W0
006FF4  0716F2     RCALL ADC1_ComparatorCallbackRegister
281:                   
282:               
283:                   // Setting WARMTIME bit
284:                   ADCON5Hbits.WARMTIME = 0xF;
006FF6  20F000     MOV #0xF00, W0
006FF8  B72C02     IOR ADCON5H
285:                   // Enabling ADC Module
286:                   ADCON1Lbits.ADON = 0x1;
006FFA  A8EB01     BSET 0xB01, #7
287:                   // Enabling Power for Core0
288:                   ADC1_CorePowerEnable(ADC_CORE_0);
006FFC  EB0000     CLR W0
006FFE  07123A     RCALL ADC1_CorePowerEnable
289:                   // Enabling Power for Core1
290:                   ADC1_CorePowerEnable(ADC_CORE_1);
007000  200010     MOV #0x1, W0
007002  071238     RCALL ADC1_CorePowerEnable
291:                   // Enabling Power for the Shared Core
292:                   ADC1_SharedCorePowerEnable();
007004  071664     RCALL ADC1_SharedCorePowerEnable
293:               
294:                   //TRGSRC0 None; TRGSRC1 None; 
295:                   ADTRIG0L = 0x0;
007006  EF2B80     CLR ADTRIG0L
296:                   //TRGSRC2 None; TRGSRC3 None; 
297:                   ADTRIG0H = 0x0;
007008  EF2B82     CLR ADTRIG0H
298:                   //TRGSRC4 None; TRGSRC5 None; 
299:                   ADTRIG1L = 0x0;
00700A  EF2B84     CLR ADTRIG1L
300:                   //TRGSRC6 None; TRGSRC7 None; 
301:                   ADTRIG1H = 0x0;
00700C  EF2B86     CLR ADTRIG1H
302:                   //TRGSRC8 None; TRGSRC9 None; 
303:                   ADTRIG2L = 0x0;
00700E  EF2B88     CLR ADTRIG2L
304:                   //TRGSRC10 None; TRGSRC11 None; 
305:                   ADTRIG2H = 0x0;
007010  EF2B8A     CLR ADTRIG2H
306:                   //TRGSRC12 None; TRGSRC13 None; 
307:                   ADTRIG3L = 0x0;
007012  EF2B8C     CLR ADTRIG3L
308:                   //TRGSRC14 None; TRGSRC15 None; 
309:                   ADTRIG3H = 0x0;
007014  EF2B8E     CLR ADTRIG3H
310:                   //TRGSRC16 None; TRGSRC17 None; 
311:                   ADTRIG4L = 0x0;
007016  EF2B90     CLR ADTRIG4L
312:                   //TRGSRC18 None; TRGSRC19 None; 
313:                   ADTRIG4H = 0x0;
007018  EF2B92     CLR ADTRIG4H
314:                   //TRGSRC20 None; TRGSRC21 None; 
315:                   ADTRIG5L = 0x0;
00701A  EF2B94     CLR ADTRIG5L
316:                   //TRGSRC22 None; TRGSRC23 None; 
317:                   ADTRIG5H = 0x0;
00701C  EF2B96     CLR ADTRIG5H
318:                   //TRGSRC24 None; TRGSRC25 None; 
319:                   ADTRIG6L = 0x0;
00701E  EF2B98     CLR ADTRIG6L
320:               }
007020  060000     RETURN
007022  2000C0     MOV #0xC, W0
007024  881950     MOV W0, PG1CONL
321:               
322:               void ADC1_Deinitialize (void)
323:               {
324:                   ADCON1Lbits.ADON = 0;
007626  A9EB01     BCLR 0xB01, #7
325:                   
326:                   ADCON1L = 0x0;
007628  EF2B00     CLR ADCON1L
327:                   ADCON1H = 0x60;
00762A  200600     MOV #0x60, W0
00762C  885810     MOV W0, ADCON1H
328:                   ADCON2L = 0x0;
00762E  EF2B04     CLR ADCON2L
329:                   ADCON2H = 0x0;
007630  EF2B06     CLR ADCON2H
330:                   ADCON3L = 0x0;
007632  EF2B08     CLR ADCON3L
331:                   ADCON3H = 0x0;
007634  EF2B0A     CLR ADCON3H
332:                   ADCON4L = 0x0;
007636  EF2B0C     CLR ADCON4L
333:                   ADCON4H = 0x0;
007638  EF2B0E     CLR ADCON4H
334:                   ADMOD0L = 0x0;
00763A  EF2B10     CLR ADMOD0L
335:                   ADMOD0H = 0x0;
00763C  EF2B12     CLR ADMOD0H
336:                   ADMOD1L = 0x0;
00763E  EF2B14     CLR ADMOD1L
337:                   ADMOD1H = 0x0;
007640  EF2B16     CLR ADMOD1H
338:                   ADIEL = 0x0;
007642  EF2B20     CLR ADIEL
339:                   ADIEH = 0x0;
007644  EF2B22     CLR ADIEH
340:                   ADSTATL = 0x0;
007646  EF2B30     CLR ADSTATL
341:                   ADSTATH = 0x0;
007648  EF2B32     CLR ADSTATH
342:                   ADCMP0ENL = 0x0;
00764A  EF2B38     CLR ADCMP0ENL
343:                   ADCMP1ENL = 0x0;
00764C  EF2B40     CLR ADCMP1ENL
344:                   ADCMP2ENL = 0x0;
00764E  EF2B48     CLR ADCMP2ENL
345:                   ADCMP3ENL = 0x0;
007650  EF2B50     CLR ADCMP3ENL
346:                   ADCMP0ENH = 0x0;
007652  EF2B3A     CLR ADCMP0ENH
347:                   ADCMP1ENH = 0x0;
007654  EF2B42     CLR ADCMP1ENH
348:                   ADCMP2ENH = 0x0;
007656  EF2B4A     CLR ADCMP2ENH
349:                   ADCMP3ENH = 0x0;
007658  EF2B52     CLR ADCMP3ENH
350:                   ADCMP0LO = 0x0;
00765A  EF2B3C     CLR ADCMP0LO
351:                   ADCMP1LO = 0x0;
00765C  EF2B44     CLR ADCMP1LO
352:                   ADCMP2LO = 0x0;
00765E  EF2B4C     CLR ADCMP2LO
353:                   ADCMP3LO = 0x0;
007660  EF2B54     CLR ADCMP3LO
354:                   ADCMP0HI = 0x0;
007662  EF2B3E     CLR ADCMP0HI
355:                   ADCMP1HI = 0x0;
007664  EF2B46     CLR ADCMP1HI
356:                   ADCMP2HI = 0x0;
007666  EF2B4E     CLR ADCMP2HI
357:                   ADCMP3HI = 0x0;
007668  EF2B56     CLR ADCMP3HI
358:                   ADFL0DAT = 0x0;
00766A  EF2B68     CLR ADFL0DAT
359:                   ADFL1DAT = 0x0;
00766C  EF2B6C     CLR ADFL1DAT
360:                   ADFL2DAT = 0x0;
00766E  EF2B70     CLR ADFL2DAT
361:                   ADFL3DAT = 0x0;
007670  EF2B74     CLR ADFL3DAT
362:                   ADFL0CON = 0x0;
007672  EF2B6A     CLR ADFL0CON
363:                   ADFL1CON = 0x0;
007674  EF2B6E     CLR ADFL1CON
364:                   ADFL2CON = 0x0;
007676  EF2B72     CLR ADFL2CON
365:                   ADFL3CON = 0x0;
007678  EF2B76     CLR ADFL3CON
366:                   ADTRIG0L = 0x0;
00767A  EF2B80     CLR ADTRIG0L
367:                   ADTRIG0H = 0x0;
00767C  EF2B82     CLR ADTRIG0H
368:                   ADTRIG1L = 0x0;
00767E  EF2B84     CLR ADTRIG1L
369:                   ADTRIG1H = 0x0;
007680  EF2B86     CLR ADTRIG1H
370:                   ADTRIG2L = 0x0;
007682  EF2B88     CLR ADTRIG2L
371:                   ADTRIG2H = 0x0;
007684  EF2B8A     CLR ADTRIG2H
372:                   ADTRIG3L = 0x0;
007686  EF2B8C     CLR ADTRIG3L
373:                   ADTRIG3H = 0x0;
007688  EF2B8E     CLR ADTRIG3H
374:                   ADTRIG4L = 0x0;
00768A  EF2B90     CLR ADTRIG4L
375:                   ADTRIG4H = 0x0;
00768C  EF2B92     CLR ADTRIG4H
376:                   ADTRIG5L = 0x0;
00768E  EF2B94     CLR ADTRIG5L
377:                   ADTRIG5H = 0x0;
007690  EF2B96     CLR ADTRIG5H
378:                   ADTRIG6L = 0x0;
007692  EF2B98     CLR ADTRIG6L
379:                   ADCMP0CON = 0x0;
007694  EF2BA0     CLR ADCMP0CON
380:                   ADCMP1CON = 0x0;
007696  EF2BA4     CLR ADCMP1CON
381:                   ADCMP2CON = 0x0;
007698  EF2BA8     CLR ADCMP2CON
382:                   ADCMP3CON = 0x0;
00769A  EF2BAC     CLR ADCMP3CON
383:                   ADLVLTRGL = 0x0;
00769C  EF2BD0     CLR ADLVLTRGL
384:                   ADLVLTRGH = 0x0;
00769E  EF2BD2     CLR ADLVLTRGH
385:                   ADCORE0L = 0x0;
0076A0  EF2BD4     CLR ADCORE0L
386:                   ADCORE1L = 0x0;
0076A2  EF2BD8     CLR ADCORE1L
387:                   ADCORE0H = 0x300;
0076A4  203000     MOV #0x300, W0
0076A6  885EB0     MOV W0, ADCORE0H
388:                   ADCORE1H = 0x300;
0076A8  885ED0     MOV W0, ADCORE1H
389:                   ADEIEL = 0x0;
0076AA  EF2BF0     CLR ADEIEL
390:                   ADEIEH = 0x0;
0076AC  EF2BF2     CLR ADEIEH
391:                   ADEISTATL = 0x0;
0076AE  EF2BF8     CLR ADEISTATL
392:                   ADEISTATH = 0x0;
0076B0  EF2BFA     CLR ADEISTATH
393:                   ADCON5L = 0x0;
0076B2  EF2C00     CLR ADCON5L
394:                   ADCON5H = 0x0;
0076B4  EF2C02     CLR ADCON5H
395:                   ADCBUF0 = 0x0;
0076B6  EF2C0C     CLR ADCBUF0
396:                   ADCBUF1 = 0x0;
0076B8  EF2C0E     CLR ADCBUF1
397:                   ADCBUF2 = 0x0;
0076BA  EF2C10     CLR ADCBUF2
398:                   ADCBUF3 = 0x0;
0076BC  EF2C12     CLR ADCBUF3
399:                   ADCBUF4 = 0x0;
0076BE  EF2C14     CLR ADCBUF4
400:                   ADCBUF5 = 0x0;
0076C0  EF2C16     CLR ADCBUF5
401:                   ADCBUF6 = 0x0;
0076C2  EF2C18     CLR ADCBUF6
402:                   ADCBUF7 = 0x0;
0076C4  EF2C1A     CLR ADCBUF7
403:                   ADCBUF8 = 0x0;
0076C6  EF2C1C     CLR ADCBUF8
404:                   ADCBUF9 = 0x0;
0076C8  EF2C1E     CLR ADCBUF9
405:                   ADCBUF10 = 0x0;
0076CA  EF2C20     CLR ADCBUF10
406:                   ADCBUF11 = 0x0;
0076CC  EF2C22     CLR ADCBUF11
407:                   ADCBUF12 = 0x0;
0076CE  EF2C24     CLR ADCBUF12
408:                   ADCBUF13 = 0x0;
0076D0  EF2C26     CLR ADCBUF13
409:                   ADCBUF14 = 0x0;
0076D2  EF2C28     CLR ADCBUF14
410:                   ADCBUF15 = 0x0;
0076D4  EF2C2A     CLR ADCBUF15
411:                   ADCBUF16 = 0x0;
0076D6  EF2C2C     CLR ADCBUF16
412:                   ADCBUF17 = 0x0;
0076D8  EF2C2E     CLR ADCBUF17
413:                   ADCBUF18 = 0x0;
0076DA  EF2C30     CLR ADCBUF18
414:                   ADCBUF19 = 0x0;
0076DC  EF2C32     CLR ADCBUF19
415:                   ADCBUF20 = 0x0;
0076DE  EF2C34     CLR ADCBUF20
416:                   ADCBUF21 = 0x0;
0076E0  EF2C36     CLR ADCBUF21
417:                   ADCBUF22 = 0x0;
0076E2  EF2C38     CLR ADCBUF22
418:                   ADCBUF23 = 0x0;
0076E4  EF2C3A     CLR ADCBUF23
419:                   ADCBUF24 = 0x0;
0076E6  EF2C3C     CLR ADCBUF24
420:                   ADCBUF25 = 0x0;
0076E8  EF2C3E     CLR ADCBUF25
421:               }
0076EA  060000     RETURN
0076EC  4787F6     ADD W15, #0x16, W15
422:               
423:               void ADC1_CorePowerEnable(enum ADC_DEDICATED_CORE core) 
424:               {
425:                   switch(core)
009474  E00000     CP0 W0
009476  320003     BRA Z, .L94
009478  500FE1     SUB W0, #0x1, [W15]
00947A  3A000E     BRA NZ, .L92
00947C  370007     BRA .L100
426:                   {
427:                       case ADC_CORE_0:
428:                           ADCON5Lbits.C0PWR = 1; 
00947E  A80C00     BSET ADCON5L, #0
429:                           while(ADCON5Lbits.C0RDY == 0)
009480  201001     MOV #0x100, W1
009482  806002     MOV ADCON5L, W2
009484  608002     AND W1, W2, W0
009486  32FFFD     BRA Z, .L96
430:                           {
431:                           }
432:                           ADCON3Hbits.C0EN = 1; 
009488  A80B0A     BSET ADCON3H, #0
433:                           break;
00948A  370006     BRA .L92
434:                       case ADC_CORE_1:
435:                           ADCON5Lbits.C1PWR = 1; 
00948C  A82C00     BSET ADCON5L, #1
436:                           while(ADCON5Lbits.C1RDY == 0)
00948E  202001     MOV #0x200, W1
009490  806002     MOV ADCON5L, W2
009492  608002     AND W1, W2, W0
009494  32FFFD     BRA Z, .L97
437:                           {
438:                           }
439:                           ADCON3Hbits.C1EN = 1; 
009496  A82B0A     BSET ADCON3H, #1
440:                           break;
441:                       default:    
442:                           break;
443:                   }
444:               }
009498  060000     RETURN
00949A  EB4080     CLR.B W1
445:               
446:               
447:               void ADC1_SharedCorePowerEnable (void) 
448:               {
449:                   ADCON5Lbits.SHRPWR = 1;   
009CCE  A8EC00     BSET ADCON5L, #7
450:                   while(ADCON5Lbits.SHRRDY == 0)
009CD0  280001     MOV #0x8000, W1
009CD2  806002     MOV ADCON5L, W2
009CD4  608002     AND W1, W2, W0
009CD6  32FFFD     BRA Z, .L102
451:                   {
452:                   }
453:                   ADCON3Hbits.SHREN = 1;   
009CD8  A8EB0A     BSET ADCON3H, #7
454:               }
009CDA  060000     RETURN
009CDC  2034D1     MOV #0x34D, W1
009CDE  780801     MOV W1, [W0]
455:               
456:               static uint16_t ADC1_TriggerSourceValueGet(enum ADC_PWM_INSTANCE pwmInstance, enum ADC_PWM_TRIGGERS triggerNumber)
457:               {
458:                   uint16_t adcTriggerSourceValue = 0x0U;
007938  EB0000     CLR W0
00793A  370039     BRA .L105
007948  EB0000     CLR W0
00794A  370031     BRA .L105
007958  EB0000     CLR W0
00795A  370029     BRA .L105
007968  EB0000     CLR W0
00796A  370021     BRA .L105
007978  EB0000     CLR W0
00797A  370019     BRA .L105
007988  EB0000     CLR W0
00798A  370011     BRA .L105
007998  EB0000     CLR W0
00799A  370009     BRA .L105
0079A8  EB0000     CLR W0
0079AA  370001     BRA .L105
0079AC  EB0000     CLR W0
459:                   switch(pwmInstance)
00790A  500FE4     SUB W0, #0x4, [W15]
00790C  320027     BRA Z, .L109
00790E  3E0006     BRA GTU, .L114
007910  500FE2     SUB W0, #0x2, [W15]
007912  320014     BRA Z, .L107
007914  3E001B     BRA GTU, .L108
007916  500FE1     SUB W0, #0x1, [W15]
007918  3A0049     BRA NZ, .L115
00791A  370008     BRA .L132
00791C  500FE6     SUB W0, #0x6, [W15]
00791E  32002E     BRA Z, .L111
007920  390025     BRA NC, .L110
007922  500FE7     SUB W0, #0x7, [W15]
007924  320033     BRA Z, .L112
007926  500FE8     SUB W0, #0x8, [W15]
007928  3A0041     BRA NZ, .L115
00792A  370038     BRA .L133
460:                   {
461:                       case 1:
462:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00792E  508FE1     SUB W1, #0x1, [W15]
007930  32003E     BRA Z, .L105
463:                               {
464:                                   adcTriggerSourceValue = PWM1_TRIGGER1;
00792C  200040     MOV #0x4, W0
465:                               }
466:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007934  508FE2     SUB W1, #0x2, [W15]
007936  32003B     BRA Z, .L105
467:                               {
468:                                   adcTriggerSourceValue = PWM1_TRIGGER2;
007932  200050     MOV #0x5, W0
469:                               }
470:                               break;
471:                       case 2:
472:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00793E  508FE1     SUB W1, #0x1, [W15]
007940  320036     BRA Z, .L105
473:                               {
474:                                   adcTriggerSourceValue = PWM2_TRIGGER1;
00793C  200060     MOV #0x6, W0
475:                               }
476:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007944  508FE2     SUB W1, #0x2, [W15]
007946  320033     BRA Z, .L105
477:                               {
478:                                   adcTriggerSourceValue = PWM2_TRIGGER2;
007942  200070     MOV #0x7, W0
479:                               }
480:                               break;
481:                       case 3:
482:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00794E  508FE1     SUB W1, #0x1, [W15]
007950  32002E     BRA Z, .L105
483:                               {
484:                                   adcTriggerSourceValue = PWM3_TRIGGER1;
00794C  200080     MOV #0x8, W0
485:                               }
486:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007954  508FE2     SUB W1, #0x2, [W15]
007956  32002B     BRA Z, .L105
487:                               {
488:                                   adcTriggerSourceValue = PWM3_TRIGGER2;
007952  200090     MOV #0x9, W0
489:                               }
490:                               break;
491:                       case 4:
492:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00795E  508FE1     SUB W1, #0x1, [W15]
007960  320026     BRA Z, .L105
493:                               {
494:                                   adcTriggerSourceValue = PWM4_TRIGGER1;
00795C  2000A0     MOV #0xA, W0
495:                               }
496:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007964  508FE2     SUB W1, #0x2, [W15]
007966  320023     BRA Z, .L105
497:                               {
498:                                   adcTriggerSourceValue = PWM4_TRIGGER2;
007962  2000B0     MOV #0xB, W0
499:                               }
500:                               break;
501:                       case 5:
502:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00796E  508FE1     SUB W1, #0x1, [W15]
007970  32001E     BRA Z, .L105
503:                               {
504:                                   adcTriggerSourceValue = PWM5_TRIGGER1;
00796C  2000C0     MOV #0xC, W0
505:                               }
506:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007974  508FE2     SUB W1, #0x2, [W15]
007976  32001B     BRA Z, .L105
507:                               {
508:                                   adcTriggerSourceValue = PWM5_TRIGGER2;
007972  2000D0     MOV #0xD, W0
509:                               }
510:                               break;
511:                       case 6:
512:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00797E  508FE1     SUB W1, #0x1, [W15]
007980  320016     BRA Z, .L105
513:                               {
514:                                   adcTriggerSourceValue = PWM6_TRIGGER1;
00797C  2000E0     MOV #0xE, W0
515:                               }
516:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007984  508FE2     SUB W1, #0x2, [W15]
007986  320013     BRA Z, .L105
517:                               {
518:                                   adcTriggerSourceValue = PWM6_TRIGGER2;
007982  2000F0     MOV #0xF, W0
519:                               }
520:                               break;
521:                       case 7:
522:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00798E  508FE1     SUB W1, #0x1, [W15]
007990  32000E     BRA Z, .L105
523:                               {
524:                                   adcTriggerSourceValue = PWM7_TRIGGER1;
00798C  200100     MOV #0x10, W0
525:                               }
526:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
007994  508FE2     SUB W1, #0x2, [W15]
007996  32000B     BRA Z, .L105
527:                               {
528:                                   adcTriggerSourceValue = PWM7_TRIGGER2;
007992  200110     MOV #0x11, W0
529:                               }
530:                               break;
531:                       case 8:
532:                               if(triggerNumber == ADC_PWM_TRIGGER_1)
00799E  508FE1     SUB W1, #0x1, [W15]
0079A0  320006     BRA Z, .L105
533:                               {
534:                                   adcTriggerSourceValue = PWM8_TRIGGER1;
00799C  200120     MOV #0x12, W0
535:                               }
536:                               else if(triggerNumber == ADC_PWM_TRIGGER_2)
0079A4  508FE2     SUB W1, #0x2, [W15]
0079A6  320003     BRA Z, .L105
537:                               {
538:                                   adcTriggerSourceValue = PWM8_TRIGGER2;
0079A2  200130     MOV #0x13, W0
539:                               }
540:                               break;
541:                        default:
542:                               break;
543:                   }
544:                   return adcTriggerSourceValue;
545:               }
0079AE  060000     RETURN
0079B0  BE9F88     MOV.D W8, [W15++]
0079B2  780400     MOV W0, W8
546:               
547:               void ADC1_PWMTriggerSourceSet(enum ADC_CHANNEL channel, enum ADC_PWM_INSTANCE pwmInstance, enum ADC_PWM_TRIGGERS triggerNumber)
548:               {
007D80  BE9F88     MOV.D W8, [W15++]
007D82  780400     MOV W0, W8
007D84  780001     MOV W1, W0
007D86  780082     MOV W2, W1
549:                   uint16_t adcTriggerValue;
550:                   adcTriggerValue= ADC1_TriggerSourceValueGet(pwmInstance, triggerNumber);
007D88  07FDC0     RCALL ADC1_TriggerSourceValueGet
551:                   switch(channel)
007D8A  EB0480     CLR W9
007D8C  540FE9     SUB W8, #0x9, [W15]
007D8E  5C8FE0     SUBB W9, #0x0, [W15]
007D90  3E0041     BRA GTU, .L134
007D92  010608     BRA W8
007D94  370009     BRA .SE146, .L136
007D96  37000B     BRA .L137
007D98  37000D     BRA .L138
007D9A  370014     BRA .L139
007D9C  370016     BRA .L140
007D9E  37001D     BRA .L141
007DA0  370024     BRA .L142
007DA2  370026     BRA .L143
007DA4  37002D     BRA .L144
007DA6  37002F     BRA .L145
552:                   {
553:                       case MCAF_ADC_DCLINK_CURRENT:
554:                               ADTRIG1Lbits.TRGSRC4 = adcTriggerValue;
007DA8  0A2040     BFINS #0x0, #0x5, W0, ADTRIG1L
007DAA  000B84     NOP
555:                               break;
007DAC  370033     BRA .L134
556:                       case MCAF_ADC_PHASEC_CURRENT:
557:                               ADTRIG2Hbits.TRGSRC10 = adcTriggerValue;
007DAE  0A2040     BFINS #0x0, #0x5, W0, ADTRIG2H
007DB0  000B8A     NOP
558:                               break;
007DB2  370030     BRA .L134
559:                       case MCAF_ADC_POTENTIOMETER:
560:                               ADTRIG2Hbits.TRGSRC11 = adcTriggerValue;
007DB4  60007F     AND W0, #0x1F, W0
007DB6  DD0048     SL W0, #8, W0
007DB8  2E0FF1     MOV #0xE0FF, W1
007DBA  805C52     MOV ADTRIG2H, W2
007DBC  608082     AND W1, W2, W1
007DBE  700081     IOR W0, W1, W1
007DC0  885C51     MOV W1, ADTRIG2H
561:                               break;
007DC2  370028     BRA .L134
562:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
563:                               ADTRIG3Lbits.TRGSRC12 = adcTriggerValue;
007DC4  0A2040     BFINS #0x0, #0x5, W0, ADTRIG3L
007DC6  000B8C     NOP
564:                               break;
007DC8  370025     BRA .L134
565:                       case MCAF_ADC_DCLINK_VOLTAGE:
566:                               ADTRIG3Hbits.TRGSRC15 = adcTriggerValue;
007DCA  60007F     AND W0, #0x1F, W0
007DCC  DD0048     SL W0, #8, W0
007DCE  2E0FF1     MOV #0xE0FF, W1
007DD0  805C72     MOV ADTRIG3H, W2
007DD2  608082     AND W1, W2, W1
007DD4  700081     IOR W0, W1, W1
007DD6  885C71     MOV W1, ADTRIG3H
567:                               break;
007DD8  37001D     BRA .L134
568:                       case MCAF_ADC_PHASEA_VOLTAGE:
569:                               ADTRIG4Lbits.TRGSRC17 = adcTriggerValue;
007DDA  60007F     AND W0, #0x1F, W0
007DDC  DD0048     SL W0, #8, W0
007DDE  2E0FF1     MOV #0xE0FF, W1
007DE0  805C82     MOV ADTRIG4L, W2
007DE2  608082     AND W1, W2, W1
007DE4  700081     IOR W0, W1, W1
007DE6  885C81     MOV W1, ADTRIG4L
570:                               break;
007DE8  370015     BRA .L134
571:                       case MCAF_ADC_PHASEC_VOLTAGE:
572:                               ADTRIG5Hbits.TRGSRC22 = adcTriggerValue;
007DEA  0A2040     BFINS #0x0, #0x5, W0, ADTRIG5H
007DEC  000B96     NOP
573:                               break;
007DEE  370012     BRA .L134
574:                       case MCAF_ADC_PHASEB_VOLTAGE:
575:                               ADTRIG5Hbits.TRGSRC23 = adcTriggerValue;
007DF0  60007F     AND W0, #0x1F, W0
007DF2  DD0048     SL W0, #8, W0
007DF4  2E0FF1     MOV #0xE0FF, W1
007DF6  805CB2     MOV ADTRIG5H, W2
007DF8  608082     AND W1, W2, W1
007DFA  700081     IOR W0, W1, W1
007DFC  885CB1     MOV W1, ADTRIG5H
576:                               break;
007DFE  37000A     BRA .L134
577:                       case MCAF_ADC_PHASEA_CURRENT:
578:                               ADTRIG0Lbits.TRGSRC0 = adcTriggerValue;
007E00  0A2040     BFINS #0x0, #0x5, W0, ADTRIG0L
007E02  000B80     NOP
579:                               break;
007E04  370007     BRA .L134
580:                       case MCAF_ADC_PHASEB_CURRENT:
581:                               ADTRIG0Lbits.TRGSRC1 = adcTriggerValue;
007E06  60007F     AND W0, #0x1F, W0
007E08  DD0048     SL W0, #8, W0
007E0A  2E0FF1     MOV #0xE0FF, W1
007E0C  805C02     MOV ADTRIG0L, W2
007E0E  608082     AND W1, W2, W1
007E10  700081     IOR W0, W1, W1
007E12  885C01     MOV W1, ADTRIG0L
582:                               break;
583:                       default:
584:                               break;
585:                   }
586:               }
007E14  BE044F     MOV.D [--W15], W8
007E16  060000     RETURN
007E18  780380     MOV W0, W7
587:               
588:               void ADC1_CommonCallbackRegister(void(*callback)(void))
589:               {
590:                   if(NULL != callback)
009DCA  E00000     CP0 W0
009DCC  320001     BRA Z, .L147
591:                   {
592:                       ADC1_CommonHandler = callback;
009DCE  889270     MOV W0, ADC1_CommonHandler
593:                   }
594:               }
009DD0  060000     RETURN
009DD2  E00000     CP0 W0
595:               
596:               void __attribute__ ((weak)) ADC1_CommonCallback (void)
597:               { 
598:               
599:               } 
009FB4  060000     RETURN
009FB6  060000     RETURN
600:               
601:               
602:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCInterrupt ( void )
603:               {
00062E  F80036     PUSH RCOUNT
000630  BE9F80     MOV.D W0, [W15++]
000632  BE9F82     MOV.D W2, [W15++]
000634  BE9F84     MOV.D W4, [W15++]
000636  BE9F86     MOV.D W6, [W15++]
000638  F80032     PUSH DSRPAG
00063A  F80034     PUSH DSWPAG
00063C  200010     MOV #0x1, W0
00063E  8801A0     MOV W0, DSWPAG
000640  202000     MOV #0x200, W0
000642  FED000     MOVPAG W0, DSRPAG
604:                   uint16_t adcVal;
605:                   if(NULL != ADC1_CommonHandler)
000644  809270     MOV ADC1_CommonHandler, W0
000646  E00000     CP0 W0
000648  320001     BRA Z, .L174
606:                   {
607:                       (*ADC1_CommonHandler)();
00064A  010000     CALL W0
608:                   }
609:                   
610:                   if(IFS5bits.ADCAN4IF == 1)
00064C  E2080A     CP0 IFS5
00064E  3D0007     BRA GE, .L175
611:                   {
612:                       //Read the ADC value from the ADCBUF before clearing interrupt
613:                       adcVal = ADCBUF4;
000650  8060A1     MOV ADCBUF4, W1
614:                       if(NULL != ADC1_ChannelHandler)
000652  809262     MOV ADC1_ChannelHandler, W2
000654  E00002     CP0 W2
000656  320002     BRA Z, .L176
615:                       {
616:                           (*ADC1_ChannelHandler)(MCAF_ADC_DCLINK_CURRENT, adcVal);
000658  EB0000     CLR W0
00065A  010002     CALL W2
617:                       }
618:                       IFS5bits.ADCAN4IF = 0;
00065C  A9E80B     BCLR 0x80B, #7
619:                   }
620:                   if(IFS6bits.ADCAN10IF == 1)
00065E  ABA80C     BTST IFS6, #5
000660  320007     BRA Z, .L177
621:                   {
622:                       //Read the ADC value from the ADCBUF before clearing interrupt
623:                       adcVal = ADCBUF10;
000662  806101     MOV ADCBUF10, W1
624:                       if(NULL != ADC1_ChannelHandler)
000664  809262     MOV ADC1_ChannelHandler, W2
000666  E00002     CP0 W2
000668  320002     BRA Z, .L178
625:                       {
626:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEC_CURRENT, adcVal);
00066A  200010     MOV #0x1, W0
00066C  010002     CALL W2
627:                       }
628:                       IFS6bits.ADCAN10IF = 0;
00066E  A9A80C     BCLR IFS6, #5
629:                   }
630:                   if(IFS6bits.ADCAN11IF == 1)
000670  ABC80C     BTST IFS6, #6
000672  320007     BRA Z, .L179
631:                   {
632:                       //Read the ADC value from the ADCBUF before clearing interrupt
633:                       adcVal = ADCBUF11;
000674  806111     MOV ADCBUF11, W1
634:                       if(NULL != ADC1_ChannelHandler)
000676  809262     MOV ADC1_ChannelHandler, W2
000678  E00002     CP0 W2
00067A  320002     BRA Z, .L180
635:                       {
636:                           (*ADC1_ChannelHandler)(MCAF_ADC_POTENTIOMETER, adcVal);
00067C  200020     MOV #0x2, W0
00067E  010002     CALL W2
637:                       }
638:                       IFS6bits.ADCAN11IF = 0;
000680  A9C80C     BCLR IFS6, #6
639:                   }
640:                   if(IFS6bits.ADCAN12IF == 1)
000682  ABE80C     BTST IFS6, #7
000684  320007     BRA Z, .L181
641:                   {
642:                       //Read the ADC value from the ADCBUF before clearing interrupt
643:                       adcVal = ADCBUF12;
000686  806121     MOV ADCBUF12, W1
644:                       if(NULL != ADC1_ChannelHandler)
000688  809262     MOV ADC1_ChannelHandler, W2
00068A  E00002     CP0 W2
00068C  320002     BRA Z, .L182
645:                       {
646:                           (*ADC1_ChannelHandler)(MCAF_ADC_BRIDGE_TEMPERATURE, adcVal);
00068E  200030     MOV #0x3, W0
000690  010002     CALL W2
647:                       }
648:                       IFS6bits.ADCAN12IF = 0;
000692  A9E80C     BCLR IFS6, #7
649:                   }
650:                   if(IFS6bits.ADCAN15IF == 1)
000694  AB480D     BTST 0x80D, #2
000696  320007     BRA Z, .L183
651:                   {
652:                       //Read the ADC value from the ADCBUF before clearing interrupt
653:                       adcVal = ADCBUF15;
000698  806151     MOV ADCBUF15, W1
654:                       if(NULL != ADC1_ChannelHandler)
00069A  809262     MOV ADC1_ChannelHandler, W2
00069C  E00002     CP0 W2
00069E  320002     BRA Z, .L184
655:                       {
656:                           (*ADC1_ChannelHandler)(MCAF_ADC_DCLINK_VOLTAGE, adcVal);
0006A0  200040     MOV #0x4, W0
0006A2  010002     CALL W2
657:                       }
658:                       IFS6bits.ADCAN15IF = 0;
0006A4  A9480D     BCLR 0x80D, #2
659:                   }
660:                   if(IFS6bits.ADCAN17IF == 1)
0006A6  AB880D     BTST 0x80D, #4
0006A8  320007     BRA Z, .L185
661:                   {
662:                       //Read the ADC value from the ADCBUF before clearing interrupt
663:                       adcVal = ADCBUF17;
0006AA  806171     MOV ADCBUF17, W1
664:                       if(NULL != ADC1_ChannelHandler)
0006AC  809262     MOV ADC1_ChannelHandler, W2
0006AE  E00002     CP0 W2
0006B0  320002     BRA Z, .L186
665:                       {
666:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEA_VOLTAGE, adcVal);
0006B2  200050     MOV #0x5, W0
0006B4  010002     CALL W2
667:                       }
668:                       IFS6bits.ADCAN17IF = 0;
0006B6  A9880D     BCLR 0x80D, #4
669:                   }
670:                   if(IFS7bits.ADCAN22IF == 1)
0006B8  AB280E     BTST IFS7, #1
0006BA  320007     BRA Z, .L187
671:                   {
672:                       //Read the ADC value from the ADCBUF before clearing interrupt
673:                       adcVal = ADCBUF22;
0006BC  8061C1     MOV ADCBUF22, W1
674:                       if(NULL != ADC1_ChannelHandler)
0006BE  809262     MOV ADC1_ChannelHandler, W2
0006C0  E00002     CP0 W2
0006C2  320002     BRA Z, .L188
675:                       {
676:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEC_VOLTAGE, adcVal);
0006C4  200060     MOV #0x6, W0
0006C6  010002     CALL W2
677:                       }
678:                       IFS7bits.ADCAN22IF = 0;
0006C8  A9280E     BCLR IFS7, #1
679:                   }
680:                   if(IFS7bits.ADCAN23IF == 1)
0006CA  AB480E     BTST IFS7, #2
0006CC  320007     BRA Z, .L189
681:                   {
682:                       //Read the ADC value from the ADCBUF before clearing interrupt
683:                       adcVal = ADCBUF23;
0006CE  8061D1     MOV ADCBUF23, W1
684:                       if(NULL != ADC1_ChannelHandler)
0006D0  809262     MOV ADC1_ChannelHandler, W2
0006D2  E00002     CP0 W2
0006D4  320002     BRA Z, .L190
685:                       {
686:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEB_VOLTAGE, adcVal);
0006D6  200070     MOV #0x7, W0
0006D8  010002     CALL W2
687:                       }
688:                       IFS7bits.ADCAN23IF = 0;
0006DA  A9480E     BCLR IFS7, #2
689:                   }
690:                   if(IFS5bits.ADCAN0IF == 1)
0006DC  AB680B     BTST 0x80B, #3
0006DE  320007     BRA Z, .L191
691:                   {
692:                       //Read the ADC value from the ADCBUF before clearing interrupt
693:                       adcVal = ADCBUF0;
0006E0  806061     MOV ADCBUF0, W1
694:                       if(NULL != ADC1_ChannelHandler)
0006E2  809262     MOV ADC1_ChannelHandler, W2
0006E4  E00002     CP0 W2
0006E6  320002     BRA Z, .L192
695:                       {
696:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEA_CURRENT, adcVal);
0006E8  200080     MOV #0x8, W0
0006EA  010002     CALL W2
697:                       }
698:                       IFS5bits.ADCAN0IF = 0;
0006EC  A9680B     BCLR 0x80B, #3
699:                   }
700:                   if(IFS5bits.ADCAN1IF == 1)
0006EE  AB880B     BTST 0x80B, #4
0006F0  320007     BRA Z, .L193
701:                   {
702:                       //Read the ADC value from the ADCBUF before clearing interrupt
703:                       adcVal = ADCBUF1;
0006F2  806071     MOV ADCBUF1, W1
704:                       if(NULL != ADC1_ChannelHandler)
0006F4  809262     MOV ADC1_ChannelHandler, W2
0006F6  E00002     CP0 W2
0006F8  320002     BRA Z, .L194
705:                       {
706:                           (*ADC1_ChannelHandler)(MCAF_ADC_PHASEB_CURRENT, adcVal);
0006FA  200090     MOV #0x9, W0
0006FC  010002     CALL W2
707:                       }
708:                       IFS5bits.ADCAN1IF = 0;
0006FE  A9880B     BCLR 0x80B, #4
709:                   }
710:                       
711:                   // clear the ADC1 interrupt flag
712:                   IFS5bits.ADCIF = 0;
000700  A9480B     BCLR 0x80B, #2
713:               }
000702  F90034     POP DSWPAG
000704  F90032     POP DSRPAG
000706  BE034F     MOV.D [--W15], W6
000708  BE024F     MOV.D [--W15], W4
00070A  BE014F     MOV.D [--W15], W2
00070C  BE004F     MOV.D [--W15], W0
00070E  F90036     POP RCOUNT
000710  064000     RETFIE
000712  F80036     PUSH RCOUNT
714:               
715:               void __attribute__ ((weak)) ADC1_Tasks ( void )
716:               {
717:                   if(IFS5bits.ADCIF == 1)
009BDE  AB480B     BTST 0x80B, #2
009BE0  320005     BRA Z, .L150
718:                   {
719:                       if(NULL != ADC1_CommonHandler)
009BE2  809270     MOV ADC1_CommonHandler, W0
009BE4  E00000     CP0 W0
009BE6  320001     BRA Z, .L152
720:                       {
721:                           (*ADC1_CommonHandler)();
009BE8  010000     CALL W0
722:                       }
723:               
724:                       // clear the ADC1 interrupt flag
725:                       IFS5bits.ADCIF = 0;
009BEA  A9480B     BCLR 0x80B, #2
726:                   }
727:               }
009BEC  060000     RETURN
009BEE  ABA809     BTST 0x809, #5
728:               
729:               void ADC1_ChannelCallbackRegister(void(*callback)(enum ADC_CHANNEL channel, uint16_t adcVal))
730:               {
731:                   if(NULL != callback)
009DD2  E00000     CP0 W0
009DD4  320001     BRA Z, .L153
732:                   {
733:                       ADC1_ChannelHandler = callback;
009DD6  889260     MOV W0, ADC1_ChannelHandler
734:                   }
735:               }
009DD8  060000     RETURN
009DDA  E00000     CP0 W0
736:               
737:               void __attribute__ ((weak)) ADC1_ChannelCallback (enum ADC_CHANNEL channel, uint16_t adcVal)
738:               { 
739:                   (void)channel;
740:                   (void)adcVal;
741:               } 
009FB6  060000     RETURN
009FB8  060000     RETURN
742:               
743:               
744:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN4Interrupt ( void )
745:               {
000712  F80036     PUSH RCOUNT
000714  BE9F80     MOV.D W0, [W15++]
000716  BE9F82     MOV.D W2, [W15++]
000718  BE9F84     MOV.D W4, [W15++]
00071A  BE9F86     MOV.D W6, [W15++]
00071C  F80032     PUSH DSRPAG
00071E  F80034     PUSH DSWPAG
000720  200010     MOV #0x1, W0
000722  8801A0     MOV W0, DSWPAG
000724  202000     MOV #0x200, W0
000726  FED000     MOVPAG W0, DSRPAG
746:                   uint16_t valMCAF_ADC_DCLINK_CURRENT;
747:                   //Read the ADC value from the ADCBUF
748:                   valMCAF_ADC_DCLINK_CURRENT = ADCBUF4;
000728  8060A1     MOV ADCBUF4, W1
749:               
750:                   if(NULL != ADC1_ChannelHandler)
00072A  809262     MOV ADC1_ChannelHandler, W2
00072C  E00002     CP0 W2
00072E  320002     BRA Z, .L196
751:                   {
752:                       (*ADC1_ChannelHandler)(MCAF_ADC_DCLINK_CURRENT, valMCAF_ADC_DCLINK_CURRENT);
000730  EB0000     CLR W0
000732  010002     CALL W2
753:                   }
754:               
755:                   //clear the MCAF_ADC_DCLINK_CURRENT interrupt flag
756:                   IFS5bits.ADCAN4IF = 0;
000734  A9E80B     BCLR 0x80B, #7
757:               }
000736  F90034     POP DSWPAG
000738  F90032     POP DSRPAG
00073A  BE034F     MOV.D [--W15], W6
00073C  BE024F     MOV.D [--W15], W4
00073E  BE014F     MOV.D [--W15], W2
000740  BE004F     MOV.D [--W15], W0
000742  F90036     POP RCOUNT
000744  064000     RETFIE
758:               
759:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN10Interrupt ( void )
760:               {
000746  F80036     PUSH RCOUNT
000748  BE9F80     MOV.D W0, [W15++]
00074A  BE9F82     MOV.D W2, [W15++]
00074C  BE9F84     MOV.D W4, [W15++]
00074E  BE9F86     MOV.D W6, [W15++]
000750  F80032     PUSH DSRPAG
000752  F80034     PUSH DSWPAG
000754  200010     MOV #0x1, W0
000756  8801A0     MOV W0, DSWPAG
000758  202000     MOV #0x200, W0
00075A  FED000     MOVPAG W0, DSRPAG
761:                   uint16_t valMCAF_ADC_PHASEC_CURRENT;
762:                   //Read the ADC value from the ADCBUF
763:                   valMCAF_ADC_PHASEC_CURRENT = ADCBUF10;
00075C  806101     MOV ADCBUF10, W1
764:               
765:                   if(NULL != ADC1_ChannelHandler)
00075E  809262     MOV ADC1_ChannelHandler, W2
000760  E00002     CP0 W2
000762  320002     BRA Z, .L198
766:                   {
767:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEC_CURRENT, valMCAF_ADC_PHASEC_CURRENT);
000764  200010     MOV #0x1, W0
000766  010002     CALL W2
768:                   }
769:               
770:                   //clear the MCAF_ADC_PHASEC_CURRENT interrupt flag
771:                   IFS6bits.ADCAN10IF = 0;
000768  A9A80C     BCLR IFS6, #5
772:               }
00076A  F90034     POP DSWPAG
00076C  F90032     POP DSRPAG
00076E  BE034F     MOV.D [--W15], W6
000770  BE024F     MOV.D [--W15], W4
000772  BE014F     MOV.D [--W15], W2
000774  BE004F     MOV.D [--W15], W0
000776  F90036     POP RCOUNT
000778  064000     RETFIE
773:               
774:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN11Interrupt ( void )
775:               {
00077A  F80036     PUSH RCOUNT
00077C  BE9F80     MOV.D W0, [W15++]
00077E  BE9F82     MOV.D W2, [W15++]
000780  BE9F84     MOV.D W4, [W15++]
000782  BE9F86     MOV.D W6, [W15++]
000784  F80032     PUSH DSRPAG
000786  F80034     PUSH DSWPAG
000788  200010     MOV #0x1, W0
00078A  8801A0     MOV W0, DSWPAG
00078C  202000     MOV #0x200, W0
00078E  FED000     MOVPAG W0, DSRPAG
776:                   uint16_t valMCAF_ADC_POTENTIOMETER;
777:                   //Read the ADC value from the ADCBUF
778:                   valMCAF_ADC_POTENTIOMETER = ADCBUF11;
000790  806111     MOV ADCBUF11, W1
779:               
780:                   if(NULL != ADC1_ChannelHandler)
000792  809262     MOV ADC1_ChannelHandler, W2
000794  E00002     CP0 W2
000796  320002     BRA Z, .L200
781:                   {
782:                       (*ADC1_ChannelHandler)(MCAF_ADC_POTENTIOMETER, valMCAF_ADC_POTENTIOMETER);
000798  200020     MOV #0x2, W0
00079A  010002     CALL W2
783:                   }
784:               
785:                   //clear the MCAF_ADC_POTENTIOMETER interrupt flag
786:                   IFS6bits.ADCAN11IF = 0;
00079C  A9C80C     BCLR IFS6, #6
787:               }
00079E  F90034     POP DSWPAG
0007A0  F90032     POP DSRPAG
0007A2  BE034F     MOV.D [--W15], W6
0007A4  BE024F     MOV.D [--W15], W4
0007A6  BE014F     MOV.D [--W15], W2
0007A8  BE004F     MOV.D [--W15], W0
0007AA  F90036     POP RCOUNT
0007AC  064000     RETFIE
788:               
789:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN12Interrupt ( void )
790:               {
0007AE  F80036     PUSH RCOUNT
0007B0  BE9F80     MOV.D W0, [W15++]
0007B2  BE9F82     MOV.D W2, [W15++]
0007B4  BE9F84     MOV.D W4, [W15++]
0007B6  BE9F86     MOV.D W6, [W15++]
0007B8  F80032     PUSH DSRPAG
0007BA  F80034     PUSH DSWPAG
0007BC  200010     MOV #0x1, W0
0007BE  8801A0     MOV W0, DSWPAG
0007C0  202000     MOV #0x200, W0
0007C2  FED000     MOVPAG W0, DSRPAG
791:                   uint16_t valMCAF_ADC_BRIDGE_TEMPERATURE;
792:                   //Read the ADC value from the ADCBUF
793:                   valMCAF_ADC_BRIDGE_TEMPERATURE = ADCBUF12;
0007C4  806121     MOV ADCBUF12, W1
794:               
795:                   if(NULL != ADC1_ChannelHandler)
0007C6  809262     MOV ADC1_ChannelHandler, W2
0007C8  E00002     CP0 W2
0007CA  320002     BRA Z, .L202
796:                   {
797:                       (*ADC1_ChannelHandler)(MCAF_ADC_BRIDGE_TEMPERATURE, valMCAF_ADC_BRIDGE_TEMPERATURE);
0007CC  200030     MOV #0x3, W0
0007CE  010002     CALL W2
798:                   }
799:               
800:                   //clear the MCAF_ADC_BRIDGE_TEMPERATURE interrupt flag
801:                   IFS6bits.ADCAN12IF = 0;
0007D0  A9E80C     BCLR IFS6, #7
802:               }
0007D2  F90034     POP DSWPAG
0007D4  F90032     POP DSRPAG
0007D6  BE034F     MOV.D [--W15], W6
0007D8  BE024F     MOV.D [--W15], W4
0007DA  BE014F     MOV.D [--W15], W2
0007DC  BE004F     MOV.D [--W15], W0
0007DE  F90036     POP RCOUNT
0007E0  064000     RETFIE
803:               
804:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN15Interrupt ( void )
805:               {
0007E2  F80036     PUSH RCOUNT
0007E4  BE9F80     MOV.D W0, [W15++]
0007E6  BE9F82     MOV.D W2, [W15++]
0007E8  BE9F84     MOV.D W4, [W15++]
0007EA  BE9F86     MOV.D W6, [W15++]
0007EC  F80032     PUSH DSRPAG
0007EE  F80034     PUSH DSWPAG
0007F0  200010     MOV #0x1, W0
0007F2  8801A0     MOV W0, DSWPAG
0007F4  202000     MOV #0x200, W0
0007F6  FED000     MOVPAG W0, DSRPAG
806:                   uint16_t valMCAF_ADC_DCLINK_VOLTAGE;
807:                   //Read the ADC value from the ADCBUF
808:                   valMCAF_ADC_DCLINK_VOLTAGE = ADCBUF15;
0007F8  806151     MOV ADCBUF15, W1
809:               
810:                   if(NULL != ADC1_ChannelHandler)
0007FA  809262     MOV ADC1_ChannelHandler, W2
0007FC  E00002     CP0 W2
0007FE  320002     BRA Z, .L204
811:                   {
812:                       (*ADC1_ChannelHandler)(MCAF_ADC_DCLINK_VOLTAGE, valMCAF_ADC_DCLINK_VOLTAGE);
000800  200040     MOV #0x4, W0
000802  010002     CALL W2
813:                   }
814:               
815:                   //clear the MCAF_ADC_DCLINK_VOLTAGE interrupt flag
816:                   IFS6bits.ADCAN15IF = 0;
000804  A9480D     BCLR 0x80D, #2
817:               }
000806  F90034     POP DSWPAG
000808  F90032     POP DSRPAG
00080A  BE034F     MOV.D [--W15], W6
00080C  BE024F     MOV.D [--W15], W4
00080E  BE014F     MOV.D [--W15], W2
000810  BE004F     MOV.D [--W15], W0
000812  F90036     POP RCOUNT
000814  064000     RETFIE
818:               
819:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN17Interrupt ( void )
820:               {
000816  F80036     PUSH RCOUNT
000818  BE9F80     MOV.D W0, [W15++]
00081A  BE9F82     MOV.D W2, [W15++]
00081C  BE9F84     MOV.D W4, [W15++]
00081E  BE9F86     MOV.D W6, [W15++]
000820  F80032     PUSH DSRPAG
000822  F80034     PUSH DSWPAG
000824  200010     MOV #0x1, W0
000826  8801A0     MOV W0, DSWPAG
000828  202000     MOV #0x200, W0
00082A  FED000     MOVPAG W0, DSRPAG
821:                   uint16_t valMCAF_ADC_PHASEA_VOLTAGE;
822:                   //Read the ADC value from the ADCBUF
823:                   valMCAF_ADC_PHASEA_VOLTAGE = ADCBUF17;
00082C  806171     MOV ADCBUF17, W1
824:               
825:                   if(NULL != ADC1_ChannelHandler)
00082E  809262     MOV ADC1_ChannelHandler, W2
000830  E00002     CP0 W2
000832  320002     BRA Z, .L206
826:                   {
827:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEA_VOLTAGE, valMCAF_ADC_PHASEA_VOLTAGE);
000834  200050     MOV #0x5, W0
000836  010002     CALL W2
828:                   }
829:               
830:                   //clear the MCAF_ADC_PHASEA_VOLTAGE interrupt flag
831:                   IFS6bits.ADCAN17IF = 0;
000838  A9880D     BCLR 0x80D, #4
832:               }
00083A  F90034     POP DSWPAG
00083C  F90032     POP DSRPAG
00083E  BE034F     MOV.D [--W15], W6
000840  BE024F     MOV.D [--W15], W4
000842  BE014F     MOV.D [--W15], W2
000844  BE004F     MOV.D [--W15], W0
000846  F90036     POP RCOUNT
000848  064000     RETFIE
833:               
834:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN22Interrupt ( void )
835:               {
00084A  F80036     PUSH RCOUNT
00084C  BE9F80     MOV.D W0, [W15++]
00084E  BE9F82     MOV.D W2, [W15++]
000850  BE9F84     MOV.D W4, [W15++]
000852  BE9F86     MOV.D W6, [W15++]
000854  F80032     PUSH DSRPAG
000856  F80034     PUSH DSWPAG
000858  200010     MOV #0x1, W0
00085A  8801A0     MOV W0, DSWPAG
00085C  202000     MOV #0x200, W0
00085E  FED000     MOVPAG W0, DSRPAG
836:                   uint16_t valMCAF_ADC_PHASEC_VOLTAGE;
837:                   //Read the ADC value from the ADCBUF
838:                   valMCAF_ADC_PHASEC_VOLTAGE = ADCBUF22;
000860  8061C1     MOV ADCBUF22, W1
839:               
840:                   if(NULL != ADC1_ChannelHandler)
000862  809262     MOV ADC1_ChannelHandler, W2
000864  E00002     CP0 W2
000866  320002     BRA Z, .L208
841:                   {
842:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEC_VOLTAGE, valMCAF_ADC_PHASEC_VOLTAGE);
000868  200060     MOV #0x6, W0
00086A  010002     CALL W2
843:                   }
844:               
845:                   //clear the MCAF_ADC_PHASEC_VOLTAGE interrupt flag
846:                   IFS7bits.ADCAN22IF = 0;
00086C  A9280E     BCLR IFS7, #1
847:               }
00086E  F90034     POP DSWPAG
000870  F90032     POP DSRPAG
000872  BE034F     MOV.D [--W15], W6
000874  BE024F     MOV.D [--W15], W4
000876  BE014F     MOV.D [--W15], W2
000878  BE004F     MOV.D [--W15], W0
00087A  F90036     POP RCOUNT
00087C  064000     RETFIE
848:               
849:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN23Interrupt ( void )
850:               {
00087E  F80036     PUSH RCOUNT
000880  BE9F80     MOV.D W0, [W15++]
000882  BE9F82     MOV.D W2, [W15++]
000884  BE9F84     MOV.D W4, [W15++]
000886  BE9F86     MOV.D W6, [W15++]
000888  F80032     PUSH DSRPAG
00088A  F80034     PUSH DSWPAG
00088C  200010     MOV #0x1, W0
00088E  8801A0     MOV W0, DSWPAG
000890  202000     MOV #0x200, W0
000892  FED000     MOVPAG W0, DSRPAG
851:                   uint16_t valMCAF_ADC_PHASEB_VOLTAGE;
852:                   //Read the ADC value from the ADCBUF
853:                   valMCAF_ADC_PHASEB_VOLTAGE = ADCBUF23;
000894  8061D1     MOV ADCBUF23, W1
854:               
855:                   if(NULL != ADC1_ChannelHandler)
000896  809262     MOV ADC1_ChannelHandler, W2
000898  E00002     CP0 W2
00089A  320002     BRA Z, .L210
856:                   {
857:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEB_VOLTAGE, valMCAF_ADC_PHASEB_VOLTAGE);
00089C  200070     MOV #0x7, W0
00089E  010002     CALL W2
858:                   }
859:               
860:                   //clear the MCAF_ADC_PHASEB_VOLTAGE interrupt flag
861:                   IFS7bits.ADCAN23IF = 0;
0008A0  A9480E     BCLR IFS7, #2
862:               }
0008A2  F90034     POP DSWPAG
0008A4  F90032     POP DSRPAG
0008A6  BE034F     MOV.D [--W15], W6
0008A8  BE024F     MOV.D [--W15], W4
0008AA  BE014F     MOV.D [--W15], W2
0008AC  BE004F     MOV.D [--W15], W0
0008AE  F90036     POP RCOUNT
0008B0  064000     RETFIE
863:               
864:               
865:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN0Interrupt ( void )
866:               {
0008B2  F80036     PUSH RCOUNT
0008B4  BE9F80     MOV.D W0, [W15++]
0008B6  BE9F82     MOV.D W2, [W15++]
0008B8  BE9F84     MOV.D W4, [W15++]
0008BA  BE9F86     MOV.D W6, [W15++]
0008BC  F80032     PUSH DSRPAG
0008BE  F80034     PUSH DSWPAG
0008C0  200010     MOV #0x1, W0
0008C2  8801A0     MOV W0, DSWPAG
0008C4  202000     MOV #0x200, W0
0008C6  FED000     MOVPAG W0, DSRPAG
867:                   uint16_t valMCAF_ADC_PHASEA_CURRENT;
868:                   //Read the ADC value from the ADCBUF
869:                   valMCAF_ADC_PHASEA_CURRENT = ADCBUF0;
0008C8  806061     MOV ADCBUF0, W1
870:               
871:                   if(NULL != ADC1_ChannelHandler)
0008CA  809262     MOV ADC1_ChannelHandler, W2
0008CC  E00002     CP0 W2
0008CE  320002     BRA Z, .L212
872:                   {
873:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEA_CURRENT, valMCAF_ADC_PHASEA_CURRENT);
0008D0  200080     MOV #0x8, W0
0008D2  010002     CALL W2
874:                   }
875:               
876:                   //clear the MCAF_ADC_PHASEA_CURRENT interrupt flag
877:                   IFS5bits.ADCAN0IF = 0;
0008D4  A9680B     BCLR 0x80B, #3
878:               }
0008D6  F90034     POP DSWPAG
0008D8  F90032     POP DSRPAG
0008DA  BE034F     MOV.D [--W15], W6
0008DC  BE024F     MOV.D [--W15], W4
0008DE  BE014F     MOV.D [--W15], W2
0008E0  BE004F     MOV.D [--W15], W0
0008E2  F90036     POP RCOUNT
0008E4  064000     RETFIE
879:               
880:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN1Interrupt ( void )
881:               {
0008E6  F80036     PUSH RCOUNT
0008E8  BE9F80     MOV.D W0, [W15++]
0008EA  BE9F82     MOV.D W2, [W15++]
0008EC  BE9F84     MOV.D W4, [W15++]
0008EE  BE9F86     MOV.D W6, [W15++]
0008F0  F80032     PUSH DSRPAG
0008F2  F80034     PUSH DSWPAG
0008F4  200010     MOV #0x1, W0
0008F6  8801A0     MOV W0, DSWPAG
0008F8  202000     MOV #0x200, W0
0008FA  FED000     MOVPAG W0, DSRPAG
882:                   uint16_t valMCAF_ADC_PHASEB_CURRENT;
883:                   //Read the ADC value from the ADCBUF
884:                   valMCAF_ADC_PHASEB_CURRENT = ADCBUF1;
0008FC  806071     MOV ADCBUF1, W1
885:               
886:                   if(NULL != ADC1_ChannelHandler)
0008FE  809262     MOV ADC1_ChannelHandler, W2
000900  E00002     CP0 W2
000902  320002     BRA Z, .L214
887:                   {
888:                       (*ADC1_ChannelHandler)(MCAF_ADC_PHASEB_CURRENT, valMCAF_ADC_PHASEB_CURRENT);
000904  200090     MOV #0x9, W0
000906  010002     CALL W2
889:                   }
890:               
891:                   //clear the MCAF_ADC_PHASEB_CURRENT interrupt flag
892:                   IFS5bits.ADCAN1IF = 0;
000908  A9880B     BCLR 0x80B, #4
893:               }
00090A  F90034     POP DSWPAG
00090C  F90032     POP DSRPAG
00090E  BE034F     MOV.D [--W15], W6
000910  BE024F     MOV.D [--W15], W4
000912  BE014F     MOV.D [--W15], W2
000914  BE004F     MOV.D [--W15], W0
000916  F90036     POP RCOUNT
000918  064000     RETFIE
00091A  F80036     PUSH RCOUNT
894:               
895:               
896:               void __attribute__ ((weak)) ADC1_ChannelTasks (enum ADC_CHANNEL channel)
897:               {
898:                   uint16_t adcVal;
899:                   
900:                   switch(channel)
007554  EB0080     CLR W1
007556  500FE9     SUB W0, #0x9, [W15]
007558  588FE0     SUBB W1, #0x0, [W15]
00755A  3E0064     BRA GTU, .L156
00755C  010600     BRA W0
00755E  370009     BRA .SE168, .L158
007560  370011     BRA .L159
007562  370019     BRA .L160
007564  370021     BRA .L161
007566  370029     BRA .L162
007568  370031     BRA .L163
00756A  370039     BRA .L164
00756C  370041     BRA .L165
00756E  370049     BRA .L166
007570  370051     BRA .L167
901:                   {   
902:                       case MCAF_ADC_DCLINK_CURRENT:
903:                           if((bool)ADSTATLbits.AN4RDY == 1)
007572  AB8B30     BTST ADSTATL, #4
007574  320057     BRA Z, .L156
904:                           {
905:                               //Read the ADC value from the ADCBUF
906:                               adcVal = ADCBUF4;
007576  8060A1     MOV ADCBUF4, W1
907:               
908:                               if(NULL != ADC1_ChannelHandler)
007578  809262     MOV ADC1_ChannelHandler, W2
00757A  E00002     CP0 W2
00757C  320053     BRA Z, .L156
909:                               {
910:                                   (*ADC1_ChannelHandler)(channel, adcVal);
00757E  EB0000     CLR W0
007580  010002     CALL W2
007582  370050     BRA .L156
911:                               }
912:                           }
913:                           break;
914:                       case MCAF_ADC_PHASEC_CURRENT:
915:                           if((bool)ADSTATLbits.AN10RDY == 1)
007584  AB4B31     BTST 0xB31, #2
007586  32004E     BRA Z, .L156
916:                           {
917:                               //Read the ADC value from the ADCBUF
918:                               adcVal = ADCBUF10;
007588  806101     MOV ADCBUF10, W1
919:               
920:                               if(NULL != ADC1_ChannelHandler)
00758A  809262     MOV ADC1_ChannelHandler, W2
00758C  E00002     CP0 W2
00758E  32004A     BRA Z, .L156
921:                               {
922:                                   (*ADC1_ChannelHandler)(channel, adcVal);
007590  200010     MOV #0x1, W0
007592  010002     CALL W2
007594  370047     BRA .L156
923:                               }
924:                           }
925:                           break;
926:                       case MCAF_ADC_POTENTIOMETER:
927:                           if((bool)ADSTATLbits.AN11RDY == 1)
007596  AB6B31     BTST 0xB31, #3
007598  320045     BRA Z, .L156
928:                           {
929:                               //Read the ADC value from the ADCBUF
930:                               adcVal = ADCBUF11;
00759A  806111     MOV ADCBUF11, W1
931:               
932:                               if(NULL != ADC1_ChannelHandler)
00759C  809262     MOV ADC1_ChannelHandler, W2
00759E  E00002     CP0 W2
0075A0  320041     BRA Z, .L156
933:                               {
934:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075A2  200020     MOV #0x2, W0
0075A4  010002     CALL W2
0075A6  37003E     BRA .L156
935:                               }
936:                           }
937:                           break;
938:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
939:                           if((bool)ADSTATLbits.AN12RDY == 1)
0075A8  AB8B31     BTST 0xB31, #4
0075AA  32003C     BRA Z, .L156
940:                           {
941:                               //Read the ADC value from the ADCBUF
942:                               adcVal = ADCBUF12;
0075AC  806121     MOV ADCBUF12, W1
943:               
944:                               if(NULL != ADC1_ChannelHandler)
0075AE  809262     MOV ADC1_ChannelHandler, W2
0075B0  E00002     CP0 W2
0075B2  320038     BRA Z, .L156
945:                               {
946:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075B4  200030     MOV #0x3, W0
0075B6  010002     CALL W2
0075B8  370035     BRA .L156
947:                               }
948:                           }
949:                           break;
950:                       case MCAF_ADC_DCLINK_VOLTAGE:
951:                           if((bool)ADSTATLbits.AN15RDY == 1)
0075BA  E20B30     CP0 ADSTATL
0075BC  3D0033     BRA GE, .L156
952:                           {
953:                               //Read the ADC value from the ADCBUF
954:                               adcVal = ADCBUF15;
0075BE  806151     MOV ADCBUF15, W1
955:               
956:                               if(NULL != ADC1_ChannelHandler)
0075C0  809262     MOV ADC1_ChannelHandler, W2
0075C2  E00002     CP0 W2
0075C4  32002F     BRA Z, .L156
957:                               {
958:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075C6  200040     MOV #0x4, W0
0075C8  010002     CALL W2
0075CA  37002C     BRA .L156
959:                               }
960:                           }
961:                           break;
962:                       case MCAF_ADC_PHASEA_VOLTAGE:
963:                           if((bool)ADSTATHbits.AN17RDY == 1)
0075CC  AB2B32     BTST ADSTATH, #1
0075CE  32002A     BRA Z, .L156
964:                           {
965:                               //Read the ADC value from the ADCBUF
966:                               adcVal = ADCBUF17;
0075D0  806171     MOV ADCBUF17, W1
967:               
968:                               if(NULL != ADC1_ChannelHandler)
0075D2  809262     MOV ADC1_ChannelHandler, W2
0075D4  E00002     CP0 W2
0075D6  320026     BRA Z, .L156
969:                               {
970:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075D8  200050     MOV #0x5, W0
0075DA  010002     CALL W2
0075DC  370023     BRA .L156
971:                               }
972:                           }
973:                           break;
974:                       case MCAF_ADC_PHASEC_VOLTAGE:
975:                           if((bool)ADSTATHbits.AN22RDY == 1)
0075DE  ABCB32     BTST ADSTATH, #6
0075E0  320021     BRA Z, .L156
976:                           {
977:                               //Read the ADC value from the ADCBUF
978:                               adcVal = ADCBUF22;
0075E2  8061C1     MOV ADCBUF22, W1
979:               
980:                               if(NULL != ADC1_ChannelHandler)
0075E4  809262     MOV ADC1_ChannelHandler, W2
0075E6  E00002     CP0 W2
0075E8  32001D     BRA Z, .L156
981:                               {
982:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075EA  200060     MOV #0x6, W0
0075EC  010002     CALL W2
0075EE  37001A     BRA .L156
983:                               }
984:                           }
985:                           break;
986:                       case MCAF_ADC_PHASEB_VOLTAGE:
987:                           if((bool)ADSTATHbits.AN23RDY == 1)
0075F0  ABEB32     BTST ADSTATH, #7
0075F2  320018     BRA Z, .L156
988:                           {
989:                               //Read the ADC value from the ADCBUF
990:                               adcVal = ADCBUF23;
0075F4  8061D1     MOV ADCBUF23, W1
991:               
992:                               if(NULL != ADC1_ChannelHandler)
0075F6  809262     MOV ADC1_ChannelHandler, W2
0075F8  E00002     CP0 W2
0075FA  320014     BRA Z, .L156
993:                               {
994:                                   (*ADC1_ChannelHandler)(channel, adcVal);
0075FC  200070     MOV #0x7, W0
0075FE  010002     CALL W2
007600  370011     BRA .L156
995:                               }
996:                           }
997:                           break;
998:                       case MCAF_ADC_PHASEA_CURRENT:
999:                           if((bool)ADSTATLbits.AN0RDY == 1)
007602  AB0B30     BTST ADSTATL, #0
007604  32000F     BRA Z, .L156
1000:                          {
1001:                              //Read the ADC value from the ADCBUF
1002:                              adcVal = ADCBUF0;
007606  806061     MOV ADCBUF0, W1
1003:              
1004:                              if(NULL != ADC1_ChannelHandler)
007608  809262     MOV ADC1_ChannelHandler, W2
00760A  E00002     CP0 W2
00760C  32000B     BRA Z, .L156
1005:                              {
1006:                                  (*ADC1_ChannelHandler)(channel, adcVal);
00760E  200080     MOV #0x8, W0
007610  010002     CALL W2
007612  370008     BRA .L156
1007:                              }
1008:                          }
1009:                          break;
1010:                      case MCAF_ADC_PHASEB_CURRENT:
1011:                          if((bool)ADSTATLbits.AN1RDY == 1)
007614  AB2B30     BTST ADSTATL, #1
007616  320006     BRA Z, .L156
1012:                          {
1013:                              //Read the ADC value from the ADCBUF
1014:                              adcVal = ADCBUF1;
007618  806071     MOV ADCBUF1, W1
1015:              
1016:                              if(NULL != ADC1_ChannelHandler)
00761A  809262     MOV ADC1_ChannelHandler, W2
00761C  E00002     CP0 W2
00761E  320002     BRA Z, .L156
1017:                              {
1018:                                  (*ADC1_ChannelHandler)(channel, adcVal);
007620  200090     MOV #0x9, W0
007622  010002     CALL W2
1019:                              }
1020:                          }
1021:                          break;
1022:                      default:
1023:                          break;
1024:                  }            
1025:              }
007624  060000     RETURN
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
007626  A9EB01     BCLR 0xB01, #7
1026:              
1027:              void ADC1_ComparatorCallbackRegister(void(*callback)(enum ADC_CMP comparator))
1028:              {
1029:                  if(NULL != callback)
009DDA  E00000     CP0 W0
009DDC  320001     BRA Z, .L169
1030:                  {
1031:                      ADC1_ComparatorHandler = callback;
009DDE  889250     MOV W0, ADC1_ComparatorHandler
1032:                  }
1033:              }
009DE0  060000     RETURN
009DE2  E00000     CP0 W0
009DE4  320001     BRA Z, .L8
1034:              
1035:              void __attribute__ ((weak)) ADC1_ComparatorCallback (enum ADC_CMP comparator)
1036:              { 
1037:                  (void)comparator;
1038:              } 
009FB8  060000     RETURN
009FBA  060000     RETURN
1039:              
1040:              
1041:              
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/mcc_generated_files/adc/adc1.h  
1:                 /**
2:                  * ADC1 Generated Driver Header File
3:                  * 
4:                  * @file      adc1.h
5:                  *            
6:                  * @ingroup   adcdriver
7:                  *            
8:                  * @brief     This is the generated driver header file for the ADC1 driver
9:                  *            
10:                 * @version   Firmware Driver Version 1.4.3
11:                 *
12:                 * @version   PLIB Version 2.3.0
13:                 *            
14:                 * @skipline  Device : dsPIC33CK256MP508
15:                */
16:                
17:                /*
18:                © [2023] Microchip Technology Inc. and its subsidiaries.
19:                
20:                    Subject to your compliance with these terms, you may use Microchip 
21:                    software and any derivatives exclusively with Microchip products. 
22:                    You are responsible for complying with 3rd party license terms  
23:                    applicable to your use of 3rd party software (including open source  
24:                    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
25:                    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
26:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
27:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
28:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
29:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
30:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
31:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
32:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
33:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
34:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
35:                    THIS SOFTWARE.
36:                */
37:                
38:                #ifndef ADC1_H
39:                #define ADC1_H
40:                
41:                // Section: Included Files
42:                
43:                #include <xc.h>
44:                #include <stdbool.h>
45:                #include <stdint.h>
46:                #include "adc_types.h"
47:                #include "adc_interface.h"
48:                #ifdef __cplusplus  //Provide C++ Compatibility
49:                
50:                    extern "C" {
51:                
52:                #endif
53:                
54:                // Section: Data Types
55:                
56:                /** 
57:                  @ingroup  adcdriver
58:                  @brief    Defines the scan option selection done for the shared channels
59:                */
60:                #define ADC1_SCAN_MODE_SELECTED true
61:                
62:                /** 
63:                  @ingroup  adcdriver
64:                  @brief    Defines the ADC Resolution
65:                */
66:                #define ADC1_RESOLUTION 12
67:                
68:                // Section: Data Type Definitions
69:                
70:                /**
71:                 * @ingroup  adcdriver
72:                 * @brief    Structure object of type ADC_INTERFACE with the custom name
73:                 *           given by the user in the Melody Driver User interface. The default name 
74:                 *           e.g. ADC1 can be changed by the user in the ADC user interface. 
75:                 *           This allows defining a structure with application specific name using 
76:                 *           the 'Custom Name' field. Application specific name allows the API Portability.
77:                */
78:                extern const struct ADC_INTERFACE MCC_ADC;
79:                
80:                /**
81:                 * @ingroup  adcdriver
82:                 * @brief    This macro defines the Custom Name for \ref ADC1_Initialize API
83:                 */
84:                #define MCC_ADC_Initialize ADC1_Initialize
85:                /**
86:                 * @ingroup  adcdriver
87:                 * @brief    This macro defines the Custom Name for \ref ADC1_Deinitialize API
88:                 */
89:                #define MCC_ADC_Deinitialize ADC1_Deinitialize
90:                /**
91:                 * @ingroup  adcdriver
92:                 * @brief    This macro defines the Custom Name for \ref ADC1_Enable API
93:                 */
94:                #define MCC_ADC_Enable ADC1_Enable
95:                /**
96:                 * @ingroup  adcdriver
97:                 * @brief    This macro defines the Custom Name for \ref ADC1_Disable API
98:                 */
99:                #define MCC_ADC_Disable ADC1_Disable
100:               /**
101:                * @ingroup  adcdriver
102:                * @brief    This macro defines the Custom Name for \ref ADC1_SoftwareTriggerEnable API
103:                */
104:               #define MCC_ADC_SoftwareTriggerEnable ADC1_SoftwareTriggerEnable
105:               /**
106:                * @ingroup  adcdriver
107:                * @brief    This macro defines the Custom Name for \ref ADC1_SoftwareTriggerDisable API
108:                */
109:               #define MCC_ADC_SoftwareTriggerDisable ADC1_SoftwareTriggerDisable
110:               /**
111:                * @ingroup  adcdriver
112:                * @brief    This macro defines the Custom Name for \ref ADC1_ChannelSelect API
113:                */
114:               #define MCC_ADC_ChannelSelect ADC1_ChannelSelect
115:               /**
116:                * @ingroup  adcdriver
117:                * @brief    This macro defines the Custom Name for \ref ADC1_ConversionResultGet API
118:                */
119:               #define MCC_ADC_ConversionResultGet ADC1_ConversionResultGet
120:               /**
121:                * @ingroup  adcdriver
122:                * @brief    This macro defines the Custom Name for \ref ADC1_IsConversionComplete API
123:                */
124:               #define MCC_ADC_IsConversionComplete ADC1_IsConversionComplete
125:               /**
126:                * @ingroup  adcdriver
127:                * @brief    This macro defines the Custom Name for \ref ADC1_ResolutionSet API
128:                */
129:               #define MCC_ADC_ResolutionSet ADC1_ResolutionSet
130:               /**
131:                * @ingroup  adcdriver
132:                * @brief    This macro defines the Custom Name for \ref ADC1_InterruptEnable API
133:                */
134:               #define MCC_ADC_InterruptEnable ADC1_InterruptEnable
135:               /**
136:                * @ingroup  adcdriver
137:                * @brief    This macro defines the Custom Name for \ref ADC1_InterruptDisable API
138:                */
139:               #define MCC_ADC_InterruptDisable ADC1_InterruptDisable
140:               /**
141:                * @ingroup  adcdriver
142:                * @brief    This macro defines the Custom Name for \ref ADC1_InterruptFlagClear API
143:                */
144:               #define MCC_ADC_InterruptFlagClear ADC1_InterruptFlagClear
145:               /**
146:                * @ingroup  adcdriver
147:                * @brief    This macro defines the Custom Name for \ref ADC1_InterruptPrioritySet API
148:                */
149:               #define MCC_ADC_InterruptPrioritySet ADC1_InterruptPrioritySet
150:               /**
151:                * @ingroup  adcdriver
152:                * @brief    This macro defines the Custom Name for \ref ADC1_CommonCallbackRegister API
153:                */
154:               #define MCC_ADC_CommonCallbackRegister ADC1_CommonCallbackRegister
155:               /**
156:                * @ingroup  adcdriver
157:                * @brief    This macro defines the Custom Name for \ref ADC1_Tasks API
158:                */
159:               #define MCC_ADC_Tasks ADC1_Tasks
160:               /**
161:                * @ingroup  adcdriver
162:                * @brief    This macro defines the Custom Name for \ref ADC1_IndividualChannelInterruptEnable API
163:                */
164:               #define MCC_ADC_IndividualChannelInterruptEnable ADC1_IndividualChannelInterruptEnable
165:               /**
166:                * @ingroup  adcdriver
167:                * @brief    This macro defines the Custom Name for \ref ADC1_IndividualChannelInterruptDisable API
168:                */
169:               #define MCC_ADC_IndividualChannelInterruptDisable ADC1_IndividualChannelInterruptDisable
170:               /**
171:                * @ingroup  adcdriver
172:                * @brief    This macro defines the Custom Name for \ref ADC1_IndividualChannelInterruptFlagClear API
173:                */
174:               #define MCC_ADC_IndividualChannelInterruptFlagClear ADC1_IndividualChannelInterruptFlagClear
175:               /**
176:                * @ingroup  adcdriver
177:                * @brief    This macro defines the Custom Name for \ref ADC1_IndividualChannelInterruptPrioritySet API
178:                */
179:               #define MCC_ADC_IndividualChannelInterruptPrioritySet ADC1_IndividualChannelInterruptPrioritySet
180:               /**
181:                * @ingroup  adcdriver
182:                * @brief    This macro defines the Custom Name for \ref ADC1_ChannelCallbackRegister API
183:                */
184:               #define MCC_ADC_ChannelCallbackRegister ADC1_ChannelCallbackRegister
185:               /**
186:                * @ingroup  adcdriver
187:                * @brief    This macro defines the Custom Name for \ref ADC1_ComparatorCallbackRegister API
188:                */
189:               #define MCC_ADC_ComparatorCallbackRegister ADC1_ComparatorCallbackRegister
190:               /**
191:                * @ingroup  adcdriver
192:                * @brief    This macro defines the Custom Name for \ref ADC1_ChannelTasks API
193:                */
194:               #define MCC_ADC_ChannelTasks ADC1_ChannelTasks
195:               /**
196:                * @ingroup  adcdriver
197:                * @brief    This macro defines the Custom Name for \ref ADC1_CorePowerEnable API
198:                */
199:               #define MCC_ADC_CorePowerEnable ADC1_CorePowerEnable
200:               /**
201:                * @ingroup  adcdriver
202:                * @brief    This macro defines the Custom Name for \ref ADC1_SharedCorePowerEnable API
203:                */
204:               #define MCC_ADC_SharedCorePowerEnable ADC1_SharedCorePowerEnable
205:               /**
206:                * @ingroup  adcdriver
207:                * @brief    This macro defines the Custom Name for \ref ADC1_PWMTriggerSourceSet API
208:                */
209:               #define MCC_ADC_PWMTriggerSourceSet ADC1_PWMTriggerSourceSet
210:               
211:               // Section: Driver Interface Functions
212:               
213:               /**
214:                * @ingroup  adcdriver
215:                * @brief    Initializes ADC1 module, using the given initialization data
216:                *           This function must be called before any other ADC1 function is called
217:                * @return   none  
218:                */
219:               void ADC1_Initialize (void);
220:               
221:               /**
222:                * @ingroup  adcdriver
223:                * @brief    Deinitializes the ADC1 to POR values
224:                * @return   none  
225:                */
226:               void ADC1_Deinitialize(void);
227:               
228:               /**
229:                * @ingroup  adcdriver
230:                * @brief    This inline function enables the ADC1 module
231:                * @pre      \ref ADC1_Initialize function should have been 
232:                *           called  before calling this function.
233:                * @return   none  
234:                */
235:               inline static void ADC1_Enable(void)
236:               {
237:                  ADCON1Lbits.ADON = 1;
00825A  A8EB01     BSET 0xB01, #7
009F0E  A8EB01     BSET 0xB01, #7
238:               }
009F10  060000     RETURN
239:               
240:               /**
241:                * @ingroup  adcdriver
242:                * @brief    This inline function disables the ADC1 module
243:                * @pre      \ref ADC1_Initialize function should have been 
244:                *           called  before calling this function.
245:                * @return   none  
246:                */
247:               inline static void ADC1_Disable(void)
248:               {
249:                  ADCON1Lbits.ADON = 0;
009F12  A9EB01     BCLR 0xB01, #7
250:               }
009F14  060000     RETURN
251:               
252:               /**
253:                * @ingroup  adcdriver
254:                * @brief    This inline function sets software common trigger
255:                * @pre      \ref ADC1_Initialize function should have been 
256:                *           called before calling this function.
257:                * @return   none  
258:                */
259:               inline static void ADC1_SoftwareTriggerEnable(void)
260:               {
261:                  ADCON3Lbits.SWCTRG = 1;
009F16  A8CB08     BSET ADCON3L, #6
262:               }
009F18  060000     RETURN
263:               
264:               /**
265:                * @ingroup  adcdriver
266:                * @brief    This inline function resets software common trigger
267:                * @pre      ADC1_Initialize function should have been 
268:                *           called before calling this function.
269:                * @return   none  
270:                */
271:               inline static void ADC1_SoftwareTriggerDisable(void)
272:               {
273:                  ADCON3Lbits.SWCTRG = 0;
009F1A  A9CB08     BCLR ADCON3L, #6
274:               }
009F1C  060000     RETURN
009F1E  A8482B     BSET 0x82B, #2
275:               
276:               /**
277:                * @ingroup    adcdriver
278:                * @brief      This inline function allows selection of a channel for conversion
279:                * @pre        \ref ADC1_Initialize() function should have been
280:                *             called before calling this function.
281:                * @param[in]  channel - Channel for conversion  
282:                * @return     none  
283:                */
284:               inline static void ADC1_ChannelSelect( enum ADC_CHANNEL channel )
285:               {
286:                   //This function does not have any implementation since 
287:                   //Shared channels are selected from UI.
288:                   //Dedicated channels are selected from UI.
289:                   
290:                   (void)channel;
291:               }
009FB2  060000     RETURN
009FB4  060000     RETURN
292:               
293:               /**
294:                * @ingroup    adcdriver
295:                * @brief      Returns the conversion value for the channel selected
296:                * @pre        This inline function returns the conversion value only after the conversion is complete. 
297:                *             Conversion completion status can be checked using 
298:                *             \ref ADC1_IsConversionComplete(channel) function.
299:                * @param[in]  channel - Selected channel  
300:                * @return     Returns the analog to digital converted value  
301:                */
302:               inline static uint16_t ADC1_ConversionResultGet( enum ADC_CHANNEL channel )
303:               {
008CA2  780100     MOV W0, W2
304:                   uint16_t result = 0x0U;
008CA6  EB0000     CLR W0
305:               
306:                   switch(channel)
008CA4  EB0180     CLR W3
008CA8  510FE9     SUB W2, #0x9, [W15]
008CAA  598FE0     SUBB W3, #0x0, [W15]
008CAC  3E001E     BRA GTU, .L7
008CAE  010602     BRA W2
008CB0  370009     BRA .SE18, .L8
008CB2  37000A     BRA .L9
008CB4  37000B     BRA .L10
008CB6  37000C     BRA .L11
008CB8  37000D     BRA .L12
008CBA  37000E     BRA .L13
008CBC  37000F     BRA .L14
008CBE  370010     BRA .L15
008CC0  370011     BRA .L16
008CC2  370012     BRA .L17
307:                   {
308:                       case MCAF_ADC_DCLINK_CURRENT:
309:                               result = ADCBUF4;
008CC4  8060A0     MOV ADCBUF4, W0
310:                               break;
008CC6  370011     BRA .L7
311:                       case MCAF_ADC_PHASEC_CURRENT:
312:                               result = ADCBUF10;
008CC8  806100     MOV ADCBUF10, W0
313:                               break;
008CCA  37000F     BRA .L7
314:                       case MCAF_ADC_POTENTIOMETER:
315:                               result = ADCBUF11;
008CCC  806110     MOV ADCBUF11, W0
316:                               break;
008CCE  37000D     BRA .L7
317:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
318:                               result = ADCBUF12;
008CD0  806120     MOV ADCBUF12, W0
319:                               break;
008CD2  37000B     BRA .L7
320:                       case MCAF_ADC_DCLINK_VOLTAGE:
321:                               result = ADCBUF15;
00094C  806150     MOV ADCBUF15, W0
008CD4  806150     MOV ADCBUF15, W0
008DFC  806150     MOV ADCBUF15, W0
322:                               break;
008CD6  370009     BRA .L7
323:                       case MCAF_ADC_PHASEA_VOLTAGE:
324:                               result = ADCBUF17;
008CD8  806170     MOV ADCBUF17, W0
325:                               break;
008CDA  370007     BRA .L7
326:                       case MCAF_ADC_PHASEC_VOLTAGE:
327:                               result = ADCBUF22;
008CDC  8061C0     MOV ADCBUF22, W0
328:                               break;
008CDE  370005     BRA .L7
329:                       case MCAF_ADC_PHASEB_VOLTAGE:
330:                               result = ADCBUF23;
008CE0  8061D0     MOV ADCBUF23, W0
331:                               break;
008CE2  370003     BRA .L7
332:                       case MCAF_ADC_PHASEA_CURRENT:
333:                               result = ADCBUF0;
008B60  806062     MOV ADCBUF0, W2
008CE4  806060     MOV ADCBUF0, W0
334:                               break;
008CE6  370001     BRA .L7
335:                       case MCAF_ADC_PHASEB_CURRENT:
336:                               result = ADCBUF1;
008B64  806070     MOV ADCBUF1, W0
008CE8  806070     MOV ADCBUF1, W0
337:                               break;
338:                       default:
339:                               break;
340:                   }
341:                   return result;
342:               }
008CEA  060000     RETURN
008CEC  BE9F88     MOV.D W8, [W15++]
343:               
344:               /**
345:                * @ingroup    adcdriver
346:                * @brief      This inline function returns the status of conversion.This function is used to 
347:                *             determine if conversion is completed. When conversion is complete 
348:                *             the function returns true otherwise false.
349:                * 
350:                * @pre        \ref ADC1_SoftwareTriggerEnable() function should have been 
351:                *             called before calling this function.
352:                * @param[in]  channel - Selected channel  
353:                * @return     true - Conversion is complete.
354:                * @return     false - Conversion is not complete.  
355:                */
356:               inline static bool ADC1_IsConversionComplete(enum ADC_CHANNEL channel)
357:               {
00879A  780100     MOV W0, W2
358:                   bool status = false;
00879E  EB4000     CLR.B W0
359:               
360:                   switch(channel)
00879C  EB0180     CLR W3
0087A0  510FE9     SUB W2, #0x9, [W15]
0087A2  598FE0     SUBB W3, #0x0, [W15]
0087A4  3E0028     BRA GTU, .L21
0087A6  010602     BRA W2
0087A8  370009     BRA .SE32, .L22
0087AA  37000B     BRA .L23
0087AC  37000D     BRA .L24
0087AE  37000F     BRA .L25
0087B0  370011     BRA .L26
0087B2  370013     BRA .L27
0087B4  370015     BRA .L28
0087B6  370017     BRA .L29
0087B8  370019     BRA .L30
0087BA  37001B     BRA .L31
361:                   {
362:                       case MCAF_ADC_DCLINK_CURRENT:
363:                               status = ADSTATLbits.AN4RDY;
0087BC  0AA044     BFEXT #0x4, #0x1, ADSTATL, W0
0087BE  000B30     NOP
364:                               break;
0087C0  37001A     BRA .L21
365:                       case MCAF_ADC_PHASEC_CURRENT:
366:                               status = ADSTATLbits.AN10RDY;
0087C2  0AA0AA     BFEXT #0xa, #0x1, ADSTATL, W0
0087C4  000B30     NOP
367:                               break;
0087C6  370017     BRA .L21
368:                       case MCAF_ADC_POTENTIOMETER:
369:                               status = ADSTATLbits.AN11RDY;
0087C8  0AA0BB     BFEXT #0xb, #0x1, ADSTATL, W0
0087CA  000B30     NOP
370:                               break;
0087CC  370014     BRA .L21
371:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
372:                               status = ADSTATLbits.AN12RDY;
0087CE  0AA0CC     BFEXT #0xc, #0x1, ADSTATL, W0
0087D0  000B30     NOP
373:                               break;
0087D2  370011     BRA .L21
374:                       case MCAF_ADC_DCLINK_VOLTAGE:
375:                               status = ADSTATLbits.AN15RDY;
0087D4  805980     MOV ADSTATL, W0
0087D6  DE004F     LSR W0, #15, W0
376:                               break;
0087D8  37000E     BRA .L21
377:                       case MCAF_ADC_PHASEA_VOLTAGE:
378:                               status = ADSTATHbits.AN17RDY;
0087DA  0AA011     BFEXT #0x1, #0x1, ADSTATH, W0
0087DC  000B32     NOP
379:                               break;
0087DE  37000B     BRA .L21
380:                       case MCAF_ADC_PHASEC_VOLTAGE:
381:                               status = ADSTATHbits.AN22RDY;
0087E0  0AA066     BFEXT #0x6, #0x1, ADSTATH, W0
0087E2  000B32     NOP
382:                               break;
0087E4  370008     BRA .L21
383:                       case MCAF_ADC_PHASEB_VOLTAGE:
384:                               status = ADSTATHbits.AN23RDY;
0087E6  0AA077     BFEXT #0x7, #0x1, ADSTATH, W0
0087E8  000B32     NOP
385:                               break;
0087EA  370005     BRA .L21
386:                       case MCAF_ADC_PHASEA_CURRENT:
387:                               status = ADSTATLbits.AN0RDY;
0087EC  805980     MOV ADSTATL, W0
0087EE  604061     AND.B W0, #0x1, W0
388:                               break;
0087F0  370002     BRA .L21
389:                       case MCAF_ADC_PHASEB_CURRENT:
390:                               status = ADSTATLbits.AN1RDY;
0087F2  0AA011     BFEXT #0x1, #0x1, ADSTATL, W0
0087F4  000B30     NOP
391:                               break;
392:                       default:
393:                               break;
394:                   }
395:               
396:                   return status;
397:               }
0087F6  060000     RETURN
0087F8  230010     MOV #0x3001, W0
0087FA  887C30     MOV W0, CLKDIV
398:               
399:               /**
400:                * @ingroup    adcdriver
401:                * @brief      This inline function helps to configure all cores with same resolution
402:                * 
403:                * @param[in]  resolution - Resolution type  
404:                * @return     none 
405:                */
406:               inline static void ADC1_ResolutionSet(enum ADC_RESOLUTION_TYPE resolution)
407:               {
408:                  ADCORE0Hbits.RES = resolution;
008250  203000     MOV #0x300, W0
008252  B72BD6     IOR ADCORE0H
0095A2  600063     AND W0, #0x3, W0
0095A4  DD00C8     SL W0, #8, W1
0095A6  2FCFF2     MOV #0xFCFF, W2
0095A8  805EB4     MOV ADCORE0H, W4
0095AA  610184     AND W2, W4, W3
0095AC  708183     IOR W1, W3, W3
0095AE  885EB3     MOV W3, ADCORE0H
409:                  ADCORE1Hbits.RES = resolution;
008254  B72BDA     IOR ADCORE1H
0095B0  805ED3     MOV ADCORE1H, W3
0095B2  610103     AND W2, W3, W2
0095B4  708102     IOR W1, W2, W2
0095B6  885ED2     MOV W2, ADCORE1H
410:                  ADCON1Hbits.SHRRES = resolution;
008256  200600     MOV #0x60, W0
008258  B72B02     IOR ADCON1H
0095B8  DD0045     SL W0, #5, W0
0095BA  2FF9F1     MOV #0xFF9F, W1
0095BC  805814     MOV ADCON1H, W4
0095BE  608084     AND W1, W4, W1
0095C0  700081     IOR W0, W1, W1
0095C2  885811     MOV W1, ADCON1H
411:               }
0095C4  060000     RETURN
0095C6  200400     MOV #0x40, W0
412:               
413:               /**
414:                * @ingroup  adcdriver
415:                * @brief    This inline function enables the ADC1 interrupt
416:                * @return   none  
417:                */
418:               inline static void ADC1_InterruptEnable(void)
419:               {
420:                   IEC5bits.ADCIE = 1;
009F1E  A8482B     BSET 0x82B, #2
421:               }
009F20  060000     RETURN
422:               
423:               /**
424:                * @ingroup  adcdriver
425:                * @brief    This inline function disables the ADC1 interrupt
426:                * @return   none  
427:                */
428:               inline static void ADC1_InterruptDisable(void)
429:               {
430:                   IEC5bits.ADCIE = 0;
009F22  A9482B     BCLR 0x82B, #2
431:               }
009F24  060000     RETURN
432:               
433:               /**
434:                * @ingroup  adcdriver
435:                * @brief    Clears interrupt flag manually
436:                * @return   none  
437:                */
438:               inline static void ADC1_InterruptFlagClear(void)
439:               {
440:                   IFS5bits.ADCIF = 0;
009F26  A9480B     BCLR 0x80B, #2
441:               }
009F28  060000     RETURN
009F2A  A8EC81     BSET 0xC81, #7
442:               
443:               /**
444:                * @ingroup    adcdriver
445:                * @brief      This inline function allows selection of priority for interrupt
446:                * @param[in]  priorityValue  -  The numerical value of interrupt priority
447:                * @return     none  
448:                */
449:               inline static void ADC1_InterruptPrioritySet( uint16_t priorityValue )
450:               {
451:                   IPC22bits.ADCIP = (uint16_t)0x7 & priorityValue;
009BCE  600067     AND W0, #0x7, W0
009BD0  DD0048     SL W0, #8, W0
009BD2  2F8FF1     MOV #0xF8FF, W1
009BD4  804362     MOV IPC22, W2
009BD6  608082     AND W1, W2, W1
009BD8  700081     IOR W0, W1, W1
009BDA  884361     MOV W1, IPC22
452:               }
009BDC  060000     RETURN
009BDE  AB480B     BTST 0x80B, #2
453:               
454:               /**
455:                * @ingroup    adcdriver
456:                * @brief      This function can be used to override default callback and to 
457:                *             define custom callback for ADC1 Common event
458:                * @param[in]  callback - Address of the callback function.  
459:                * @return     none  
460:                *             
461:                */
462:               void ADC1_CommonCallbackRegister(void(*callback)(void));
463:               
464:               /**
465:                * @ingroup  adcdriver
466:                * @brief    This is the default callback with weak attribute. The user can override and implement the default callback without weak attribute
467:                *           or can register a custom callback function using  ADC1_CommonCallbackRegister
468:                * @return   none  
469:                */
470:               void ADC1_CommonCallback(void);
471:               
472:                
473:               /**
474:                * @ingroup  adcdriver
475:                * @brief    This function is used to implement the tasks for polled implementations
476:                * @pre      \ref ADC1_Initialize() function should have been
477:                *           called before calling this function.
478:                * @return   none
479:                * @note     This function has to be polled to notify callbacks and clear 
480:                *           the interrupt flags in non-interrupt mode of ADC
481:                */
482:               void ADC1_Tasks(void);
483:               
484:               /**
485:                * @ingroup    adcdriver
486:                * @brief      This inline function enables individual channel interrupt
487:                * @param[in]  channel - Selected channel  
488:                * @return     none  
489:                */
490:               inline static void ADC1_IndividualChannelInterruptEnable(enum ADC_CHANNEL channel)
491:               {
492:                   switch(channel)
0088B2  EB0080     CLR W1
0088B4  500FE9     SUB W0, #0x9, [W15]
0088B6  588FE0     SUBB W1, #0x0, [W15]
0088B8  3E0028     BRA GTU, .L39
0088BA  010600     BRA W0
0088BC  370009     BRA .SE51, .L41
0088BE  37000B     BRA .L42
0088C0  37000D     BRA .L43
0088C2  37000F     BRA .L44
0088C4  370011     BRA .L45
0088C6  370013     BRA .L46
0088C8  370015     BRA .L47
0088CA  370017     BRA .L48
0088CC  370019     BRA .L49
0088CE  37001B     BRA .L50
493:                   {
494:                       case MCAF_ADC_DCLINK_CURRENT:
495:                               IEC5bits.ADCAN4IE = 1;
0088D0  A8E82B     BSET 0x82B, #7
496:                               ADIELbits.IE4 = 1;
0088D2  A88B20     BSET ADIEL, #4
497:                               break;
0088D4  37001A     BRA .L39
498:                       case MCAF_ADC_PHASEC_CURRENT:
499:                               IEC6bits.ADCAN10IE = 1;
0088D6  A8A82C     BSET IEC6, #5
500:                               ADIELbits.IE10 = 1;
0088D8  A84B21     BSET 0xB21, #2
501:                               break;
0088DA  370017     BRA .L39
502:                       case MCAF_ADC_POTENTIOMETER:
503:                               IEC6bits.ADCAN11IE = 1;
0088DC  A8C82C     BSET IEC6, #6
504:                               ADIELbits.IE11 = 1;
0088DE  A86B21     BSET 0xB21, #3
505:                               break;
0088E0  370014     BRA .L39
506:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
507:                               IEC6bits.ADCAN12IE = 1;
0088E2  A8E82C     BSET IEC6, #7
508:                               ADIELbits.IE12 = 1;
0088E4  A88B21     BSET 0xB21, #4
509:                               break;
0088E6  370011     BRA .L39
510:                       case MCAF_ADC_DCLINK_VOLTAGE:
511:                               IEC6bits.ADCAN15IE = 1;
0088E8  A8482D     BSET 0x82D, #2
008E00  A8482D     BSET 0x82D, #2
512:                               ADIELbits.IE15 = 1;
0088EA  A8EB21     BSET 0xB21, #7
008E02  A8EB21     BSET 0xB21, #7
513:                               break;
0088EC  37000E     BRA .L39
514:                       case MCAF_ADC_PHASEA_VOLTAGE:
515:                               IEC6bits.ADCAN17IE = 1;
0088EE  A8882D     BSET 0x82D, #4
516:                               ADIEHbits.IE17 = 1;
0088F0  A82B22     BSET ADIEH, #1
517:                               break;
0088F2  37000B     BRA .L39
518:                       case MCAF_ADC_PHASEC_VOLTAGE:
519:                               IEC7bits.ADCAN22IE = 1;
0088F4  A8282E     BSET IEC7, #1
520:                               ADIEHbits.IE22 = 1;
0088F6  A8CB22     BSET ADIEH, #6
521:                               break;
0088F8  370008     BRA .L39
522:                       case MCAF_ADC_PHASEB_VOLTAGE:
523:                               IEC7bits.ADCAN23IE = 1;
0088FA  A8482E     BSET IEC7, #2
524:                               ADIEHbits.IE23 = 1;
0088FC  A8EB22     BSET ADIEH, #7
525:                               break;
0088FE  370005     BRA .L39
526:                       case MCAF_ADC_PHASEA_CURRENT:
527:                               IEC5bits.ADCAN0IE = 1;
008900  A8682B     BSET 0x82B, #3
528:                               ADIELbits.IE0 = 1;
008902  A80B20     BSET ADIEL, #0
529:                               break;
008904  370002     BRA .L39
530:                       case MCAF_ADC_PHASEB_CURRENT:
531:                               IEC5bits.ADCAN1IE = 1;
008906  A8882B     BSET 0x82B, #4
532:                               ADIELbits.IE1 = 1;
008908  A82B20     BSET ADIEL, #1
533:                               break;
534:                       default:
535:                               break;
536:                   }
537:               }
00890A  060000     RETURN
538:               
539:               /**
540:                * @ingroup    adcdriver
541:                * @brief      This inline function disables individual channel interrupt
542:                * @param[in]  channel - Selected channel  
543:                * @return     none  
544:                */
545:               inline static void ADC1_IndividualChannelInterruptDisable(enum ADC_CHANNEL channel)
546:               {
547:                   switch(channel)
00890C  EB0080     CLR W1
00890E  500FE9     SUB W0, #0x9, [W15]
008910  588FE0     SUBB W1, #0x0, [W15]
008912  3E0028     BRA GTU, .L52
008914  010600     BRA W0
008916  370009     BRA .SE64, .L54
008918  37000B     BRA .L55
00891A  37000D     BRA .L56
00891C  37000F     BRA .L57
00891E  370011     BRA .L58
008920  370013     BRA .L59
008922  370015     BRA .L60
008924  370017     BRA .L61
008926  370019     BRA .L62
008928  37001B     BRA .L63
548:                   {
549:                       case MCAF_ADC_DCLINK_CURRENT:
550:                               IEC5bits.ADCAN4IE = 0;
00892A  A9E82B     BCLR 0x82B, #7
551:                               ADIELbits.IE4 = 0;
00892C  A98B20     BCLR ADIEL, #4
552:                               break;
00892E  37001A     BRA .L52
553:                       case MCAF_ADC_PHASEC_CURRENT:
554:                               IEC6bits.ADCAN10IE = 0;
008930  A9A82C     BCLR IEC6, #5
555:                               ADIELbits.IE10 = 0;
008932  A94B21     BCLR 0xB21, #2
556:                               break;
008934  370017     BRA .L52
557:                       case MCAF_ADC_POTENTIOMETER:
558:                               IEC6bits.ADCAN11IE = 0;
008936  A9C82C     BCLR IEC6, #6
559:                               ADIELbits.IE11 = 0;
008938  A96B21     BCLR 0xB21, #3
560:                               break;
00893A  370014     BRA .L52
561:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
562:                               IEC6bits.ADCAN12IE = 0;
00893C  A9E82C     BCLR IEC6, #7
563:                               ADIELbits.IE12 = 0;
00893E  A98B21     BCLR 0xB21, #4
564:                               break;
008940  370011     BRA .L52
565:                       case MCAF_ADC_DCLINK_VOLTAGE:
566:                               IEC6bits.ADCAN15IE = 0;
008942  A9482D     BCLR 0x82D, #2
567:                               ADIELbits.IE15 = 0;
008944  A9EB21     BCLR 0xB21, #7
568:                               break;
008946  37000E     BRA .L52
569:                       case MCAF_ADC_PHASEA_VOLTAGE:
570:                               IEC6bits.ADCAN17IE = 0;
008948  A9882D     BCLR 0x82D, #4
571:                               ADIEHbits.IE17 = 0;
00894A  A92B22     BCLR ADIEH, #1
572:                               break;
00894C  37000B     BRA .L52
573:                       case MCAF_ADC_PHASEC_VOLTAGE:
574:                               IEC7bits.ADCAN22IE = 0;
00894E  A9282E     BCLR IEC7, #1
575:                               ADIEHbits.IE22 = 0;
008950  A9CB22     BCLR ADIEH, #6
576:                               break;
008952  370008     BRA .L52
577:                       case MCAF_ADC_PHASEB_VOLTAGE:
578:                               IEC7bits.ADCAN23IE = 0;
008954  A9482E     BCLR IEC7, #2
579:                               ADIEHbits.IE23 = 0;
008956  A9EB22     BCLR ADIEH, #7
580:                               break;
008958  370005     BRA .L52
581:                       case MCAF_ADC_PHASEA_CURRENT:
582:                               IEC5bits.ADCAN0IE = 0;
00895A  A9682B     BCLR 0x82B, #3
583:                               ADIELbits.IE0 = 0;
00895C  A90B20     BCLR ADIEL, #0
584:                               break;
00895E  370002     BRA .L52
585:                       case MCAF_ADC_PHASEB_CURRENT:
586:                               IEC5bits.ADCAN1IE = 0;
008960  A9882B     BCLR 0x82B, #4
587:                               ADIELbits.IE1 = 0;
008962  A92B20     BCLR ADIEL, #1
588:                               break;
589:                       default:
590:                               break;
591:                   }
592:               }
008964  060000     RETURN
008966  500FE2     SUB W0, #0x2, [W15]
008968  320010     BRA Z, .L14
00896A  500FE4     SUB W0, #0x4, [W15]
00896C  32001A     BRA Z, .L15
00896E  500FE1     SUB W0, #0x1, [W15]
008970  3A0023     BRA NZ, .L11
593:               
594:               /**
595:                * @ingroup    adcdriver
596:                * @brief      This inline function clears individual channel interrupt flag
597:                * @param[in]  channel - Selected channel  
598:                * @return     none  
599:                */
600:               inline static void ADC1_IndividualChannelInterruptFlagClear(enum ADC_CHANNEL channel)
601:               {
602:                   switch(channel)
008D7C  EB0080     CLR W1
008D7E  500FE9     SUB W0, #0x9, [W15]
008D80  588FE0     SUBB W1, #0x0, [W15]
008D82  3E001E     BRA GTU, .L65
008D84  010600     BRA W0
008D86  370009     BRA .SE77, .L67
008D88  37000A     BRA .L68
008D8A  37000B     BRA .L69
008D8C  37000C     BRA .L70
008D8E  37000D     BRA .L71
008D90  37000E     BRA .L72
008D92  37000F     BRA .L73
008D94  370010     BRA .L74
008D96  370011     BRA .L75
008D98  370012     BRA .L76
603:                   {
604:                       case MCAF_ADC_DCLINK_CURRENT:
605:                               IFS5bits.ADCAN4IF = 0;
008D9A  A9E80B     BCLR 0x80B, #7
606:                               break;
008D9C  370011     BRA .L65
607:                       case MCAF_ADC_PHASEC_CURRENT:
608:                               IFS6bits.ADCAN10IF = 0;
008D9E  A9A80C     BCLR IFS6, #5
609:                               break;
008DA0  37000F     BRA .L65
610:                       case MCAF_ADC_POTENTIOMETER:
611:                               IFS6bits.ADCAN11IF = 0;
008DA2  A9C80C     BCLR IFS6, #6
612:                               break;
008DA4  37000D     BRA .L65
613:                       case MCAF_ADC_BRIDGE_TEMPERATURE:
614:                               IFS6bits.ADCAN12IF = 0;
008DA6  A9E80C     BCLR IFS6, #7
615:                               break;
008DA8  37000B     BRA .L65
616:                       case MCAF_ADC_DCLINK_VOLTAGE:
617:                               IFS6bits.ADCAN15IF = 0;
00094E  A9480D     BCLR 0x80D, #2
008DAA  A9480D     BCLR 0x80D, #2
008DFE  A9480D     BCLR 0x80D, #2
618:                               break;
008DAC  370009     BRA .L65
619:                       case MCAF_ADC_PHASEA_VOLTAGE:
620:                               IFS6bits.ADCAN17IF = 0;
008DAE  A9880D     BCLR 0x80D, #4
621:                               break;
008DB0  370007     BRA .L65
622:                       case MCAF_ADC_PHASEC_VOLTAGE:
623:                               IFS7bits.ADCAN22IF = 0;
008DB2  A9280E     BCLR IFS7, #1
624:                               break;
008DB4  370005     BRA .L65
625:                       case MCAF_ADC_PHASEB_VOLTAGE:
626:                               IFS7bits.ADCAN23IF = 0;
008DB6  A9480E     BCLR IFS7, #2
627:                               break;
008DB8  370003     BRA .L65
628:                       case MCAF_ADC_PHASEA_CURRENT:
629:                               IFS5bits.ADCAN0IF = 0;
008DBA  A9680B     BCLR 0x80B, #3
630:                               break;
008DBC  370001     BRA .L65
631:                       case MCAF_ADC_PHASEB_CURRENT:
632:                               IFS5bits.ADCAN1IF = 0;
008DBE  A9880B     BCLR 0x80B, #4
633:                               break;
634:                       default:
635:                               break;
636:                   }
637:               }
008DC0  060000     RETURN
008DC2  A88E76     BSET LATE, #4
638:               
639:               /**
640:                * @ingroup    adcdriver
641:                * @brief      This inline function allows selection of priority for individual channel interrupt
642:                * @param[in]  channel - Selected channel 
643:                * @param[in]  priorityValue  -  The numerical value of interrupt priority
644:                * @return     none  
645:                */
646:               inline static void ADC1_IndividualChannelInterruptPrioritySet(enum ADC_CHANNEL channel, enum INTERRUPT_PRIORITY priorityValue)
647:               {
007CE4  780101     MOV W1, W2
648:               	switch(channel)
007CE6  EB0080     CLR W1
007CE8  500FE9     SUB W0, #0x9, [W15]
007CEA  588FE0     SUBB W1, #0x0, [W15]
007CEC  3E0048     BRA GTU, .L78
007CEE  010600     BRA W0
007CF0  370009     BRA .SE90, .L80
007CF2  37000F     BRA .L81
007CF4  370015     BRA .L82
007CF6  37001B     BRA .L83
007CF8  370021     BRA .L84
007CFA  370027     BRA .L85
007CFC  370029     BRA .L86
007CFE  37002F     BRA .L87
007D00  370035     BRA .L88
007D02  37003B     BRA .L89
649:               	{
650:               		case MCAF_ADC_DCLINK_CURRENT:
651:               				IPC23bits.ADCAN4IP = priorityValue;
007D04  610167     AND W2, #0x7, W2
007D06  DD114C     SL W2, #12, W2
007D08  28FFF0     MOV #0x8FFF, W0
007D0A  B6086E     AND IPC23, WREG
007D0C  710000     IOR W2, W0, W0
007D0E  884370     MOV W0, IPC23
652:               				break;
007D10  370036     BRA .L78
653:               		case MCAF_ADC_PHASEC_CURRENT:
654:               				IPC25bits.ADCAN10IP = priorityValue;
007D12  610167     AND W2, #0x7, W2
007D14  DD1144     SL W2, #4, W2
007D16  2FF8F0     MOV #0xFF8F, W0
007D18  B60872     AND IPC25, WREG
007D1A  710000     IOR W2, W0, W0
007D1C  884390     MOV W0, IPC25
655:               				break;
007D1E  37002F     BRA .L78
656:               		case MCAF_ADC_POTENTIOMETER:
657:               				IPC25bits.ADCAN11IP = priorityValue;
007D20  610167     AND W2, #0x7, W2
007D22  DD1148     SL W2, #8, W2
007D24  2F8FF0     MOV #0xF8FF, W0
007D26  B60872     AND IPC25, WREG
007D28  710000     IOR W2, W0, W0
007D2A  884390     MOV W0, IPC25
658:               				break;
007D2C  370028     BRA .L78
659:               		case MCAF_ADC_BRIDGE_TEMPERATURE:
660:               				IPC25bits.ADCAN12IP = priorityValue;
007D2E  610167     AND W2, #0x7, W2
007D30  DD114C     SL W2, #12, W2
007D32  28FFF0     MOV #0x8FFF, W0
007D34  B60872     AND IPC25, WREG
007D36  710000     IOR W2, W0, W0
007D38  884390     MOV W0, IPC25
661:               				break;
007D3A  370021     BRA .L78
662:               		case MCAF_ADC_DCLINK_VOLTAGE:
663:               				IPC26bits.ADCAN15IP = priorityValue;
007D3C  610167     AND W2, #0x7, W2
007D3E  DD1148     SL W2, #8, W2
007D40  2F8FF0     MOV #0xF8FF, W0
007D42  B60874     AND IPC26, WREG
007D44  710000     IOR W2, W0, W0
007D46  8843A0     MOV W0, IPC26
00822A  2F8FF1     MOV #0xF8FF, W1
00822C  8043A0     MOV IPC26, W0
00822E  608080     AND W1, W0, W1
008230  206000     MOV #0x600, W0
008232  700001     IOR W0, W1, W0
008234  8843A0     MOV W0, IPC26
664:               				break;
007D48  37001A     BRA .L78
665:               		case MCAF_ADC_PHASEA_VOLTAGE:
666:               				IPC27bits.ADCAN17IP = priorityValue;
007D4A  0A2220     BFINS #0x0, #0x3, W2, IPC27
007D4C  000876     NOP
667:               				break;
007D4E  370017     BRA .L78
668:               		case MCAF_ADC_PHASEC_VOLTAGE:
669:               				IPC28bits.ADCAN22IP = priorityValue;
007D50  610167     AND W2, #0x7, W2
007D52  DD1144     SL W2, #4, W2
007D54  2FF8F0     MOV #0xFF8F, W0
007D56  B60878     AND IPC28, WREG
007D58  710000     IOR W2, W0, W0
007D5A  8843C0     MOV W0, IPC28
670:               				break;
007D5C  370010     BRA .L78
671:               		case MCAF_ADC_PHASEB_VOLTAGE:
672:               				IPC28bits.ADCAN23IP = priorityValue;
007D5E  610167     AND W2, #0x7, W2
007D60  DD1148     SL W2, #8, W2
007D62  2F8FF0     MOV #0xF8FF, W0
007D64  B60878     AND IPC28, WREG
007D66  710000     IOR W2, W0, W0
007D68  8843C0     MOV W0, IPC28
673:               				break;
007D6A  370009     BRA .L78
674:               		case MCAF_ADC_PHASEA_CURRENT:
675:               				IPC22bits.ADCAN0IP = priorityValue;
007D6C  610167     AND W2, #0x7, W2
007D6E  DD114C     SL W2, #12, W2
007D70  28FFF0     MOV #0x8FFF, W0
007D72  B6086C     AND IPC22, WREG
007D74  710000     IOR W2, W0, W0
007D76  884360     MOV W0, IPC22
676:               				break;
007D78  370002     BRA .L78
677:               		case MCAF_ADC_PHASEB_CURRENT:
678:               				IPC23bits.ADCAN1IP = priorityValue;
007D7A  0A2220     BFINS #0x0, #0x3, W2, IPC23
007D7C  00086E     NOP
679:               				break;
680:               		default:
681:               				break;
682:               	}
683:               }
007D7E  060000     RETURN
007D80  BE9F88     MOV.D W8, [W15++]
684:               
685:               /**
686:                * @ingroup    adcdriver
687:                * @brief      This function can be used to override default callback \ref ADC1_ChannelCallback
688:                *             and to define custom callback for ADC1 Channel event. 
689:                *             Read the conversion result of the corresponding channel in the custom callback.
690:                * @param[in]  callback - Address of the callback function.  
691:                * @return     none  
692:                */
693:               void ADC1_ChannelCallbackRegister(void(*callback)(enum ADC_CHANNEL channel, uint16_t adcVal));
694:               
695:               /**
696:                * @ingroup    adcdriver
697:                * @brief      This is the default callback function for all the analog channels. 
698:                *             This callback is triggered once the channel conversion is done for a
699:                *             channel and to read the conversion result of the corresponding channel
700:                * @param[in]  channel - conversion completed channel
701:                * @param[in]  adcVal - conversion result of channel  
702:                * @return     none  
703:                */
704:               void ADC1_ChannelCallback(enum ADC_CHANNEL channel, uint16_t adcVal);
705:               
706:               
707:               /**
708:                * @ingroup    adcdriver
709:                * @brief      This function can be used to override default callback and to 
710:                *             define custom callback for ADC1_Comparator event
711:                * @param[in]  callback - Address of the callback function.  
712:                * @return     none  
713:                */
714:               void ADC1_ComparatorCallbackRegister(void(*callback)(enum ADC_CMP comparator));
715:               
716:               /**
717:                * @ingroup    adcdriver
718:                * @brief      Comparator callback function
719:                * @param[in]  comparator - comparator in which compare event occurred  
720:                * @return     none  
721:                */
722:               void ADC1_ComparatorCallback(enum ADC_CMP comparator);
723:               
724:               
725:               /**
726:                * @ingroup    adcdriver
727:                * @brief      This function call used only in polling mode, if channel 
728:                *             conversion is done for requested channel, the calls the 
729:                *             respective callback function
730:                * @pre        \ref ADC1_Initialize() function should have been  
731:                *             called before calling this function.
732:                * @param[in]  channel - Selected channel.  
733:                * @return     none  
734:                * @note       This function has to be polled to notify channel callbacks and clear 
735:                *             the channel interrupt flags in non-interrupt mode of ADC
736:                */
737:               void ADC1_ChannelTasks(enum ADC_CHANNEL channel);
738:               
739:               
740:               // Section: Interface functions: Dedicated Core
741:               
742:               /**
743:                * @ingroup    adcdriver
744:                * @brief      Enables analog and digital power for ADC1 dedicated core
745:                * @param[in]  core - Selected core  
746:                * @return     none  
747:                */
748:               void ADC1_CorePowerEnable(enum ADC_DEDICATED_CORE core);
749:               
750:               
751:               /**
752:                * @ingroup  adcdriver
753:                * @brief    Enables power for ADC1 shared Core
754:                *           This function is used to set the analog and digital power for 
755:                *           ADC1 shared Core.
756:                * @return   none  
757:                */
758:               void ADC1_SharedCorePowerEnable(void);
759:               
760:               
761:               /**
762:                * @ingroup  adcdriver
763:                * @brief    Sets PWM trigger source for corresponding analog input 
764:                * @param[in]  channel - Selected channel  
765:                * @param[in]  pwmInstance - PWM instance for the trigger source
766:                * @param[in]  triggerNumber - 1, for PWMx Trigger 1
767:                * @param[in]  triggerNumber - 2, for PWMx Trigger 2
768:                * @return   none  
769:                * @note     Configure PWM trigger value using \ref PWM_TriggerACompareValueSet, \ref PWM_TriggerBCompareValueSet
770:                *           or \ref PWM_TriggerCCompareValueSet before calling this funcion and enable corresponding 
771:                *           PWM trigger using \ref PWM_Trigger1Enable or \ref PWM_Trigger2Enable post calling it.
772:                */
773:               void ADC1_PWMTriggerSourceSet(enum ADC_CHANNEL channel, enum ADC_PWM_INSTANCE pwmInstance, enum ADC_PWM_TRIGGERS triggerNumber);
774:               
775:               #ifdef __cplusplus  // Provide C++ Compatibility
776:               
777:                   }
778:               
779:               #endif
780:               
781:               #endif //_ADC1_H
782:                   
783:               /**
784:                End of File
785:               */
786:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/main.c  -----------------------
1:                 /*
2:                 © [2023] Microchip Technology Inc. and its subsidiaries.
3:                 
4:                     Subject to your compliance with these terms, you may use Microchip 
5:                     software and any derivatives exclusively with Microchip products. 
6:                     You are responsible for complying with 3rd party license terms  
7:                     applicable to your use of 3rd party software (including open source  
8:                     software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
9:                     NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
10:                    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
11:                    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
12:                    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
13:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
14:                    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
15:                    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
16:                    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
17:                    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
18:                    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
19:                    THIS SOFTWARE.
20:                */
21:                
22:                
23:                #include <util.h>
24:                #include <stddef.h>                     // Defines NULL
25:                #include <stdbool.h>                    // Defines true
26:                #include <stdint.h>
27:                #include <stdlib.h>                     // Defines EXIT_FAILURE
28:                #include <stdio.h>
29:                #include "ringbuffer.h"
30:                #include <string.h>
31:                #include "app_config.h"
32:                
33:                #if STREAM_FORMAT_IS(SMLSS)
34:                #include "sensiml/ssi_comms.h"
35:                #elif STREAM_FORMAT_IS(NONE)
36:                
37:                #include "knowledgepack/mplabml/inc/kb.h"
38:                #include "knowledgepack/application/sml_output.h"
39:                #include "knowledgepack/application/sml_recognition_run.h"
40:                #endif //STREAM_FORMAT_IS(SMLSS)
41:                // *****************************************************************************
42:                // *****************************************************************************
43:                // Section: Platform specific includes
44:                // *****************************************************************************
45:                // ***************************************************************************** 
46:                
47:                
48:                #include "mcc_generated_files/motorBench/mcaf_main.h"
49:                #include "mcc_generated_files/system/system.h"
50:                #include "motorbench/system_state.h"
51:                #include "motorbench/sat_PI.h"
52:                #include "motorbench/filter.h"
53:                #include "mcaf_sample_application.h"
54:                #include "mcc_generated_files/timer/sccp2.h"
55:                
56:                
57:                
58:                
59:                
60:                
61:                
62:                // *****************************************************************************
63:                // *****************************************************************************
64:                // Section: Global variables
65:                // *****************************************************************************
66:                // *****************************************************************************
67:                
68:                
69:                /* Must be large enough to hold the connect/disconnect strings from SensiML DCL */
70:                #define UART_RXBUF_LEN  128
71:                
72:                
73:                #define rpm_conversion_factor 6.99          
74:                static uint8_t _uartRxBuffer_data[UART_RXBUF_LEN];
75:                static ringbuffer_t uartRxBuffer;
76:                
77:                static volatile uint32_t tickcounter = 0;
78:                static volatile unsigned int tickrate = 0;
79:                
80:                
81:                extern MCAF_MOTOR_DATA motor;
82:                extern APPLICATION_DATA app;
83:                
84:                
85:                static sample_data_t motor_buffer_data[BUF_LEN][NUM_AXES];
86:                static ringbuffer_t data_sample_buffer;
87:                static volatile bool data_sample_buffer_overrun = false;
88:                
89:                static sample_data_t * l_data_sample_buffer = NULL;
90:                
91:                volatile uint16_t rpm=0;
92:                
93:                volatile int8_t flag_read =0;
94:                int8_t flag_print=1;
95:                
96:                
97:                
98:                void sensor_read( sample_data_t *ptr, MCAF_MOTOR_DATA *pmotor, APPLICATION_DATA *appdata);
99:                
100:               
101:               // *****************************************************************************
102:               // Section: Platform specific stub definitions
103:               // *****************************************************************************
104:               // *****************************************************************************
105:               
106:               
107:               bool USART_Write( void *buffer, const size_t size )
108:               {
109:                   bool writeStatus      = false;
009330  EB4100     CLR.B W2
110:                   uint8_t *pu8Data      = (uint8_t*)buffer;
111:                   uint32_t u32Index     = 0U;
112:               
113:                   if(buffer != NULL)
009332  E00000     CP0 W0
009334  320010     BRA Z, .L6
114:                   {
115:                       /* Blocks while buffer is being transferred */
116:                       while(u32Index < size)
009336  B80A61     MUL.UU W1, #0x1, W4
00933A  520FE0     SUB W4, #0x0, [W15]
00933C  5A8FE0     SUBB W5, #0x0, [W15]
00933E  32000B     BRA Z, .L6
009340  B81160     MUL.UU W2, #0x0, W2
00934E  510F84     SUB W2, W4, [W15]
009350  598F85     SUBB W3, W5, [W15]
009352  39FFF7     BRA NC, .L13
117:                       {
118:                           /* Check if USART is ready for new data */
119:                           while(U1STAHbits.UTXBF == 1)
009342  AB823E     BTST U1STAH, #4
009344  3AFFFE     BRA NZ, .L13
120:                            {
121:                       
122:                            }
123:                           /* Write data to USART module */
124:                             U1TXREG = pu8Data[u32Index];;    // Write the data byte to the USART.
009346  FB80B0     ZE [W0++], W1
009348  881241     MOV W1, U1TXREG
125:                           /* Increment index */
126:                           u32Index++;
00934A  410161     ADD W2, #0x1, W2
00934C  4981E0     ADDC W3, #0x0, W3
127:                       }
128:                       writeStatus = true;
009338  B3C012     MOV.B #0x1, W2
009354  B3C012     MOV.B #0x1, W2
129:                   }
130:               
131:                   return writeStatus;
132:               }
009356  784002     MOV.B W2, W0
009358  060000     RETURN
00935A  E90282     DEC W2, W5
133:               
134:               void __attribute__ ((interrupt, no_auto_psv))  _U1RXInterrupt(void)
135:               {
000C36  F80036     PUSH RCOUNT
000C38  BE9F80     MOV.D W0, [W15++]
000C3A  BE9F82     MOV.D W2, [W15++]
000C3C  BE9F84     MOV.D W4, [W15++]
000C3E  BE9F86     MOV.D W6, [W15++]
000C40  781F88     MOV W8, [W15++]
000C42  FA0002     LNK #0x2
136:                   IFS0bits.U1RXIF = 0;
000C44  A96801     BCLR 0x801, #3
137:                   ringbuffer_size_t rdcnt;
138:                   uint8_t *ptr = ringbuffer_get_write_buffer(&uartRxBuffer, &rdcnt);
000C46  E9808F     DEC2 W15, W1
000C48  233B80     MOV #0x33B8, W0
000C4A  0743ED     RCALL ringbuffer_get_write_buffer
000C4C  780400     MOV W0, W8
139:                   if (UART_IsRxReady() && rdcnt) {
000C4E  0748B8     RCALL UART1_IsRxReady
000C50  E00400     CP0.B W0
000C52  320008     BRA Z, .L14
000C54  97B87F     MOV [W15-2], W0
000C56  E00000     CP0 W0
000C58  320005     BRA Z, .L14
140:                       *ptr = UART_RX_DATA;
000C5A  801220     MOV U1RXREG, W0
000C5C  784C00     MOV.B W0, [W8]
141:                       ringbuffer_advance_write_index(&uartRxBuffer, 1);
000C5E  200011     MOV #0x1, W1
000C60  233B80     MOV #0x33B8, W0
000C62  074589     RCALL ringbuffer_advance_write_index
142:                   }
143:               }
000C64  FA8000     ULNK
000C66  78044F     MOV [--W15], W8
000C68  BE034F     MOV.D [--W15], W6
000C6A  BE024F     MOV.D [--W15], W4
000C6C  BE014F     MOV.D [--W15], W2
000C6E  BE004F     MOV.D [--W15], W0
000C70  F90036     POP RCOUNT
000C72  064000     RETFIE
000C74  FA000A     LNK #0xA
144:               
145:               size_t __attribute__(( unused )) UART_Write(uint8_t *ptr, const size_t nbytes) {
009B16  781F88     MOV W8, [W15++]
009B18  780401     MOV W1, W8
146:                   return USART_Write(ptr, nbytes) ? nbytes : 0;
009B1A  780088     MOV W8, W1
009B1C  07FC09     RCALL USART_Write
009B1E  E00400     CP0.B W0
009B20  3A0001     BRA NZ, .L17
009B22  EB0400     CLR W8
147:               }
009B24  780008     MOV W8, W0
009B26  78044F     MOV [--W15], W8
009B28  060000     RETURN
009B2A  900010     MOV [W0+2], W0
148:               
149:               // *****************************************************************************
150:               // *****************************************************************************
151:               // Section: Generic stub definitions
152:               // *****************************************************************************
153:               // *****************************************************************************
154:               void Null_Handler() {
155:                   // Do nothing
156:               }
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
157:               
158:               size_t __attribute__(( unused )) UART_Read(uint8_t *ptr, const size_t nbytes) {
159:                   return ringbuffer_read(&uartRxBuffer, ptr, nbytes);
000000  040200     GOTO __resetPRI, __reset
160:               }
000008  000B4A     NOP
00000A  000BD2     NOP
161:               
162:               static void Ticker_Callback() {
163:                   static uint32_t mstick = 0;
164:               
165:                   ++tickcounter;
008F0A  809160     MOV tickcounter, W0
166:                   if (tickrate == 0 || mstick > tickrate) {
008F16  E21228     CP0 tickrate
008F18  320007     BRA Z, .L2
008F1A  809142     MOV tickrate, W2
008F1C  809180     MOV mstick, W0
008F1E  809191     MOV 0x1232, W1
008F20  EB0180     CLR W3
008F22  510F80     SUB W2, W0, [W15]
008F24  598F81     SUBB W3, W1, [W15]
008F26  310003     BRA C, .L3
167:                       mstick = 0;
008F28  EF3230     CLR mstick
008F2A  EF3232     CLR 0x1232
008F2C  37000B     BRA .L1
168:                   }
169:                   else if (++mstick == tickrate) {
008F2E  400061     ADD W0, #0x1, W0
008F30  4880E0     ADDC W1, #0x0, W1
008F32  889180     MOV W0, mstick
008F34  889191     MOV W1, 0x1232
008F36  809142     MOV tickrate, W2
008F38  EB0180     CLR W3
008F3A  500F82     SUB W0, W2, [W15]
008F3C  588F83     SUBB W1, W3, [W15]
008F3E  3A0002     BRA NZ, .L1
170:               
171:                       mstick = 0;
008F40  EF3230     CLR mstick
008F42  EF3232     CLR 0x1232
172:                   }
173:               }
008F44  060000     RETURN
174:               
175:               uint64_t read_timer_ms(void) {
176:                   return tickcounter;
000000  040200     GOTO __resetPRI, __reset
177:               }
000006  000B2E     NOP
000008  000B4A     NOP
178:               
179:               void sleep_ms(uint32_t ms) 
180:               {
000000  040200     GOTO __resetPRI, __reset
181:                   uint32_t t0 = read_timer_ms();
000008  000B4A     NOP
182:                   while ((read_timer_ms() - t0) < ms) { };
00000A  000BD2     NOP
183:               }
000044  000C16     NOP
00004C  000920     NOP
184:               
185:               
186:               uint16_t speed_measurement_local(APPLICATION_DATA *appData)
187:               {
188:                   rpm = (float)appData->motorVelocityCommand / rpm_conversion_factor;      
009B2A  900010     MOV [W0+2], W0
009B2C  DE80CF     ASR W0, #15, W1
009B2E  07B91D     RCALL ___floatsisf
009B30  2AE142     MOV #0xAE14, W2
009B32  240DF3     MOV #0x40DF, W3
009B34  07BA99     RCALL ___divsf3, ___divsf3x
009B36  07B8EE     RCALL ___fixunssfsi
009B38  889120     MOV W0, rpm
189:                   return rpm;
009B3A  809120     MOV rpm, W0
190:               }
009B3C  060000     RETURN
009B3E  780801     MOV W1, [W0]
191:               
192:               // For handling read of the motor IQ data
193:                void Read_iq_value() 
194:               {
009656  FA0002     LNK #0x2
195:                  
196:                   ringbuffer_size_t wrcnt;
197:                   sample_data_t *ptr = ringbuffer_get_write_buffer(&data_sample_buffer, &wrcnt);
009658  E9808F     DEC2 W15, W1
00965A  231AC0     MOV #0x31AC, W0
00965C  07FEE4     RCALL ringbuffer_get_write_buffer
198:                   
199:                   if (wrcnt == 0)
00965E  97B8FF     MOV [W15-2], W1
009660  E00001     CP0 W1
009662  3A0003     BRA NZ, .L27
200:                       data_sample_buffer_overrun = true;
009664  B3C010     MOV.B #0x1, W0
009666  B7F22A     MOV.B WREG, data_sample_buffer_overrun
009668  370006     BRA .L26
201:                   else 
202:                   {
203:                       sensor_read( ptr, &motor, &app );
00966A  237302     MOV #0x3730, W2
00966C  22E001     MOV #0x2E00, W1
00966E  0701F4     RCALL sensor_read
204:                       ringbuffer_advance_write_index(&data_sample_buffer, 1);
009670  200011     MOV #0x1, W1
009672  231AC0     MOV #0x31AC, W0
009674  070080     RCALL ringbuffer_advance_write_index
205:                   }
206:               }    
009676  FA8000     ULNK
009678  060000     RETURN
00967A  508FE1     SUB W1, #0x1, [W15]
207:               
208:               #if STREAM_FORMAT_IS(SMLSS)
209:               static char json_config_str[SML_MAX_CONFIG_STRLEN];
210:               
211:               size_t ssi_build_json_config(char json_config_str[], size_t maxlen)
212:               {
213:                   size_t written=0;
214:                   size_t snsr_index = 0;
215:               
216:                   written += snprintf(json_config_str, maxlen,
217:                           "{\"version\":%d"
218:                           ",\"sample_rate\":%d"
219:                           ",\"samples_per_packet\":%d"
220:                           ",\"column_location\":{"
221:                           , SSI_JSON_CONFIG_VERSION, SAMPLE_RATE, SAMPLES_PER_PACKET);
222:               
223:                   written += snprintf(json_config_str+written, maxlen-written, "\"parameterIQ\":%d,", snsr_index++);
224:                   written += snprintf(json_config_str+written, maxlen-written, "\"parameterRPM\":%d,", snsr_index++);
225:                   
226:               
227:                   if(json_config_str[written-1] == ',')
228:                   {
229:                       written--;
230:                   }
231:                   snprintf(json_config_str+written, maxlen-written, "}}\n");
232:               
233:                   return written;
234:               }
235:               
236:               #endif //STREAM_FORMAT_IS(SMLSS)
237:               
238:               void sensor_read( sample_data_t *ptr, MCAF_MOTOR_DATA *pmotor, APPLICATION_DATA *appData)
239:               {
009A58  781F88     MOV W8, [W15++]
240:                   l_data_sample_buffer = ptr;
241:                   
242:               
243:                   *l_data_sample_buffer++ = (sample_data_t) abs(pmotor->idq.q);
009A5A  9008D1     MOV [W1+26], W1
009A5C  A7F001     BTSC W1, #15
009A5E  EA0081     NEG W1, W1
009A60  780400     MOV W0, W8
009A62  781C01     MOV W1, [W8++]
244:                   *l_data_sample_buffer++ = (sample_data_t) speed_measurement_local(&app);
009A64  237300     MOV #0x3730, W0
009A66  070061     RCALL speed_measurement_local
009A68  781C00     MOV W0, [W8++]
009A6A  8891A8     MOV W8, l_data_sample_buffer
245:                
246:               }
009A6C  78044F     MOV [--W15], W8
009A6E  060000     RETURN
009A70  900190     MOV [W0+2], W3
247:               
248:               
249:               int main ( void )
250:               {
007858  FA0004     LNK #0x4
00785A  BE9F88     MOV.D W8, [W15++]
00785C  BE9F8A     MOV.D W10, [W15++]
251:                   int8_t app_failed = 0;
252:               
253:               #if STREAM_FORMAT_IS(SMLSS)
254:                   uint32_t ssi_adtimer = 0;
255:                   ssi_io_funcs_t ssi_io_s;
256:               #endif
257:                   
258:                   /* Initialize all modules */
259:                   SYSTEM_Initialize ();
00785E  070E69     RCALL SYSTEM_Initialize
260:                   MCAF_MainInit();
007860  0703FC     RCALL MCAF_MainInit
261:               
262:                   /* Register and start the millisecond interrupt ticker */
263:                   TC_TimerCallbackRegister(Ticker_Callback);
007862  28F0A0     MOV #0x8F0A, W0
007864  071306     RCALL SCCP2_TimeoutCallbackRegister
264:                   TC_TimerStart();
007866  0712F9     RCALL SCCP2_Timer_Start
265:               
266:                   printf("\n");
007868  2000A0     MOV #0xA, W0
00786A  07D44A     RCALL _putchar
267:               
268:                   /* Application init routine */
269:                   app_failed = 1;
270:                   while (1)
271:                   {
272:                               
273:                        
274:                       /* Initialize the sensor data buffer */
275:                       if (ringbuffer_init(&data_sample_buffer, motor_buffer_data, sizeof(motor_buffer_data) / sizeof(motor_buffer_data[0]), sizeof(motor_buffer_data[0])))
00786C  200043     MOV #0x4, W3
00786E  200802     MOV #0x80, W2
007870  231B81     MOV #0x31B8, W1
007872  231AC0     MOV #0x31AC, W0
007874  070D72     RCALL ringbuffer_init
007876  E00400     CP0.B W0
007878  3A0046     BRA NZ, .L32
276:                           break;
277:                   
278:                       /* Initialize the UART RX buffer */
279:                       if (ringbuffer_init(&uartRxBuffer, _uartRxBuffer_data, sizeof(_uartRxBuffer_data) / sizeof(_uartRxBuffer_data[0]), sizeof(_uartRxBuffer_data[0])))
00787A  200013     MOV #0x1, W3
00787C  200802     MOV #0x80, W2
00787E  233C41     MOV #0x33C4, W1
007880  233B80     MOV #0x33B8, W0
007882  070D6B     RCALL ringbuffer_init
007884  E00400     CP0.B W0
007886  3A003F     BRA NZ, .L32
280:                           break;
281:                       
282:                     
283:               
284:                       /* Enable the RX interrupt */
285:                       UART_RXC_Enable();
007888  A86821     BSET 0x821, #3
286:                      
287:               #if STREAM_FORMAT_IS(SMLSS)
288:                       /* Init SensiML simple-stream interface */
289:                       ssi_io_s.ssi_read = UART_Read;
290:                       ssi_io_s.ssi_write = UART_Write;
291:                       ssi_io_s.connected = false;
292:                       ssi_init(&ssi_io_s);
293:                       ssi_build_json_config(json_config_str, SML_MAX_CONFIG_STRLEN);
294:               #elif STREAM_FORMAT_IS(NONE)        
295:                       /* Initialize SensiML Knowledge Pack */
296:                       
297:                       kb_model_init();
298:                       sml_output_init(NULL);
299:                       
300:                       const uint8_t *ptr = kb_get_model_uuid_ptr(0);
301:                       printf("    Running MPLABML Anomaly Detection Demo \r\n\n ");
302:                       printf(" Knowledge pack uuid: ");
303:                       printf("%02x", *ptr++); 
304:                       for (int i=1; i < 15; i++) {
305:                           if ((i%4) == 0)
306:                               printf("-");
307:                           printf("%02x", *ptr++); 
308:                       }
309:                       printf("%02x", *ptr++); 
310:                       printf("\r\n\n");
311:                       printf("*********************************************************** \r\n");
312:                       printf("\r\n\n");        
313:               #endif
314:               
315:                              
316:                       /* STATE CHANGE - Application successfully initialized */
317:                       tickrate = 0;
00788A  EF3228     CLR tickrate
318:                      
319:               
320:               #if STREAM_FORMAT_IS(SMLSS)
321:                       /* STATE CHANGE - Application now waiting for connect */
322:               #elif !STREAM_FORMAT_IS(NONE)
323:                       /* STATE CHANGE - Application is streaming */
324:               #endif //STREAM_FORMAT_IS(SMLSS)
325:               
326:                       app_failed = 0;
327:                       break;
328:                   }
329:                   
330:               #if STREAM_FORMAT_IS(NONE)
331:                   int clsid = -1;
332:               #endif
333:                   
334:                   while (!app_failed)
335:                   {
336:                       
337:                       MCAF_MainLoop();
007892  070C68     RCALL MCAF_MainLoop
338:                       
339:                       if (flag_read == 1)
007894  BFD226     MOV.B flag_read, WREG
007896  504FE1     SUB.B W0, #0x1, [W15]
007898  3A0002     BRA NZ, .L33
340:                       {
341:                           Read_iq_value();
00789A  070EDD     RCALL Read_iq_value
342:                           flag_read = 0;
00789C  EF7226     CLR.B flag_read
343:                       }
344:                       
345:                       if(motor.state == MCSM_FAULT)
00788C  22FE8A     MOV #0x2FE8, W10
00789E  200050     MOV #0x5, W0
0078A0  100F9A     SUBR W0, [W10], [W15]
0078A2  3A0005     BRA NZ, .L34
346:                       {
347:                           printf("\r\033[K  ERROR: Got a bad motor status");
0078A4  2B9280     MOV #0xB928, W0
0078A6  781F80     MOV W0, [W15++]
0078A8  07D41C     RCALL __printf_0, __dprintf_0, ___wrap_printf
348:                           break;
0078AA  E9878F     DEC2 W15, W15
0078AC  37002C     BRA .L32
349:                       }
350:                     
351:               #if STREAM_FORMAT_IS(SMLSS)
352:                       else if (!ssi_connected()) {
353:                           if (ringbuffer_get_read_items(&uartRxBuffer) >= CONNECT_CHARS) {
354:                               ssi_try_connect();
355:                               ringbuffer_advance_read_index(&uartRxBuffer, ringbuffer_get_read_items(&uartRxBuffer));
356:                           }
357:                           if (ssi_connected()) {
358:                               /* STATE CHANGE - Application is streaming */
359:                              
360:                               /* Reset the buffer */
361:                               
362:                               ringbuffer_reset(&data_sample_buffer);
363:                               data_sample_buffer_overrun = false;
364:                              
365:                           }
366:                           if (read_timer_ms() - ssi_adtimer > 500) {
367:                               ssi_adtimer = read_timer_ms();
368:                               UART_Write((uint8_t *) json_config_str, strlen(json_config_str));
369:                           }
370:                       }
371:               #endif
372:                       else if (data_sample_buffer_overrun == true) {
0078AE  E2522A     CP0.B data_sample_buffer_overrun
0078B0  320007     BRA Z, .L35
373:                           printf("\n\n\nOverrun!\n\n\n");
0078B2  2B94C0     MOV #0xB94C, W0
0078B4  07D428     RCALL _puts
374:               
375:                           /* STATE CHANGE - buffer overflow */
376:                           tickrate = 0;
0078B6  EF3228     CLR tickrate
377:               
378:                           ringbuffer_reset(&data_sample_buffer);
0078B8  780008     MOV W8, W0
0078BA  0712E3     RCALL ringbuffer_reset
379:                           data_sample_buffer_overrun = false;
0078BC  EF722A     CLR.B data_sample_buffer_overrun
380:                         
381:               #if STREAM_FORMAT_IS(NONE)
382:                           /* STATE CHANGE - Application is running inference model */
383:                           
384:               #else            
385:                           /* STATE CHANGE - Application is streaming */
386:                           
387:               #endif
388:                         
389:                           continue;
0078BE  37FFE9     BRA .LBE2, .LBE3, .L42
390:                       }
391:               #if !STREAM_FORMAT_IS(NONE)
392:                       else if(ringbuffer_get_read_items(&data_sample_buffer) >= SAMPLES_PER_PACKET) {
00788E  231AC8     MOV #0x31AC, W8
0078C0  780008     MOV W8, W0
0078C2  071254     RCALL ringbuffer_get_read_items
0078C4  E00000     CP0 W0
0078C6  32FFE5     BRA Z, .LBE2, .LBE3, .L42
393:                           ringbuffer_size_t rdcnt;
394:                           sample_dataframe_t const *ptr = ringbuffer_get_read_buffer(&data_sample_buffer, &rdcnt);
0078C8  5780EA     SUB W15, #0xA, W1
0078CA  780008     MOV W8, W0
0078CC  070E45     RCALL ringbuffer_get_read_buffer
0078D4  780480     MOV W0, W9
395:                           while (rdcnt >= SAMPLES_PER_PACKET) {
0078CE  97B8BF     MOV [W15-10], W1
0078D0  E00001     CP0 W1
0078D2  32FFDF     BRA Z, .LBE2, .LBE3, .L42
0078FE  97B83F     MOV [W15-10], W0
007900  E00000     CP0 W0
007902  3AFFE9     BRA NZ, .L37
007904  37FFC6     BRA .LBE2, .LBE3, .L42
396:                   #if STREAM_FORMAT_IS(ASCII)
397:                               sample_data_t const *scalarptr = (sample_data_t const *) ptr;
398:                               printf("%d", *scalarptr++);
399:                               for (int j=1; j < sizeof(sample_datapacket_t) / sizeof(sample_data_t); j++) {
400:                                   printf(" %d", *scalarptr++);
401:                               }
402:                               printf("\r\n");
403:                   #elif STREAM_FORMAT_IS(MDV)
404:                               uint8_t headerbyte = MDV_START_OF_FRAME;
007890  B3CA5B     MOV.B #0xA5, W11
0078D6  9FF7CB     MOV.B W11, [W15-12]
405:                               UART_Write(&headerbyte, 1);
0078D8  200011     MOV #0x1, W1
0078DA  57806C     SUB W15, #0xC, W0
0078DC  07111C     RCALL UART_Write
406:                               UART_Write((uint8_t *) ptr, sizeof(sample_datapacket_t));
0078DE  200041     MOV #0x4, W1
0078E0  780009     MOV W9, W0
0078E2  071119     RCALL UART_Write
407:                               headerbyte = ~headerbyte;
0078E4  97F04F     MOV.B [W15-12], W0
0078E6  EAC000     COM.B W0, W0
0078E8  9FF7C0     MOV.B W0, [W15-12]
408:                               UART_Write(&headerbyte, 1);
0078EA  200011     MOV #0x1, W1
0078EC  57806C     SUB W15, #0xC, W0
0078EE  071113     RCALL UART_Write
409:                   #elif STREAM_FORMAT_IS(SMLSS)
410:                               #if (SSI_JSON_CONFIG_VERSION == 2)
411:                               ssiv2_publish_sensor_data(0, (uint8_t*) ptr, sizeof(sample_datapacket_t));
412:                               #elif (SSI_JSON_CONFIG_VERSION == 1)
413:                               ssiv1_publish_sensor_data((uint8_t*) ptr, sizeof(sample_datapacket_t));
414:                               #endif
415:                   #endif //STREAM_FORMAT_IS(ASCII)
416:                               ptr += SAMPLES_PER_PACKET;
0078F0  4484E4     ADD W9, #0x4, W9
417:                               rdcnt -= SAMPLES_PER_PACKET;
0078F2  97B83F     MOV [W15-10], W0
0078F4  E90000     DEC W0, W0
0078F6  9FBFB0     MOV W0, [W15-10]
418:                               ringbuffer_advance_read_index(&data_sample_buffer, SAMPLES_PER_PACKET);
0078F8  200011     MOV #0x1, W1
0078FA  780008     MOV W8, W0
0078FC  0710B9     RCALL ringbuffer_advance_read_index
419:                           }
420:                       }
421:               #else   /* Template code for processing sensor data */
422:                       else {
423:                           
424:                           if (motor.state == MCSM_RUNNING )
425:                           {
426:                           
427:                               ringbuffer_size_t rdcnt;
428:                               sample_dataframe_t const *ptr = ringbuffer_get_read_buffer(&data_sample_buffer, &rdcnt);
429:                                while (rdcnt--) 
430:                               {
431:                                  int ret = sml_recognition_run((sample_data_t *) ptr++, 10, NUM_AXES,1);
432:                                   ringbuffer_advance_read_index(&data_sample_buffer, 1);
433:               
434:               
435:                                   /*Class ID
436:                                     1 - broken_bearing
437:                                     2 - Normal_operation
438:                                     3 - unbalanced_load*/
439:               
440:                                   if (ret >=0 && ret != clsid)
441:                                   {
442:                                       clsid = ret;
443:                                       tickrate = 0;
444:                                       if (clsid == 1 )
445:                                           printf("\r\033[K   Broken_bearing");
446:                                       else if (clsid == 2) 
447:                                           printf("\r\033[K   Normal_operation");
448:                                       else if (clsid == 3) {
449:                                           printf("\r\033[K   Unbalanced_load");
450:                                       }
451:               
452:                                   }
453:               
454:                               }
455:                               flag_print =1;
456:                           }
457:                       
458:                           else
459:                           {
460:                               if(flag_print)
461:                               {
462:                               printf("\r\033[K   Motor is in idle state! ");
463:                               flag_print=0;
464:                               clsid=0;
465:                               }
466:                               
467:                               ringbuffer_reset(&data_sample_buffer);
468:                               
469:                           }
470:                       }
471:               #endif //!STREAM_FORMAT_IS(NONE)
472:               
473:               #if STREAM_FORMAT_IS(SMLSS)
474:                       if (ssi_connected() && ringbuffer_get_read_items(&uartRxBuffer) >= DISCONNECT_CHARS) {
475:                           ssi_try_disconnect();
476:                           ringbuffer_advance_read_index(&uartRxBuffer, ringbuffer_get_read_items(&uartRxBuffer));
477:                           if (!ssi_connected()) {
478:                               /* STATE CHANGE - Application now waiting for connect */
479:                               tickrate = 0;
480:                              
481:                           }
482:                       }
483:               #endif
484:               
485:                   }
486:               
487:                   tickrate = 0;
007906  EF3228     CLR tickrate
007908  37FFFF     BRA .L38
00790A  500FE4     SUB W0, #0x4, [W15]
488:               
489:                   
490:                   /* Loop forever on error */
491:                   while (1) {};
492:               
493:                   return ( EXIT_FAILURE );
494:               }
495:               
496:               
497:               /*******************************************************************************
498:                End of File
499:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_tr_sensor.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Selects sensor data to keep from in input data stream
29:                *
30:                * \param rawdata Raw sensor data array pointer.
31:                * \param cols_to_use array of columns to use from rawdata
32:                * \param num_cols number of columns to use
33:                * \param frameData Pointer to the new framedata array
34:                */
35:                int32_t tr_sensor_sensors(SENSOR_DATA_T *rawdata, int32_t *cols_to_use, int32_t num_cols, SENSOR_DATA_T *frameData)
36:                {
00944E  781F88     MOV W8, [W15++]
009450  780280     MOV W0, W5
37:                    int32_t icol;
38:                
39:                    for (icol = 0; icol < num_cols; icol++)
009452  510FE0     SUB W2, #0x0, [W15]
009454  598FE0     SUBB W3, #0x0, [W15]
009456  34000B     BRA LE, .L2
009458  780401     MOV W1, W8
00945A  B80060     MUL.UU W0, #0x0, W0
009464  400061     ADD W0, #0x1, W0
009466  4880E0     ADDC W1, #0x0, W1
009468  500F82     SUB W0, W2, [W15]
00946A  588F83     SUBB W1, W3, [W15]
00946C  3AFFF7     BRA NZ, .L3
40:                    {
41:                        frameData[icol] = rawdata[cols_to_use[icol]];
00945C  BE0338     MOV.D [W8++], W6
00945E  430306     ADD W6, W6, W6
009460  428306     ADD W5, W6, W6
009462  781A16     MOV [W6], [W4++]
42:                    }
43:                
44:                    return num_cols;
45:                }
00946E  BE0002     MOV.D W2, W0
009470  78044F     MOV [--W15], W8
009472  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_total_energy.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t utils_model_total_energy(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t abs_val)
000034  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                #if SML_DEBUG
30:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || num_params != 0 || !pFV)
31:                	{
32:                		return 0;
33:                	}
34:                #endif
35:                
36:                	float sum = 0;
000010  000B66     NOP
37:                	int32_t row, icol;
38:                	short data;
39:                	int32_t base_index = kb_model->sg_index;
40:                	ringb *rb;
41:                
42:                	for (icol = 0; icol < num_cols; icol++)
000012  00091A     NOP
00002E  000920     NOP
00009E  000920     NOP
43:                	{
44:                		rb = kb_model->pringb + cols_to_use[icol];
000018  000920     NOP
000044  000C16     NOP
45:                		base_index = kb_model->sg_index;
00001C  000920     NOP
00003C  000920     NOP
00005A  000920     NOP
46:                
47:                		for (row = 0; row < kb_model->sg_length; row++)
000022  000BF6     NOP
00004C  000920     NOP
000094  000920     NOP
48:                		{
49:                			data = MOD_READ_RINGBUF(rb, base_index++);
000056  000920     NOP
00005E  000920     NOP
50:                			if(abs_val)
00006A  000920     NOP
51:                				sum += abs(data);
000074  000920     NOP
52:                			else
53:                				sum += data*data;
000086  000920     NOP
54:                		}
55:                	}
56:                	if(abs_val)
0000B4  000920     NOP
57:                		*pFV = (float)sum;
0000BE  000920     NOP
0000C0  000920     NOP
58:                	else
59:                		*pFV = ((float)sum)/ kb_model->sg_length;
0000C4  000920     NOP
60:                
61:                	return 1;
62:                }
0000D6  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_total_area.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t utils_model_total_area(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t abs_val)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                #define FG_AREA_TOTAL_AREA_NUM_PARAMS 1
30:                #define FG_AREA_TOTAL_AREA_SAMPLE_RATE_PARAM_IDX 0
31:                
32:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !params || num_params < FG_AREA_TOTAL_AREA_NUM_PARAMS || !pFV)
000010  000B66     NOP
33:                		return 0;
0000F8  00087E     NOP
34:                
35:                	int32_t fsum;
36:                	int32_t naxes, i;
37:                	ringb *rb;
38:                	int32_t start_index;
39:                
40:                	for (naxes = 0; naxes < num_cols; naxes++)
0000DE  000746     NOP
41:                	{
42:                		fsum = 0;
000040  000920     NOP
000060  000920     NOP
000078  000920     NOP
43:                		rb = kb_model->pringb + cols_to_use[naxes];
000048  000920     NOP
44:                		start_index = kb_model->sg_index & rb->mask;
000056  000920     NOP
000068  000920     NOP
45:                		for (i = 0; i < kb_model->sg_length; i++)
00005C  000920     NOP
000062  000920     NOP
000076  000920     NOP
0000B2  000920     NOP
46:                		{
47:                			if(abs_val)
000086  000920     NOP
000088  000920     NOP
00008A  000920     NOP
48:                				fsum += abs(rb->buff[start_index]);
000090  000920     NOP
000092  000920     NOP
49:                			else
50:                				fsum += rb->buff[start_index];
0000A4  000920     NOP
51:                			start_index = (start_index + 1) & rb->mask;
00007A  000920     NOP
0000C0  000920     NOP
52:                		}
53:                		*pFV++ = ((float)fsum) / params[FG_AREA_TOTAL_AREA_SAMPLE_RATE_PARAM_IDX];
0000D0  000920     NOP
0000D2  000712     NOP
54:                	}
55:                	return num_cols;
56:                }
000112  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_stats_max_min.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t utils_model_stats_max_min(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t max)
000054  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                	int32_t icol;
30:                	ringb *rb;
31:                	int16_t data, max_value, min_value;
32:                	int32_t start_index;
33:                
34:                #if SML_DEBUG
35:                	if (kb_model == NULL || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
36:                	{
37:                		return 0;
38:                	}
39:                #endif
40:                
41:                	
42:                	for (icol = 0; icol < num_cols; icol++)
000012  00091A     NOP
00009C  000920     NOP
43:                	{
44:                		rb = kb_model->pringb + cols_to_use[icol];
000026  000920     NOP
45:                		start_index = kb_model->sg_index & rb->mask;
000034  000920     NOP
46:                		max_value = rb->buff[start_index];
000042  000920     NOP
47:                		min_value = max_value;
000058  000920     NOP
000086  000920     NOP
48:                		for (int32_t row = 0; row < kb_model->sg_length; row++)
00004A  000920     NOP
00007E  000920     NOP
49:                		{
50:                			data = MOD_READ_RINGBUF(rb, start_index++);
00005A  000920     NOP
51:                			if(max == FIND_MAX_VAL)
000066  000920     NOP
52:                			{
53:                				if (data > max_value)
00006C  000920     NOP
54:                					max_value = data;
000078  000920     NOP
55:                			} else {
56:                				if (data < min_value)
000072  000920     NOP
57:                					min_value = data;
00007C  000920     NOP
58:                			}
59:                		}
60:                		if(max == FIND_MAX_VAL)
000088  000920     NOP
61:                			pFV[icol] = (FLOAT)max_value;
00008E  000920     NOP
62:                		else
63:                			pFV[icol] = (FLOAT)min_value;
000096  000920     NOP
64:                	}
65:                
66:                	return num_cols;
67:                }
0000B6  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_pct_time_over_threshold.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t utils_model_pct_time_over_threshold(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t threshold_val)
00006E  000B0E     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                #define FG_TIME_PCT_TIME_OVER_THRESHOLD_NUM_PARAMS 1
30:                #define FG_TIME_PCT_TIME_OVER_THRESHOLD_THRESHOLD_PARAM_IDX 0
31:                
32:                #if SML_DEBUG
33:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
34:                	{
35:                		return 0;
36:                	}
37:                #endif
38:                
39:                	int32_t icol;
40:                	int32_t base_index = kb_model->sg_index;
000012  00091A     NOP
41:                	int32_t threshold;
42:                	ringb *rb;
43:                	int16_t val;
44:                	int32_t start_index;
45:                	if(threshold_val)
000020  000920     NOP
46:                		threshold = (int32_t)params[FG_TIME_PCT_TIME_OVER_THRESHOLD_THRESHOLD_PARAM_IDX];
00002A  000C36     NOP
47:                	else
48:                		threshold = 0;
00001A  000920     NOP
49:                
50:                	for (icol = 0; icol < num_cols; icol++)
000032  000920     NOP
0000B2  000920     NOP
51:                	{
52:                		int32_t irow;
53:                		int32_t sum = 0;
000062  000920     NOP
00007A  000920     NOP
54:                		rb = kb_model->pringb + cols_to_use[icol];
000052  000920     NOP
55:                		start_index = base_index;
000042  000920     NOP
000076  000920     NOP
56:                		for (irow = 0; irow < kb_model->sg_length; irow++)
00005E  000920     NOP
000064  000920     NOP
000096  000920     NOP
000098  000920     NOP
57:                		{
58:                			val = MOD_READ_RINGBUF(rb, start_index++);
00006A  000920     NOP
00007E  000920     NOP
000080  000920     NOP
000082  000920     NOP
000084  000920     NOP
59:                			if (val > threshold)
00008A  000920     NOP
60:                			{
61:                				sum++;
000092  000920     NOP
62:                			}
63:                		}
64:                
65:                		pFV[icol] = (FLOAT)sum / (FLOAT)kb_model->sg_length;
00009E  000920     NOP
66:                	}
67:                
68:                	return num_cols;
69:                }
0000CA  0008B2     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_pct_time_over_sigma.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t utils_model_pct_time_over_sigma(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t sigma_level)
000090  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                
30:                #if SML_DEBUG
31:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
32:                	{
33:                		return 0;
34:                	}
35:                #endif
36:                	int32_t icol;
37:                	int32_t base_index = kb_model->sg_index;
000010  000B66     NOP
38:                	ringb *rb;
39:                	int32_t start_index;
40:                
41:                	for (icol = 0; icol < num_cols; icol++)
000014  000920     NOP
0000F8  00087E     NOP
42:                	{
43:                		int32_t irow;
44:                		int32_t sum = 0;
000070  000920     NOP
00009C  000920     NOP
45:                		rb = kb_model->pringb + cols_to_use[icol];
000026  000920     NOP
46:                
47:                		FLOAT tmp = mean(rb, base_index, kb_model->sg_length) + sigma_level * kb_std(rb, base_index, kb_model->sg_length);
000036  000920     NOP
48:                		start_index = base_index & rb->mask;
000024  000920     NOP
000062  000920     NOP
000078  000920     NOP
49:                		for (irow = 0; irow < kb_model->sg_length; irow++)
000066  000920     NOP
000072  000920     NOP
0000CE  000920     NOP
0000D0  000920     NOP
50:                		{
51:                			FLOAT val = (FLOAT)MOD_READ_RINGBUF(rb, start_index++);
00008A  000920     NOP
0000AA  000920     NOP
52:                			if (val > tmp)
0000BA  000920     NOP
53:                			{
54:                				sum++;
0000C2  000920     NOP
0000C4  000920     NOP
55:                			}
56:                		}
57:                
58:                		pFV[icol] = (FLOAT)sum / (FLOAT)kb_model->sg_length;
0000E0  00077A     NOP
59:                	}
60:                
61:                	return num_cols;
62:                }
00010E  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_mean_crossing_rate.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                #define NUM_PARAMS 1
28:                #define OFFSET_PARAM_IDX 0
29:                int32_t utils_model_mean_crossing_rate(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t offset)
000030  000920     NOP
30:                {
000000  040200     GOTO __resetPRI, __reset
31:                
32:                #if SML_DEBUG
33:                    if (!kb_model || !cols_to_use || num_cols != 2 || num_params != NUM_PARAMS || kb_model->sg_length <= 0 || !pFV)
34:                    {
35:                        return 0;
36:                    }
37:                #endif
38:                
39:                    int32_t sum = 0;
000024  000920     NOP
00003A  000920     NOP
40:                    int32_t base_index = kb_model->sg_index;
000010  000B66     NOP
000038  000920     NOP
41:                    ringb *rb;
42:                
43:                    rb = kb_model->pringb + cols_to_use[0];
000014  000920     NOP
44:                    for (int32_t i = 0; i < kb_model->sg_length; i++)
00001C  000920     NOP
000026  000920     NOP
000050  000920     NOP
45:                    {
46:                        sum += MOD_READ_RINGBUF(rb, base_index++); // mean = sum << num_bits(mask);
00002C  000920     NOP
00003E  000920     NOP
47:                    }
48:                    if(offset)
000058  000920     NOP
49:                        sum += (int32_t)params[OFFSET_PARAM_IDX] * kb_model->sg_length;
000062  000920     NOP
50:                    rb = kb_model->pringb + cols_to_use[1];
000078  000920     NOP
51:                    base_index = kb_model->sg_index;
52:                
53:                    *pFV++ = crossing_rate_over_sum(rb, base_index, kb_model->sg_length, sum);
00007E  000920     NOP
54:                
55:                    return 1;
56:                }
00008A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_crossing_rate.c
1:                 /*******************************************************************************
2:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
3:                 *
4:                 * Subject to your compliance with these terms, you may use Microchip software
5:                 * and any derivatives exclusively with Microchip products. It is your
6:                 * responsibility to comply with third party license terms applicable to your
7:                 * use of third party software (including open source software) that may
8:                 * accompany Microchip software.
9:                 *
10:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                * PARTICULAR PURPOSE.
14:                *
15:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
16:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
17:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
18:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
19:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
20:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
21:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
22:                 *******************************************************************************/
23:                
24:                #include "kbutils.h"
25:                
26:                int32_t util_model_check_positive_crossing(int32_t first, int32_t second, int32_t positive_threshold, int32_t negative_threshold)
27:                {
000000  040200     GOTO __resetPRI, __reset
28:                
29:                    int32_t ncrossings = 0;
000002  000000     NOP
00000A  000BD2     NOP
30:                
31:                    // Positive Threshold Value Crossing
32:                
33:                    // Postive Crossing
34:                    if ((first < positive_threshold) && (second > positive_threshold))
000004  000B9A     NOP
35:                    {
36:                        ncrossings++;
37:                    }
38:                
39:                    // Negative Threshold Value Crossing
40:                
41:                    // Postive Crossing
42:                    if ((first < negative_threshold) && (second > negative_threshold))
000016  000920     NOP
43:                    {
44:                        ncrossings++;
000022  000BF6     NOP
45:                    }
46:                
47:                    return ncrossings;
48:                }
000026  000920     NOP
49:                
50:                int32_t util_model_check_negative_crossing(int32_t first, int32_t second, int32_t positive_threshold, int32_t negative_threshold)
51:                {
000000  040200     GOTO __resetPRI, __reset
52:                
53:                    int32_t ncrossings = 0;
000002  000000     NOP
00000A  000BD2     NOP
54:                
55:                    // Positive Threshold Value Crossing
56:                    // Negative Crossing
57:                    if ((first > positive_threshold) && (second < positive_threshold))
000004  000B9A     NOP
58:                    {
59:                        ncrossings++;
60:                    }
61:                
62:                    // Negative Threshold Value Crossing
63:                    // Negative Crossing
64:                    if ((first > negative_threshold) && (second < negative_threshold))
000016  000920     NOP
65:                    {
66:                        ncrossings++;
000022  000BF6     NOP
67:                    }
68:                
69:                    return ncrossings;
70:                }
000026  000920     NOP
00002C  000920     NOP
71:                int32_t utils_model_crossing_rate(ringb *rb, int32_t base_index, int32_t num_rows, int32_t positive_threshold, int32_t negative_threshold, crossingType cross_type)
0000D0  000920     NOP
72:                {
000000  040200     GOTO __resetPRI, __reset
73:                	int32_t ncrossings = 0;
0000AE  000920     NOP
74:                	int32_t first;	// must be 32-bit int32_t for bit mask operations
75:                	int32_t second; // must be 32-bit int32_t for bit mask operations
76:                	int32_t i;
77:                	int32_t start_index = base_index & rb->mask;
000014  000920     NOP
78:                    int32_t threshold = 0;
00003E  000920     NOP
00009C  000920     NOP
79:                    int32_t sum = 0;
000038  000920     NOP
00004C  000920     NOP
00005C  000920     NOP
00006C  000920     NOP
00007C  000920     NOP
00008C  000920     NOP
80:                
81:                    if((cross_type == CROSSING_RATE) 
000020  000920     NOP
82:                            || (cross_type == CROSSING_RATE_OVER_SUM)
000024  000920     NOP
83:                            || (cross_type == NUMBER_OF_CROSSINGS_OVER_THRESHOLD)
000028  000920     NOP
84:                            || (cross_type == NUMBER_OF_POSITIVE_CROSSINGS_OVER_THRESHOLD) 
00002C  000920     NOP
85:                            || (cross_type == NUMBER_OF_NEGATIVE_CROSSINGS_OVER_THRESHOLD))
000030  000920     NOP
86:                        threshold = positive_threshold;
000044  000C16     NOP
000054  000920     NOP
000064  000920     NOP
000074  000920     NOP
000084  000920     NOP
87:                    else if(cross_type == CROSSING_RATE_OVER_ZERO)
000034  000920     NOP
000036  000920     NOP
88:                            sum = positive_threshold;
000094  000920     NOP
89:                
90:                	first = rb->buff[start_index++] - threshold;
0000A2  000920     NOP
0000A4  000920     NOP
0000A6  000920     NOP
0000BE  000920     NOP
91:                
92:                	for (i = 1; i < num_rows; i++)
0000B4  000920     NOP
0000B6  000920     NOP
0000B8  000920     NOP
0000BA  000920     NOP
0000BC  000920     NOP
000346  047626     GOTO ADC1_Deinitialize
000348  000000     NOP
00034A  049F0E     GOTO ADC1_Enable
00034C  000000     NOP
00034E  049F12     GOTO ADC1_Disable
000350  000000     NOP
000352  049F16     GOTO ADC1_SoftwareTriggerEnable
93:                	{
94:                		second = MOD_READ_RINGBUF(rb, start_index++);
0000E0  00077A     NOP
000272  E16C60     CP.B W13, #0
0002B2  EC2034     INC DSWPAG
0002B4  A0F00A     BSET W10, #15
0002E4  785D05     MOV.B W5, [W10++]
000302  0484BE     GOTO KB_data_segmentation_PIPELINE_1_RANK_0
000320  000000     NOP
000324  000000     NOP
000326  0488B2     GOTO ADC1_IndividualChannelInterruptEnable
000338  000000     NOP
00033A  049CCE     GOTO ADC1_SharedCorePowerEnable
00033C  000000     NOP
00033E  047D80     GOTO ADC1_PWMTriggerSourceSet
000340  000000     NOP
000342  046F3A     GOTO ADC1_Initialize
000344  000000     NOP
95:                
96:                        switch(cross_type)
0000FC  000920     NOP
97:                        {
98:                            case CROSSING_RATE:
99:                                second = second - threshold;
000122  000920     NOP
000148  000920     NOP
000328  000000     NOP
00032A  04890C     GOTO ADC1_IndividualChannelInterruptDisable
100:                               if (second == 0)
00012A  000920     NOP
101:                                   continue;
102:                               if (first * second < 0)
00012C  000920     NOP
103:                               {
104:                                   ncrossings++;
00013C  000920     NOP
105:                               }
106:                           break;
107:                           case CROSSING_RATE_OVER_ZERO:
108:                               second = (second * num_rows) - sum;
00014C  000920     NOP
00014E  000920     NOP
00019C  FFFFFF     NOPR
00032C  000000     NOP
00032E  048D7C     GOTO ADC1_IndividualChannelInterruptFlagClear
109:                               if (second == 0)
000164  000920     NOP
110:                                   continue;
111:                               if (((first & 0x8000) ^ (second & 0x8000)) == 0x8000)
0000DC  000920     NOP
000166  000920     NOP
112:                               {
113:                                   ncrossings++;
000190  000920     NOP
114:                               }
115:                           break;
116:                           case CROSSING_RATE_OVER_SUM:
117:                               second = (second * num_rows) - sum;
0001A0  FFFFFF     NOPR
0001F0  FFFFFF     NOPR
000330  000000     NOP
000332  047CE4     GOTO ADC1_IndividualChannelInterruptPrioritySet
118:                           		if (second == 0)
0001B8  FFFFFF     NOPR
119:                                       continue;
120:                                   if (((first & 0x80000000) ^ (second & 0x80000000)) == 0x80000000)
0001BA  FFFFFF     NOPR
121:                                   {
122:                                       ncrossings++;
0001E4  FFFFFF     NOPR
123:                                   }
124:                           break;
125:                           case NUMBER_OF_CROSSINGS_OVER_THRESHOLD:
126:                                   second = second - threshold;
0001F4  FFFFFF     NOPR
000232  000000     NOP
000334  000000     NOP
000336  049474     GOTO ADC1_CorePowerEnable
127:                           		if (((first & 0x80000000) ^ (second & 0x80000000)) == 0x80000000)
0001FC  FFFFFF     NOPR
128:                                   {
129:                                       ncrossings++;
000226  320001     BRA Z, 0x22A
130:                                   }
131:                           break;
132:                           case NUMBER_OF_POSITIVE_CROSSINGS_OVER_THRESHOLD:
133:                           		if (((first & 0x80000000) ^ (second & 0x80000000)) == 0x80000000)
0000D8  000920     NOP
000236  000000     NOP
000238  DA4000     BREAK
00023A  FE0000     RESET
134:                                   {
135:                                       if (second > first)
000260  EB0600     CLR W12
000262  DE6F47     LSR W13, #7, W14
000264  B207FD     AND #0x7F, W13
136:                                       {
137:                                           ncrossings++;
000266  8801AE     MOV W14, DSWPAG
000268  E16C63     CP.B W13, #3
138:                                       }
139:                                   }
140:                           break;
141:                           case NUMBER_OF_NEGATIVE_CROSSINGS_OVER_THRESHOLD:
142:                           		if (((first & 0x80000000) ^ (second & 0x80000000)) == 0x80000000)
000276  EB4D00     CLR.B [W10]
143:                                   {
144:                                       if (first > second)
0002A0  78048A     MOV W10, W9
145:                                       {
146:               
147:                                           ncrossings++;
0002A6  4D0FE2     ADDC W10, #0x2, [W15]
148:                                       }
149:                                   }
150:                           break;
151:                           case NUMBER_OF_CROSSINGS_OVER_THRESHOLD_REGIONS:
152:                               ncrossings += util_model_check_positive_crossing(first, second, positive_threshold, negative_threshold);
0002B6  E9058B     DEC W11, W11
0002B8  32000F     BRA Z, 0x2D8
0002BA  BA4D25     TBLRDL.B [W5--], [W10]
0002BC  E8050A     INC W10, W10
0002BE  390002     BRA NC, 0x2C4
0002C0  EC2034     INC DSWPAG
0002C2  A0F00A     BSET W10, #15
0002C4  E9058B     DEC W11, W11
0002D4  A0F00A     BSET W10, #15
0002D6  E9058B     DEC W11, W11
153:                               ncrossings += util_model_check_negative_crossing(first, second, positive_threshold, negative_threshold);                
0002C6  320008     BRA Z, 0x2D8
0002C8  E0000C     CP0 W12
0002CA  320006     BRA Z, 0x2D8
0002CC  BACD15     TBLRDH.B [W5], [W10]
0002CE  E8050A     INC W10, W10
0002D0  390002     BRA NC, 0x2D6
0002D2  EC2034     INC DSWPAG
0002D8  E88489     INC2 W9, W9
0002DA  B4A054     ADDC TBLPAG
0002DC  E0000B     CP0 W11
0002DE  3AFFE2     BRA NZ, __memcpyd3extended
0002E0  060000     RETURN
0002E2  BA0299     TBLRDL [W9], W5
154:                           break;
0002E6  E9058B     DEC W11, W11
155:                           case NUMBER_OF_POSITIVE_CROSSINGS_OVER_THRESHOLD_REGIONS:
156:                               ncrossings += util_model_check_positive_crossing(first, second, positive_threshold, negative_threshold);
0002E8  32FFF7     BRA Z, 0x2D8
0002EA  DE2AC8     LSR W5, #8, W5
0002EC  785D05     MOV.B W5, [W10++]
0002EE  E9058B     DEC W11, W11
0002F0  32FFF3     BRA Z, 0x2D8
0002F2  E0000C     CP0 W12
0002F4  32FFF1     BRA Z, 0x2D8
0002F6  BADD19     TBLRDH.B [W9], [W10++]
0002F8  37FFEE     BRA 0x2D6
0002FA  0477A4     GOTO KB_feature_gen_model_PIPELINE_1_RANK_0
0002FC  000000     NOP
0002FE  04957E     GOTO KB_data_streaming_PIPELINE_1_RANK_0
000300  000000     NOP
157:                           break;
000304  000000     NOP
158:                           case NUMBER_OF_NEGATIVE_CROSSINGS_OVER_THRESHOLD_REGIONS:
159:                               ncrossings += util_model_check_negative_crossing(first, second, positive_threshold, negative_threshold);
000306  049D30     GOTO KB_recognize_vector_PIPELINE_1_RANK_0
000308  000000     NOP
00030A  048FBC     GOTO KB_feature_transform_PIPELINE_1_RANK_0
00030C  000000     NOP
00030E  049FB4     GOTO ADC1_CommonCallback
000310  000000     NOP
000312  049FB6     GOTO ADC1_ChannelCallback
000314  000000     NOP
000316  049FB8     GOTO ADC1_ComparatorCallback
000318  000000     NOP
00031A  049DD2     GOTO ADC1_ChannelCallbackRegister
00031C  000000     NOP
00031E  049DDA     GOTO ADC1_ComparatorCallbackRegister
160:                           break;
000322  047554     GOTO ADC1_ChannelTasks
161:                           default:
162:                           break;
163:                       }
164:               
165:               		first = second;
166:               	}
167:               
168:               	return ncrossings;
169:               }
000354  000000     NOP
000356  049F1A     GOTO ADC1_SoftwareTriggerDisable
000358  000000     NOP
00035A  049FB2     GOTO ADC1_ChannelSelect
00035C  000000     NOP
00035E  048CA2     GOTO ADC1_ConversionResultGet
000360  000000     NOP
000362  04879A     GOTO ADC1_IsConversionComplete
000364  000000     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_cross_difference.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                #define NUM_PARAMS 0
28:                
29:                int32_t utils_model_cross_difference(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t min_max)
30:                {
000000  040200     GOTO __resetPRI, __reset
31:                
32:                #if SML_DEBUG
33:                    if (!kb_model || !cols_to_use || kb_model->sg_length <= 0 || num_cols <= 0 || num_params != NUM_PARAMS || !pFV)
34:                    {
35:                        return 0;
36:                    }
37:                #endif
38:                
39:                    int32_t i, index_col1, index_col2;
40:                    int16_t val_col1, val_col2, max_col1, max_col2;
41:                    ringb *rb1;
42:                    ringb *rb2;
43:                    int32_t base_index = kb_model->sg_index;
000008  000B4A     NOP
44:                
45:                    rb1 = kb_model->pringb + cols_to_use[0];
00000C  000BB6     NOP
000034  000920     NOP
46:                    rb2 = kb_model->pringb + cols_to_use[1];
47:                
48:                    index_col1 = base_index;
49:                    index_col2 = base_index;
50:                
51:                    max_col1 = KB_SHORT_INT_MIN;
52:                    max_col2 = KB_SHORT_INT_MIN;
53:                    int32_t final_index = base_index + kb_model->sg_length;
000010  000B66     NOP
54:                
55:                    for (i = base_index; i < final_index; i++)
000018  000920     NOP
56:                    {
57:                        val_col1 = MOD_READ_RINGBUF(rb1, i);
58:                        val_col2 = MOD_READ_RINGBUF(rb2, i);
59:                
60:                        if (val_col1 < max_col1)
61:                        {
62:                            max_col1 = val_col1;
63:                            index_col1 = i;
64:                        }
65:                
66:                        if (val_col2 < max_col2)
67:                        {
68:                            max_col2 = val_col2;
69:                            index_col2 = i;
70:                        }
71:                    }
72:                
73:                    if(min_max)
00002A  000C36     NOP
74:                    {
75:                        if (max_col1 > max_col2)
76:                        {
77:                            *pFV = (FLOAT)(max_col1 - rb2->buff[index_col1 & rb2->mask]);
78:                        }
79:                        else
80:                        {
81:                            *pFV = (FLOAT)(max_col2 - rb1->buff[index_col2 & rb1->mask]);
000038  000920     NOP
82:                        }
83:                    }
84:                    else
85:                    {
86:                        *pFV = (FLOAT)(max_col1 - max_col2);
00004E  000920     NOP
87:                    }
88:                
89:                    return 1;
90:                }
000052  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_model_cross_column.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                #define NUM_PARAMS 0
28:                
29:                int32_t utils_model_cross_column(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV, int32_t abs_val)
000038  000920     NOP
30:                {
000000  040200     GOTO __resetPRI, __reset
31:                #if SML_DEBUG
32:                	if (!kb_model || !cols_to_use || kb_model->sg_length <= 0 || num_cols <= 0 || num_params != NUM_PARAMS || !pFV)
33:                	{
34:                		return 0;
35:                	}
36:                #endif
37:                
38:                	//uint64_t sum = 0;
39:                	int32_t row, icol;
40:                	int16_t max_col = 1;
000028  000920     NOP
41:                	ringb *rb;
42:                	int32_t start_index;
43:                	int16_t data, max_value;
44:                	rb = kb_model->pringb + cols_to_use[0];
00000C  000BB6     NOP
45:                	start_index = kb_model->sg_index & rb->mask;
000018  000920     NOP
46:                	max_value = rb->buff[start_index];
000020  000920     NOP
47:                	for (icol = 0; icol < num_cols; icol++)
00002C  000920     NOP
0000E0  00077A     NOP
48:                	{
49:                		rb = kb_model->pringb + cols_to_use[icol];
000054  000920     NOP
50:                		start_index = kb_model->sg_index & rb->mask;
000048  000920     NOP
000060  000920     NOP
000068  000920     NOP
51:                		for (row = 0; row < kb_model->sg_length; row++)
000032  000920     NOP
000050  000920     NOP
000062  000920     NOP
00007A  000920     NOP
0000B2  000920     NOP
52:                		{
53:                			if(abs_val)
00008A  000920     NOP
54:                				data = abs(rb->buff[start_index]);
000094  000920     NOP
55:                			else
56:                				data = rb->buff[start_index];
0000A2  000920     NOP
57:                			start_index = (start_index + 1) & rb->mask;
00007E  000920     NOP
0000C0  000920     NOP
58:                			if (data > max_value)
00007C  000920     NOP
0000AA  000920     NOP
59:                			{
60:                				max_col = icol + 1;
61:                				max_value = data;
0000B0  000920     NOP
0000B2  000920     NOP
62:                			}
63:                		}
64:                	}
65:                	*pFV = (FLOAT)max_col;
0000EA  000920     NOP
66:                
67:                	return 1;
68:                }
0000F4  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_variance.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_variance(ringb *pringb, int32_t base_index, int32_t offset, int32_t nrows)
000038  000920     NOP
00003A  000920     NOP
00003C  000920     NOP
00003E  000920     NOP
000040  000920     NOP
000042  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    int32_t i;
30:                    FLOAT sum = 0.0;
00001C  000920     NOP
31:                    int32_t start_index = base_index + offset;
000028  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
00002E  000920     NOP
000030  000920     NOP
32:                
33:                    // Compute the mean of the input data
34:                    FLOAT xmean = buffer_mean(pringb, base_index, offset, nrows);
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
35:                
36:                    for (i = 0; i < nrows; i++)
00001E  000920     NOP
000020  000920     NOP
000022  000BF6     NOP
000024  000920     NOP
000026  000920     NOP
000028  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
000066  000920     NOP
000068  000920     NOP
00006A  000920     NOP
00006C  000920     NOP
00006E  000B0E     NOP
000070  000920     NOP
000072  000920     NOP
000074  000920     NOP
000076  000920     NOP
000078  000920     NOP
37:                    {
38:                        FLOAT tmp = (FLOAT)MOD_READ_RINGBUF(pringb, start_index++) - xmean;
000030  000920     NOP
000032  000920     NOP
000034  000920     NOP
000036  000920     NOP
000038  000920     NOP
000044  000C16     NOP
000046  000920     NOP
000048  000920     NOP
00004A  000920     NOP
00004C  000920     NOP
00004E  000920     NOP
000050  000920     NOP
000052  000920     NOP
000054  000920     NOP
000056  000920     NOP
000058  000920     NOP
00005A  000920     NOP
00005C  000920     NOP
00005E  000920     NOP
39:                        sum += tmp * tmp;
00005A  000920     NOP
00005C  000920     NOP
00005E  000920     NOP
000060  000920     NOP
000062  000920     NOP
000064  000920     NOP
000066  000920     NOP
000068  000920     NOP
00006A  000920     NOP
40:                    }
41:                
42:                    return (FLOAT)(sum / nrows);
000070  000920     NOP
000072  000920     NOP
000074  000920     NOP
000076  000920     NOP
000078  000920     NOP
00007A  000920     NOP
43:                }
00007C  000920     NOP
00007E  000920     NOP
000080  000920     NOP
000082  000920     NOP
000084  000920     NOP
000086  000920     NOP
000088  000920     NOP
00008A  000920     NOP
00008C  000920     NOP
00008E  000920     NOP
000090  000920     NOP
000092  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_std.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_standard_deviation(ringb *pringb, int32_t base_index, int32_t offset, int32_t nrows)
28:                {
29:                    return SQRT(buffer_variance(pringb, base_index, offset, nrows));
000000  040200     GOTO __resetPRI, __reset
30:                }
000004  000B9A     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_pass_threshold.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                    Check if buffer has value greater than some threshold
29:                
30:                    Return true if buffer has value greater than threshold else false
31:                	@param pringb - pointer to ring buffer
32:                	@param offset -offset to start at in ring buffer
33:                	@param col - the axis of the data to get form the ring buffer
34:                	@param datalen - the len of the data to use in the ring buffer
35:                    @param threshold - value to check against
36:                
37:                */
38:                
39:                bool buffer_pass_threshold(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen, int32_t threshold)
40:                {
000000  040200     GOTO __resetPRI, __reset
41:                    int32_t irow;
42:                    int32_t start_index = base_index + offset;
000012  00091A     NOP
43:                    for (irow = 0; irow < datalen; irow++)
00000C  000BB6     NOP
000034  000920     NOP
000050  000920     NOP
44:                    {
45:                        if (abs(MOD_READ_RINGBUF(pringb, start_index++)) > threshold)
000016  000920     NOP
00002A  000C36     NOP
000038  000920     NOP
46:                        {
47:                            return true;                
000028  000920     NOP
00005E  000920     NOP
48:                        }
49:                    }
50:                
51:                    return false;
00000A  000BD2     NOP
00005A  000920     NOP
52:                }
000060  000920     NOP
53:                
54:                
55:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_min_max.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                int32_t buffer_min_max(ringb *pringb, int32_t base_index, int32_t nrows, int32_t offset, int32_t *min, int32_t *max)
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    int32_t i;
30:                    int16_t dmin = KB_SHORT_INT_MAX;
00001A  000920     NOP
00003E  000920     NOP
31:                    int16_t dmax = KB_SHORT_INT_MIN;
000018  000920     NOP
00003C  000920     NOP
00003E  000920     NOP
32:                    int16_t temp;
33:                    int32_t start_index = base_index + offset;
00000C  000BB6     NOP
34:                
35:                    for (i = 0; i < nrows; i++)
000006  000B2E     NOP
000008  000B4A     NOP
00000A  000BD2     NOP
000034  000920     NOP
36:                    {
37:                        temp = MOD_READ_RINGBUF(pringb, start_index++);
000010  000B66     NOP
00001C  000920     NOP
38:                        if (temp > dmax)
39:                            dmax = temp;
40:                        if (temp < dmin)
41:                            dmin = temp;
42:                    }
43:                
44:                    *max = dmax;
000040  000920     NOP
45:                    *min = dmin;
000046  000920     NOP
46:                
47:                    return 1;
48:                }
00004A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_min.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                    min value in buffer
29:                
30:                    Return the min of the elements in an array.
31:                	@param pringb - pointer to ring buffer
32:                	@param offset -offset to start at in ring buffer
33:                	@param col - the axis of the data to get form the ring buffer
34:                	@param datalen - the len of the data to use in the ring buffer
35:                
36:                */
37:                
38:                int16_t buffer_min(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
00001C  000920     NOP
39:                {
000000  040200     GOTO __resetPRI, __reset
40:                    int32_t irow;
41:                    int16_t val;
42:                    int32_t start_index = (base_index + offset) & pringb->mask;
000002  000000     NOP
000004  000B9A     NOP
000006  000B2E     NOP
43:                    int16_t fmin = pringb->buff[start_index];
00000E  000920     NOP
44:                
45:                    for (irow = 0; irow < datalen; irow++)
000016  000920     NOP
000032  000920     NOP
000034  000920     NOP
000036  000920     NOP
000038  000920     NOP
46:                    {
47:                        val = MOD_READ_RINGBUF(pringb, start_index++);
000020  000920     NOP
48:                        if (fmin > val)
49:                            fmin = val;
50:                    }
51:                
52:                    return fmin;
53:                }
000038  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_median.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_median(ringb *pringb, int32_t index, int32_t datalen)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                
30:                    SENSOR_DATA_T *psorted;
31:                
32:                    psorted = sorted_copy(pringb, index, datalen, 0);
000004  000B9A     NOP
33:                
34:                    int32_t mid_index = datalen >> 1; // mid_index = n/2 where n is number of samples
000008  000B4A     NOP
35:                
36:                    if (datalen & 1) // if n is odd, return the element in the middle
00000C  000BB6     NOP
37:                    {
38:                        return (FLOAT)psorted[mid_index];
000010  000B66     NOP
39:                    }
40:                    else // if there is an even number of elements, return mean of the two elements in the middle
41:                    {
42:                        return ((FLOAT)(psorted[mid_index] + psorted[mid_index - 1])) / 2.0;
00001C  000920     NOP
43:                    }
44:                }
000034  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_mean.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_mean(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    return buffer_cumulative_sum_0(pringb, base_index, offset, datalen, BUFFER_NO_ABS)/(FLOAT)datalen;
000006  000B2E     NOP
000008  000B4A     NOP
30:                }
00001A  000920     NOP
31:                
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_max.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                    min value in buffer
29:                
30:                    Return the min of the elements in an array.
31:                	@param pringb - pointer to ring buffer
32:                	@param offset -offset to start at in ring buffer
33:                	@param col - the axis of the data to get form the ring buffer
34:                	@param datalen - the len of the data to use in the ring buffer
35:                
36:                */
37:                int16_t buffer_max(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
38:                {
39:                    return buffer_max_0(pringb, base_index, offset, datalen, BUFFER_NO_ABS);
000000  040200     GOTO __resetPRI, __reset
40:                }
000008  000B4A     NOP
00000A  000BD2     NOP
41:                
42:                int16_t buffer_max_0(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen, int32_t abs_val)
43:                {
000000  040200     GOTO __resetPRI, __reset
44:                    int32_t irow;
45:                    int16_t fmax;
46:                    int16_t val;
47:                    int32_t start_index = (base_index + offset) & pringb->mask;
00000E  000920     NOP
48:                
49:                    fmax = pringb->buff[start_index];
00001C  000920     NOP
50:                
51:                    for (irow = 0; irow < datalen; irow++)
000024  000920     NOP
00004E  000920     NOP
52:                    {
53:                        if(abs_val)
000030  000920     NOP
54:                            val = abs(pringb->buff[start_index]);
000036  000920     NOP
55:                        else
56:                            val = pringb->buff[start_index];
000042  000920     NOP
57:                        if (fmax < val)
58:                            fmax = val;
59:                        start_index = (start_index + 1) & pringb->mask;
00002C  000920     NOP
000058  000920     NOP
60:                    }
61:                
62:                    return fmax;
63:                }
000064  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_cumsum.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_cumulative_sum_0(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen, int32_t abs_val)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    int32_t i;
30:                    int32_t sum = 0;
00000E  000920     NOP
000020  000920     NOP
31:                    int32_t start_index = (base_index + offset) & pringb->mask;
00000C  000BB6     NOP
000016  000920     NOP
32:                
33:                    for (i = 0; i < datalen; i++)
000010  000B66     NOP
000022  000BF6     NOP
000058  000920     NOP
34:                    {
35:                        if(abs_val)
00002C  000920     NOP
36:                            sum += abs(pringb->buff[start_index]);
000036  000920     NOP
37:                        else
38:                            sum += pringb->buff[start_index];
00004A  000920     NOP
39:                        start_index = (start_index + 1) & pringb->mask;
000024  000920     NOP
000066  000920     NOP
40:                    }
41:                
42:                    return (FLOAT)sum;
000072  000920     NOP
43:                }
000076  000920     NOP
44:                
45:                FLOAT buffer_cumulative_sum(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
46:                {
47:                    return buffer_cumulative_sum_0(pringb, base_index, offset, datalen, BUFFER_NO_ABS);
000000  040200     GOTO __resetPRI, __reset
48:                }
000008  000B4A     NOP
00000A  000BD2     NOP
49:                
50:                #if 0 //these 2 loops makes the code clumsy 
51:                FLOAT buffer_cumulative_sum_0(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen, int32_t abs_val)
52:                {
53:                    int32_t i;
54:                    int32_t sum = 0;
55:                    int32_t start_index = (base_index + offset) & pringb->mask;;
56:                    int32_t rb_length = pringb->mask + 1;
57:                    int32_t final_index = start_index + datalen;
58:                
59:                    if(final_index > pringb->mask)
60:                    {
61:                        for (i = start_index; i < rb_length; i++)
62:                        {
63:                            if(abs_val)
64:                                sum += abs(pringb->buff[i]);
65:                            else
66:                                sum += pringb->buff[i];
67:                        }
68:                        start_index = 0;
69:                        final_index = final_index - rb_length;
70:                    }
71:                    if(final_index > 0)
72:                    {
73:                        for (i = start_index; i < final_index; i++)
74:                        {
75:                            if(abs_val)
76:                                sum += abs(pringb->buff[i]);
77:                            else
78:                                sum += pringb->buff[i];
79:                        }
80:                    }
81:                
82:                    return (FLOAT)sum;
83:                }
84:                
85:                #endif
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_autoscale.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                void buffer_autoscale(ringb *pringb, int32_t base_index, int32_t length)
00001C  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                
30:                    int32_t idx;
31:                    int16_t value = 0;
32:                    int32_t min = KB_SHORT_INT_MAX;
000026  000920     NOP
33:                    int32_t max = KB_SHORT_INT_MIN;
000022  000BF6     NOP
34:                    float sf = 0;
35:                    int32_t start_index = base_index;
000020  000920     NOP
36:                
37:                    // find min,max:
38:                    for (idx = 0; idx < length; idx++)
000012  00091A     NOP
000048  000920     NOP
000074  000920     NOP
000076  000920     NOP
39:                    {
40:                        value = MOD_READ_RINGBUF(pringb, start_index++); 
000018  000920     NOP
00002A  000C36     NOP
41:                        if (value < min)
000036  000920     NOP
42:                        {
43:                            min = value;
44:                        }
45:                        if (value > max)
46:                        {
47:                            max = value;
48:                        }
49:                    }
50:                
51:                    // get abs of min,max:
52:                    if (max < 0)
53:                    {
54:                        max *= -1;
55:                    }
56:                    if (min < 0)
57:                    {
58:                        min *= -1;
59:                    }
60:                
61:                    // calc scale factor based on larger abs value:
62:                    if (max >= min)
000066  000920     NOP
63:                    {
64:                        if (max > 0)
00006C  000920     NOP
65:                        {
66:                            sf = 32767 / (float)max;
000078  000920     NOP
67:                        }
68:                    }
69:                    else
70:                    {
71:                        if (min > 0)
000086  000920     NOP
72:                        {
73:                            sf = 32767 / (float)min;
00008C  000920     NOP
74:                        }
75:                    }
76:                
77:                    if (sf <= 1.)
00009A  000920     NOP
78:                    {
79:                        return;
80:                    }
81:                
82:                    for (idx = base_index; idx < base_index + length; idx++)
0000A6  000920     NOP
0000BC  000920     NOP
83:                    {
84:                        multiply_axis_data_float(pringb, idx, sf);
0000B4  000920     NOP
85:                    }
86:                }
0000C6  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_argmax.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                    min value in buffer
29:                
30:                    Return the min of the elements in an array.
31:                	@param pringb - pointer to ring buffer
32:                	@param offset -offset to start at in ring buffer
33:                	@param col - the axis of the data to get form the ring buffer
34:                	@param datalen - the len of the data to use in the ring buffer
35:                
36:                */
37:                
38:                int32_t buffer_argmax(ringb *pringb, int32_t base_index, int32_t datalen)
000024  000920     NOP
39:                {
000000  040200     GOTO __resetPRI, __reset
40:                    int32_t irow;
41:                    int16_t val;
42:                    int32_t imax = 0;
000018  000920     NOP
000020  000920     NOP
43:                    int32_t start_index = base_index & pringb->mask;
000008  000B4A     NOP
44:                    int16_t fmax = pringb->buff[start_index];
000010  000B66     NOP
45:                
46:                    for (irow = 0; irow < datalen; irow++)
00001A  000920     NOP
000022  000BF6     NOP
000036  000920     NOP
47:                    {
48:                        val = MOD_READ_RINGBUF(pringb, start_index++); 
000026  000920     NOP
49:                        if (fmax < val)
00002E  000920     NOP
000034  000920     NOP
50:                        {
51:                            fmax = val;
000032  000920     NOP
52:                            imax = irow;
53:                        }
54:                    }
55:                
56:                    return imax;
57:                }
000040  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_abssum.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_absolute_cumulative_sum(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    return buffer_cumulative_sum_0(pringb, base_index, offset, datalen, BUFFER_USE_ABS);
000002  000000     NOP
30:                }
00000C  000BB6     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_absmean.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT buffer_absolute_mean(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    return buffer_cumulative_sum_0(pringb, base_index, offset, datalen, BUFFER_USE_ABS)/(FLOAT)datalen;
000006  000B2E     NOP
30:                }
00001C  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_buffer_abs_max.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                    return the absolute value in buffer
29:                
30:                    Return the absolute value of the elements in an array.
31:                    @param pringb - pointer to ring buffer
32:                    @param offset -offset to start at in ring buffer
33:                    @param col - the axis of the data to get form the ring buffer
34:                    @param datalen - the len of the data to use in the ring buffer
35:                
36:                */
37:                
38:                int16_t buffer_abs_max(ringb *pringb, int32_t base_index, int32_t offset, int32_t datalen)
39:                {
000000  040200     GOTO __resetPRI, __reset
40:                    return buffer_max_0(pringb, base_index, offset, datalen, BUFFER_USE_ABS);
000002  000000     NOP
41:                }
00000C  000BB6     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_bitwise_abs_val.c
1:                 /*******************************************************************************
2:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
3:                 *
4:                 * Subject to your compliance with these terms, you may use Microchip software
5:                 * and any derivatives exclusively with Microchip products. It is your
6:                 * responsibility to comply with third party license terms applicable to your
7:                 * use of third party software (including open source software) that may
8:                 * accompany Microchip software.
9:                 *
10:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                * PARTICULAR PURPOSE.
14:                *
15:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
16:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
17:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
18:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
19:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
20:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
21:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
22:                 *******************************************************************************/
23:                
24:                #include "kbutils.h"
25:                
26:                uint16_t bitwise_absolute_value(int16_t x)
27:                {
28:                    int16_t y = (x >> 15);
000000  040200     GOTO __resetPRI, __reset
29:                
30:                    return (x ^ y) - y;
000002  000000     NOP
31:                }
000006  000B2E     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_array_max_uint8.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                void array_max_uint8(
000026  000920     NOP
000046  000920     NOP
28:                    uint8_t *pSrc,
29:                    uint32_t blockSize,
30:                    uint8_t *pResult)
31:                {
000000  040200     GOTO __resetPRI, __reset
32:                #ifndef ARM_MATH_CM0_FAMILY
33:                    /* Run the below code for Cortex-M4 and Cortex-M3 */
34:                
35:                    uint8_t maxVal1, maxVal2, out; /* Temporary variables to store the output value. */
36:                    uint32_t blkCnt, count;        /* loop counter */
37:                
38:                    /* Initialise the count value. */
39:                    count = 0u;
40:                    /* Load first input value that act as reference value for comparision */
41:                    out = *pSrc++;
000006  000B2E     NOP
00001C  000920     NOP
42:                
43:                    /* Loop unrolling */
44:                    blkCnt = (blockSize - 1u) >> 2u;
000008  000B4A     NOP
00001A  000920     NOP
45:                
46:                    /* Run the below code for Cortex-M4 and Cortex-M3 */
47:                    while (blkCnt > 0u)
000014  000920     NOP
000044  000C16     NOP
000048  000920     NOP
48:                    {
49:                        /* Initialize maxVal to the next consecutive values one by one */
50:                        maxVal1 = *pSrc++;
00001E  000920     NOP
51:                
52:                        maxVal2 = *pSrc++;
000020  000920     NOP
53:                
54:                        /* compare for the maximum value */
55:                        if (out < maxVal1)
56:                        {
57:                            /* Update the maximum value and its index */
58:                            out = maxVal1;
59:                        }
60:                
61:                        maxVal1 = *pSrc++;
000022  000BF6     NOP
62:                
63:                        /* compare for the maximum value */
64:                        if (out < maxVal2)
65:                        {
66:                            /* Update the maximum value and its index */
67:                            out = maxVal2;
68:                        }
69:                
70:                        maxVal2 = *pSrc++;
000024  000920     NOP
71:                
72:                        /* compare for the maximum value */
73:                        if (out < maxVal1)
74:                        {
75:                            /* Update the maximum value and its index */
76:                            out = maxVal1;
77:                        }
78:                
79:                        /* compare for the maximum value */
80:                        if (out < maxVal2)
81:                        {
82:                            /* Update the maximum value and its index */
83:                            out = maxVal2;
84:                        }
85:                
86:                        count += 4u;
87:                
88:                        /* Decrement the loop counter */
89:                        blkCnt--;
000040  000920     NOP
90:                    }
91:                
92:                    /* if (blockSize - 1u) is not multiple of 4 */
93:                    blkCnt = (blockSize - 1u) % 4u;
00004A  000920     NOP
94:                
95:                #else
96:                
97:                    /* Run the below code for Cortex-M0 */
98:                    uint8_t maxVal1, out;      /* Temporary variables to store the output value. */
99:                    uint32_t blkCnt, outIndex; /* loop counter */
100:               
101:                   /* Initialise the index value to zero. */
102:                   outIndex = 0u;
103:                   /* Load first input value that act as reference value for comparision */
104:                   out = *pSrc++;
105:               
106:                   blkCnt = (blockSize - 1u);
107:               
108:               #endif /* #ifndef ARM_MATH_CM0_FAMILY */
109:               
110:                   while (blkCnt > 0u)
00004E  000920     NOP
000060  000920     NOP
111:                   {
112:                       /* Initialize maxVal to the next consecutive values one by one */
113:                       maxVal1 = *pSrc++;
000054  000920     NOP
114:               
115:                       /* compare for the maximum value */
116:                       if (out < maxVal1)
117:                       {
118:                           /* Update the maximum value and it's index */
119:                           out = maxVal1;
120:                       }
121:                       /* Decrement the loop counter */
122:                       blkCnt--;
00005C  000920     NOP
123:                   }
124:               
125:                   /* Store the maximum value and its index into destination pointers */
126:                   *pResult = out;
000062  000920     NOP
127:               }
000064  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/utils_array.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                /* Support function for data in a contigous array, these will typically be used to act on our tempData buffer */
26:                
27:                #include <stdbool.h>
28:                #include "kbutils.h"
29:                #include "fftr_utils.h"
30:                
31:                ////////////////////////////////////////////////////////////////////////////////////////////
32:                // NOTE: this is here to make it easier to debug off-device (during development) using the
33:                // unit test (gtest) framework and printf()
34:                #ifdef UTEST
35:                // comment out the next line before committing:
36:                // #define DBG_UTEST
37:                #endif
38:                #ifdef DBG_UTEST
39:                #include <stdio.h>
40:                #endif
41:                ////////////////////////////////////////////////////////////////////////////////////////////
42:                
43:                // buffer large enough to hold 1/2 the hanning coefficients for window sizes upto 512 (FFTR limit):
44:                // note: only need the 1st half of them because the other half is mirrored
45:                static FLOAT window_coeffs[NUM_FFTR / 2];
46:                static int16_t window_size = 0;
47:                static uint8_t window_uses_float = false;
48:                
49:                void remove_mean_data_float(FLOAT *pdata, int32_t len)
50:                {
000000  040200     GOTO __resetPRI, __reset
51:                    int32_t idx;
52:                    FLOAT sum = 0.0;
000014  000920     NOP
53:                    FLOAT average;
54:                
55:                    // calc average:
56:                    for (idx = 0; idx < len; idx++)
00000A  000BD2     NOP
000016  000920     NOP
000024  000920     NOP
57:                    {
58:                        sum += pdata[idx];
00001C  000920     NOP
59:                    }
60:                    average = sum / len;
000036  000920     NOP
61:                
62:                    // remove mean:
63:                    for (idx = 0; idx < len; idx++)
000042  000920     NOP
000050  000920     NOP
64:                    {
65:                        pdata[idx] -= average;
000048  000920     NOP
66:                    }
67:                }
000062  000920     NOP
00006C  000920     NOP
68:                
69:                void autoscale_data_float(FLOAT *pdata, int32_t len)
70:                {
000000  040200     GOTO __resetPRI, __reset
71:                    int32_t idx;
72:                    FLOAT min = KB_FLT_MAX;
00001C  000920     NOP
00006E  000B0E     NOP
73:                    FLOAT max = KB_FLT_MIN;
000018  000920     NOP
00006A  000920     NOP
74:                    FLOAT sf;
75:                
76:                    // find min,max:
77:                    for (idx = 0; idx < len; idx++)
000010  000B66     NOP
000020  000920     NOP
000044  000C16     NOP
78:                    {
79:                        if (pdata[idx] < min)
00002A  000C36     NOP
80:                        {
81:                            min = pdata[idx];
000036  000920     NOP
82:                        }
83:                        if (pdata[idx] > max)
000038  000920     NOP
84:                        {
85:                            max = pdata[idx];
000042  000920     NOP
86:                        }
87:                    }
88:                
89:                    // get abs of min,max:
90:                    if (max < 0.0f)
00005E  000920     NOP
91:                        max *= -1.0f;
000072  000920     NOP
92:                    if (min < 0.0f)
000074  000920     NOP
93:                        min *= -1.0f;
00007E  000920     NOP
94:                
95:                    // calc scale factor based on larger abs value:
96:                    if (max >= min)
000080  000920     NOP
97:                    {
98:                        sf = 32767.0f / max;
00008A  000920     NOP
99:                    }
100:                   else
101:                   {
102:                       sf = 32767.0f / min;
000096  000920     NOP
103:                   }
104:               
105:                   // scale the data:
106:                   for (idx = 0; idx < len; idx++)
0000A0  000920     NOP
0000B6  000920     NOP
107:                   {
108:                       pdata[idx] *= sf;
0000AE  000920     NOP
109:                   }
110:               }
0000C4  000920     NOP
0000D0  000920     NOP
111:               
112:               static void gen_coeffs_float(int32_t len)
113:               {
000000  040200     GOTO __resetPRI, __reset
114:                   FLOAT fTmp;
115:                   FLOAT *pWC = window_coeffs;
116:                   int32_t idx;
117:               
118:                   // generate the 1st half; the 2nd half mirrors the first
119:                   for (idx = 0; idx < len / 2; idx++)
00000C  000BB6     NOP
00004C  000920     NOP
120:                   {
121:                       fTmp = 0.5 - (0.5 * cos((2 * PI * idx) / len)); // range is 0.0 to 1.0
000024  000920     NOP
122:                       pWC[idx] = fTmp;
00004A  000920     NOP
123:                   }
124:               #ifdef DBG_UTEST
125:                   printf("\nHanning Coeffs:\n");
126:                   for (idx = 0; idx < len / 2; idx += 8)
127:                   {
128:                       printf("%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f\n",
129:                              pWC[idx], pWC[idx + 1], pWC[idx + 2], pWC[idx + 3],
130:                              pWC[idx + 4], pWC[idx + 5], pWC[idx + 6], pWC[idx + 7]);
131:                   }
132:               #endif
133:               }
00005A  000920     NOP
000066  000920     NOP
134:               
135:               void apply_hanning_float(FLOAT *pdata, int32_t len)
00003C  000920     NOP
136:               {
000000  040200     GOTO __resetPRI, __reset
137:                   FLOAT fTmp;
138:                   int32_t idx, idx_m;
139:               
140:                   // see if we need to regenerate the coefficients:
141:                   if ((window_size != len) || (!window_uses_float))
00000C  000BB6     NOP
142:                   {
143:                       gen_coeffs_float(len);
00001A  000920     NOP
144:                       window_size = len;
00001E  000920     NOP
145:                       window_uses_float = true;
000020  000920     NOP
146:                   }
147:               
148:                   // now, apply them to the data:
149:                   for (idx = 0; idx < len / 2; idx++)
000024  000920     NOP
00005C  000920     NOP
150:                   {
151:                       fTmp = window_coeffs[idx];
00004A  000920     NOP
152:               
153:                       pdata[idx] = (fTmp * pdata[idx]);
00004C  000920     NOP
154:                       idx_m = (len - idx - 1);
155:                       pdata[idx_m] = (fTmp * pdata[idx_m]);
000054  000920     NOP
156:                   }
157:               }
000072  000920     NOP
00007C  000920     NOP
158:               
159:               void remove_mean_data_int(int16_t *pdata, int32_t len)
160:               {
000000  040200     GOTO __resetPRI, __reset
161:                   int32_t sum = 0;
000012  00091A     NOP
162:                   int16_t average;
163:                   int32_t idx;
164:               
165:                   // calc average:
166:                   for (idx = 0; idx < len; idx++)
000006  000B2E     NOP
00001C  000920     NOP
167:                   {
168:                       sum += pdata[idx];
000014  000920     NOP
169:                   }
170:                   average = sum / len;
000026  000920     NOP
171:               
172:                   // remove mean:
173:                   for (idx = 0; idx < len; idx++)
00002A  000C36     NOP
000030  000920     NOP
174:                   {
175:                       pdata[idx] -= average;
00002C  000920     NOP
176:                   }
177:               }
00003A  000920     NOP
000040  000920     NOP
178:               
179:               void autoscale_data_int(int16_t *pdata, int32_t len)
180:               {
000000  040200     GOTO __resetPRI, __reset
181:                   int32_t idx;
182:                   int32_t min = KB_SHORT_INT_MAX;
000018  000920     NOP
183:                   int32_t max = KB_SHORT_INT_MIN;
000014  000920     NOP
184:                   FLOAT sf = 0;
185:                   FLOAT tmp = 0;
186:               
187:                   // find min,max:
188:                   for (idx = 0; idx < len; idx++)
00000C  000BB6     NOP
00001C  000920     NOP
000032  000920     NOP
000062  000920     NOP
189:                   {
190:                       if (pdata[idx] < min)
00001E  000920     NOP
191:                       {
192:                           min = pdata[idx];
193:                       }
194:                       if (pdata[idx] > max)
195:                       {
196:                           max = pdata[idx];
197:                       }
198:                   }
199:               
200:                   // get abs of min,max:
201:                   if (max < 0)
202:                       max *= -1;
203:                   if (min < 0)
204:                       min *= -1;
205:               
206:                   // calc scale factor based on larger abs value:
207:                   if (max >= min)
000054  000920     NOP
208:                   {
209:                       if (max > 0)
00005A  000920     NOP
210:                       {
211:                           sf = 32767 / (float)max;
000066  000920     NOP
212:                       }
213:                   }
214:                   else
215:                   {
216:                       if (min > 0)
000074  000920     NOP
217:                       {
218:                           sf = 32767 / (float)min;
00007A  000920     NOP
219:                       }
220:                   }
221:               
222:                   // leave data alone if sf < 2:
223:                   if (sf > 1)
000088  000920     NOP
224:                   {
225:                       for (idx = 0; idx < len; idx++)
000094  000920     NOP
0000AE  000920     NOP
226:                       {
227:                           tmp = pdata[idx] * sf;
0000A0  000920     NOP
228:                           pdata[idx] = (int16_t)tmp;
0000AA  000920     NOP
229:                       }
230:                   }
231:               }
0000C0  000920     NOP
0000CA  0008B2     NOP
232:               
233:               static void gen_coeffs_int(int32_t len)
234:               {
000000  040200     GOTO __resetPRI, __reset
235:                   FLOAT fTmp;
236:                   int32_t idx;
237:                   int16_t *pWC = (int16_t *)window_coeffs;
238:               
239:                   // generate the 1st half; the 2nd half mirrors the first
240:                   for (idx = 0; idx < len / 2; idx++)
00000C  000BB6     NOP
000054  000920     NOP
241:                   {
242:                       fTmp = 0.5f - (0.5f * cos((2.0f * PI * idx) / len)); // range is 0.0 to 1.0
000024  000920     NOP
243:                       fTmp *= 16384.0f;
00004A  000920     NOP
244:                       pWC[idx] = (int16_t)(fTmp);
000050  000920     NOP
245:                   }
246:               #ifdef DBG_UTEST
247:                   printf("\nHanning Coeffs:\n");
248:                   for (idx = 0; idx < len / 2; idx += 8)
249:                   {
250:                       printf("%5d, %5d, %5d, %5d, %5d, %5d, %5d, %5d\n",
251:                              pWC[idx], pWC[idx + 1], pWC[idx + 2], pWC[idx + 3],
252:                              pWC[idx + 4], pWC[idx + 5], pWC[idx + 6], pWC[idx + 7]);
253:                   }
254:               #endif
255:               }
000062  000920     NOP
256:               
257:               void apply_hanning_int(int16_t *pdata, int32_t len)
000036  000920     NOP
258:               {
000000  040200     GOTO __resetPRI, __reset
259:                   int32_t iTmp;
260:                   int32_t idx, idx_m;
261:                   int16_t *pWC = (int16_t *)window_coeffs;
262:               
263:                   // see if we need to regenerate the coefficients:
264:                   if ((window_size != len) || window_uses_float)
00000C  000BB6     NOP
265:                   {
266:                       gen_coeffs_int(len);
00001A  000920     NOP
267:                       window_size = len;
00001E  000920     NOP
268:                       window_uses_float = false;
000020  000920     NOP
269:                   }
270:               
271:                   // now, apply them to the data and scale down to fit in 16 bits:
272:                   for (idx = 0; idx < len / 2; idx++)
000022  000BF6     NOP
00005E  000920     NOP
273:                   {
274:                       iTmp = (int32_t)pWC[idx];
00003C  000920     NOP
275:               
276:                       pdata[idx] = ((iTmp * (int32_t)pdata[idx]) + 1) >> 14;
00003E  000920     NOP
277:                       idx_m = (len - idx - 1);
278:                       pdata[idx_m] = ((iTmp * (int32_t)pdata[idx_m]) + 1) >> 14;
00004E  000920     NOP
279:                   }
280:               }
000068  000920     NOP
000072  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/tree_ensemble.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "tree_ensemble.h"
26:                
27:                tree_ensemble_classifier_rows_t *ClassifierTable;
28:                
29:                //FILL_MAX_DECISION_TREE_ENSEMBLE_TMP_PARAMETERS
30:                #ifndef MAX_DTE_CLASSIFICATIONS
31:                #define MAX_DTE_CLASSIFICATIONS 10
32:                #endif
33:                
34:                uint8_t classification_counts[MAX_DTE_CLASSIFICATIONS];
35:                
36:                uint8_t tree_classification(tree_t *model, uint8_t *feature_vector)
37:                {
008F82  781F88     MOV W8, [W15++]
38:                    int32_t classification = 0;
39:                    int32_t current_node = 0;
008F8A  B81160     MUL.UU W2, #0x0, W2
40:                    while (1)
41:                    {
42:                        if (feature_vector[model->features[current_node]] <= model->threshold[current_node])
008F84  9003B0     MOV [W0+6], W7
008F86  900420     MOV [W0+4], W8
008F8C  438282     ADD W7, W2, W5
008F8E  FB8295     ZE [W5], W5
008F90  408285     ADD W1, W5, W5
008F92  440202     ADD W8, W2, W4
008F94  784295     MOV.B [W5], W5
008F96  52CF94     SUB.B W5, [W4], [W15]
008F98  3E0005     BRA GTU, .L2
43:                        {
44:                            current_node = model->left_children[current_node];
008F9A  410102     ADD W2, W2, W2
008F9C  410110     ADD W2, [W0], W2
008F9E  780112     MOV [W2], W2
008FA0  EB0180     CLR W3
008FA2  370004     BRA .L3
45:                        }
46:                        else
47:                        {
48:                            current_node = model->right_children[current_node];
008FA4  410102     ADD W2, W2, W2
008FA6  430102     ADD W6, W2, W2
008FA8  780112     MOV [W2], W2
008FAA  EB0180     CLR W3
49:                        }
50:                        if (model->right_children[current_node] == 0)
008F88  900310     MOV [W0+2], W6
008FAC  410202     ADD W2, W2, W4
008FAE  430204     ADD W6, W4, W4
008FB0  E00014     CP0 [W4]
008FB2  3AFFEC     BRA NZ, .L4
008FB6  784012     MOV.B [W2], W0
51:                        {
52:                            break;
53:                        }
54:                    }
55:                
56:                    return model->features[current_node];
008FB4  438102     ADD W7, W2, W2
57:                }
008FB8  78044F     MOV [--W15], W8
008FBA  060000     RETURN
58:                
59:                uint8_t ensemble_classification(tree_t *forest_ensemble, uint8_t *classification_counts, uint16_t number_of_trees, uint8_t number_of_classses, uint8_t *feature_vector)
60:                {
000000  040200     GOTO __resetPRI, __reset
61:                
62:                    uint8_t y = 0;
000046  000920     NOP
63:                    uint16_t max_count = 0;
64:                  
65:                
66:                    memset(classification_counts, 0, sizeof(uint8_t) * MAX_DTE_CLASSIFICATIONS);
00000E  000920     NOP
67:                
68:                    for (int32_t i = 0; i < number_of_trees; i++)
000014  000920     NOP
000030  000920     NOP
69:                    {
70:                        classification_counts[tree_classification(&forest_ensemble[i], feature_vector)]++;
000024  000920     NOP
71:                    }
72:                
73:                    max_count = classification_counts[0];
000040  000920     NOP
00004E  000920     NOP
74:                
75:                    for (int32_t i = 1; i < number_of_classses; i++)
000042  000920     NOP
000048  000920     NOP
000050  000920     NOP
00005E  000920     NOP
76:                    {
77:                        if (classification_counts[i] > max_count)
000054  000920     NOP
78:                        {
79:                            max_count = classification_counts[i];
00005C  000920     NOP
80:                            y = i;
81:                        }
82:                    }
83:                
84:                    return y + 1;
000068  000920     NOP
85:                }
00006A  000920     NOP
000074  000920     NOP
86:                
87:                uint8_t tree_ensemble_simple_submit(uint8_t classifier_id, uint8_t *feature_vector)
88:                {
0083DA  BE9F88     MOV.D W8, [W15++]
0083DC  BE9F8A     MOV.D W10, [W15++]
0083DE  781F8C     MOV W12, [W15++]
0083E0  780481     MOV W1, W9
89:                
90:                    uint8_t y = 0;
008422  EB4000     CLR.B W0
91:                    uint16_t max_count = 0;
92:                
93:                    memset(classification_counts, 0, sizeof(uint8_t) * MAX_DTE_CLASSIFICATIONS);
0083E2  2373E1     MOV #0x373E, W1
0083E4  090009     REPEAT #0x9
0083E6  EB5880     CLR.B [W1++]
94:                
95:                    for (int32_t i = 0; i < ClassifierTable[classifier_id].number_of_trees; i++)
0083E8  B3C062     MOV.B #0x6, W2
0083EA  BC4004     MUL.B WREG2
0083EC  780002     MOV W2, W0
0083EE  B41256     ADD ClassifierTable, WREG
0083F0  780400     MOV W0, W8
0083F2  900018     MOV [W8+2], W0
0083F4  E00000     CP0 W0
0083F6  320011     BRA Z, .LBE5, .L16
0083F8  B85560     MUL.UU W10, #0x0, W10
00840C  450561     ADD W10, #0x1, W10
00840E  4D85E0     ADDC W11, #0x0, W11
008410  900018     MOV [W8+2], W0
008412  EB0080     CLR W1
008414  500F8A     SUB W0, W10, [W15]
008416  588F8B     SUBB W1, W11, [W15]
008418  3CFFF1     BRA GT, .L17
96:                    {
97:                        classification_counts[tree_classification(&ClassifierTable[classifier_id].tree_ensemble[i], feature_vector)]++;
0083FA  2373EC     MOV #0x373E, W12
0083FC  DD5043     SL W10, #3, W0
0083FE  9000A8     MOV [W8+4], W1
008400  408000     ADD W1, W0, W0
008402  780089     MOV W9, W1
008404  0705BE     RCALL tree_classification
008406  FB8000     ZE W0, W0
008408  460000     ADD W12, W0, W0
00840A  E84810     INC.B [W0], [W0]
98:                    }
99:                
100:                   max_count = classification_counts[0];
00841A  2373E0     MOV #0x373E, W0
00841C  784290     MOV.B [W0], W5
00842A  FB8285     ZE W5, W5
00842C  2373E4     MOV #0x373E, W4
101:               
102:                   for (int32_t i = 1; i < ClassifierTable[classifier_id].number_of_classes; i++)
00841E  FB8318     ZE [W8], W6
008420  EB0380     CLR W7
008424  530FE1     SUB W6, #0x1, [W15]
008426  5B8FE0     SUBB W7, #0x0, [W15]
008428  34000E     BRA LE, .L18
00842E  200012     MOV #0x1, W2
008430  200003     MOV #0x0, W3
00843C  410161     ADD W2, #0x1, W2
00843E  4981E0     ADDC W3, #0x0, W3
008440  530F82     SUB W6, W2, [W15]
008442  5B8F83     SUBB W7, W3, [W15]
008444  3CFFF6     BRA GT, .L20
103:                   {
104:                       if (classification_counts[i] > max_count)
008432  FB80D4     ZE [++W4], W1
008434  528F81     SUB W5, W1, [W15]
008436  310002     BRA C, .L19
008438  784002     MOV.B W2, W0
105:                       {
106:                           max_count = classification_counts[i];
00843A  780281     MOV W1, W5
107:                           y = i;
108:                       }
109:                   }
110:               
111:                   return y + 1;
008446  E84000     INC.B W0, W0
112:               }
008448  78064F     MOV [--W15], W12
00844A  BE054F     MOV.D [--W15], W10
00844C  BE044F     MOV.D [--W15], W8
00844E  060000     RETURN
008450  91B0C0     MOV [W0+488], W1
113:               
114:               void tree_ensemble_model_results_object(int32_t classifier_id, model_results_t *model_results){
000000  040200     GOTO __resetPRI, __reset
115:               
116:                   for (int32_t i = 0; i < ClassifierTable[classifier_id].number_of_classes; i++){
000002  000000     NOP
00001E  000920     NOP
117:                         
118:                         model_results->output_tensor[i] = classification_counts[i];
000016  000920     NOP
119:                   }
120:                   
121:                   model_results->num_outputs = ClassifierTable[classifier_id].number_of_classes;
000036  000920     NOP
122:               }
000038  000920     NOP
00003C  000920     NOP
123:               
124:               /*
125:                * Inititalize the PME
126:               */
127:               void tree_ensemble_init(tree_ensemble_classifier_rows_t *classifier_table, const uint8_t num_classifiers)
128:               {
129:                   ClassifierTable = classifier_table;
000000  040200     GOTO __resetPRI, __reset
130:               }
000002  000000     NOP
000004  000B9A     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/tr_min_max_scale.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /**
28:                * Transcoded from min_max_scale from tr_scale.py
29:                */
30:                int32_t min_max_scale(FVCOMP_T *pFeatures, uint8_t *feature_vector, int32_t nfeats, int32_t start, int32_t total_features, FLOAT minbound, FLOAT maxbound, struct minmax *m)
31:                {
0076EC  4787F6     ADD W15, #0x16, W15
0076EE  BE9F88     MOV.D W8, [W15++]
0076F0  BE9F8A     MOV.D W10, [W15++]
0076F2  BE9F8C     MOV.D W12, [W15++]
0076F4  781F8E     MOV W14, [W15++]
0076F6  9FB7B0     MOV W0, [W15-26]
0076F8  9FB7C2     MOV W2, [W15-24]
0076FA  9FB7D3     MOV W3, [W15-22]
0076FC  9FB794     MOV W4, [W15-30]
0076FE  9FB7A5     MOV W5, [W15-28]
007700  9FAFF6     MOV W6, [W15-34]
007702  9FB787     MOV W7, [W15-32]
007704  97AE0F     MOV [W15-48], W12
007706  97AE9F     MOV [W15-46], W13
32:                	int32_t index;
33:                	int32_t i;
34:                	FLOAT value;
35:                
36:                	for (i = 0; i < nfeats; i++)
007708  97B14F     MOV [W15-24], W2
00770A  97B1DF     MOV [W15-22], W3
00770C  510FE0     SUB W2, #0x0, [W15]
00770E  598FE0     SUBB W3, #0x0, [W15]
007710  340041     BRA LE, .L2
007712  97A77F     MOV [W15-50], W14
007714  9FB7E1     MOV W1, [W15-20]
007716  B84460     MUL.UU W8, #0x0, W8
007718  9FB7F8     MOV W8, [W15-18]
00771A  9FBF89     MOV W9, [W15-16]
00777C  97B07F     MOV [W15-18], W0
00777E  97B88F     MOV [W15-16], W1
007780  400061     ADD W0, #0x1, W0
007782  4880E0     ADDC W1, #0x0, W1
007784  9FB7F0     MOV W0, [W15-18]
007786  9FBF81     MOV W1, [W15-16]
007788  47076A     ADD W14, #0xA, W14
00778A  97B14F     MOV [W15-24], W2
00778C  97B1DF     MOV [W15-22], W3
00778E  500F82     SUB W0, W2, [W15]
007790  588F83     SUBB W1, W3, [W15]
007792  3AFFC4     BRA NZ, .L5
37:                	{
38:                		index = (start + m[i].index) % total_features;
007720  78001E     MOV [W14], W0
007722  97B11F     MOV [W15-30], W2
007724  97B1AF     MOV [W15-28], W3
007726  400002     ADD W0, W2, W0
007728  4980E0     ADDC W3, #0x0, W1
00772A  97A97F     MOV [W15-34], W2
00772C  97B18F     MOV [W15-32], W3
00772E  07CB8C     RCALL ___modsi3
39:                		//printf("%d: %f\n", index, pFeatures[index]);
40:                		value = maxbound * (pFeatures[index] - m[i].min) / (m[i].max - m[i].min + 1.0e-10);
00771C  90051E     MOV [W14+2], W10
00771E  9005AE     MOV [W14+4], W11
007730  DD00C2     SL W0, #2, W1
007732  97B1BF     MOV [W15-26], W3
007734  418081     ADD W3, W1, W1
007736  BE010A     MOV.D W10, W2
007738  BE0011     MOV.D [W1], W0
00773A  07CBA8     RCALL ___subsf3x, ___subsf3
00773C  BE010C     MOV.D W12, W2
00773E  07CD73     RCALL ___mulsf3x, ___mulsf3
007740  BE0400     MOV.D W0, W8
007742  BE010A     MOV.D W10, W2
007744  90003E     MOV [W14+6], W0
007746  9000CE     MOV [W14+8], W1
007748  07CBA1     RCALL ___subsf3x, ___subsf3
00774A  2E6FF2     MOV #0xE6FF, W2
00774C  22EDB3     MOV #0x2EDB, W3
00774E  07CBA7     RCALL ___addsf3x, ___addsf3
007750  BE0100     MOV.D W0, W2
007752  BE0008     MOV.D W8, W0
007754  07CC89     RCALL ___divsf3, ___divsf3x
007756  BE0400     MOV.D W0, W8
41:                		if (value > maxbound)
007758  BE010C     MOV.D W12, W2
00775A  07CAB9     RCALL ___gesf2, ___gtsf2
00775C  E00000     CP0 W0
00775E  340001     BRA LE, .L3
42:                			value = maxbound;
007760  BE040C     MOV.D W12, W8
43:                		if (value < minbound)
007762  97A92F     MOV [W15-44], W2
007764  97A9BF     MOV [W15-42], W3
007766  BE0008     MOV.D W8, W0
007768  07CAB0     RCALL ___ltsf2, ___eqsf2, ___lesf2
00776A  E00000     CP0 W0
00776C  3D0002     BRA GE, .L4
44:                			value = minbound;
00776E  97AC2F     MOV [W15-44], W8
007770  97ACBF     MOV [W15-42], W9
45:                		feature_vector[i] = (uint8_t)value;
007772  BE0008     MOV.D W8, W0
007774  07CACF     RCALL ___fixunssfsi
007776  97B46F     MOV [W15-20], W8
007778  785C00     MOV.B W0, [W8++]
00777A  9FB7E8     MOV W8, [W15-20]
46:                	}
47:                	return nfeats;
48:                }
007794  97B04F     MOV [W15-24], W0
007796  97B0DF     MOV [W15-22], W1
007798  78074F     MOV [--W15], W14
00779A  BE064F     MOV.D [--W15], W12
00779C  BE054F     MOV.D [--W15], W10
00779E  BE044F     MOV.D [--W15], W8
0077A0  B1016F     SUB #0x16, W15
0077A2  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sum.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                int32_t i_sum(ringb *pringb, int32_t base_index, int32_t num_rows)
000010  000B66     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    int32_t sum;
30:                    int32_t irow;
31:                
32:                    sum = 0;
000004  000B9A     NOP
000014  000920     NOP
33:                
34:                    for (irow = 0; irow < num_rows ; irow++)
000006  000B2E     NOP
000028  000920     NOP
35:                    {
36:                        sum += MOD_READ_RINGBUF(pringb, base_index++); // 16-bit elements, added to 32-bit accumulator
00000C  000BB6     NOP
000016  000920     NOP
37:                    }
38:                
39:                    return sum;
40:                }
00002E  000920     NOP
41:                
42:                FLOAT sum(ringb *pringb, int32_t base_index, int32_t num_rows)
43:                {
44:                    return (FLOAT) i_sum(pringb, base_index, num_rows);
000000  040200     GOTO __resetPRI, __reset
45:                }
000004  000B9A     NOP
000006  000B2E     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/std.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                //      std.c
28:                //
29:                //      Return square root of the arithmetic mean of the square of the
30:                //      elements in an array.  It is called the "root mean square",
31:                //      or the Standard Deviation.
32:                //
33:                //      std = SQRT(mean(abs(x - x.mean())**2))
34:                //
35:                //      This is the integer optimized version of std.c
36:                //      It calls the inline routine get_axis_data(), which returns an int16.
37:                //      The input data values are therefore in -32k..32k (16 bits).
38:                //      The routine get_axis_data() is in ../include/rb.h.
39:                //
40:                //      Note that there is a small danger of integer overflow if more than
41:                //      64k data elements are input.
42:                //
43:                //      Note that we are now supporting both FLOAT and int32 return values.
44:                //      Note that we lose a small amount of  precision when the int32 divide
45:                //      takes place, at the end of the function.
46:                
47:                int32_t i_mean(ringb *pringb, int32_t base_index, int32_t len);
48:                
49:                FLOAT f_std(ringb *pringb, int32_t base_index, int32_t len)
00002C  000920     NOP
50:                {
000000  040200     GOTO __resetPRI, __reset
51:                    int32_t irow;
52:                    FLOAT sum = 0.0;
000018  000920     NOP
53:                    FLOAT tmp;
54:                    FLOAT xmean;
55:                
56:                    // Compute the mean of the input data
57:                    xmean = mean(pringb, base_index, len);
000012  00091A     NOP
58:                
59:                    for (irow = 0; irow < len; irow++)
00001A  000920     NOP
00005A  000920     NOP
60:                    {
61:                        tmp = MOD_READ_RINGBUF(pringb, base_index++) - xmean;
000024  000920     NOP
000038  000920     NOP
62:                        sum += tmp * tmp;
00004E  000920     NOP
63:                    }
64:                
65:                    return SQRT(sum / len);
000064  000920     NOP
66:                }
000072  000920     NOP
67:                
68:                int32_t i_std(ringb *pringb, int32_t base_index, int32_t len)
000028  000920     NOP
69:                //
70:                //      Returns the standard deviation, as computed using integers.
71:                //
72:                {
000000  040200     GOTO __resetPRI, __reset
73:                    int32_t irow;
74:                    int32_t tmp;
75:                    int32_t xmean;
76:                    int64_t sum = 0.0;
000012  00091A     NOP
00002C  000920     NOP
77:                
78:                    // Compute the mean of the input data
79:                    xmean = i_mean(pringb, base_index, len);
00000E  000920     NOP
80:                
81:                    for (irow = 0; irow < len; irow++)
00001E  000920     NOP
00006E  000B0E     NOP
82:                    {
83:                        tmp = MOD_READ_RINGBUF(pringb, base_index++) - xmean;
000024  000920     NOP
000034  000920     NOP
84:                        sum += tmp * tmp; // don't need 64-bit multiply
00004C  000920     NOP
85:                    }
86:                
87:                    return (int32_t)(SQRT((FLOAT)sum / (FLOAT)len));
000074  000920     NOP
88:                }
00008E  000920     NOP
000098  000920     NOP
89:                
90:                FLOAT kb_std(ringb *pringb, int32_t base_index, int32_t len)
91:                //
92:                //      Generic version, for compatibility
93:                //
94:                {
95:                    return f_std(pringb, base_index, len);
000000  040200     GOTO __resetPRI, __reset
96:                }
000002  000000     NOP
000004  000B9A     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/stats_percentile_presorted.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT stats_percentile_presorted(const SENSOR_DATA_T *input_data, int32_t nframes, FLOAT pct)
28:                {
0073A6  4787EE     ADD W15, #0xE, W15
29:                	int32_t idx;
30:                	int32_t nteger;
31:                	FLOAT result;
32:                
33:                	if (pct <= 0.0)
0073B6  B81160     MUL.UU W2, #0x0, W2
0073B8  BE0004     MOV.D W4, W0
0073BA  07CC87     RCALL ___ltsf2, ___eqsf2, ___lesf2
0073BC  E00000     CP0 W0
0073BE  3C0004     BRA GT, .L14
34:                		return (FLOAT)input_data[0];
0073C0  78001E     MOV [W14], W0
0073C2  DE80CF     ASR W0, #15, W1
0073C4  07CCD2     RCALL ___floatsisf
0073C6  370056     BRA .L4
35:                	if (pct >= 1.0)
0073C8  200002     MOV #0x0, W2
0073CA  23F803     MOV #0x3F80, W3
0073CC  BE0008     MOV.D W8, W0
0073CE  07CC7F     RCALL ___gesf2, ___gtsf2
0073D0  E00000     CP0 W0
0073D2  350007     BRA LT, .L15
36:                		return (FLOAT)input_data[nframes - 1];
0073D4  E9050A     DEC W10, W10
0073D6  45050A     ADD W10, W10, W10
0073D8  47070A     ADD W14, W10, W14
0073DA  78001E     MOV [W14], W0
0073DC  DE80CF     ASR W0, #15, W1
0073DE  07CCC5     RCALL ___floatsisf
0073E0  370049     BRA .L4
37:                
38:                	// Compute percentile
39:                	FLOAT index = pct * (nframes - 1);
0073E2  550061     SUB W10, #0x1, W0
0073E4  5D80E0     SUBB W11, #0x0, W1
0073E6  07CCC1     RCALL ___floatsisf
0073E8  BE0600     MOV.D W0, W12
0073EA  BE0108     MOV.D W8, W2
0073EC  07CF1C     RCALL ___mulsf3x, ___mulsf3
0073EE  BE0400     MOV.D W0, W8
40:                
41:                	FLOAT finteger;
42:                	FLOAT frac = (FLOAT)MODF(index, &finteger);
0073F0  57817A     SUB W15, #0x1A, W2
0073F2  07D1A3     RCALL _modff
0073F4  9FB7D0     MOV W0, [W15-22]
0073F6  9FB7E1     MOV W1, [W15-20]
43:                
44:                	if (finteger <= (FLOAT)(nframes - 1))
0073F8  97B03F     MOV [W15-26], W0
0073FA  97B0CF     MOV [W15-24], W1
0073FC  9FB7F0     MOV W0, [W15-18]
0073FE  9FBF81     MOV W1, [W15-16]
007400  BE0100     MOV.D W0, W2
007402  BE000C     MOV.D W12, W0
007404  07CC64     RCALL ___gesf2, ___gtsf2
007406  E00000     CP0 W0
007408  350007     BRA LT, .L16
45:                		nteger = (int32_t)finteger;
007436  97B07F     MOV [W15-18], W0
007438  97B88F     MOV [W15-16], W1
00743A  07CC4B     RCALL ___fixsfsi
00743C  BE0500     MOV.D W0, W10
46:                	else
47:                		return input_data[nframes - 1];
007418  E9050A     DEC W10, W10
00741A  45050A     ADD W10, W10, W10
00741C  47070A     ADD W14, W10, W14
00741E  78001E     MOV [W14], W0
007420  DE80CF     ASR W0, #15, W1
007422  07CCA3     RCALL ___floatsisf
007424  370027     BRA .L4
48:                
49:                	if (frac == 0.0)
00740A  B81160     MUL.UU W2, #0x0, W2
00740C  97B05F     MOV [W15-22], W0
00740E  97B0EF     MOV [W15-20], W1
007410  07CC5C     RCALL ___ltsf2, ___eqsf2, ___lesf2
007412  E00000     CP0 W0
007414  320008     BRA Z, .L9
007416  37000F     BRA .L18
50:                	{
51:                		idx = (int32_t)index;
007426  BE0008     MOV.D W8, W0
007428  07CC54     RCALL ___fixsfsi
52:                		result = input_data[idx];
00742A  400000     ADD W0, W0, W0
00742C  470000     ADD W14, W0, W0
00742E  780010     MOV [W0], W0
007430  DE80CF     ASR W0, #15, W1
007432  07CC9B     RCALL ___floatsisf
007434  37001F     BRA .L4
53:                	}
54:                	else
55:                	{
56:                		result = ((FLOAT)1.0 - frac) * input_data[nteger] + frac * input_data[nteger + 1];
00743E  97B15F     MOV [W15-22], W2
007440  97B1EF     MOV [W15-20], W3
007442  200000     MOV #0x0, W0
007444  23F801     MOV #0x3F80, W1
007446  07CD22     RCALL ___subsf3x, ___subsf3
007448  BE0400     MOV.D W0, W8
00744A  45000A     ADD W10, W10, W0
00744C  470000     ADD W14, W0, W0
00744E  780010     MOV [W0], W0
007450  DE80CF     ASR W0, #15, W1
007452  07CC8B     RCALL ___floatsisf
007454  BE0100     MOV.D W0, W2
007456  BE0008     MOV.D W8, W0
007458  07CEE6     RCALL ___mulsf3x, ___mulsf3
00745A  BE0400     MOV.D W0, W8
00745C  E8050A     INC W10, W10
00745E  45050A     ADD W10, W10, W10
007460  47070A     ADD W14, W10, W14
007462  78001E     MOV [W14], W0
007464  DE80CF     ASR W0, #15, W1
007466  07CC81     RCALL ___floatsisf
007468  97B15F     MOV [W15-22], W2
00746A  97B1EF     MOV [W15-20], W3
00746C  07CEDC     RCALL ___mulsf3x, ___mulsf3
00746E  BE0100     MOV.D W0, W2
007470  BE0008     MOV.D W8, W0
007472  07CD15     RCALL ___addsf3x, ___addsf3
57:                	}
58:                
59:                	return result;
60:                }
007474  78074F     MOV [--W15], W14
007476  BE064F     MOV.D [--W15], W12
007478  BE054F     MOV.D [--W15], W10
00747A  BE044F     MOV.D [--W15], W8
00747C  B100EF     SUB #0xE, W15
00747E  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/stat_moment.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                //      This routine computes the nth moment of a given data set.
28:                //      There are pretty much two optimizations:  First, we use a case
29:                //      statement instead of using the POW library function.
30:                //      Second, we do the calculations using int32 or int64 instead
31:                //      of float.
32:                //      As customay, we supply three entry points:
33:                //      i_stat_moment()         returns an integer.
34:                //      f_stat_moment()         returns a float.
35:                //      stat_moment()           compatible with the old calling style
36:                //
37:                //      Note:  The i_stat_moment() will generally produce different results
38:                //      than the other routines, because it uses a fixed-point value for the
39:                //      average (and the interior summations).  This is generally a small error.
40:                //
41:                //      Note:  There will be an integer overflow in cases where more than
42:                //      128 million 12-bit data points are fed into this routine.
43:                //      We know that this won't happen in the current version,
44:                //      but be careful in the future. . .
45:                
46:                FLOAT f_stat_moment(ringb *rb, int32_t base_index, int32_t len, int32_t moment)
006B14  97B01F     MOV [W15-30], W0
006B16  97B0AF     MOV [W15-28], W1
006B18  97B17F     MOV [W15-18], W2
006B1A  97B98F     MOV [W15-16], W3
006B1C  410000     ADD W2, W0, W0
006B1E  498081     ADDC W3, W1, W1
006B20  9FB7B0     MOV W0, [W15-26]
006B22  9FB7C1     MOV W1, [W15-24]
006B24  BE0602     MOV.D W2, W12
006B26  B84460     MUL.UU W8, #0x0, W8
006B5C  97B11F     MOV [W15-30], W2
006B5E  97B1AF     MOV [W15-28], W3
006B60  97B07F     MOV [W15-18], W0
006B62  97B88F     MOV [W15-16], W1
006B64  400102     ADD W0, W2, W2
006B66  488183     ADDC W1, W3, W3
006B68  9FB7B2     MOV W2, [W15-26]
006B6A  9FB7C3     MOV W3, [W15-24]
006B6C  B84460     MUL.UU W8, #0x0, W8
006B6E  BE060A     MOV.D W10, W12
006B70  BE0508     MOV.D W8, W10
006BC8  97B1DF     MOV [W15-22], W3
006BCA  97B07F     MOV [W15-18], W0
006BCC  418080     ADD W3, W0, W1
47:                //
48:                //      The floating-point version, cleaned up somewhat by not
49:                //      using the POW library routine in every case.
50:                //
51:                {
006AD2  4787F2     ADD W15, #0x12, W15
006AD4  BE9F88     MOV.D W8, [W15++]
006AD6  BE9F8A     MOV.D W10, [W15++]
006AD8  BE9F8C     MOV.D W12, [W15++]
006ADA  781F8E     MOV W14, [W15++]
006ADC  780700     MOV W0, W14
006ADE  9FB7F2     MOV W2, [W15-18]
006AE0  9FBF83     MOV W3, [W15-16]
006AE2  9FB794     MOV W4, [W15-30]
006AE4  9FB7A5     MOV W5, [W15-28]
006AE6  BE0606     MOV.D W6, W12
52:                	int32_t i;
53:                	FLOAT avg;
54:                	FLOAT temp;
55:                	FLOAT sum;
56:                	int32_t start_index;
57:                
58:                	if (len <= 0)
006AEA  520FE0     SUB W4, #0x0, [W15]
006AEC  5A8FE0     SUBB W5, #0x0, [W15]
006AEE  340091     BRA LE, .L2
59:                		return 0.0;
006AE8  B80060     MUL.UU W0, #0x0, W0
60:                
61:                	if(moment == 1)
006AF0  530FE1     SUB W6, #0x1, [W15]
006AF2  5B8FE0     SUBB W7, #0x0, [W15]
006AF4  32008E     BRA Z, .L2
62:                		return 0.0;
63:                	avg = mean(rb, base_index, len);
006AF6  97B17F     MOV [W15-18], W2
006AF8  97B98F     MOV [W15-16], W3
006AFA  78000E     MOV W14, W0
006AFC  070DE9     RCALL mean
006AFE  BE0500     MOV.D W0, W10
64:                	sum = 0.0f;
65:                	start_index = base_index;
66:                
67:                	switch (moment)
006B00  560FE2     SUB W12, #0x2, [W15]
006B02  5E8FE0     SUBB W13, #0x0, [W15]
006B04  320004     BRA Z, .L4
006B06  560FE3     SUB W12, #0x3, [W15]
006B08  5E8FE0     SUBB W13, #0x0, [W15]
006B0A  3A0055     BRA NZ, .L15
006B0C  370024     BRA .L16
006BB6  B84460     MUL.UU W8, #0x0, W8
006BB8  B80060     MUL.UU W0, #0x0, W0
006BBA  9FB7D0     MOV W0, [W15-22]
006BBC  9FB7E1     MOV W1, [W15-20]
006BBE  9FB7BA     MOV W10, [W15-26]
006BC0  9FB7CB     MOV W11, [W15-24]
68:                	{
69:                	case 2:
70:                		for (i = 0; i < len; i++)
006B4A  97B03F     MOV [W15-26], W0
006B4C  97B0CF     MOV [W15-24], W1
006B4E  560F80     SUB W12, W0, [W15]
006B50  5E8F81     SUBB W13, W1, [W15]
006B52  3AFFEA     BRA NZ, .L6
006B54  370058     BRA .L7
71:                		{
72:                			temp = (FLOAT)MOD_READ_RINGBUF(rb, start_index++) - avg;
006B0E  9001BE     MOV [W14+6], W3
006B10  9FB7D3     MOV W3, [W15-22]
006B12  90072E     MOV [W14+4], W14
006B28  67000C     AND W14, W12, W0
006B2A  400000     ADD W0, W0, W0
006B2C  97B1DF     MOV [W15-22], W3
006B2E  418000     ADD W3, W0, W0
006B30  780010     MOV [W0], W0
006B32  DE80CF     ASR W0, #15, W1
006B34  07D11A     RCALL ___floatsisf
006B36  BE010A     MOV.D W10, W2
006B38  07D1A9     RCALL ___subsf3x, ___subsf3
006B3A  460661     ADD W12, #0x1, W12
006B3C  4E86E0     ADDC W13, #0x0, W13
73:                			sum += temp * temp; // temp**2
006B3E  BE0100     MOV.D W0, W2
006B40  07D372     RCALL ___mulsf3x, ___mulsf3
006B42  BE0100     MOV.D W0, W2
006B44  BE0008     MOV.D W8, W0
006B46  07D1AB     RCALL ___addsf3x, ___addsf3
006B48  BE0400     MOV.D W0, W8
74:                		}
75:                		break;
76:                	case 3:
77:                		for (i = 0; i < len; i++)
006BA4  97B07F     MOV [W15-18], W0
006BA6  97B88F     MOV [W15-16], W1
006BA8  97B13F     MOV [W15-26], W2
006BAA  97B1CF     MOV [W15-24], W3
006BAC  500F82     SUB W0, W2, [W15]
006BAE  588F83     SUBB W1, W3, [W15]
006BB0  3AFFE0     BRA NZ, .L8
006BB2  BE040A     MOV.D W10, W8
006BB4  370028     BRA .L7
78:                		{
79:                			temp = (FLOAT)MOD_READ_RINGBUF(rb, start_index++) - avg;
006B56  9000BE     MOV [W14+6], W1
006B58  9FB7D1     MOV W1, [W15-22]
006B5A  90072E     MOV [W14+4], W14
006B72  97B1FF     MOV [W15-18], W3
006B74  670003     AND W14, W3, W0
006B76  400000     ADD W0, W0, W0
006B78  97B0DF     MOV [W15-22], W1
006B7A  408000     ADD W1, W0, W0
006B7C  780010     MOV [W0], W0
006B7E  DE80CF     ASR W0, #15, W1
006B80  07D0F4     RCALL ___floatsisf
006B82  BE010C     MOV.D W12, W2
006B84  07D183     RCALL ___subsf3x, ___subsf3
006B86  BE0400     MOV.D W0, W8
006B88  97B17F     MOV [W15-18], W2
006B8A  97B98F     MOV [W15-16], W3
006B8C  410161     ADD W2, #0x1, W2
006B8E  4981E0     ADDC W3, #0x0, W3
006B90  9FB7F2     MOV W2, [W15-18]
006B92  9FBF83     MOV W3, [W15-16]
80:                			sum += temp * temp * temp; // temp**3
006B94  BE0100     MOV.D W0, W2
006B96  07D347     RCALL ___mulsf3x, ___mulsf3
006B98  BE0108     MOV.D W8, W2
006B9A  07D345     RCALL ___mulsf3x, ___mulsf3
006B9C  BE0100     MOV.D W0, W2
006B9E  BE000A     MOV.D W10, W0
006BA0  07D17E     RCALL ___addsf3x, ___addsf3
006BA2  BE0500     MOV.D W0, W10
81:                		}
82:                		break;
83:                	default:
84:                		for (i = 0; i < len; i++)
006BF0  97B15F     MOV [W15-22], W2
006BF2  97B1EF     MOV [W15-20], W3
006BF4  410161     ADD W2, #0x1, W2
006BF6  4981E0     ADDC W3, #0x0, W3
006BF8  9FB7D2     MOV W2, [W15-22]
006BFA  9FB7E3     MOV W3, [W15-20]
006BFC  97B01F     MOV [W15-30], W0
006BFE  97B0AF     MOV [W15-28], W1
006C00  500F82     SUB W0, W2, [W15]
006C02  588F83     SUBB W1, W3, [W15]
006C04  3CFFDE     BRA GT, .L3
85:                		{
86:                			sum +=
006BEA  BE0008     MOV.D W8, W0
006BEC  07D158     RCALL ___addsf3x, ___addsf3
006BEE  BE0400     MOV.D W0, W8
87:                				(float)POW((float)MOD_READ_RINGBUF(rb, start_index++) -
006BC2  BE000C     MOV.D W12, W0
006BC4  07D0D2     RCALL ___floatsisf
006BC6  BE0500     MOV.D W0, W10
006BCE  90002E     MOV [W14+4], W0
006BD0  608000     AND W1, W0, W0
006BD2  9000BE     MOV [W14+6], W1
006BD4  400000     ADD W0, W0, W0
006BD6  408000     ADD W1, W0, W0
006BD8  780010     MOV [W0], W0
006BDA  DE80CF     ASR W0, #15, W1
006BDC  07D0C6     RCALL ___floatsisf
006BDE  97B13F     MOV [W15-26], W2
006BE0  97B1CF     MOV [W15-24], W3
006BE2  07D154     RCALL ___subsf3x, ___subsf3
006BE4  BE010A     MOV.D W10, W2
006BE6  07D5E4     RCALL _powf
006BE8  BE0100     MOV.D W0, W2
88:                							   avg,
89:                						   (float)moment);
90:                		}
91:                		break;
92:                	}
93:                	return sum / len;
006C06  97B01F     MOV [W15-30], W0
006C08  97B0AF     MOV [W15-28], W1
006C0A  07D0AF     RCALL ___floatsisf
006C0C  BE0100     MOV.D W0, W2
006C0E  BE0008     MOV.D W8, W0
006C10  07D22B     RCALL ___divsf3, ___divsf3x
94:                }
006C12  78074F     MOV [--W15], W14
006C14  BE064F     MOV.D [--W15], W12
006C16  BE054F     MOV.D [--W15], W10
006C18  BE044F     MOV.D [--W15], W8
006C1A  B1012F     SUB #0x12, W15
006C1C  060000     RETURN
95:                
96:                int32_t i_stat_moment(ringb *rb, int32_t base_index, int32_t len, int32_t moment)
000044  000C16     NOP
0000A0  000920     NOP
0000A2  000920     NOP
97:                //
98:                //      The integer version.
99:                //
100:               //      Note that, for moments other than 2 or 3, it just returns 0.
101:               //      Typical higher-order moment results won't fit in 32 bits.
102:               //
103:               {
000000  040200     GOTO __resetPRI, __reset
104:               	int32_t i;
105:               	int32_t avg;
106:               	int32_t temp;
107:               	int64_t sum;
108:               	int32_t start_index;
109:               
110:               	if (len <= 0)
000016  000920     NOP
111:               		return 0;
000014  000920     NOP
112:               	if(moment == 1)
00001C  000920     NOP
113:               		return 0;
114:               
115:               	sum = 0;
116:               	avg = (int32_t)mean(rb, base_index, len);
000022  000BF6     NOP
117:               	start_index = base_index;
118:               
119:               	switch (moment)
00002C  000920     NOP
000038  000920     NOP
120:               	{
121:               	default:
122:               	case 1:
123:               		return 0;
000036  000920     NOP
124:               		break;
125:               	case 2:
126:               		for (i = 0; i < len; i++)
000088  000920     NOP
127:               		{
128:               			temp = MOD_READ_RINGBUF(rb, start_index++) - avg;
000040  000920     NOP
000064  000920     NOP
129:               			sum += (temp * temp); // temp**2
000076  000920     NOP
130:               		}
131:               		break;
132:               	case 3:
133:               		for (i = 0; i < len; i++)
0000F4  000920     NOP
134:               		{
135:               			temp = MOD_READ_RINGBUF(rb, start_index++) - avg;
00009C  000920     NOP
0000B8  000920     NOP
136:               			sum += ((int64_t)(temp * temp)) * temp; // temp**3
0000CA  0008B2     NOP
137:               		}
138:               		break;
139:               	}
140:               	return (int32_t)(sum / len);
0000FE  000920     NOP
141:               }
000112  000920     NOP
00011C  000920     NOP
142:               
143:               FLOAT stat_moment(ringb *rb, int32_t base_index, int32_t len, int32_t moment)
144:               //
145:               //      The generic version, used for compatibility.
146:               //      Calls f_stat_moment(), at this time.
147:               //
148:               {
149:               	return f_stat_moment(rb, base_index, len, moment);
009F0A  07E5E3     RCALL f_stat_moment
150:               }
009F0C  060000     RETURN
009F0E  A8EB01     BSET 0xB01, #7
151:               
152:               //
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/stat_mean.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                FLOAT stat_mean(ringb *rb, int32_t base_index, int32_t len)
00001A  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                    FLOAT t = 0;
00000C  000BB6     NOP
30:                    int32_t irow;
31:                    int32_t start_index = base_index;
000022  000BF6     NOP
32:                
33:                    for (irow = 0; irow < len; irow++)
00000E  000920     NOP
00003E  000920     NOP
34:                    {
35:                        t += MOD_READ_RINGBUF(rb, start_index++);
000014  000920     NOP
000024  000920     NOP
36:                    }
37:                    return t / len;
000048  000920     NOP
38:                }
000052  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/st_moving_average.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Moving average for incomming sensor data by taking the average over filter order
29:                *
30:                * \param ringbuffer pointer to the ring buffer to add data too
31:                * \param frameData Pointer to the data which will be transformed
32:                */
33:                int16_t ma_filter_full(ringb *pringb, int32_t filter_order)
34:                {
000000  040200     GOTO __resetPRI, __reset
35:                    int32_t val = 0;
000012  00091A     NOP
00001A  000920     NOP
36:                    int32_t num_vals = 2 * filter_order + 1;
00000A  000BD2     NOP
37:                
38:                    for (int32_t i = 0; i < num_vals; i++)
000014  000920     NOP
000028  000920     NOP
39:                    {
40:                        val += rb_read_offset(pringb, i);
00001C  000920     NOP
41:                    }
42:                
43:                    return val / num_vals;
000032  000920     NOP
44:                }
000038  000920     NOP
45:                
46:                int16_t time_lapse(ringb *pringb, int32_t filter_order)
47:                {
48:                    return rb_read_offset(pringb, filter_order);
000000  040200     GOTO __resetPRI, __reset
49:                }
000004  000B9A     NOP
000006  000B2E     NOP
50:                
51:                int32_t streaming_moving_average(ring_buffer_t *pringb, SENSOR_DATA_T *pSample, int32_t *cols_to_use, int32_t num_cols, int32_t filter_order)
52:                {
000000  040200     GOTO __resetPRI, __reset
53:                    saveSensorData(pringb, pSample, num_cols);
000014  000920     NOP
54:                    ringb *rb;
55:                
56:                    if (rb_items(pringb) < (2 * filter_order))
00001C  000920     NOP
00002A  000C36     NOP
57:                    {
58:                        return -1;
000026  000920     NOP
59:                    }
60:                
61:                    for (int32_t i = 0; i < num_cols; i++)
000034  000920     NOP
000048  000920     NOP
000072  000920     NOP
62:                    {
63:                        rb = pringb + i;
64:                        if (cols_to_use[i])
00004A  000920     NOP
65:                        {
66:                            pSample[i] = (SENSOR_DATA_T)ma_filter_full(rb, filter_order);
000056  000920     NOP
67:                        }
68:                        else
69:                        {
70:                            pSample[i] = (SENSOR_DATA_T)time_lapse(rb, filter_order);
000062  000920     NOP
71:                        }
72:                        rb_step_head(rb, 1);
000044  000C16     NOP
00006C  000920     NOP
00006E  000B0E     NOP
000070  000920     NOP
73:                    }
74:                
75:                    //printf("moving avg %d\n" , get_col_data(rbuff_index, index));
76:                
77:                    return 1;
000030  000920     NOP
000032  000920     NOP
000090  000920     NOP
78:                }
000094  000920     NOP
0000A0  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/st_high_pass_filter.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                 * \brief Simple IIR filter
29:                 *
30:                 * \param pringb pointer to the ring buffer to add data too
31:                 * \param pSample Pointer to the data which will be transformed
32:                 * \param cols_to_use columns to transform
33:                 * \param num_cols number of columns ub in col_to_use
34:                 * \param alpha attenuation coefficient
35:                 */
36:                
37:                int32_t streaming_high_pass_filter(ring_buffer_t *pringb, SENSOR_DATA_T *pSample, int32_t *cols_to_use, int32_t num_cols, float alpha)
000062  000920     NOP
38:                {
000000  040200     GOTO __resetPRI, __reset
39:                    ringb *rb;
40:                    int32_t col;
41:                    if (rb_status(pringb) == false)
000016  000920     NOP
42:                    {
43:                        for (int32_t i = 0; i < num_cols; i++)
000032  000920     NOP
00004C  000920     NOP
44:                        {
45:                            rb = pringb + i;
46:                            rb->stat = pSample[cols_to_use[i]];
00003E  000920     NOP
47:                            rb_lock(rb);
000048  000920     NOP
48:                        }
49:                        return -1;
00002E  000920     NOP
00005C  000920     NOP
50:                    }
51:                
52:                    for (int32_t i = 0; i < num_cols; i++)
00001E  000920     NOP
000026  000920     NOP
000086  000920     NOP
53:                    {
54:                        rb = pringb + i;
55:                        col = cols_to_use[i];
00006A  000920     NOP
56:                        {
57:                            pSample[col] = (SENSOR_DATA_T)(pringb->stat + (int16_t)(alpha * (float)(pSample[col] - rb->stat)));
00006C  000920     NOP
58:                            rb->stat = pSample[col];
000084  000920     NOP
59:                        }
60:                    }
61:                
62:                    // printf("moving avg %d\n" , get_col_data(rbuff_index, index));
63:                
64:                    return 1;
000022  000BF6     NOP
00009E  000920     NOP
65:                }
0000A2  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/st_average.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Transform the sensor data into average and add it to frameData
29:                *
30:                * \param rawdata Raw sensor data array pointer.
31:                * \param cols_to_use array of columns to use from rawdata
32:                * \param num_cols number of columns to use
33:                * \param frameData Pointer to the new framedata array
34:                */
35:                int32_t st_sensor_average(SENSOR_DATA_T *rawdata, int32_t *cols_to_use, int32_t num_cols, SENSOR_DATA_T *frameData)
36:                {
000000  040200     GOTO __resetPRI, __reset
37:                    int32_t icol;
38:                    int32_t col;
39:                
40:                    int32_t sum = 0;
000008  000B4A     NOP
000012  00091A     NOP
41:                
42:                    for (icol = 0; icol < num_cols; icol++)
00000A  000BD2     NOP
000014  000920     NOP
000024  000920     NOP
43:                    {
44:                        col = cols_to_use[icol];
000016  000920     NOP
45:                        sum += rawdata[col];
000018  000920     NOP
46:                    }
47:                
48:                    frameData[0] = (uint16_t)(sum / num_cols);
00002E  000920     NOP
49:                
50:                    return 1;
51:                }
000034  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/st_absolute_average.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Transform the sensor data into absolute average and add it to frameData
29:                *
30:                * \param rawdata Raw sensor data array pointer.
31:                * \param cols_to_use array of columns to use from rawdata
32:                * \param num_cols number of columns to use
33:                * \param frameData Pointer to the new framedata array
34:                */
35:                int32_t st_sensor_abs_average(SENSOR_DATA_T *rawdata, int32_t *cols_to_use, int32_t num_cols, SENSOR_DATA_T *frameData)
36:                {
000000  040200     GOTO __resetPRI, __reset
37:                    int32_t icol;
38:                    int32_t col;
39:                
40:                    int32_t sum = 0;
000008  000B4A     NOP
000012  00091A     NOP
41:                
42:                    for (icol = 0; icol < num_cols; icol++)
00000A  000BD2     NOP
000014  000920     NOP
000028  000920     NOP
43:                    {
44:                        col = cols_to_use[icol];
000016  000920     NOP
45:                        sum += abs(rawdata[col]);
000018  000920     NOP
46:                    }
47:                
48:                    frameData[0] = (uint16_t)(sum / num_cols);
000032  000920     NOP
49:                
50:                    return 1;
51:                }
000038  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sorted_copy.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                SENSOR_DATA_T *sorted_copy(ringb *rb, int32_t base_index, int32_t len, int32_t force_sort)
008D0A  450408     ADD W10, W8, W8
008D0C  4D8489     ADDC W11, W9, W9
28:                {
008CEC  BE9F88     MOV.D W8, [W15++]
008CEE  BE9F8A     MOV.D W10, [W15++]
008CF0  BE0504     MOV.D W4, W10
29:                	int32_t start_index = base_index & rb->mask;
008CF2  900220     MOV [W0+4], W4
008D02  B84460     MUL.UU W8, #0x0, W8
008D04  620402     AND W4, W2, W8
008D06  BE0308     MOV.D W8, W6
008D08  225943     MOV #0x2594, W3
30:                	if (len)
008CF6  550FE0     SUB W10, #0x0, [W15]
008CF8  5D8FE0     SUBB W11, #0x0, [W15]
008CFA  320018     BRA Z, .L2
31:                	{
32:                		int32_t irow;
33:                
34:                		for (irow = 0; irow < len; irow++)
008CFC  550FE0     SUB W10, #0x0, [W15]
008CFE  5D8FE0     SUBB W11, #0x0, [W15]
008D00  340011     BRA LE, .L3
008D1E  530F88     SUB W6, W8, [W15]
008D20  5B8F89     SUBB W7, W9, [W15]
008D22  3AFFF5     BRA NZ, .L4
35:                		{
36:                			sortedData[irow] = MOD_READ_RINGBUF(rb, start_index++);
008D0E  9000A0     MOV [W0+4], W1
008D10  608086     AND W1, W6, W1
008D12  9002B0     MOV [W0+6], W5
008D14  408081     ADD W1, W1, W1
008D16  428081     ADD W5, W1, W1
008D18  781991     MOV [W1], [W3++]
008D1A  430361     ADD W6, #0x1, W6
008D1C  4B83E0     ADDC W7, #0x0, W7
37:                		}
38:                
39:                		sortarray(sortedData, len);
008D24  BE010A     MOV.D W10, W2
008D26  225940     MOV #0x2594, W0
008D28  07F015     RCALL sortarray
40:                
41:                		return sortedData;
008D2A  225941     MOV #0x2594, W1
42:                	}
43:                
44:                	return (SENSOR_DATA_T *)0L;
008CF4  EB0080     CLR W1
45:                }
008D2C  780001     MOV W1, W0
008D2E  BE054F     MOV.D [--W15], W10
008D30  BE044F     MOV.D [--W15], W8
008D32  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sortarray.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /* function to sort arr using shellSort */
28:                void sortarray(SENSOR_DATA_T arr[], int32_t n)
006D98  97B35F     MOV [W15-22], W6
006D9A  97B3EF     MOV [W15-20], W7
006D9C  53010A     SUB W6, W10, W2
006D9E  5B818B     SUBB W7, W11, W3
006DA0  97B2BF     MOV [W15-26], W5
006E1A  E9010A     DEC W10, W2
006E1C  410102     ADD W2, W2, W2
006E1E  400102     ADD W0, W2, W2
006E20  9FB792     MOV W2, [W15-30]
006E22  9FB7C0     MOV W0, [W15-24]
006E24  2FFFE6     MOV #0xFFFE, W6
006E26  B9D186     MULW.SS W10, W6, W2
006E28  400102     ADD W0, W2, W2
006E2A  9FB7B2     MOV W2, [W15-26]
006E2C  BE010A     MOV.D W10, W2
006E2E  9FB7D2     MOV W2, [W15-22]
006E30  9FB7E3     MOV W3, [W15-20]
006E32  150260     SUBR W10, #0x0, W4
006E34  1D82E0     SUBBR W11, #0x0, W5
006E36  9FB7F4     MOV W4, [W15-18]
006E38  9FBF85     MOV W5, [W15-16]
006E3A  420704     ADD W4, W4, W14
006E3C  37FF9C     BRA .L6
29:                {
006D54  4787F6     ADD W15, #0x16, W15
30:                	int32_t temp;
31:                	int32_t gap;
32:                	int32_t i;
33:                	int32_t j;
34:                
35:                	// Start with a big gap, then reduce the gap
36:                	for (gap = n / 2; gap > 0; gap /= 2)
006D64  DE2D4F     LSR W5, #15, W10
006D66  450502     ADD W10, W2, W10
006D68  4985E0     ADDC W3, #0x0, W11
006D6A  D1858B     ASR W11, W11
006D6C  D3850A     RRC W10, W10
006D6E  550FE0     SUB W10, #0x0, [W15]
006D70  5D8FE0     SUBB W11, #0x0, [W15]
006D72  3C004E     BRA GT, .L2
006D74  370064     BRA .L1
006D76  97B25F     MOV [W15-22], W4
006E00  DE58CF     LSR W11, #15, W1
006E02  40850A     ADD W1, W10, W10
006E04  4D85E0     ADDC W11, #0x0, W11
006E06  D1858B     ASR W11, W11
006E08  D3850A     RRC W10, W10
006E0A  550FE0     SUB W10, #0x0, [W15]
006E0C  5D8FE0     SUBB W11, #0x0, [W15]
006E0E  340017     BRA LE, .L1
37:                	{
38:                		// Do a gapped insertion sort for this gap size.
39:                		// The first gap elements a[0..gap-1] are already in gapped order
40:                		// keep adding one more element until the entire array is
41:                		// gap sorted
42:                		for (i = gap; i < n; i += 1)
006DDA  97B15F     MOV [W15-22], W2
006DDC  97B1EF     MOV [W15-20], W3
006DDE  410161     ADD W2, #0x1, W2
006DE0  4981E0     ADDC W3, #0x0, W3
006DE2  9FB7D2     MOV W2, [W15-22]
006DE4  9FB7E3     MOV W3, [W15-20]
006DE6  97B1CF     MOV [W15-24], W3
006DE8  E88183     INC2 W3, W3
006DEA  9FB7C3     MOV W3, [W15-24]
006DEC  97B23F     MOV [W15-26], W4
006DEE  E88204     INC2 W4, W4
006DF0  9FB7B4     MOV W4, [W15-26]
006DF2  97AB7F     MOV [W15-34], W6
006DF4  97B38F     MOV [W15-32], W7
006DF6  97B15F     MOV [W15-22], W2
006DF8  97B1EF     MOV [W15-20], W3
006DFA  530F82     SUB W6, W2, [W15]
006DFC  5B8F83     SUBB W7, W3, [W15]
006DFE  3CFFBB     BRA GT, .L6
006E10  97AA7F     MOV [W15-34], W4
006E12  97B28F     MOV [W15-32], W5
006E14  520F8A     SUB W4, W10, [W15]
006E16  5A8F8B     SUBB W5, W11, [W15]
006E18  34FFF3     BRA LE, .L7
43:                		{
44:                			// add a[i] to the elements that have been gap sorted
45:                			// save a[i] in temp and make a hole at position i
46:                			temp = arr[i];
006D78  97B39F     MOV [W15-30], W7
006D7A  7800D7     MOV [++W7], W1
006D7C  9FB797     MOV W7, [W15-30]
006D7E  9FB7A1     MOV W1, [W15-28]
006D8A  B90E61     MUL.SU W1, #0x1, W12
47:                
48:                			// shift earlier gap-sorted elements up until the correct
49:                			// location for a[i] is found
50:                			for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)
006D80  97B15F     MOV [W15-22], W2
006D82  97B1EF     MOV [W15-20], W3
006D84  550F82     SUB W10, W2, [W15]
006D86  5D8F83     SUBB W11, W3, [W15]
006D88  3C001F     BRA GT, .L9
006D8C  97B1CF     MOV [W15-24], W3
006D8E  780093     MOV [W3], W1
006D90  B90961     MUL.SU W1, #0x1, W2
006D92  560F82     SUB W12, W2, [W15]
006D94  5E8F83     SUBB W13, W3, [W15]
006D96  3D001B     BRA GE, .L10
006DAA  550F82     SUB W10, W2, [W15]
006DAC  5D8F83     SUBB W11, W3, [W15]
006DAE  3C0011     BRA GT, .L4
006DB0  780202     MOV W2, W4
006DB2  780095     MOV [W5], W1
006DB4  97B37F     MOV [W15-18], W6
006DB6  97BB8F     MOV [W15-16], W7
006DB8  430102     ADD W6, W2, W2
006DBA  4B8183     ADDC W7, W3, W3
006DBC  42828E     ADD W5, W14, W5
006DBE  B90B61     MUL.SU W1, #0x1, W6
006DC0  560F86     SUB W12, W6, [W15]
006DC2  5E8F87     SUBB W13, W7, [W15]
006DC4  35FFEE     BRA LT, .L5
006DC6  370005     BRA .L4
006DC8  97B45F     MOV [W15-22], W8
006DCA  97B4EF     MOV [W15-20], W9
006DCC  370002     BRA .L4
006DCE  97B45F     MOV [W15-22], W8
006DD0  97B4EF     MOV [W15-20], W9
51:                				arr[j] = arr[j - gap];
006DA2  420204     ADD W4, W4, W4
006DA4  400204     ADD W0, W4, W4
006DA6  780A01     MOV W1, [W4]
006DA8  BE0402     MOV.D W2, W8
52:                
53:                			// put temp (the original a[i]) in its correct location
54:                			arr[j] = temp;
006DD2  440408     ADD W8, W8, W8
006DD4  400408     ADD W0, W8, W8
006DD6  97B3AF     MOV [W15-28], W7
006DD8  780C07     MOV W7, [W8]
55:                		}
56:                	}
57:                }
006E3E  78074F     MOV [--W15], W14
006E40  BE064F     MOV.D [--W15], W12
006E42  BE054F     MOV.D [--W15], W10
006E44  BE044F     MOV.D [--W15], W8
006E46  B1016F     SUB #0x16, W15
006E48  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sg_windowing.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*
28:                * seg_windowing
29:                *
30:                * Returns: 1 if WINDOW_SIZE samples have been collected.
31:                */
32:                int32_t tr_windowing(kb_model_t *model, int32_t *columns, int32_t num_cols, seg_params *segParams)
33:                {
34:                
35:                	// Collect data into the raw data buffer for the feature generators.
36:                	model->sg_length += 1;
0096FE  900140     MOV [W0+8], W2
009700  9001D0     MOV [W0+10], W3
009702  410161     ADD W2, #0x1, W2
009704  4981E0     ADDC W3, #0x0, W3
009706  980042     MOV W2, [W0+8]
009708  980053     MOV W3, [W0+10]
37:                
38:                	if (model->sg_length >= segParams->window_size)
00970A  780214     MOV [W4], W4
00970C  DEA2CF     ASR W4, #15, W5
39:                	{
40:                		return 1;
00970E  200010     MOV #0x1, W0
009710  200001     MOV #0x0, W1
009712  510F84     SUB W2, W4, [W15]
009714  598F85     SUBB W3, W5, [W15]
009716  3D0001     BRA GE, .L2
009718  B80060     MUL.UU W0, #0x0, W0
41:                	}
42:                
43:                	return 0;
44:                }
00971A  060000     RETURN
45:                
46:                void tr_windowing_init(kb_model_t *model, seg_params *segParams)
47:                {
48:                	model->sg_length = segParams->window_size - segParams->delta;
000000  040200     GOTO __resetPRI, __reset
49:                	model->sg_index += segParams->delta;
00000A  000BD2     NOP
50:                
51:                	return;
52:                }
00001A  000920     NOP
00001C  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sf_downsample_by_decimation.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Downsample incomming sensor data by taking the average over filter length
29:                *
30:                * \param ringbuffer pointer to the ring buffer to add data too
31:                * \param frameData Pointer to the data which will be transformed
32:                */
33:                int32_t streaming_downsample_by_decimation(ring_buffer_t *pringb, SENSOR_DATA_T *pSample, int32_t *cols_to_use, int32_t num_cols, int32_t filter_length)
34:                {    
35:                    ringb *rb = pringb;
36:                
37:                    if (rb->stat < filter_length - 1)
000000  040200     GOTO __resetPRI, __reset
38:                    {
39:                        rb->stat+=1;
00000E  000920     NOP
40:                        return -1;
000012  00091A     NOP
41:                    }
42:                
43:                    rb->stat=0;
000018  000920     NOP
44:                
45:                    return 1;
00001C  000920     NOP
46:                }
000020  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/sf_downsample_by_averaging.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                /*!
28:                * \brief Downsample incomming sensor data by taking the average over filter length
29:                *
30:                * \param ringbuffer pointer to the ring buffer to add data too
31:                * \param frameData Pointer to the data which will be transformed
32:                */
33:                int32_t streaming_downsample_by_averaging(ring_buffer_t *pringb, SENSOR_DATA_T *pSample, int32_t *cols_to_use, int32_t num_cols, int32_t filter_length)
00004A  000920     NOP
34:                {
000000  040200     GOTO __resetPRI, __reset
35:                    saveSensorData(pringb, pSample, num_cols);
000014  000920     NOP
36:                    ringb *rb = pringb;
37:                
38:                    if (rb_items(rb) < filter_length - 1)
00001C  000920     NOP
00002E  000920     NOP
39:                    {
40:                        return -1;
00002A  000C36     NOP
41:                    }
42:                
43:                    for (int32_t i = 0; i < num_cols; i++)
000038  000920     NOP
000060  000920     NOP
44:                    {
45:                        pSample[i] = (SENSOR_DATA_T)i_mean(rb, 0, filter_length);
000044  000C16     NOP
000050  000920     NOP
46:                        rb_reset(rb);
00005C  000920     NOP
47:                        rb++;
48:                    }
49:                    return 1;
000034  000920     NOP
000076  000920     NOP
50:                }
00007A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/save_sensor_data.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "rb.h"
26:                #include "kbutils.h"
27:                /*!
28:                * \brief Save raw sensor data into KBSensorData in s16 format.
29:                *
30:                * \param rawdata Raw sensor data array pointer.
31:                * \param count Count of data values to save into the KBSensorData array.
32:                */
33:                void saveSensorData(ringb *pringb, SENSOR_DATA_T *rawdata, int32_t count)
34:                {
0091F6  BE9F88     MOV.D W8, [W15++]
0091F8  BE9F8A     MOV.D W10, [W15++]
0091FA  BE9F8C     MOV.D W12, [W15++]
0091FC  780581     MOV W1, W11
0091FE  BE0402     MOV.D W2, W8
35:                    int32_t i;
36:                
37:                    for (i = 0; i < count; i++)
009200  510FE0     SUB W2, #0x0, [W15]
009202  598FE0     SUBB W3, #0x0, [W15]
009204  34000B     BRA LE, .L1
009206  780500     MOV W0, W10
009208  B86660     MUL.UU W12, #0x0, W12
009210  460661     ADD W12, #0x1, W12
009212  4E86E0     ADDC W13, #0x0, W13
009214  45056C     ADD W10, #0xC, W10
009216  540F8C     SUB W8, W12, [W15]
009218  5C8F8D     SUBB W9, W13, [W15]
00921A  3CFFF7     BRA GT, .L3
38:                    {
39:                        rb_add(pringb + i, *rawdata++);
00920A  7800BB     MOV [W11++], W1
00920C  78000A     MOV W10, W0
00920E  070268     RCALL rb_add
40:                    }
41:                
42:                    return;
43:                }
00921C  BE064F     MOV.D [--W15], W12
00921E  BE054F     MOV.D [--W15], W10
009220  BE044F     MOV.D [--W15], W8
009222  060000     RETURN
44:                
45:                /*!
46:                * \brief Save raw sensor data into KBSensorData in s16 format.
47:                *
48:                * \param rawdata Mixed size sensor data array.
49:                * \param row startcol in rows to the frame to update.
50:                * \param count Count of data values to save into the KBSensorData array.
51:                */
52:                void saveSenseDataOffset(ringb *pringb, SENSOR_DATA_T *rawdata, int32_t startcol, int32_t count)
000012  00091A     NOP
53:                {
000000  040200     GOTO __resetPRI, __reset
54:                    int32_t icol;
55:                
56:                    for (icol = startcol; icol < (count + startcol); icol++)
000008  000B4A     NOP
000016  000920     NOP
00001E  000920     NOP
57:                    {
58:                        rb_add(pringb + icol, *rawdata++);
000018  000920     NOP
59:                    }
60:                    return;
61:                }
00002A  000C36     NOP
000032  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/rb.c  
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                /**
26:                 *
27:                 * Since the knowledge pack needs to maintain an array of sensor samples with
28:                 * sliding window access for its computation, ring buffer data structure is
29:                 * needed.
30:                 *
31:                 * This ring buffer implementation requires the ring size to be power of 2 for
32:                 * fast lookup using ring mask.
33:                 *
34:                 */
35:                
36:                #include "rb.h"
37:                
38:                #if SML_DEBUG
39:                #include "assert.h"
40:                
41:                /**
42:                 * \brief Check if a number of power 2
43:                 *
44:                 * @param[i] x - number to be checked
45:                 *
46:                 * @return non-zero if yes, otherwise 0
47:                 */
48:                static int32_t is_pow2(uint16_t x)
49:                {
50:                    return ((x != 0) && ((x & (~x + 1)) == x));
51:                }
52:                
53:                #endif
54:                
55:                /**
56:                 * \brief Return the next power of 2
57:                 *
58:                 * @param[i] x - length to check
59:                 *
60:                 * @return nearest power of 2
61:                 */
62:                int32_t next_pow_2(uint16_t x)
63:                {
64:                    x--;
000000  040200     GOTO __resetPRI, __reset
65:                    x |= x >> 1;
000002  000000     NOP
66:                    x |= x >> 2;
000006  000B2E     NOP
67:                    x |= x >> 4;
00000A  000BD2     NOP
68:                    x |= x >> 8;
00000E  000920     NOP
69:                    x |= x >> 16;
000010  000B66     NOP
70:                    x++;
000012  00091A     NOP
71:                
72:                    return x;
000014  000920     NOP
73:                }
000016  000920     NOP
74:                
75:                /**
76:                 * \brief Initialize the ring buffer.
77:                 *
78:                 * Initialize the ring buffer before start using.
79:                 * - Ring will be empty
80:                 * - Ring will be pointed to array
81:                 * - Ring size must be provided and must be power of 2
82:                 * - Ring mask is used internally under ring buffer APIs for fast lookup
83:                 *
84:                 * @param[in] rb the pointer to ring buffer structure
85:                 * @param[in] ring_size size of the ring buffer
86:                 * @param[in] buffer the pointer the array
87:                 *
88:                 * @return None
89:                 */
90:                
91:                void rb_init(ringb *rb, rb_data_t *buffer, uint16_t ring_size)
92:                {
93:                #if SML_DEBUG
94:                    assert(is_pow2(ring_size) != 0);
95:                    assert(rb);
96:                    assert(buffer);
97:                #endif
98:                
99:                    rb->head = 0;
000000  040200     GOTO __resetPRI, __reset
100:                   rb->tail = 0;
000004  000B9A     NOP
101:                   rb->mask = ring_size - 1; // ring_size must be power of 2
000006  000B2E     NOP
102:                   rb->buff = buffer;
00000A  000BD2     NOP
103:                   rb->stat = 0;
00000C  000BB6     NOP
104:               }
00000E  000920     NOP
000010  000B66     NOP
105:               
106:               /**
107:                * Setup the Ring Buffer.
108:                *
109:                * Setup the ring buffer with the user provided
110:                * buffer to be used as well as its size.
111:                *
112:                * @param[in] rb Pointer to a ringb.
113:                * @param[in] buffer Array for the ring buffer.
114:                * @param[in] size Size of the rng buffer.
115:                *
116:                * @return None
117:                */
118:               
119:               // Same as rb_init(), please use rb_init()
120:               // It is still here for code migration only and will be removed soon!
121:               void setup_rb(ringb *rb, rb_data_t *buffer, uint16_t ring_size)
122:               {
123:               #if SML_DEBUG
124:                   assert(is_pow2(ring_size) == 0);
125:                   assert(rb);
126:                   assert(buffer);
127:               #endif
128:                   rb->head = 0;
000000  040200     GOTO __resetPRI, __reset
129:                   rb->tail = 0;             // size = next to be written index = tail
000004  000B9A     NOP
130:                   rb->mask = ring_size - 1; // ring_size must be power of 2
000006  000B2E     NOP
131:                   rb->buff = buffer;
00000A  000BD2     NOP
132:               }
00000C  000BB6     NOP
00000E  000920     NOP
133:               
134:               /**
135:                * Setup the Ring Buffer with a filled/partiall filled segment.
136:                *
137:                * Setup the ring buffer with the user provided
138:                * buffer to be used as well as its size.
139:                *
140:                * @param[in] rb Pointer to a ringb.
141:                * @param[in] buffer Array for the ring buffer.
142:                * @param[in] size Size of the rng buffer.
143:                * @param[in] size sensor data in the ring buffer.
144:                *
145:                * @return None
146:                */
147:               
148:               // Same as rb_init(), please use rb_init()
149:               // It is still here for code migration only and will be removed soon!
150:               void setup_rb_with_data(ringb *rb, rb_data_t *buffer, uint16_t ring_size, uint16_t data_size)
151:               {
152:               #if SML_DEBUG
153:                   assert(is_pow2(ring_size) == 0);
154:                   assert(rb);
155:                   assert(buffer);
156:               #endif
157:                   rb->head = 0;
000000  040200     GOTO __resetPRI, __reset
158:                   rb->tail = 0;             // size = next to be written index = tail
159:                   rb->mask = ring_size - 1; // ring_size must be power of 2
000002  000000     NOP
160:                   rb->buff = buffer;
000006  000B2E     NOP
161:               
162:                   rb->tail = (rb->tail + data_size) & rb->mask;
000008  000B4A     NOP
163:               
164:                   if (rb->tail == rb->head)
00000C  000BB6     NOP
165:                   {
166:                       rb->head = (rb->head + 1) & rb->mask;
00000E  000920     NOP
167:                   }
168:               }
000010  000B66     NOP
000012  00091A     NOP
169:               
170:               /**
171:                * Read sample value from ring buffer using index to buffer
172:                *
173:                * This read API needs a pointer to the ring buffer and sample index.
174:                *
175:                * @param[in] rb   Pointer to a ringb.
176:                * @param[in] idx  Sample index to be read from ring buffer.
177:                *                 - idx value : 0 - mask, then wrap around
178:                *                 - caller can pass any idx value, this function wil
179:                *                   handle the wrap around index before accessing *rb
180:                *
181:                * @return Value of sample at provided index.
182:                */
183:               rb_data_t rb_read(ringb *rb, uint16_t idx)
184:               {
00000A  000BD2     NOP
185:               #if SML_DEBUG
186:                   assert(rb);
187:               #endif
188:                   return (rb->buff[idx & rb->mask]);
000000  040200     GOTO __resetPRI, __reset
189:               }
00000C  000BB6     NOP
00000E  000920     NOP
190:               
191:               /*
192:                * Read sample value from ring buffer using offset from head (oldest sample)
193:                *
194:                * This read API needs a pointer to the ring buffer and offset.
195:                *
196:                * @param[in] rb   Pointer to a ringb.
197:                * @param[in] offset   Offset from head to read from ring buffer.
198:                *
199:                * @return Value of sample at provided offset.
200:                */
201:               rb_data_t rb_read_offset(ringb *rb, uint16_t offset)
202:               {
00000C  000BB6     NOP
203:               #if SML_DEBUG
204:                   assert(rb);
205:               #endif
206:                   return (rb->buff[(rb->head + offset) & rb->mask]);
000000  040200     GOTO __resetPRI, __reset
207:               }
00000E  000920     NOP
000010  000B66     NOP
000012  00091A     NOP
000014  000920     NOP
208:               
209:               /**
210:                * Add one new sample value to the tail of ring buffer
211:                *
212:                * Since 'tail' is pointing where the new value to be added, it simply write
213:                * that value into that array[tail].
214:                * Next, it takes care of the index wraparound, by +1 & mask.
215:                * Then, it takes care of the 'head' if 'head' needs to be advanced.
216:                *
217:                * @param[in] rb   Pointer to a ringb.
218:                * @param[in] data Value of the sample to be added into the ring buffer
219:                *
220:                * @return None
221:                */
222:               void rb_add(ringb *rb, rb_data_t data)
223:               {
224:               #if SML_DEBUG
225:                   assert(rb);
226:               #endif
227:                   rb->buff[rb->tail] = data;
0096E0  900110     MOV [W0+2], W2
0096E2  9001B0     MOV [W0+6], W3
0096E4  410102     ADD W2, W2, W2
0096E6  418102     ADD W3, W2, W2
0096E8  780901     MOV W1, [W2]
228:                   rb->tail = (rb->tail + 1) & rb->mask;
0096EA  900120     MOV [W0+4], W2
0096EC  900090     MOV [W0+2], W1
0096EE  E80081     INC W1, W1
0096F0  608082     AND W1, W2, W1
0096F2  980011     MOV W1, [W0+2]
229:               
230:                   if (rb->tail == rb->head)
0096F4  508F90     SUB W1, [W0], [W15]
0096F6  3A0002     BRA NZ, .L8
231:                   {
232:                       rb->head = (rb->head + 1) & rb->mask;
0096F8  E80081     INC W1, W1
0096FA  608802     AND W1, W2, [W0]
233:                   }
234:               }
0096FC  060000     RETURN
0096FE  900140     MOV [W0+8], W2
235:               
236:               /**
237:                * Overwrite sample value to a specific index of the ring buffer
238:                *
239:                * @param[in] rb   Pointer to a ringb.
240:                * @param[in] data Value of the sample to be added into the ring buffer
241:                * @param[in] idx  Sample index to be read from ring buffer.
242:                *
243:                * @return None
244:                */
245:               void rb_write(ringb *rb, uint16_t idx, rb_data_t val)
246:               {
247:               #if SML_DEBUG
248:                   assert(rb);
249:               #endif
250:                   rb->buff[idx & rb->mask] = val;
000000  040200     GOTO __resetPRI, __reset
251:               }
00000C  000BB6     NOP
00000E  000920     NOP
252:               
253:               /**
254:                * get_axis_data() To be deplicated??
255:                *
256:                * get_axis_dta() is the same as rb_read().  Should we eliminate one?
257:                */
258:               rb_data_t get_axis_data(ringb *rb, int32_t idx)
259:               {
00000A  000BD2     NOP
260:               #if SML_DEBUG
261:                   assert(rb);
262:               #endif
263:                   return (rb->buff[idx & rb->mask]);
000000  040200     GOTO __resetPRI, __reset
264:               }
00000C  000BB6     NOP
00000E  000920     NOP
265:               
266:               /**
267:                * Add one new sample value to the tail of ring buffer
268:                *
269:                * Since 'tail' is pointing where the new value to be added, it simply write
270:                * that value into that array[tail].
271:                * Next, it takes care of the index wraparound, by +1 & mask.
272:                * Then, it takes care of the 'head' if 'head' needs to be advanced.
273:                *
274:                * @param[in] rb   Pointer to a ringb.
275:                * @param[in] data Value of the sample to be added into the ring buffer
276:                *
277:                * @return None
278:                */
279:               
280:               void rb_reset(ringb *rb)
281:               {
282:                   rb->tail = 0;
000000  040200     GOTO __resetPRI, __reset
283:                   rb->head = 0;
000004  000B9A     NOP
284:                   rb->stat = 0;
000006  000B2E     NOP
285:                   rb->lock = false;
000008  000B4A     NOP
286:               }
00000A  000BD2     NOP
00000C  000BB6     NOP
287:               
288:               /**
289:                * Reset the ring buffer effectivley clearing out the data
290:                *
291:                * @param[in] rb   Pointer to a ringb.
292:                * @param[in] delta step side
293:                * @return None
294:                */
295:               void rb_step_head(ringb *rb, int32_t delta)
296:               {
297:                   rb->head = (rb->head + delta) & rb->mask;
000000  040200     GOTO __resetPRI, __reset
298:               }
000006  000B2E     NOP
000008  000B4A     NOP
299:               
300:               /**
301:                *
302:                */
303:               int32_t rb_valid(ringb *rb)
304:               {
305:               #if SML_DEBUG
306:                   assert(rb);
307:               #endif
308:                   return (rb->tail != rb->head);
000000  040200     GOTO __resetPRI, __reset
309:               }
00000E  000920     NOP
000010  000B66     NOP
310:               
311:               /**
312:                * Set ring buffer lock to True
313:                */
314:               void rb_lock(ringb *rb)
315:               {
316:                   rb->lock = true;
000000  040200     GOTO __resetPRI, __reset
317:               }
000004  000B9A     NOP
000006  000B2E     NOP
318:               
319:               /**
320:                * Set ring buffer lock to False.
321:                */
322:               void rb_unlock(ringb *rb)
323:               {
324:                   rb->lock = false;
000000  040200     GOTO __resetPRI, __reset
325:               }
000004  000B9A     NOP
000006  000B2E     NOP
326:               
327:               /**
328:                * Get the status of the ring buffer.
329:                */
330:               bool rb_status(ringb *rb)
331:               {
000000  040200     GOTO __resetPRI, __reset
332:                   return rb->lock;
333:               }
000002  000000     NOP
000004  000B9A     NOP
334:               
335:               /**
336:                * Write a new value to a location in the ring buffer.
337:                *
338:                * @param[in] rb the pointer to ring buffer structure
339:                * @param[in] idx the pointer to the pre masked index of the ring buffer
340:                * @param[in] data the value to insert into the ring buffer
341:                */
342:               void write_axis_data(ringb *rb, int32_t idx, rb_data_t data)
343:               {
344:                   rb->buff[idx & rb->mask] = data;
000000  040200     GOTO __resetPRI, __reset
345:               }
00000C  000BB6     NOP
00000E  000920     NOP
346:               
347:               /**
348:                * Multiply a data point in ring buffer by value.
349:                * recasts to rb_data_t after multiplcation
350:                *
351:                * @param[in] rb the pointer to ring buffer structure
352:                * @param[in] idx the pointer to the pre masked index of the ring buffer
353:                * @param[in] data value to multiple by
354:                */
355:               void multiply_axis_data(ringb *rb, int32_t idx, rb_data_t data)
356:               {
357:                   int32_t value = rb->buff[idx & rb->mask] * data;
000000  040200     GOTO __resetPRI, __reset
358:               
359:                   if (value > 0x7FFF)
360:                   {
361:                       value = 0x7FFF;
362:                   }
363:                   else if (value < -32768)
364:                   {
365:                       value = -32768;
366:                   }
367:               
368:                   rb->buff[idx & rb->mask] = (rb_data_t)value;
00000E  000920     NOP
369:               }
000010  000B66     NOP
000012  00091A     NOP
370:               
371:               /**
372:                * Divide a data point in ring buffer by value. will recast to rb_data_t
373:                * (note: does not check for a zero divide value)
374:                *
375:                * @param[in] rb the pointer to ring buffer structure
376:                * @param[in] idx the pointer to the pre masked index of the ring buffer
377:                * @param[in] data value to divide by
378:                */
379:               void divide_axis_data(ringb *rb, int32_t idx, rb_data_t data)
380:               {
381:               
382:                   if (data == 0)
000000  040200     GOTO __resetPRI, __reset
383:                   {
384:                       rb->buff[idx & rb->mask] = 0x7FFF;
000004  000B9A     NOP
385:                       return;
000012  00091A     NOP
386:                   }
387:               
388:                   rb->buff[idx & rb->mask] /= data;
000014  000920     NOP
389:               }
000028  000920     NOP
00002A  000C36     NOP
390:               
391:               /**
392:                * Divide a data point in ring buffer by value. will recast to rb_data_t
393:                * (note: does not check for a zero divide value)
394:                *
395:                * @param[in] rb the pointer to ring buffer structure
396:                * @param[in] idx the pointer to the pre masked index of the ring buffer
397:                * @param[in] data value to divide by
398:                */
399:               void divide_axis_data_float(ringb *rb, int32_t idx, float data)
400:               {
000000  040200     GOTO __resetPRI, __reset
401:                   float tmp = 0;
402:               
403:                   if (data == 0)
00000C  000BB6     NOP
404:                   {
405:                       rb->buff[idx & rb->mask] = 0x7FFF;
000016  000920     NOP
406:                       return;
000024  000920     NOP
407:                   }
408:               
409:                   tmp = (float)rb->buff[idx & rb->mask];
410:               
411:                   tmp /= data;
412:               
413:                   rb->buff[idx & rb->mask] = (rb_data_t)data;
000026  000920     NOP
414:               }
000036  000920     NOP
00003E  000920     NOP
415:               
416:               /**
417:                * Divide a data point in ring buffer by value. will recast to rb_data_t
418:                * (note: does not check for a zero divide value)
419:                *
420:                * @param[in] rb the pointer to ring buffer structure
421:                * @param[in] idx the pointer to the pre masked index of the ring buffer
422:                * @param[in] data value to divide by
423:                */
424:               void multiply_axis_data_float(ringb *rb, int32_t idx, float data)
425:               {
000000  040200     GOTO __resetPRI, __reset
426:                   float value = 0;
427:               
428:                   if (data == 0)
00000C  000BB6     NOP
429:                   {
430:                       rb->buff[idx & rb->mask] = 0;
000016  000920     NOP
431:                       return;
000022  000BF6     NOP
432:                   }
433:               
434:                   value = (float)rb->buff[idx & rb->mask];
000024  000920     NOP
435:               
436:                   value *= data;
000034  000920     NOP
437:               
438:                   if (value > 0x7FFF)
00003A  000920     NOP
439:                   {
440:                       value = 0x7FFF;
000052  000920     NOP
441:                   }
442:                   else if (value < -32768)
000044  000C16     NOP
443:                   {
444:                       value = -32768;
000058  000920     NOP
00005A  000920     NOP
00005C  000920     NOP
00005E  000920     NOP
445:                   }
446:               
447:                   rb->buff[idx & rb->mask] = (rb_data_t)value;
00005C  000920     NOP
448:               }
000062  000920     NOP
00006A  000920     NOP
449:               
450:               /**
451:                * Add a value to a point in the ring buffer.
452:                * (note: does not check for int32_t overflow, should we recast?)
453:                *
454:                * @param[in] rb the pointer to ring buffer structure
455:                * @param[in] idx the pointer to the pre masked index of the ring buffer
456:                * @param[in] data value to add
457:                */
458:               void add_axis_data(ringb *rb, int32_t idx, rb_data_t data)
459:               {
460:                   int32_t value = rb->buff[idx & rb->mask] + data;
000000  040200     GOTO __resetPRI, __reset
461:               
462:                   if (value > 0x7FFF)
463:                   {
464:                       value = 0x7FFF;
465:                   }
466:                   else if (value < -32768)
467:                   {
468:                       value = -32768;
469:                   }
470:               
471:                   rb->buff[idx & rb->mask] = (rb_data_t)value;
472:               }
00000C  000BB6     NOP
00000E  000920     NOP
473:               
474:               /**
475:                * Get the number of items in the ring buffer after a specific index.
476:                *
477:                * @param[in] rb the pointer to ring buffer structure
478:                * @param[in] idx the pointer to the pre masked index of the ring buffer
479:                *
480:                * NOTE: this will return rb_size when the tail and idx are the same value
481:                */
482:               int32_t rb_num_items(ringb *rb, int32_t idx)
483:               {
484:                   return ((rb->tail - idx + rb->mask) & rb->mask) + 1;
0098A8  900220     MOV [W0+4], W4
0098AA  B82361     MUL.UU W4, #0x1, W6
0098AC  900010     MOV [W0+2], W0
0098AE  400006     ADD W0, W6, W0
0098B0  4B80E0     ADDC W7, #0x0, W1
0098B2  500002     SUB W0, W2, W0
0098B4  588083     SUBB W1, W3, W1
0098B6  638181     AND W7, W1, W3
0098B8  620100     AND W4, W0, W2
0098BA  410061     ADD W2, #0x1, W0
0098BC  4980E0     ADDC W3, #0x0, W1
485:               }
0098BE  060000     RETURN
0098C0  500FE2     SUB W0, #0x2, [W15]
486:               
487:               /**
488:                * Get the number of items in the ring buffer.
489:                *
490:                * @param[in] rb the pointer to ring buffer structure
491:                */
492:               int32_t rb_items(ringb *rb)
493:               {
494:                   return (rb->tail - rb->head + rb->mask) & rb->mask;
000000  040200     GOTO __resetPRI, __reset
495:               }
00000C  000BB6     NOP
00000E  000920     NOP
496:               
497:               /*
498:                * Print API for SML_DEBUGging only
499:                * - print all data starting with [0]; not head
500:                */
501:               /*
502:               void rb_dump(ringb *rb) {
503:                   int32_t i;
504:                   int32_t len = rb->mask + 1;
505:               //    printf("DUMP: head=%d tail=%d len=%d mask=0x%x [ ",
506:                   pr_info(LOG_MODULE_MAIN, "DUMP: head=%d tail=%d len=%d mask=0x%x [ ",
507:                       rb->head, rb->tail, len, rb->mask);
508:               
509:                   for (i=0; i<len; i++) {
510:               //        printf("%d ", rb->buff[i]);
511:                       pr_info(LOG_MODULE_MAIN,"%d ", rb->buff[i]);
512:                   }
513:               //    printf("]\n");
514:                   pr_info(LOG_MODULE_MAIN,"]\n");
515:               }
516:               */
517:               
518:               /*
519:               int32_t initrb_array(ringb *prb, short *p, int32_t rblen, int32_t rbcnt)
520:               {
521:                   //rb_init(prb, p, rblen);
522:               	int32_t i = 0;
523:               	if (p == 0 || prb == 0 || rbcnt <= 0 || rblen <= 0) return 0;
524:               	for (i = 0; i < rbcnt; i++)
525:               		initrb(prb + i, p + rblen*i, rblen, 0, 0);
526:               	return 1;
527:               }
528:               */
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/ratio_diff_impl.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                int32_t ratio_diff_impl(ringb *rb, int32_t base_index, int32_t nlen, int32_t half_winsize, int32_t flag_h_l, float *out)
00004C  000920     NOP
00009E  000920     NOP
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                	int32_t i, window_size;
30:                	int32_t start_index = base_index + nlen * flag_h_l;
00001C  000920     NOP
000058  000920     NOP
31:                	float sum_mem = 0, sumtemp = 0;
32:                
33:                	float max = -KB_FLT_MAX, min = KB_FLT_MAX;
0000B4  000920     NOP
0000B6  000920     NOP
000152  000920     NOP
34:                
35:                	window_size = 2 * half_winsize + 1;
000030  000920     NOP
36:                
37:                	sum_mem = 0;
000040  000920     NOP
00005C  000920     NOP
38:                	for (i = 0; i < window_size; i++)
000042  000920     NOP
000076  000920     NOP
39:                	{
40:                		sum_mem += MOD_READ_RINGBUF(rb, start_index++);
000048  000920     NOP
00005E  000920     NOP
41:                	}
42:                	start_index = base_index + nlen * flag_h_l + half_winsize;
43:                	for (i = half_winsize; i < nlen - half_winsize; i++)
000080  000920     NOP
00012E  000920     NOP
000130  000920     NOP
44:                	{
45:                		sumtemp = sum_mem;
46:                		sumtemp = sumtemp / (window_size);
0000C2  000920     NOP
47:                		sumtemp = rb->buff[start_index] - sumtemp;
000096  000920     NOP
0000D0  000920     NOP
48:                		sum_mem = sum_mem - MOD_READ_RINGBUF(rb, (start_index - half_winsize) ) +
00009A  000920     NOP
0000E0  00077A     NOP
000104  000920     NOP
49:                				  MOD_READ_RINGBUF(rb, (start_index + half_winsize + 1) );
0000F8  00087E     NOP
50:                		start_index++;
51:                		if (sumtemp > max)
000112  000920     NOP
52:                			max = sumtemp;
00011E  000920     NOP
53:                		if (sumtemp < min)
000122  000920     NOP
54:                			min = sumtemp;
00012C  000920     NOP
55:                	}
56:                
57:                	*out = max - min;
00015E  000920     NOP
58:                	return 1;
59:                }
00016A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/mean.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                //      mean.c
28:                //
29:                //	Return the arithmetic mean of the elements in an array.
30:                //
31:                //      This is the integer optimized version of mean.c
32:                //      It calls the inline routine get_axis_data(), which returns an int16.
33:                //      The input data values are therefore in -32k..32k (16 bits).
34:                //      The routine get_axis_data() is in ../include/rb.h.
35:                //
36:                //	Note that there is a small danger of integer overflow if more than
37:                //	64k data elements are input.
38:                //
39:                //	Note that we are now supporting both FLOAT and int32 return values.
40:                //	Note that we lose a small amount of  precision when the int32 divide
41:                //	takes place, at the end of the function.
42:                
43:                FLOAT mean(ringb *pringb, int32_t base_index, int32_t len)
44:                {
0086D0  BE9F88     MOV.D W8, [W15++]
0086D2  BE9F8A     MOV.D W10, [W15++]
0086D4  BE9F8C     MOV.D W12, [W15++]
0086D6  780080     MOV W0, W1
0086D8  BE0504     MOV.D W4, W10
45:                    if ((!pringb) || (!len))
0086DC  E00001     CP0 W1
0086DE  320026     BRA Z, .L2
0086E0  550FE0     SUB W10, #0x0, [W15]
0086E2  5D8FE0     SUBB W11, #0x0, [W15]
0086E4  320023     BRA Z, .L2
46:                    {
47:                        return 0;
0086DA  B82260     MUL.UU W4, #0x0, W4
48:                    }
49:                
50:                    int32_t irow;
51:                    int64_t sum = 0;
52:                
53:                    for (irow = base_index; irow < (base_index + len); irow++)
0086E6  41040A     ADD W2, W10, W8
0086E8  49848B     ADDC W3, W11, W9
0086EA  B82260     MUL.UU W4, #0x0, W4
0086EC  B83360     MUL.UU W6, #0x0, W6
0086EE  510F88     SUB W2, W8, [W15]
0086F0  598F89     SUBB W3, W9, [W15]
0086F2  3D0012     BRA GE, .L3
00870E  410161     ADD W2, #0x1, W2
008710  4981E0     ADDC W3, #0x0, W3
008712  510F88     SUB W2, W8, [W15]
008714  598F89     SUBB W3, W9, [W15]
008716  35FFF2     BRA LT, .L4
54:                    {
55:                        sum += MOD_READ_RINGBUF(pringb, irow);
0086F4  900031     MOV [W1+6], W0
0086F6  900621     MOV [W1+4], W12
0086F8  B82260     MUL.UU W4, #0x0, W4
0086FA  B83360     MUL.UU W6, #0x0, W6
0086FC  660082     AND W12, W2, W1
0086FE  408081     ADD W1, W1, W1
008700  400081     ADD W0, W1, W1
008702  780091     MOV [W1], W1
008704  DE8ECF     ASR W1, #15, W13
008706  408204     ADD W1, W4, W4
008708  4E8285     ADDC W13, W5, W5
00870A  4E8306     ADDC W13, W6, W6
00870C  4E8387     ADDC W13, W7, W7
56:                    }
57:                
58:                    return ((FLOAT)sum / len);
008718  BE0004     MOV.D W4, W0
00871A  BE0106     MOV.D W6, W2
00871C  07C316     RCALL ___floatdisf
00871E  BE0400     MOV.D W0, W8
008720  BE000A     MOV.D W10, W0
008722  07C323     RCALL ___floatsisf
008724  BE0100     MOV.D W0, W2
008726  BE0008     MOV.D W8, W0
008728  07C49F     RCALL ___divsf3, ___divsf3x
00872A  BE0200     MOV.D W0, W4
59:                }
00872C  BE0004     MOV.D W4, W0
00872E  BE064F     MOV.D [--W15], W12
008730  BE054F     MOV.D [--W15], W10
008732  BE044F     MOV.D [--W15], W8
008734  060000     RETURN
60:                
61:                int32_t i_mean(ringb *pringb, int32_t base_index, int32_t len)
62:                {
000000  040200     GOTO __resetPRI, __reset
63:                    int32_t irow;
64:                    int32_t sum = 0;
00000C  000BB6     NOP
00001A  000920     NOP
65:                
66:                    for (irow = base_index; irow < (base_index + len); irow++)
000008  000B4A     NOP
00000E  000920     NOP
000010  000B66     NOP
000018  000920     NOP
00002A  000C36     NOP
67:                    {
68:                        sum += MOD_READ_RINGBUF(pringb, irow); // add int16 to int32
000014  000920     NOP
00001C  000920     NOP
69:                    }
70:                
71:                    return (int32_t)(sum / len);
000034  000920     NOP
72:                }
00003A  000920     NOP
000040  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/max_min_high_low_freq.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                /*
28:                * max_min_high_low_freq - compute the maximum and minimum of the high or low frequency
29:                *							 component of a waveform.
30:                *
31:                * Inputs
32:                *		nframes - number of rows in the array
33:                *       col - which column to analyze
34:                * 		offset - offset into the column to start
35:                *		sf	- smoothing factor (how many data points on either side of a sample to use to
36:                *				compute the mean.)
37:                *		max = pointer to FLOAT to receive the maximum value.
38:                *		min = pointer to FLOAT to receive the minimum value.
39:                *		lowhigh  - 1 = use high-freq values, 0 = use low freq values.
40:                */
41:                int32_t max_min_high_low_freq(ringb *pringb, int32_t base_index, int32_t nframes, int32_t col, int32_t offset, int32_t sf, int32_t lowhigh, FLOAT *max, FLOAT *min)
0000A4  000920     NOP
0000A6  000920     NOP
0000A8  000920     NOP
0000AA  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
00014E  000920     NOP
000150  000920     NOP
000152  000920     NOP
000154  000920     NOP
000156  000920     NOP
000158  000920     NOP
00015A  000920     NOP
00015C  000920     NOP
00015E  000920     NOP
000160  000920     NOP
000162  000920     NOP
000164  000920     NOP
000166  000920     NOP
000168  000920     NOP
00016A  000920     NOP
00016C  000920     NOP
00016E  000920     NOP
000170  000920     NOP
000172  000920     NOP
000174  000920     NOP
000176  000920     NOP
000178  000920     NOP
00017A  000920     NOP
000192  000920     NOP
000194  000920     NOP
000196  000920     NOP
000198  000920     NOP
0001C4  FFFFFF     NOPR
0001C6  FFFFFF     NOPR
0001C8  FFFFFF     NOPR
0001CA  FFFFFF     NOPR
0001CC  FFFFFF     NOPR
0001CE  FFFFFF     NOPR
0001D0  FFFFFF     NOPR
0001D2  FFFFFF     NOPR
42:                {
000000  040200     GOTO __resetPRI, __reset
43:                	int32_t i;
44:                	ringb *rb = pringb + col;
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
00001C  000920     NOP
45:                	int32_t start_index = (base_index + offset) & rb->mask;
00001A  000920     NOP
46:                	FLOAT dsum;
47:                	FLOAT davg;
48:                	FLOAT dmin = KB_FLT_MAX;
000102  000920     NOP
000104  000920     NOP
000106  000920     NOP
000108  000920     NOP
00010A  000920     NOP
00010C  000920     NOP
00010E  000920     NOP
49:                	FLOAT dmax = KB_FLT_MIN;
00011C  000920     NOP
00011E  000920     NOP
000120  000920     NOP
000122  000920     NOP
000124  000920     NOP
000126  000920     NOP
000128  000920     NOP
50:                	FLOAT dval;
51:                	FLOAT dval0 = (FLOAT)rb->buff[start_index];
000044  000C16     NOP
52:                
53:                	// Compute the running mean for the first sample
54:                	for (i = -sf / 2, dsum = 0.0; i < sf / 2; i++)
000056  000920     NOP
0000CA  0008B2     NOP
0000CC  0008E6     NOP
0000CE  000920     NOP
0000D0  000920     NOP
0000D2  000712     NOP
0000D4  000920     NOP
0000D6  000920     NOP
0000D8  000920     NOP
0000DA  000920     NOP
0000DC  000920     NOP
0000DE  000746     NOP
0000E0  00077A     NOP
0000E2  0007AE     NOP
55:                	{
56:                		start_index = (base_index + offset + i) & rb->mask;
00007E  000920     NOP
000080  000920     NOP
000082  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
0000B0  000920     NOP
0000B2  000920     NOP
0000B4  000920     NOP
0000B6  000920     NOP
57:                		if (i < 0)
000094  000920     NOP
000096  000920     NOP
000098  000920     NOP
00009A  000920     NOP
00009C  000920     NOP
00009E  000920     NOP
0000A0  000920     NOP
58:                		{
59:                			dsum += dval0; // pad with first value on left side.
00009A  000920     NOP
00009C  000920     NOP
00009E  000920     NOP
0000A0  000920     NOP
0000A2  000920     NOP
0000A4  000920     NOP
0000A6  000920     NOP
0000A8  000920     NOP
0000AA  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
60:                		}
61:                		else
62:                		{
63:                			dsum += (FLOAT)rb->buff[start_index];
0000B6  000920     NOP
0000B8  000920     NOP
0000BA  000920     NOP
0000BC  000920     NOP
0000BE  000920     NOP
0000C0  000920     NOP
0000C2  000920     NOP
0000C4  000920     NOP
0000C6  000920     NOP
0000C8  00062E     NOP
0000CA  0008B2     NOP
0000CC  0008E6     NOP
0000CE  000920     NOP
0000D0  000920     NOP
64:                		}
65:                	}
66:                	davg = dsum / sf;
0000E0  00077A     NOP
0000E2  0007AE     NOP
0000E4  000920     NOP
0000E6  000920     NOP
0000E8  00092A     NOP
0000EA  000920     NOP
0000EC  000816     NOP
0000EE  000920     NOP
0000F0  000920     NOP
0000F2  000920     NOP
67:                
68:                	// Subtract the mean from the first sample
69:                	dval = dval0 - davg;
0000F0  000920     NOP
0000F2  000920     NOP
0000F4  000920     NOP
0000F6  00084A     NOP
0000F8  00087E     NOP
0000FA  000920     NOP
70:                
71:                	// Compare to max/min
72:                	if (dval < dmin)
0000F8  00087E     NOP
0000FA  000920     NOP
0000FC  000920     NOP
0000FE  000920     NOP
000100  000920     NOP
000102  000920     NOP
73:                		dmin = dval;
00010C  000920     NOP
00010E  000920     NOP
000110  000920     NOP
000112  000920     NOP
74:                	if (dval > dmax)
000110  000920     NOP
000112  000920     NOP
000114  000920     NOP
000116  000920     NOP
000118  000920     NOP
00011A  000920     NOP
75:                		dmax = dval;
000126  000920     NOP
000128  000920     NOP
00012A  000920     NOP
00012C  000920     NOP
00012E  000920     NOP
76:                
77:                	start_index = (base_index + offset) & rb->mask;
78:                	// Compute the running mean for the each sample
79:                	for (i = 1; i < nframes; i++)
00012A  000920     NOP
00012C  000920     NOP
00012E  000920     NOP
000130  000920     NOP
000132  000920     NOP
000134  000920     NOP
000136  000920     NOP
00028C  07000B     RCALL __memcpyd3extended
00028E  BAC719     TBLRDH.B [W9], W14
000290  BA0519     TBLRDL [W9], W10
000292  E0040E     CP0.B W14
000294  3A0003     BRA NZ, 0x29C
000296  E0000A     CP0 W10
80:                	{
81:                		int32_t decndx = i - sf / 2;
82:                		int32_t addndx = i + sf / 2;
83:                		int32_t dec = decndx < 0 ? dval0 : rb->buff[(base_index + decndx + offset) & rb->mask];
000188  000920     NOP
00018A  000920     NOP
00018C  000920     NOP
00018E  000920     NOP
000190  000920     NOP
000192  000920     NOP
000194  000920     NOP
000196  000920     NOP
000198  000920     NOP
00019A  000920     NOP
00019C  FFFFFF     NOPR
00019E  FFFFFF     NOPR
0001A0  FFFFFF     NOPR
0001A2  FFFFFF     NOPR
0001A4  FFFFFF     NOPR
0001A6  FFFFFF     NOPR
0001A8  FFFFFF     NOPR
0001AA  FFFFFF     NOPR
0001AC  FFFFFF     NOPR
0001AE  FFFFFF     NOPR
0001B0  FFFFFF     NOPR
0001B2  FFFFFF     NOPR
84:                		int32_t add = addndx >= nframes ? rb->buff[(base_index + nframes + offset - 1) & rb->mask] : rb->buff[(base_index + addndx + offset) & rb->mask];
000134  000920     NOP
000136  000920     NOP
000138  000920     NOP
00013A  000920     NOP
00013C  000920     NOP
00013E  000920     NOP
000140  000920     NOP
000142  000920     NOP
000144  000920     NOP
000146  000920     NOP
000148  000920     NOP
00014A  000920     NOP
00014C  000920     NOP
00014E  000920     NOP
000150  000920     NOP
0001B0  FFFFFF     NOPR
0001B2  FFFFFF     NOPR
0001B4  FFFFFF     NOPR
0001B6  FFFFFF     NOPR
0001B8  FFFFFF     NOPR
0001BA  FFFFFF     NOPR
0001BC  FFFFFF     NOPR
0001BE  FFFFFF     NOPR
0001C0  FFFFFF     NOPR
0001C2  FFFFFF     NOPR
0001C4  FFFFFF     NOPR
0001C6  FFFFFF     NOPR
0001CA  FFFFFF     NOPR
0001CC  FFFFFF     NOPR
0001CE  FFFFFF     NOPR
0001D0  FFFFFF     NOPR
0001D2  FFFFFF     NOPR
0001D4  FFFFFF     NOPR
0001D6  FFFFFF     NOPR
0001D8  FFFFFF     NOPR
0001DA  FFFFFF     NOPR
0001DE  FFFFFF     NOPR
85:                
86:                		dsum = dsum - dec + add;
0001D4  FFFFFF     NOPR
0001D6  FFFFFF     NOPR
0001D8  FFFFFF     NOPR
0001DA  FFFFFF     NOPR
0001DC  FFFFFF     NOPR
0001DE  FFFFFF     NOPR
0001E0  FFFFFF     NOPR
0001E2  FFFFFF     NOPR
0001E4  FFFFFF     NOPR
0001E6  FFFFFF     NOPR
0001E8  FFFFFF     NOPR
87:                		davg = dsum / sf;
0001EA  FFFFFF     NOPR
0001EC  FFFFFF     NOPR
0001EE  FFFFFF     NOPR
0001F0  FFFFFF     NOPR
0001F2  FFFFFF     NOPR
88:                
89:                		start_index = (start_index + 1) & rb->mask;
00017A  000920     NOP
00017C  000920     NOP
00017E  000920     NOP
000180  000920     NOP
000182  000920     NOP
000184  000920     NOP
000186  000920     NOP
000188  000920     NOP
0001F2  FFFFFF     NOPR
0001F4  FFFFFF     NOPR
0001F6  FFFFFF     NOPR
0001F8  FFFFFF     NOPR
0001FA  FFFFFF     NOPR
0001FC  FFFFFF     NOPR
0001FE  FFFFFF     NOPR
000200  23752F     MOV #0x3752, W15
000202  26FF0E     MOV #0x6FF0, W14
000204  88010E     MOV W14, SPLIM
000206  000000     NOP
000208  200000     MOV #0x0, W0
00020A  E00000     CP0 W0
00020C  320002     BRA Z, CORCON_RESET
00020E  200100     MOV #0x10, W0
90:                		switch (lowhigh)
000182  000920     NOP
000184  000920     NOP
000186  000920     NOP
000188  000920     NOP
00020E  200100     MOV #0x10, W0
000210  880220     MOV W0, CORCON
000212  070014     RCALL __psv_init
000214  07054F     RCALL __crt_start_mode, __crt_start_mode_normal, .LFE17
000216  E00000     CP0 W0
000218  3A0003     BRA NZ, 0x220
00021A  265320     MOV #0x6532, W0
00021C  200001     MOV #0x0, W1
00021E  370002     BRA 0x224
000220  200000     MOV #0x0, W0
000222  200001     MOV #0x0, W1
000224  700F81     IOR W0, W1, [W15]
000226  320001     BRA Z, 0x22A
000228  07000F     RCALL __data_init, __data_init_extended
00022A  200000     MOV #0x0, W0
00022C  E00000     CP0 W0
91:                		{
92:                		case MOD_HF: // Subtract the mean to get the high freq components.
93:                			dval = rb->buff[start_index] - davg;
00022E  320002     BRA Z, 0x234
000230  020000     CALL buffer_variance
000232  000000     NOP
000234  027858     CALL main
000236  000000     NOP
000238  DA4000     BREAK
00023A  FE0000     RESET
00023C  200660     MOV #0x66, W0
00023E  E00000     CP0 W0
94:                			break;
000240  320002     BRA Z, 0x246
95:                
96:                		case MOD_LF:
97:                			dval = davg; // Return the mean for the low freq components.
000252  B4A054     ADDC TBLPAG
000254  BA0599     TBLRDL [W9], W11
98:                			break;
99:                
100:               		case MOD_RAW:
101:               			dval = rb->buff[start_index];
000242  202000     MOV #0x200, W0
000244  880190     MOV W0, DSRPAG
000246  060000     RETURN
000248  8802A1     MOV W1, TBLPAG
00024A  780480     MOV W0, W9
00024C  EB0000     CLR W0
00024E  37001F     BRA 0x28E
102:               			break;
000250  4484E2     ADD W9, #0x2, W9
000252  B4A054     ADDC TBLPAG
103:               		}
104:               		if (dval < dmin)
000254  BA0599     TBLRDL [W9], W11
000256  4484E2     ADD W9, #0x2, W9
000258  B4A054     ADDC TBLPAG
00025A  BA0699     TBLRDL [W9], W13
00025C  4484E2     ADD W9, #0x2, W9
00025E  B4A054     ADDC TBLPAG
105:               			dmin = dval;
000260  EB0600     CLR W12
000262  DE6F47     LSR W13, #7, W14
106:               		if (dval > dmax)
000264  B207FD     AND #0x7F, W13
000266  8801AE     MOV W14, DSWPAG
000268  E16C63     CP.B W13, #3
00026A  3A0003     BRA NZ, 0x272
00026C  01D80A     CALL.L W10
00026E  EB0000     CLR W0
000270  37000E     BRA 0x28E
000274  3A0008     BRA NZ, 0x286
000276  EB4D00     CLR.B [W10]
000278  E8050A     INC W10, W10
00027A  390002     BRA NC, 0x280
00027C  EC2034     INC DSWPAG
00027E  A0F00A     BSET W10, #15
000280  E9058B     DEC W11, W11
000282  3EFFF9     BRA GTU, 0x276
000284  370004     BRA 0x28E
000286  E16861     CP W13, #1
000288  320001     BRA Z, 0x28C
00028A  EB8600     SETM W12
107:               			dmax = dval;
000270  37000E     BRA 0x28E
000272  E16C60     CP.B W13, #0
000274  3A0008     BRA NZ, 0x286
108:               	}
109:               	*max = dmax;
000296  E0000A     CP0 W10
000298  3AFFDB     BRA NZ, 0x250
00029A  060000     RETURN
00029C  B207FE     AND #0x7F, W14
00029E  8802AE     MOV W14, TBLPAG
0002A0  78048A     MOV W10, W9
0002A2  37FFF5     BRA 0x28E
0002A4  A3D00C     BTST.C W12, #13
110:               	*min = dmin;
00029E  8802AE     MOV W14, TBLPAG
0002A0  78048A     MOV W10, W9
0002A2  37FFF5     BRA 0x28E
0002A4  A3D00C     BTST.C W12, #13
111:               
112:               	return 1;
113:               }
0002A6  4D0FE2     ADDC W10, #0x2, [W15]
0002A8  3B001C     BRA NN, 0x2E2
0002AA  780289     MOV W9, W5
0002AC  BA4D35     TBLRDL.B [W5++], [W10]
0002AE  E8050A     INC W10, W10
0002B0  390002     BRA NC, 0x2B6
0002B2  EC2034     INC DSWPAG
0002B4  A0F00A     BSET W10, #15
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/ma_symmetric.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                static int32_t MA_Symmetric_mm(ringb *pringb, int32_t base_index, int32_t nFrameLen,
0000A4  000920     NOP
28:                						   int32_t nWinSize, int32_t nColToUse, int32_t nSampleRate,
29:                						   int32_t isAC, int32_t nFlagUseSampleRate,
30:                						   int32_t nABSBeforSum, int32_t nABSAfterSum, int32_t nFGName,
31:                						   FLOAT *pFV)
32:                //
33:                //      The version of Moving Average Symmetric which does minimum/maximum code.
34:                //      Anything having to do with sum code is ignored.
35:                //
36:                {
000000  040200     GOTO __resetPRI, __reset
37:                	ringb *rb = pringb + nColToUse; // pointer to ring buffer
000014  000920     NOP
38:                
39:                	int32_t latest_dc_sum = 0;		// sum of the sample values for the set of window size
000026  000920     NOP
000032  000920     NOP
40:                	int32_t sum_dc_sum = 0;			// sum of all DC mean values;
41:                	int32_t max_dc_sum, min_dc_sum; // latest max and min of sum for DC mean
42:                
43:                	int32_t latest_ac_sum = 0;
44:                	int32_t sum_ac_sum = 0;			// sum of all AC mean values;
45:                	int32_t max_ac_sum, min_ac_sum; // latest max and min of sum of AC mean
46:                
47:                	int32_t half_win_size_offset = nWinSize >> 1; // divided by 2
00001E  000920     NOP
48:                
49:                	float max = -FLOAT_MAX, min = FLOAT_MAX; // max and min of mean values
50:                
51:                	int32_t i; // loop index variable
52:                
53:                	// Calculate sum of sample values of the first window
54:                	for (i = 0; i < nWinSize; i++)
00002C  000920     NOP
00004E  000920     NOP
55:                	{
56:                		latest_dc_sum += rb_read(rb, i + base_index);
000040  000920     NOP
57:                	}
58:                
59:                	// update statistical variables for the window
60:                	max_dc_sum = min_dc_sum = latest_dc_sum;
61:                	sum_dc_sum += nABSBeforSum == 1 ? Fabs(latest_dc_sum) : latest_dc_sum;
62:                
63:                	if (isAC != 0)
000060  000920     NOP
64:                	{
65:                		// Chris pointed out that it should be the mid sample of the window
66:                		latest_ac_sum =
00007E  000920     NOP
67:                			(rb_read(rb, half_win_size_offset + base_index) * nWinSize) -
00006A  000920     NOP
68:                			latest_dc_sum;
69:                
70:                		max_ac_sum = min_ac_sum = latest_ac_sum;
00008A  000920     NOP
71:                		sum_ac_sum +=
72:                			nABSBeforSum == 1 ? Fabs(latest_ac_sum) : latest_ac_sum;
73:                	}
74:                	// Bug fix to JSD-7213 by adding +1 to this loop
75:                	for (i = 1; i < nFrameLen - nWinSize + 1; i++)
00008E  000920     NOP
00015A  000920     NOP
76:                	{
77:                
78:                		latest_dc_sum =
0000EE  000920     NOP
79:                			latest_dc_sum - rb_read(rb, i - 1 + base_index) + rb_read(rb, i + nWinSize - 1 + base_index);
0000D4  000920     NOP
80:                		sum_dc_sum +=
81:                			nABSBeforSum == 1 ? Fabs(latest_dc_sum) : latest_dc_sum;
82:                
83:                		if (max_dc_sum < latest_dc_sum)
0000F2  000920     NOP
84:                		{
85:                			max_dc_sum = latest_dc_sum;
000108  000920     NOP
86:                		}
87:                		else if (min_dc_sum > latest_dc_sum)
0000FC  000920     NOP
0000FE  000920     NOP
88:                		{
89:                			min_dc_sum = latest_dc_sum;
00010E  000920     NOP
000110  000920     NOP
90:                		}
91:                
92:                		if (isAC != 0)
000112  000920     NOP
93:                		{
94:                			// Chris pointed out that it should be the mid sample of the window
95:                			latest_ac_sum =
000136  000920     NOP
96:                				(rb_read(rb, i + half_win_size_offset + base_index) *
00011C  000920     NOP
97:                				 nWinSize) -
98:                				latest_dc_sum;
99:                
100:               			if (max_ac_sum < latest_ac_sum)
00013A  000920     NOP
101:               			{
102:               				max_ac_sum = latest_ac_sum;
000150  000920     NOP
103:               			}
104:               			else if (min_ac_sum > latest_ac_sum)
000144  000920     NOP
105:               			{
106:               				min_ac_sum = latest_ac_sum;
000156  000920     NOP
000158  000920     NOP
00015A  000920     NOP
107:               			}
108:               		}
109:               	}
110:               
111:               	if (isAC != 0)
00017E  000920     NOP
112:               	{
113:               		max = (max_ac_sum * 1.0) / nWinSize; // AC
000188  000920     NOP
114:               		min = (min_ac_sum * 1.0) / nWinSize;
00019A  000920     NOP
115:               	}
116:               	else
117:               	{
118:               		max = (max_dc_sum * 1.0) / nWinSize; // DC
0001A6  FFFFFF     NOPR
119:               		min = (min_dc_sum * 1.0) / nWinSize;
0001B6  FFFFFF     NOPR
0001B8  FFFFFF     NOPR
120:               	}
121:               
122:               	switch (nFGName)
0001BE  FFFFFF     NOPR
123:               	{
124:               	case global_p2p_high_frequency_name:
125:               		*pFV = max - min;
0001D4  FFFFFF     NOPR
126:               		break;
0001DE  FFFFFF     NOPR
127:               	case global_p2p_low_frequency_name:
128:               		*pFV = max - min;
0001E0  FFFFFF     NOPR
0001E2  FFFFFF     NOPR
129:               		break;
0001EA  FFFFFF     NOPR
130:               	case max_p2p_half_high_frequency_name:
131:               		*pFV = max - min;
0001EC  FFFFFF     NOPR
132:               		break;
0001F6  FFFFFF     NOPR
133:               	case absolute_area_high_frequency_name:
134:               	case absolute_area_low_frequency_name:
135:               	case total_area_low_frequency_name:
136:               	case total_area_high_frequency_name:
137:               	default:
138:               		pFV[0] = 1234.5678; // error flag value
0001F8  FFFFFF     NOPR
139:               		break;
140:               	}
141:               
142:               	return 1;
143:               }
000200  23752F     MOV #0x3752, W15
144:               
145:               static int32_t MA_Symmetric_sum(ringb *pringb, int32_t base_index, int32_t nFrameLen,
00010E  000920     NOP
146:               							int32_t nWinSize, int32_t nColToUse, int32_t nSampleRate,
147:               							int32_t isAC, int32_t nFlagUseSampleRate,
148:               							int32_t nABSBeforSum, int32_t nABSAfterSum,
149:               							int32_t nFGName, FLOAT *pFV)
150:               //
151:               //      The version of Moving Average Symmetric which does summation code.
152:               //      Anything having to do with minimum/maximum code is ignored.
153:               //
154:               {
000000  040200     GOTO __resetPRI, __reset
155:               	ringb *rb = pringb + nColToUse; // pointer to ring buffer
000014  000920     NOP
156:               
157:               	int32_t latest_dc_sum = 0; // sum of the sample values for the set of window size
000046  000920     NOP
000052  000920     NOP
158:               	int32_t sum_dc_sum = 0;	   // sum of all DC mean values;
159:               
160:               	int32_t latest_ac_sum = 0;
161:               	int32_t sum_ac_sum = 0; // sum of all AC mean values;
0000AA  000920     NOP
162:               
163:               	int32_t half_win_size_offset = nWinSize >> 1; // divided by 2
00001E  000920     NOP
164:               
165:               	float sum_fv = 0; // sum of feature values,i.e, sum of each mean values
166:               
167:               	float fSampleInterval =
168:               		nFlagUseSampleRate == 1 ? (1.0f / (float)nSampleRate) : 1.0f;
000026  000920     NOP
169:               
170:               	int32_t i; // loop index variable
171:               
172:               	// Calculate sum of sample values of the first window
173:               	for (i = 0; i < nWinSize; i++)
00004C  000920     NOP
00006E  000B0E     NOP
174:               	{
175:               		latest_dc_sum += rb_read(rb, i + base_index);
000060  000920     NOP
176:               	}
177:               
178:               	// update statistical variables for the window
179:               	sum_dc_sum += nABSBeforSum == 1 ? Fabs(latest_dc_sum) : latest_dc_sum;
000084  000920     NOP
180:               
181:               	if (isAC != 0)
0000B0  000920     NOP
182:               	{
183:               		// Chris pointed out that it should be the mid sample of the window
184:               		latest_ac_sum =
0000D0  000920     NOP
185:               			(rb_read(rb, half_win_size_offset + base_index) * nWinSize) -
0000BA  000920     NOP
186:               			latest_dc_sum;
187:               
188:               		sum_ac_sum +=
189:               			nABSBeforSum == 1 ? Fabs(latest_ac_sum) : latest_ac_sum;
0000D8  000920     NOP
190:               	}
191:               	// Bug fix to JSD-7213 by adding +1 to this loop
192:               	for (i = 1; i < nFrameLen - nWinSize + 1; i++)
0000F8  00087E     NOP
0001CA  FFFFFF     NOPR
193:               	{
194:               
195:               		latest_dc_sum =
00014C  000920     NOP
196:               			latest_dc_sum - rb_read(rb, i - 1 + base_index) + rb_read(rb, i + nWinSize - 1 + base_index);
000136  000920     NOP
197:               		sum_dc_sum +=
000172  000920     NOP
000174  000920     NOP
000176  000920     NOP
000178  000920     NOP
198:               			nABSBeforSum == 1 ? Fabs(latest_dc_sum) : latest_dc_sum;
000158  000920     NOP
199:               
200:               		if (isAC != 0)
00017E  000920     NOP
201:               		{
202:               			// Chris pointed out that it should be the mid sample of the window
203:               			latest_ac_sum =
0001A2  FFFFFF     NOPR
204:               				(rb_read(rb, i + half_win_size_offset + base_index) *
000188  000920     NOP
205:               				 nWinSize) -
206:               				latest_dc_sum;
207:               
208:               			sum_ac_sum +=
0001BE  FFFFFF     NOPR
0001C0  FFFFFF     NOPR
209:               				nABSBeforSum == 1 ? Fabs(latest_ac_sum) : latest_ac_sum;
0001AA  FFFFFF     NOPR
0001AC  FFFFFF     NOPR
210:               		}
211:               	}
212:               
213:               	if (isAC != 0)
0001EC  FFFFFF     NOPR
214:               	{
215:               		sum_fv = (sum_ac_sum * fSampleInterval) / nWinSize; // AC
0001F6  FFFFFF     NOPR
0001F8  FFFFFF     NOPR
0001FA  FFFFFF     NOPR
0001FC  FFFFFF     NOPR
216:               	}
217:               	else
218:               	{
219:               		sum_fv = (sum_dc_sum * fSampleInterval) / nWinSize; // DC
000212  070014     RCALL __psv_init
000214  07054F     RCALL __crt_start_mode, __crt_start_mode_normal, .LFE17
000216  E00000     CP0 W0
000218  3A0003     BRA NZ, 0x220
220:               	}
221:               
222:               	sum_fv = nABSAfterSum == 1 ? Fabs(sum_fv) : sum_fv;
00022A  200000     MOV #0x0, W0
00022C  E00000     CP0 W0
00022E  320002     BRA Z, 0x234
000230  020000     CALL buffer_variance
223:               
224:               	switch (nFGName)
000240  320002     BRA Z, 0x246
000242  202000     MOV #0x200, W0
225:               	{
226:               	case absolute_area_high_frequency_name:
227:               		*pFV = sum_fv;
000266  8801AE     MOV W14, DSWPAG
228:               		break;
00026A  3A0003     BRA NZ, 0x272
229:               	case absolute_area_low_frequency_name:
230:               		*pFV = sum_fv;
00026C  01D80A     CALL.L W10
231:               		break;
000270  37000E     BRA 0x28E
232:               	case total_area_low_frequency_name:
233:               		*pFV = Fabs(sum_fv);
000272  E16C60     CP.B W13, #0
234:               		break;
000282  3EFFF9     BRA GTU, 0x276
000284  370004     BRA 0x28E
000286  E16861     CP W13, #1
235:               	case total_area_high_frequency_name:
236:               		*pFV = sum_fv;
000284  370004     BRA 0x28E
237:               		break;
000288  320001     BRA Z, 0x28C
238:               	default:
239:               	case global_p2p_high_frequency_name:
240:               	case global_p2p_low_frequency_name:
241:               	case max_p2p_half_high_frequency_name:
242:               		pFV[0] = 1234.5678; // error flag value
00028A  EB8600     SETM W12
00028C  07000B     RCALL __memcpyd3extended
00028E  BAC719     TBLRDH.B [W9], W14
000290  BA0519     TBLRDL [W9], W10
243:               		break;
244:               	}
245:               
246:               	return 1;
247:               }
000292  E0040E     CP0.B W14
0002A2  37FFF5     BRA 0x28E
248:               
249:               int32_t MA_Symmetric(ringb *pringb, int32_t base_index, int32_t nFrameLen,
250:               				 int32_t nWinSize, int32_t nColToUse, int32_t nSampleRate, int32_t isAC,
251:               				 int32_t nFlagUseSampleRate, int32_t nABSBeforSum,
252:               				 int32_t nABSAfterSum, int32_t nFGName, FLOAT *pFV)
253:               {
000000  040200     GOTO __resetPRI, __reset
254:               	nWinSize = nWinSize * 2 + 1;
000014  000920     NOP
255:               
256:               	switch (nFGName)
00001C  000920     NOP
257:               	{
258:               	case global_p2p_high_frequency_name:
259:               	case global_p2p_low_frequency_name:
260:               	case max_p2p_half_high_frequency_name:
261:               		MA_Symmetric_mm(pringb, base_index, nFrameLen,
000030  000920     NOP
262:               						nWinSize, nColToUse, nSampleRate, isAC,
263:               						nFlagUseSampleRate, nABSBeforSum,
264:               						nABSAfterSum, nFGName, pFV);
265:               		break;
000050  000920     NOP
266:               
267:               	case absolute_area_high_frequency_name:
268:               	case absolute_area_low_frequency_name:
269:               	case total_area_low_frequency_name:
270:               	case total_area_high_frequency_name:
271:               		MA_Symmetric_sum(pringb, base_index, nFrameLen,
000054  000920     NOP
272:               						 nWinSize, nColToUse, nSampleRate, isAC,
273:               						 nFlagUseSampleRate, nABSBeforSum,
274:               						 nABSAfterSum, nFGName, pFV);
275:               		break;
000074  000920     NOP
000076  000920     NOP
276:               	default:
277:               		pFV[0] = 1234.5678; // error flag value
000078  000920     NOP
278:               		break;
279:               	}
280:               
281:               	return 1;
282:               }
00007E  000920     NOP
00008C  000920     NOP
283:               
284:               //
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/kb_pipeline.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kb_pipeline.h"
26:                
27:                #include "tree_ensemble.h"
28:                
29:                #include "sml_profile_utils.h"
30:                static uint32_t profile_cycle_count = 0;
31:                static float profile_total_time = 0.0f;
32:                static float profile_avg_iter_time = 0.0f;
33:                
34:                #pragma GCC diagnostic ignored "-Wunused-function"
35:                #pragma GCC diagnostic ignored "-Wunused-variable"
36:                
37:                // Operations
38:                #define FLT_MAX (FLOAT) 0x7f7fffff
39:                #define FLT_MIN -(FLT_MAX)
40:                #define NUMBER_OF_SENSORS 2
41:                #define MAX_FEATURE_SELECTION 0
42:                
43:                int32_t          columns[NUMBER_OF_SENSORS];
44:                int32_t          feature_selection[MAX_FEATURE_SELECTION];
45:                int32_t          num_feature_selection = 0;
46:                static float params[6];
47:                
48:                
49:                int32_t KB_data_streaming_PIPELINE_1_RANK_0(void* model, SENSOR_DATA_T *pSample)
50:                {
00957E  781F88     MOV W8, [W15++]
51:                	int32_t FrameIdx = 0;
52:                	kb_model_t * kb_model = (kb_model_t*)model;
53:                
54:                	columns[0] = IQ_S_PIPELINE_1_RANK_0;
009584  EF323A     CLR columns
009586  EF323C     CLR 0x123C
55:                	FrameIdx += tr_sensor_sensors(pSample, columns, 1, &kb_model->frameData[FrameIdx]);	
009588  901268     MOV [W8+44], W4
00958A  200012     MOV #0x1, W2
00958C  200003     MOV #0x0, W3
00958E  2123A1     MOV #0x123A, W1
009590  07FF5E     RCALL tr_sensor_sensors
56:                saveSensorData(kb_model->pringb, kb_model->frameData, kb_model->framelen);
009592  9010E8     MOV [W8+44], W1
009594  901048     MOV [W8+40], W0
009596  BE0118     MOV.D [W8], W2
009598  07FE2E     RCALL saveSensorData
57:                	return 1;
58:                }
00959A  200010     MOV #0x1, W0
00959C  200001     MOV #0x0, W1
00959E  78044F     MOV [--W15], W8
0095A0  060000     RETURN
59:                
60:                
61:                
62:                int32_t KB_data_segmentation_PIPELINE_1_RANK_0(void* model, int32_t model_index)
63:                {
0084BE  FA0004     LNK #0x4
64:                	int32_t FrameIdx = 0;
65:                	kb_model_t * kb_model = (kb_model_t*)model+model_index;
0084C6  2004C1     MOV #0x4C, W1
0084C8  B99181     MULW.SS W2, W1, W2
0084CA  400602     ADD W0, W2, W12
66:                	int32_t new_samples = rb_num_items(kb_model->pringb, kb_model->last_read_idx);
0084CC  90090C     MOV [W12+16], W2
0084CE  90099C     MOV [W12+18], W3
0084D0  90104C     MOV [W12+40], W0
0084D2  0709EA     RCALL rb_num_items
0084D4  BE0500     MOV.D W0, W10
67:                	int32_t i;
68:                	for (i=0; i<new_samples; i++){
0084DA  550FE0     SUB W10, #0x0, [W15]
0084DC  5D8FE0     SUBB W11, #0x0, [W15]
0084DE  340020     BRA LE, .L3
0084E0  B80060     MUL.UU W0, #0x0, W0
0084E2  9FBF80     MOV W0, [W15-16]
0084E4  9FBF91     MOV W1, [W15-14]
008504  97B80F     MOV [W15-16], W0
008506  97B89F     MOV [W15-14], W1
008508  400061     ADD W0, #0x1, W0
00850A  4880E0     ADDC W1, #0x0, W1
00850C  9FBF80     MOV W0, [W15-16]
00850E  9FBF91     MOV W1, [W15-14]
008510  550F80     SUB W10, W0, [W15]
008512  5D8F81     SUBB W11, W1, [W15]
008514  3CFFEA     BRA GT, .L4
69:                			kb_model->last_read_idx += 1;
0084EA  90080C     MOV [W12+16], W0
0084EC  90089C     MOV [W12+18], W1
0084EE  400061     ADD W0, #0x1, W0
0084F0  4880E0     ADDC W1, #0x0, W1
0084F2  980E00     MOV W0, [W12+16]
0084F4  980E11     MOV W1, [W12+18]
70:                		
71:                	if(tr_windowing(kb_model, columns, 0, kb_model->psegParams)){
0084E6  B84460     MUL.UU W8, #0x0, W8
0084E8  2123AD     MOV #0x123A, W13
0084F6  90122C     MOV [W12+36], W4
0084F8  BE0108     MOV.D W8, W2
0084FA  BE000C     MOV.D W12, W0
0084FC  070900     RCALL tr_windowing
0084FE  500FE0     SUB W0, #0x0, [W15]
008500  588FE0     SUBB W1, #0x0, [W15]
008502  3A000C     BRA NZ, .L6
72:                			return 1;
00851C  200010     MOV #0x1, W0
00851E  200001     MOV #0x0, W1
73:                		}
74:                	}
75:                	// Colect more samples
76:                	return -1;
0084D6  EB8000     SETM W0
0084D8  EB8080     SETM W1
008516  EB8000     SETM W0
008518  EB8080     SETM W1
00851A  370002     BRA .L3
77:                }
008520  BE064F     MOV.D [--W15], W12
008522  BE054F     MOV.D [--W15], W10
008524  BE044F     MOV.D [--W15], W8
008526  FA8000     ULNK
008528  060000     RETURN
00852A  FA0008     LNK #0x8
78:                
79:                
80:                
81:                int32_t KB_feature_gen_model_PIPELINE_1_RANK_0(void * model, int32_t *nfeats)
82:                {
0077A4  FA0004     LNK #0x4
0077A6  BE9F88     MOV.D W8, [W15++]
0077A8  BE9F8A     MOV.D W10, [W15++]
0077AA  BE9F8C     MOV.D W12, [W15++]
0077AC  780400     MOV W0, W8
0077AE  780501     MOV W1, W10
83:                	int32_t column = 0;
84:                	int32_t num_params = 1;
85:                	kb_model_t * kb_model = (kb_model_t*)model;
86:                	int32_t nframes = kb_model->sg_length;
87:                	int32_t CompIdx = (kb_model->feature_bank_index) * (kb_model->feature_bank_size);
0077B0  905808     MOV.B [W8+24], W0
0077B2  FB8000     ZE W0, W0
0077B4  9008D8     MOV [W8+26], W1
0077B6  B98081     MULW.SS W0, W1, W0
0077B8  B80161     MUL.UU W0, #0x1, W2
0077BA  9FBF82     MOV W2, [W15-16]
0077BC  9FBF93     MOV W3, [W15-14]
88:                	
89:                num_params = 0;	
90:                columns[0] = IQ_D_PIPELINE_1_RANK_0;	
0077BE  2123A9     MOV #0x123A, W9
0077C0  B86660     MUL.UU W12, #0x0, W12
0077C2  8891DC     MOV W12, columns
0077C4  8891ED     MOV W13, 0x123C
91:                *nfeats = fg_stats_pct025(kb_model, columns, 1, params, num_params, &kb_model->pFeatures[CompIdx]);	
0077C6  DD0042     SL W0, #2, W0
0077C8  9012B8     MOV [W8+38], W5
0077CA  428280     ADD W5, W0, W5
0077CC  B83360     MUL.UU W6, #0x0, W6
0077CE  237004     MOV #0x3700, W4
0077D0  200012     MOV #0x1, W2
0077D2  200003     MOV #0x0, W3
0077D4  BE0008     MOV.D W8, W0
0077D6  0706A9     RCALL fg_stats_pct025
0077D8  BE8D00     MOV.D W0, [W10]
92:                CompIdx += *nfeats;	
0077DA  97B90F     MOV [W15-16], W2
0077DC  97B99F     MOV [W15-14], W3
0077DE  410100     ADD W2, W0, W2
0077E0  498181     ADDC W3, W1, W3
0077E2  9FBF82     MOV W2, [W15-16]
0077E4  9FBF93     MOV W3, [W15-14]
93:                num_params = 0;	
94:                columns[0] = IQ_D_PIPELINE_1_RANK_0;	
0077E6  8891DC     MOV W12, columns
0077E8  8891ED     MOV W13, 0x123C
95:                *nfeats = fg_stats_pct075(kb_model, columns, 1, params, num_params, &kb_model->pFeatures[CompIdx]);	
0077EA  DD1042     SL W2, #2, W0
0077EC  9012B8     MOV [W8+38], W5
0077EE  428280     ADD W5, W0, W5
0077F0  B83360     MUL.UU W6, #0x0, W6
0077F2  237004     MOV #0x3700, W4
0077F4  200012     MOV #0x1, W2
0077F6  200003     MOV #0x0, W3
0077F8  BE0008     MOV.D W8, W0
0077FA  0706CC     RCALL fg_stats_pct075
0077FC  BE8D00     MOV.D W0, [W10]
96:                CompIdx += *nfeats;	
0077FE  97B90F     MOV [W15-16], W2
007800  97B99F     MOV [W15-14], W3
007802  400102     ADD W0, W2, W2
007804  488183     ADDC W1, W3, W3
007806  9FBF82     MOV W2, [W15-16]
007808  9FBF93     MOV W3, [W15-14]
97:                params[0] = 100;	
00780A  23700B     MOV #0x3700, W11
00780C  200000     MOV #0x0, W0
00780E  242C81     MOV #0x42C8, W1
007810  BE8D80     MOV.D W0, [W11]
98:                num_params = 1;	
99:                columns[0] = IQ_D_PIPELINE_1_RANK_0;	
007812  8891DC     MOV W12, columns
007814  8891ED     MOV W13, 0x123C
100:               *nfeats = fg_area_power_spectrum_density(kb_model, columns, 1, params, num_params, &kb_model->pFeatures[CompIdx]);	
007816  DD1042     SL W2, #2, W0
007818  9012B8     MOV [W8+38], W5
00781A  428280     ADD W5, W0, W5
00781C  200016     MOV #0x1, W6
00781E  200007     MOV #0x0, W7
007820  78020B     MOV W11, W4
007822  BE0106     MOV.D W6, W2
007824  BE0008     MOV.D W8, W0
007826  07016A     RCALL fg_area_power_spectrum_density
007828  BE8D00     MOV.D W0, [W10]
101:               CompIdx += *nfeats;	
00782E  97B90F     MOV [W15-16], W2
007830  97B99F     MOV [W15-14], W3
007832  400002     ADD W0, W2, W0
007834  488083     ADDC W1, W3, W1
102:               num_params = 0;	
103:               columns[0] = IQ_D_PIPELINE_1_RANK_0;	
00782A  8891DC     MOV W12, columns
00782C  8891ED     MOV W13, 0x123C
104:               *nfeats = fg_stats_skewness(kb_model, columns, 1, params, num_params, &kb_model->pFeatures[CompIdx]);	
007836  DD0042     SL W0, #2, W0
007838  9012B8     MOV [W8+38], W5
00783A  428280     ADD W5, W0, W5
00783C  B83360     MUL.UU W6, #0x0, W6
00783E  78020B     MOV W11, W4
007840  200012     MOV #0x1, W2
007842  200003     MOV #0x0, W3
007844  BE0008     MOV.D W8, W0
007846  0701AC     RCALL fg_stats_skewness
007848  BE8D00     MOV.D W0, [W10]
105:               CompIdx += *nfeats;	
106:               return 1;
107:               }
00784A  200010     MOV #0x1, W0
00784C  200001     MOV #0x0, W1
00784E  BE064F     MOV.D [--W15], W12
007850  BE054F     MOV.D [--W15], W10
007852  BE044F     MOV.D [--W15], W8
007854  FA8000     ULNK
007856  060000     RETURN
007858  FA0004     LNK #0x4
108:               
109:               
110:               
111:               int32_t KB_feature_transform_PIPELINE_1_RANK_0(void * model)
112:               {
008FBC  BE9F88     MOV.D W8, [W15++]
113:               	kb_model_t * kb_model = (kb_model_t*)model;
114:               	
115:               	static struct minmax aminmax[4] = {
116:               	
117:               		{0, 151.0f, 737.0f},	
118:               		{1, 163.0f, 859.0f},	
119:               		{2, 1240402816.0f, 32113020928.0f},	
120:               		{3, -2.403172731399536f, 1.0124948024749756f},	
121:               	};
122:               	
123:               	int32_t start = (kb_model->feature_bank_index+1) * (kb_model->feature_bank_size);
008FBE  9008D0     MOV [W0+26], W1
008FC6  905A00     MOV.B [W0+24], W4
008FC8  FB8204     ZE W4, W4
008FCA  E80204     INC W4, W4
008FCC  B9A281     MULW.SS W4, W1, W4
124:               	
125:               	int32_t total_features = (kb_model->feature_bank_size) * (kb_model->feature_bank_number);
008FC0  905B50     MOV.B [W0+29], W6
008FC2  FB8306     ZE W6, W6
008FC4  B9B381     MULW.SS W6, W1, W6
126:               	
127:               	min_max_scale(kb_model->pFeatures, kb_model->feature_vector, kb_model->feature_vector_size, start, total_features, 0, 255, aminmax);
008FCE  900970     MOV [W0+30], W2
008FD0  EB0180     CLR W3
008FD2  901080     MOV [W0+32], W1
008FD4  901030     MOV [W0+38], W0
008FD6  234865     MOV #0x3486, W5
008FD8  781F85     MOV W5, [W15++]
008FDA  200008     MOV #0x0, W8
008FDC  2437F9     MOV #0x437F, W9
008FDE  BE9F88     MOV.D W8, [W15++]
008FE0  B84460     MUL.UU W8, #0x0, W8
008FE2  BE9F88     MOV.D W8, [W15++]
008FE4  EB0380     CLR W7
008FE6  EB0280     CLR W5
008FE8  07F381     RCALL min_max_scale
008FEA  5787EA     SUB W15, #0xA, W15
128:               	return 1;
129:               
130:               }
008FEC  200010     MOV #0x1, W0
008FEE  200001     MOV #0x0, W1
008FF0  BE044F     MOV.D [--W15], W8
008FF2  060000     RETURN
008FF4  500FE1     SUB W0, #0x1, [W15]
131:               
132:               
133:               
134:               int32_t KB_recognize_vector_PIPELINE_1_RANK_0(void * model)
135:               {
136:               	int32_t ret;
137:               	kb_model_t * kb_model = (kb_model_t*)model;
138:               	ret = tree_ensemble_simple_submit(kb_model->classifier_id , kb_model->feature_vector);
009D30  901080     MOV [W0+32], W1
009D32  906030     MOV.B [W0+35], W0
009D34  07F352     RCALL tree_ensemble_simple_submit
009D36  FB8000     ZE W0, W0
009D38  EB0080     CLR W1
139:               	return ret;
140:               
141:               }
009D3A  060000     RETURN
009D3C  B81160     MUL.UU W2, #0x0, W2
142:               
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/kb_debug.c
1:                 #include "kb_debug.h"
2:                 
3:                 int16_t output_tensor[20];
4:                 model_results_t model_results = {.num_outputs=0,
5:                                                  .output_tensor=output_tensor                
6:                                                  };
7:                 
8:                 
9:                 int32_t kb_print_model_result(
10:                    int32_t model_index, int32_t result, char* pbuf, bool feature_vectors, uint8_t* fv_arr)
11:                {
000000  040200     GOTO __resetPRI, __reset
12:                    uint16_t fv_len;
13:                    int32_t  count = 0;
14:                
15:                    count += sprintf(
000014  000920     NOP
16:                        pbuf,
17:                        "{\"ModelNumber\":%d,\"Classification\":%d,\"SegmentStart\":%d,\"SegmentLength\":%d",
18:                        model_index,
19:                        result,
20:                        kb_get_segment_start(model_index),
21:                        kb_get_segment_length(model_index));
22:                
23:                    if (feature_vectors)
000034  000920     NOP
24:                    {
25:                        fv_len = kb_get_feature_vector_size(model_index);
00003C  000920     NOP
26:                        kb_get_feature_vector_v2(model_index, fv_arr);
000044  000C16     NOP
27:                
28:                        count += sprintf(pbuf + count, ",\"FeatureVectorLength\":%d, \"FeatureVector\":[", fv_len);
00004A  000920     NOP
29:                
30:                        for (int32_t j = 0; j < fv_len - 1; j++)
00005E  000920     NOP
000086  000920     NOP
31:                        {
32:                            count += sprintf(pbuf + count, "%d,", fv_arr[j]);
000074  000920     NOP
33:                        }
34:                        count += sprintf(pbuf + count, "%d]", fv_arr[fv_len - 1]);
000096  000920     NOP
35:                    };
36:                
37:                    count += sprintf(pbuf + count, "}\n");
0000B6  000920     NOP
38:                
39:                    return count;
40:                }
0000CC  0008E6     NOP
41:                
42:                int32_t kb_print_model_output_tensor(int32_t model_index, int32_t result, char* pbuf)
43:                {
000000  040200     GOTO __resetPRI, __reset
44:                
45:                    int32_t  count = 0;
46:                    int32_t j = 0;
47:                
48:                    kb_get_classification_result_info(model_index, &model_results);
000008  000B4A     NOP
49:                
50:                    count += sprintf(pbuf + count, "{\"TensorSize\":%d,\"OutputTensor\":[", model_results.num_outputs);
00000C  000BB6     NOP
51:                
52:                    for (j = 0; j < model_results.num_outputs-1; j++)
00001C  000920     NOP
000042  000920     NOP
53:                    {
54:                        count += sprintf(pbuf + count, "%d,", model_results.output_tensor[j]);
00002C  000920     NOP
55:                    }
56:                    
57:                    count += sprintf(pbuf + count, "%d]}", model_results.output_tensor[j]);
000056  000920     NOP
58:                
59:                    return count;
60:                } 
00006E  000B0E     NOP
000076  000920     NOP
61:                
62:                void kb_print_model_class_map(int32_t model_index, char* output)
63:                {
000000  040200     GOTO __resetPRI, __reset
64:                    printf("\n");
000008  000B4A     NOP
65:                    switch (model_index)
00000C  000BB6     NOP
66:                    {
67:                        	case(0):
68:                		printf("{\"1\":\"broken_bearing\",\"2\":\"normal\",\"3\":\"unbalanced_load\",\"0\":\"Unknown\"}");
000012  00091A     NOP
69:                		if(output != NULL)
000018  000920     NOP
70:                		{
71:                		sprintf( output,"{\"1\":\"broken_bearing\",\"2\":\"normal\",\"3\":\"unbalanced_load\",\"0\":\"Unknown\"}");
00001E  000920     NOP
72:                		}
73:                		break;
74:                
75:                        default:
76:                            break;
77:                    }
78:                }
000026  000920     NOP
00002C  000920     NOP
79:                
80:                void kb_print_model_map()
81:                {
82:                    printf("{\"NumModels\":1,\"0\":\"PIPELINE_1_RANK_0\"}");
000000  040200     GOTO __resetPRI, __reset
83:                    printf("\n");
000006  000B2E     NOP
84:                }
00000C  000BB6     NOP
00000E  000920     NOP
85:                
86:                int32_t kb_print_model_cycles(
87:                    int32_t model_index, char* pbuf, uint32_t* cycles)
88:                {
000000  040200     GOTO __resetPRI, __reset
89:                    uint16_t     fv_len;
90:                    int32_t      count = 0;
91:                    float        classifier_time;
92:                    uint32_t classifier_cycles;
93:                
94:                    if(!kb_is_profiling_enabled(model_index))
000010  000B66     NOP
95:                    {
96:                        count += sprintf(pbuf, "Model %d does not have profiling enabled\r\n", model_index);
000016  000920     NOP
97:                        return count;
000022  000BF6     NOP
98:                    }
99:                
100:                   count += sprintf(
000026  000920     NOP
101:                       pbuf,
102:                       "{\"ModelNumber\":%d,\"Type\":\"Cycles\"",
103:                       model_index);
104:               
105:                   fv_len = kb_get_feature_vector_size(model_index);
000034  000920     NOP
106:                   kb_get_feature_gen_cycles(model_index, cycles);
00003C  000920     NOP
107:                   classifier_cycles = kb_get_classifier_cycles(model_index);
000042  000920     NOP
108:               
109:                   count += sprintf(pbuf + count, ", \"FeatureCycles\":[");
000048  000920     NOP
110:                   for (int32_t j = 0; j < fv_len - 1; j++)
000056  000920     NOP
000082  000920     NOP
000084  000920     NOP
111:                   {
112:                       count += sprintf(pbuf + count, "%d,", cycles[j]);
000070  000920     NOP
113:                   }
114:                   count += sprintf(pbuf + count, "%d],", cycles[fv_len - 1]);
00009A  000920     NOP
115:               
116:                   count += sprintf(pbuf + count, "\"ClassifierCycles\": %d", classifier_cycles);
0000B6  000920     NOP
117:                   count += sprintf(pbuf + count, "}\n");
0000C6  000920     NOP
118:               
119:                   return count;
0000D6  000920     NOP
120:               }
0000D8  000920     NOP
0000E4  000920     NOP
121:               
122:               int32_t kb_print_model_times(
123:                   int32_t model_index, char* pbuf, float* times)
124:               {
000000  040200     GOTO __resetPRI, __reset
125:                   uint16_t     fv_len;
126:                   int32_t      count = 0;
127:                   float        classifier_time;
128:                   uint32_t classifier_cycles;
129:               
130:                   if(!kb_is_profiling_enabled(model_index))
000010  000B66     NOP
131:                   {
132:                       count += sprintf(pbuf, "Model %d does not have profiling enabled\r\n", model_index);
000016  000920     NOP
133:                       return count;
000022  000BF6     NOP
134:                   }
135:               
136:                   count += sprintf(
000026  000920     NOP
137:                       pbuf,
138:                       "{\"ModelNumber\":%d,\"Type\":\"Times\"",
139:                       model_index
140:                   );
141:                   fv_len = kb_get_feature_vector_size(model_index);
000034  000920     NOP
142:                   kb_get_feature_gen_times(model_index, times);
00003C  000920     NOP
143:                   classifier_time   = kb_get_classifier_time(model_index);
000042  000920     NOP
144:               
145:                   count += sprintf(pbuf + count, ", \"FeatureTimes\":[");
000048  000920     NOP
146:                   for (int32_t j = 0; j < fv_len - 1; j++)
000056  000920     NOP
000082  000920     NOP
147:                   {
148:                       count += sprintf(pbuf + count, "%.9f,", times[j]);
000070  000920     NOP
149:                   }
150:                   count += sprintf(pbuf + count, "%.9f], ", times[fv_len - 1]);
00009A  000920     NOP
151:                   count += sprintf(pbuf + count, "\"ClassifierTime\": %.9f, ", classifier_time);
0000B6  000920     NOP
152:                   count += sprintf(pbuf + count, "}\n");
0000C6  000920     NOP
153:               
154:                   return count;
0000D6  000920     NOP
155:               }
0000D8  000920     NOP
0000E4  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/kb.c  
1:                 /*******************************************************************************
2:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
3:                 *
4:                 * Subject to your compliance with these terms, you may use Microchip software
5:                 * and any derivatives exclusively with Microchip products. It is your
6:                 * responsibility to comply with third party license terms applicable to your
7:                 * use of third party software (including open source software) that may
8:                 * accompany Microchip software.
9:                 *
10:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                * PARTICULAR PURPOSE.
14:                *
15:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
16:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
17:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
18:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
19:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
20:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
21:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
22:                 *******************************************************************************/
23:                
24:                #include <limits.h>
25:                
26:                /* kb_classifier includes */
27:                #include "kb_pipeline.h"
28:                #include "kb_common.h"
29:                #include "kb_classifier.h"
30:                #include "tree_ensemble.h"
31:                #include "tree_ensemble_trained_models.h"
32:                #include "kb.h"
33:                #include "kb_defines.h"
34:                
35:                #define STARTER_EDITION_CHECK 0
36:                #define MAX_RINGBUFFERS_USED 1
37:                
38:                #define NUMBER_OF_PARENT_MODELS 1
39:                #define NUMBER_OF_MODELS 1
40:                #define NUMBER_OF_SEGMENTERS 1
41:                #define NUMBER_OF_FEATURE_BANKS_0 1
42:                #define NUMBER_OF_FEATURES_PER_BANK_0 4
43:                #define TOTAL_FEATURES_0 4
44:                #define NUMBER_OF_RINGBUFFS_0 1
45:                #define _RAWDATABUF_LEN_0 512
46:                #define NUMBER_OF_SBUFFS_0 0
47:                #define _RAWDATASBUF_LEN_0 0
48:                static int32_t rbuffers_len[NUMBER_OF_PARENT_MODELS] = {1};
49:                static int32_t sbuffers_len[NUMBER_OF_PARENT_MODELS] = {0};
50:                static FVCOMP_T pFeatures_PIPELINE_1_RANK_0[TOTAL_FEATURES_0];
51:                static uint8_t feature_vector_PIPELINE_1_RANK_0[FEATURE_VECTOR_SIZE_0];
52:                static uint8_t model_uuid_PIPELINE_1_RANK_0[16] = {0x53,0xf6,0x66,0xa,0xf5,0x84,0x46,0x2a,0xa0,0xb,0xce,0xff,0x7a,0x37,0x8e,0x3d};
53:                static SENSOR_DATA_T frameData_0[NUMBER_OF_RINGBUFFS_0];
54:                SENSOR_DATA_T KBSensorData_0[_RAWDATABUF_LEN_0];
55:                ring_buffer_t rbuffers_0[NUMBER_OF_RINGBUFFS_0];
56:                SENSOR_DATA_T SSensorData_0[_RAWDATASBUF_LEN_0];
57:                ring_buffer_t sbuffers_0[NUMBER_OF_SBUFFS_0];
58:                static SENSOR_DATA_T *frameData[NUMBER_OF_PARENT_MODELS] = {frameData_0};
59:                static FVCOMP_T *pFeatures[NUMBER_OF_MODELS] = {pFeatures_PIPELINE_1_RANK_0};
60:                uint8_t *pfeature_vectors[NUMBER_OF_MODELS] = {feature_vector_PIPELINE_1_RANK_0};
61:                SENSOR_DATA_T *KBSensorData[NUMBER_OF_PARENT_MODELS] = {KBSensorData_0};
62:                ring_buffer_t *rbuffers[NUMBER_OF_PARENT_MODELS] = {rbuffers_0};
63:                SENSOR_DATA_T *SSensorData[NUMBER_OF_PARENT_MODELS] = {SSensorData_0};
64:                ring_buffer_t *sbuffers[NUMBER_OF_PARENT_MODELS] = {sbuffers_0};
65:                
66:                
67:                #define SORTED_DATA_LEN 512
68:                SENSOR_DATA_T sortedData[SORTED_DATA_LEN];
69:                #ifndef SORTED_DATA_LEN
70:                #define SORTED_DATA_LEN 8192
71:                SENSOR_DATA_T sortedData[SORTED_DATA_LEN];
72:                #endif
73:                
74:                static uint8_t feature_vector[MAX_VECTOR_SIZE];
75:                static seg_params segParams[NUMBER_OF_SEGMENTERS];
76:                static kb_model_t kb_models[NUMBER_OF_MODELS];
77:                static bool reset_num_classes = true;
78:                
79:                // need to do some checking on this
80:                #if SML_DEBUG
81:                #define PRINTBUFFLEN 256 + 4 * MAX_VECTOR_SIZE
82:                static char printfbuff[PRINTBUFFLEN];
83:                static char *pbuf = printfbuff;
84:                #endif
85:                static SENSOR_DATA_T segment_sample_data[MAX_RINGBUFFERS_USED];
86:                
87:                #if STARTER_EDITION_CHECK
88:                
89:                static bool kb_check_starter_still_has_classifications(int32_t model_index)
90:                {
91:                    if (kb_models[model_index].total_classifications > max_classifications[model_index])
92:                    {
93:                        dbgprintlev(1, "Community Edition classification limit reached.\n");
94:                        return false;
95:                    }
96:                    return true;
97:                }
98:                #endif
99:                
100:               void ring_buffer_init()
101:               {
102:                   int32_t cbuflen, ibuf, imodel, sbuflen;
103:                   static int32_t init_framelen = 1;
104:               
105:                   if (init_framelen)
000000  040200     GOTO __resetPRI, __reset
106:                   {
107:                       init_framelen = 0;
00000A  000BD2     NOP
108:                       for (imodel = 0; imodel < NUMBER_OF_PARENT_MODELS; imodel++)
109:                       {
110:                           // Initialize the ring buffers (this will have to be more carefully done)
111:                           switch (imodel)
112:                           {
113:                               case(0):
114:               		cbuflen = _RAWDATABUF_LEN_0 / NUMBER_OF_RINGBUFFS_0;
115:               sbuflen = 0;
116:               break;
117:                               //FILL_SRING_BUFFER_INIT_SIZES
118:                           }
119:                           for (ibuf = 0; ibuf < rbuffers_len[imodel]; ibuf++)
120:                           {
121:                               setup_rb(&rbuffers[imodel][ibuf], (int16_t *)&KBSensorData[imodel][ibuf * cbuflen], cbuflen);
00000E  000920     NOP
122:                           }
123:               
124:                           for (ibuf = 0; ibuf < sbuffers_len[imodel]; ibuf++) // Make this a fill
125:                           {
126:                               setup_rb(&sbuffers[imodel][ibuf], (int16_t *)&SSensorData[imodel][ibuf * sbuflen], sbuflen);
127:                           }
128:                       }
129:                   }
130:                   return;
131:               }
000016  000920     NOP
132:               
133:               void kb_model_init()
134:               {
135:                   segParams[0].window_size = 500;
000000  040200     GOTO __resetPRI, __reset
136:               segParams[0].delta = 100;
000004  000B9A     NOP
137:               
138:                   kb_models[0].psegParams = &segParams[0];
000008  000B4A     NOP
139:               kb_models[0].feature_bank_filled_flag = false;
00000C  000BB6     NOP
140:               kb_models[0].sg_length = 0;
000012  00091A     NOP
141:               kb_models[0].sg_index = 0;
000018  000920     NOP
142:               kb_models[0].last_read_idx = 0;
00001C  000920     NOP
143:               kb_models[0].pFeatures = pFeatures[0];
000020  000920     NOP
144:               kb_models[0].feature_bank_index = 0;
000024  000920     NOP
145:               kb_models[0].streaming_filter_length = 1;
000028  000920     NOP
146:               kb_models[0].feature_bank_number = NUMBER_OF_FEATURE_BANKS_0;
00002C  000920     NOP
147:               kb_models[0].feature_bank_size = NUMBER_OF_FEATURES_PER_BANK_0;
000030  000920     NOP
148:               kb_models[0].feature_vector_size = FEATURE_VECTOR_SIZE_0;
000034  000920     NOP
149:               kb_models[0].feature_vector = pfeature_vectors[0];
000036  000920     NOP
150:               kb_models[0].m_profile.enabled = 0;
00003A  000920     NOP
151:               kb_models[0].classifier_id = 0;
00003E  000920     NOP
152:               kb_models[0].classifier_type = 2;
000042  000920     NOP
153:               kb_models[0].pringb = rbuffers[0];
000048  000920     NOP
154:               kb_models[0].psringb = sbuffers[0];
00004C  000920     NOP
155:               kb_models[0].frameData = frameData[0];
000050  000920     NOP
156:               kb_models[0].parent = 0;
000054  000920     NOP
157:               kb_models[0].framelen = NUMBER_OF_RINGBUFFS_0;
000058  000920     NOP
158:               kb_models[0].sframelen = NUMBER_OF_SBUFFS_0;
000060  000920     NOP
000062  000920     NOP
159:               kb_models[0].feature_gen = KB_feature_gen_model_PIPELINE_1_RANK_0;
000066  000920     NOP
160:               kb_models[0].data_streaming = KB_data_streaming_PIPELINE_1_RANK_0;
00006A  000920     NOP
161:               kb_models[0].segmentation = KB_data_segmentation_PIPELINE_1_RANK_0;
00006E  000B0E     NOP
162:               kb_models[0].recognize_vector = KB_recognize_vector_PIPELINE_1_RANK_0;
000072  000920     NOP
163:               kb_models[0].feature_transform = KB_feature_transform_PIPELINE_1_RANK_0;
000076  000920     NOP
164:               kb_models[0].model_uuid = model_uuid_PIPELINE_1_RANK_0;
00007A  000920     NOP
165:               if(reset_num_classes){
00007E  000920     NOP
166:               
167:               kb_models[0].total_classifications = 0;
000082  000920     NOP
168:               reset_num_classes = false;
000088  000920     NOP
169:               }
170:               
171:                   ring_buffer_init();
00008A  000920     NOP
172:               
173:                   	tree_ensemble_init(tree_ensemble_classifier_rows, 0);
00008C  000920     NOP
174:               
175:               }
000092  000920     NOP
000094  000920     NOP
176:               
177:               int32_t kb_flush_model_buffer(int32_t model_index)
178:               {
000000  040200     GOTO __resetPRI, __reset
179:                   int32_t parent = kb_models[model_index].parent;
00000C  000BB6     NOP
180:                   ringb *rb;
181:               
182:                   for (int32_t i = 0; i < kb_models[parent].framelen; i++)
00001E  000920     NOP
00003A  000920     NOP
000042  000920     NOP
183:                   {
184:                       rb = &(kb_models[parent].pringb[i]);
00002C  000920     NOP
00003C  000920     NOP
185:                       rb_reset(rb);
000040  000920     NOP
186:                   }
187:               
188:                   for (int32_t i = 0; i < kb_models[parent].sframelen; i++)
00004C  000920     NOP
00006A  000920     NOP
000072  000920     NOP
189:                   {
190:                       rb = &(kb_models[parent].psringb[i]);
000060  000920     NOP
00006C  000920     NOP
191:                       rb_reset(rb);
000070  000920     NOP
192:                   }
193:               
194:                   kb_models[model_index].sg_length = 0;
00007E  000920     NOP
195:                   kb_models[model_index].sg_index = 0;
00008C  000920     NOP
196:                   kb_models[model_index].last_read_idx = 0;
000090  000920     NOP
197:                   kb_models[model_index].feature_bank_index = 0;
000094  000920     NOP
198:                   kb_models[model_index].feature_bank_filled_flag = false;
00009C  000920     NOP
00009E  000920     NOP
0000A0  000920     NOP
199:               
200:                   
201:               
202:                   return 1;
203:               }
0000A2  000920     NOP
0000B2  000920     NOP
0000B4  000920     NOP
204:               
205:               int32_t kb_flush_model(int32_t model_index)
206:               {
207:                   int32_t ret = 1;
208:                   switch (kb_models[model_index].classifier_type)
209:                   {
210:                   	case(2):
211:               		ret = 0;
212:               		break;
213:               
214:                   default:
215:                       ret = 0;
216:                   }
217:                   return ret;
218:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
219:               
220:               void kb_data_streaming_reset(int32_t model_index)
221:               {
000000  040200     GOTO __resetPRI, __reset
222:                   switch(model_index)
000004  000B9A     NOP
223:               {
224:               case(0):
225:               tr_windowing_init(&kb_models[model_index], kb_models[model_index].psegParams);
00000A  000BD2     NOP
226:               break;
227:               }
228:                   rb_unlock(kb_models[model_index].pringb);
000010  000B66     NOP
229:               }
00001C  000920     NOP
000020  000920     NOP
230:               
231:               int32_t kb_reset_model(int32_t model_index)
232:               {
233:                   kb_data_streaming_reset(model_index);
000000  040200     GOTO __resetPRI, __reset
234:               
235:                   return 1;
236:               }
000002  000000     NOP
000008  000B4A     NOP
237:               
238:               void kb_reset_feature_banks(int32_t model_index)
239:               {
240:                   kb_models[model_index].feature_bank_index = 0;
000000  040200     GOTO __resetPRI, __reset
241:                   kb_models[model_index].feature_bank_filled_flag = false;
00000C  000BB6     NOP
242:               }
000012  00091A     NOP
000014  000920     NOP
243:               
244:               bool kb_feature_bank_ready(int32_t model_index)
245:               {
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
246:                   return kb_models[model_index].feature_bank_filled_flag;
000002  000000     NOP
247:               }
00000E  000920     NOP
000010  000B66     NOP
248:               
249:               void kb_feature_generation_reset(int32_t model_index)
250:               {
000000  040200     GOTO __resetPRI, __reset
251:                   int32_t start = kb_models[model_index].feature_bank_size * kb_models[model_index].feature_bank_index;
000008  000B4A     NOP
00001C  000920     NOP
252:                   for (int32_t i = 0; i < kb_models[model_index].feature_bank_size; i++)
000018  000920     NOP
00001E  000920     NOP
000030  000920     NOP
000038  000920     NOP
253:                   {
254:                       kb_models[model_index].pFeatures[start + i] = 0.0f;
000022  000BF6     NOP
000034  000920     NOP
255:                   }
256:                   sorted_copy(kb_models[model_index].pringb, 0, 0, 1);
000048  000920     NOP
257:               }
00005C  000920     NOP
000064  000920     NOP
258:               
259:               void kb_feature_generation_increment(int32_t model_index)
260:               {
261:                   kb_models[model_index].feature_bank_index += 1;
000000  040200     GOTO __resetPRI, __reset
262:               
263:                   if (kb_models[model_index].feature_bank_index == kb_models[model_index].feature_bank_number - 1)
000014  000920     NOP
264:                   {
265:                       kb_models[model_index].feature_bank_filled_flag = true;
000022  000BF6     NOP
266:                   }
267:               
268:                   if (kb_models[model_index].feature_bank_index >= kb_models[model_index].feature_bank_number)
00002C  000920     NOP
269:                   {
270:                       kb_models[model_index].feature_bank_index = 0;
00003C  000920     NOP
271:                   }
272:               }
000046  000920     NOP
000048  000920     NOP
273:               
274:               uint16_t kb_recognize(int32_t model_index)
275:               {
000000  040200     GOTO __resetPRI, __reset
276:                   int32_t ret;
277:               #if STARTER_EDITION_CHECK
278:                   if (kb_check_starter_still_has_classifications(model_index) == false)
279:                   {
280:                       return USHRT_MAX - 1;
281:                   }
282:                   kb_models[model_index].total_classifications++;
283:               #endif
284:                   ret = kb_models[model_index].recognize_vector(&kb_models[model_index]);
000002  000000     NOP
285:                   return (uint16_t)ret;
286:               }
000010  000B66     NOP
000012  00091A     NOP
287:               
288:               uint16_t kb_feature_transform(int32_t model_index)
289:               {
000000  040200     GOTO __resetPRI, __reset
290:                   int32_t ret;
291:               
292:                   ret = kb_models[model_index].feature_transform(&kb_models[model_index]);
000002  000000     NOP
293:               
294:                   return (uint16_t)ret;
295:               }
000010  000B66     NOP
000012  00091A     NOP
296:               
297:               int32_t kb_feature_generation(int32_t model_index)
298:               {
000000  040200     GOTO __resetPRI, __reset
299:                   int32_t ret = -1;
300:                   int32_t nfeats = 0;
000004  000B9A     NOP
301:               
302:                   ret = kb_models[model_index].feature_gen(&kb_models[model_index], &nfeats);
00000A  000BD2     NOP
303:                   switch (ret)
304:                   {
305:                   case -1:
306:                       dbgprintlev(1, "Segment was filtered.");
307:                       break;
308:                   case 1:
309:                       break;
310:                   default:
311:                       dbgprintlev(1, "Unknown return from feature generation.");
312:                   }
313:                   return ret;
314:               }
00001C  000920     NOP
000020  000920     NOP
315:               
316:               int32_t kb_data_streaming(SENSOR_DATA_T *pSample, int32_t nsensors, int32_t model_index)
317:               {
000000  040200     GOTO __resetPRI, __reset
318:                   int32_t ret = 0;
319:               
320:                   ret = kb_models[model_index].data_streaming(&kb_models[model_index], pSample);
000002  000000     NOP
321:               
322:                   return ret;
323:               }
000010  000B66     NOP
000012  00091A     NOP
324:               
325:               int32_t kb_segmentation(int32_t model_index)
326:               {
000000  040200     GOTO __resetPRI, __reset
327:                   int32_t ret = 0;
328:               
329:                   ret = kb_models[model_index].segmentation(&kb_models, model_index);
000006  000B2E     NOP
330:               
331:                   if (ret == 1)
000016  000920     NOP
332:                   {
333:                       rb_lock(kb_models[model_index].pringb);
00001C  000920     NOP
334:                   }
335:               
336:                   return ret;
337:               }
000028  000920     NOP
000030  000920     NOP
338:               
339:               void kb_generate_children_features(int32_t model_index)
340:               {
341:                   if (model_index != kb_models[model_index].parent)
000000  040200     GOTO __resetPRI, __reset
342:                   {
343:                       return;
344:                   }
345:               
346:                   for (int32_t index = 0; index < NUMBER_OF_MODELS; index++)
347:                   {
348:                       if (kb_models[index].parent == model_index && index != model_index)
000012  00091A     NOP
349:                       {
350:                           if (kb_segmentation(index) == 1)
000024  000920     NOP
351:                           {
352:                               kb_feature_generation_reset(index);
00002E  000920     NOP
353:                               kb_feature_generation(index);
000032  000920     NOP
354:                               kb_feature_generation_increment(index);
000036  000920     NOP
355:                           }
356:                       }
357:                   }
358:               }
00003A  000920     NOP
00003C  000920     NOP
359:               
360:               int32_t kb_generate_classification(int32_t model_index)
361:               {
000000  040200     GOTO __resetPRI, __reset
362:                   int32_t ret = -1;
000008  000B4A     NOP
363:                   if (kb_feature_transform(model_index) == 1)
000004  000B9A     NOP
00000C  000BB6     NOP
364:                   {
365:                       ret = kb_recognize(model_index);
000010  000B66     NOP
366:                       if (ret == USHRT_MAX)
000016  000920     NOP
367:                       {
368:                           ret = 0;
00001C  000920     NOP
369:                       }
370:                   }
371:               
372:                   return ret;
373:               }
00001E  000920     NOP
000022  000BF6     NOP
374:               
375:               int32_t kb_run_model(SENSOR_DATA_T *pSample, int32_t nsensors, int32_t model_index)
376:               {
000000  040200     GOTO __resetPRI, __reset
377:                   int32_t ret = -1;
378:                   if (kb_data_streaming(pSample, nsensors, model_index))
000006  000B2E     NOP
00000C  000BB6     NOP
379:                   {
380:                       if (kb_segmentation(model_index) == 1)
000012  00091A     NOP
00001A  000920     NOP
381:                       {
382:                           kb_feature_generation_reset(model_index);
000020  000920     NOP
383:                           if (kb_feature_generation(model_index) == 1)
000024  000920     NOP
384:                           {
385:                               ret = kb_generate_classification(model_index);
00002E  000920     NOP
386:                               kb_feature_generation_increment(model_index);
000034  000920     NOP
387:                               return ret;
000038  000920     NOP
388:                           }
389:                           else
390:                           {
391:                               kb_reset_feature_banks(model_index);
00003A  000920     NOP
00003C  000920     NOP
392:                               kb_reset_model(model_index);
00003E  000920     NOP
393:                               return -2;
000042  000920     NOP
394:                           }
395:                       }
396:                   }
397:                   return -1;
000008  000B4A     NOP
000016  000920     NOP
398:               }
000046  000920     NOP
00004E  000920     NOP
399:               
400:               int32_t kb_run_model_with_cascade_features(SENSOR_DATA_T *pSample, int32_t nsensors, int32_t model_index)
401:               {
000000  040200     GOTO __resetPRI, __reset
402:                   int32_t ret = -1;
403:                   if (kb_data_streaming(pSample, nsensors, model_index))
000006  000B2E     NOP
00000C  000BB6     NOP
404:                   {
405:                       if (kb_segmentation(model_index) == 1)
000012  00091A     NOP
00001A  000920     NOP
406:                       {
407:                           kb_feature_generation_reset(model_index);
000020  000920     NOP
408:                           if (kb_feature_generation(model_index) == 1)
000024  000920     NOP
409:                           {
410:                               if (kb_feature_bank_ready(model_index))
00002E  000920     NOP
411:                               {
412:                                   ret = kb_generate_classification(model_index);
000036  000920     NOP
413:                                   kb_generate_children_features(model_index);
00003C  000920     NOP
414:                                   kb_feature_generation_increment(model_index);
000040  000920     NOP
415:                               }
416:                               else
417:                               {
418:                                   ret = -2;
000052  000920     NOP
419:                                   kb_generate_children_features(model_index);
000046  000920     NOP
000048  000920     NOP
00004A  000920     NOP
00004C  000920     NOP
420:                                   kb_feature_generation_increment(model_index);
00004A  000920     NOP
421:                                   kb_reset_model(model_index);
00004E  000920     NOP
422:                               }
423:                               return ret;
424:                           }
425:                           else
426:                           {
427:               
428:                               kb_generate_children_features(model_index);
000058  000920     NOP
00005A  000920     NOP
00005C  000920     NOP
00005E  000920     NOP
000060  000920     NOP
000062  000920     NOP
429:                               kb_feature_generation_increment(model_index);
00005C  000920     NOP
430:                               kb_reset_model(model_index);
000060  000920     NOP
431:                               return -2;
000064  000920     NOP
432:                           }
433:                       }
434:                   }
435:                   return -1;
000008  000B4A     NOP
000016  000920     NOP
436:               }
000068  000920     NOP
00006A  000920     NOP
000070  000920     NOP
437:               
438:               int32_t kb_run_model_with_cascade_reset(SENSOR_DATA_T *pSample, int32_t nsensors, int32_t model_index)
439:               {
000000  040200     GOTO __resetPRI, __reset
440:                   int32_t ret = -1;
441:               
442:                   if (kb_data_streaming(pSample, nsensors, model_index))
000006  000B2E     NOP
00000C  000BB6     NOP
443:                   {
444:                       if (kb_segmentation(model_index) == 1)
000012  00091A     NOP
00001A  000920     NOP
445:                       {
446:                           kb_feature_generation_reset(model_index);
000020  000920     NOP
447:                           if (kb_feature_generation(model_index) == 1)
000024  000920     NOP
000026  000920     NOP
448:                           {
449:               
450:                               if (kb_feature_bank_ready(model_index))
00002E  000920     NOP
451:                               {
452:                                   ret = kb_generate_classification(model_index);
000036  000920     NOP
453:                                   kb_generate_children_features(model_index);
00003C  000920     NOP
454:                                   kb_reset_feature_banks(model_index);
000040  000920     NOP
455:                                   return ret;
000044  000C16     NOP
456:                               }
457:                               else
458:                               {
459:                                   kb_feature_generation_increment(model_index);
000046  000920     NOP
460:                                   kb_generate_children_features(model_index);
00004A  000920     NOP
461:                                   kb_data_streaming_reset(model_index);
00004E  000920     NOP
462:                                   return -2;
000052  000920     NOP
463:                               }
464:                           }
465:                           else
466:                           {
467:                               kb_generate_children_features(model_index);
000058  000920     NOP
468:                               kb_feature_generation_increment(model_index);
00005C  000920     NOP
469:                               kb_reset_model(model_index);
000060  000920     NOP
470:                               return -2;
000064  000920     NOP
471:                           }
472:                       }
473:                   }
474:                   return -1;
000008  000B4A     NOP
000016  000920     NOP
475:               }
000068  000920     NOP
000070  000920     NOP
476:               
477:               void kb_add_segment(uint16_t *pBuffer, int32_t len, int32_t nbuffs, int32_t model_index)
478:               {
000000  040200     GOTO __resetPRI, __reset
479:                   int32_t ibuf;
480:                   for (ibuf = 0; ibuf < nbuffs; ibuf++)
000014  000920     NOP
000020  000920     NOP
000058  000920     NOP
481:                   {
482:                       setup_rb_with_data(&kb_models[model_index].pringb[ibuf], (int16_t *)&pBuffer[ibuf * len], next_pow_2(len), len);
00001A  000920     NOP
000022  000BF6     NOP
483:                       kb_models[model_index].sg_length = 0;
000044  000C16     NOP
000046  000920     NOP
000048  000920     NOP
00004A  000920     NOP
484:                       kb_models[model_index].sg_index = 0;
000050  000920     NOP
000052  000920     NOP
485:                       kb_models[model_index].last_read_idx = 0;
000054  000920     NOP
486:                   }
487:               }
00006A  000920     NOP
000076  000920     NOP
488:               
489:               int32_t kb_run_segment(int32_t model_index)
490:               {
000000  040200     GOTO __resetPRI, __reset
491:                   int32_t ret;
492:                   if (kb_segmentation(model_index) == 1)
000006  000B2E     NOP
00000C  000BB6     NOP
493:                   {
494:                       kb_feature_generation_reset(model_index);
000012  00091A     NOP
495:                       ret = kb_feature_generation(model_index);
000016  000920     NOP
496:                       if (ret == 1)
00001E  000920     NOP
497:                       {
498:                           ret = kb_generate_classification(model_index);
000024  000920     NOP
499:                           kb_feature_generation_increment(model_index);
00002A  000C36     NOP
500:                           return ret;
501:                       }
502:                   }
503:                   return -1;
000008  000B4A     NOP
00001A  000920     NOP
504:               }
00002E  000920     NOP
000036  000920     NOP
505:               
506:               int32_t kb_run_segment_with_cascade_features(int32_t model_index)
507:               {
000000  040200     GOTO __resetPRI, __reset
508:                   int32_t ret = -1;
509:                   if (kb_segmentation(model_index) == 1)
000006  000B2E     NOP
00000C  000BB6     NOP
510:                   {
511:                       kb_feature_generation_reset(model_index);
000012  00091A     NOP
512:                       if (kb_feature_generation(model_index) == 1)
000016  000920     NOP
513:                       {
514:                           ret = kb_generate_classification(model_index);
000020  000920     NOP
515:                           kb_feature_generation_increment(model_index);
000026  000920     NOP
516:                           return ret;
00002A  000C36     NOP
517:                       }
518:                       else
519:                       {
520:                           kb_feature_generation_increment(model_index);
00002C  000920     NOP
521:                           kb_data_streaming_reset(model_index);
000030  000920     NOP
522:                           kb_generate_children_features(model_index);
000034  000920     NOP
523:                           return -2;
000038  000920     NOP
524:                       }
525:                   }
526:               
527:                   return -1;
000008  000B4A     NOP
528:               }
00003C  000920     NOP
000044  000C16     NOP
529:               
530:               int32_t kb_run_segment_with_cascade_reset(int32_t model_index)
531:               {
000000  040200     GOTO __resetPRI, __reset
532:                   int32_t ret = -1;
533:                   if (kb_segmentation(model_index) == 1)
000006  000B2E     NOP
00000C  000BB6     NOP
534:                   {
535:                       kb_feature_generation_reset(model_index);
000012  00091A     NOP
536:                       if (kb_feature_generation(model_index) == 1)
000016  000920     NOP
00001E  000920     NOP
537:                       {
538:                           if (kb_models[model_index].feature_bank_index == kb_models[model_index].feature_bank_number - 1)
000024  000920     NOP
539:                           {
540:               
541:                               ret = kb_generate_classification(model_index);
00003C  000920     NOP
542:                               kb_generate_children_features(model_index);
000042  000920     NOP
543:                               kb_reset_feature_banks(model_index);
000046  000920     NOP
000048  000920     NOP
544:                               return ret;
00004A  000920     NOP
545:                           }
546:                           else
547:                           {
548:                               kb_feature_generation_increment(model_index);
00004C  000920     NOP
549:                               kb_data_streaming_reset(model_index);
000050  000920     NOP
550:                               kb_generate_children_features(model_index);
000054  000920     NOP
551:                               return -2;
000058  000920     NOP
552:                           }
553:                       }
554:                   }
555:                   return -1;
000008  000B4A     NOP
00001A  000920     NOP
556:               }
00005C  000920     NOP
000064  000920     NOP
000066  000920     NOP
557:               
558:               int32_t kb_add_last_pattern_to_model(int32_t model_index, uint16_t category, uint16_t influence)
559:               {
560:                   // This needs to be added in a way so that if a classifier doesn't support it, it just returns false. ie no training of random forest on the device
561:                   int32_t ret = 1;
562:               
563:                   switch (model_index)
564:                   {
565:                   	case(0):
566:               		ret = 0;
567:               		break;
568:               
569:                   default:
570:                       ret = 0;
571:                       break;
572:                   }
573:                   return ret;
574:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
575:               
576:               int32_t kb_add_custom_pattern_to_model(int32_t model_index, uint8_t *feature_vector, uint16_t category, uint16_t influence)
577:               {
578:                   int32_t ret = 1;
579:                   switch (model_index)
580:                   {
581:                   	case(0):
582:               		ret=0;
583:               		break;
584:               
585:                   default:
586:                       ret = 0;
587:                       break;
588:                   }
589:               
590:                   return ret;
591:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
592:               
593:               int32_t kb_score_model(int32_t model_index, uint16_t category)
594:               {
595:                   int32_t ret = 1;
596:                   switch (model_index)
597:                   {
598:                   	case(0):
599:               		ret = 0;
600:               		break;
601:               
602:                   default:
603:                       ret = 0;
604:                       break;
605:                   }
606:                   return ret;
607:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
608:               
609:               int32_t kb_retrain_model(int32_t model_index)
610:               {
611:                   int32_t ret = 1;
612:                   switch (model_index)
613:                   {
614:                   	case(0):
615:               		ret = 0;
616:               		break;
617:               
618:                   default:
619:                       ret = 0;
620:                       break;
621:                   }
622:               
623:                   return ret;
624:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
000006  000B2E     NOP
625:               
626:               int32_t kb_get_model_header(int32_t model_index, void *model_header)
627:               {
628:                   int32_t ret = 1;
629:                   pme_model_header_t *pme_model_header = (pme_model_header_t *)model_header;
630:                   switch (kb_models[model_index].classifier_type)
631:                   {
632:                       	case(2):
633:               		ret = 0;
634:               		break;
635:               
636:                       default:
637:                           ret = 0;
638:                           break;
639:                   }
640:                   return ret;
641:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
642:               
643:               int32_t kb_get_model_pattern(int32_t model_index, int32_t pattern_index, void *pattern)
644:               {
645:                   int32_t ret = 1;
646:                   pme_pattern_t *pme_pattern = (pme_pattern_t *)pattern;
647:                   switch (kb_models[model_index].classifier_type)
648:                   {
649:                   	case(2):
650:               		ret = 0;
651:               		break;
652:               
653:                   default:
654:                       ret = 0;
655:                       break;
656:                   }
657:                   return ret;
658:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
659:               
660:               const uint8_t *kb_get_model_uuid_ptr(int32_t model_index)
661:               {
000000  040200     GOTO __resetPRI, __reset
662:                   if (model_index < NUMBER_OF_MODELS)
000004  000B9A     NOP
663:                   {
664:                       return (const uint8_t *)kb_models[model_index].model_uuid;
00000A  000BD2     NOP
00000C  000BB6     NOP
00000E  000920     NOP
000010  000B66     NOP
665:                   }
666:                   else
667:                   {
668:                       return NULL;
000002  000000     NOP
669:                   }
670:               }
000014  000920     NOP
000018  000920     NOP
671:               
672:               int32_t kb_get_feature_vector_size(int32_t model_index)
673:               {
000000  040200     GOTO __resetPRI, __reset
674:                   return kb_models[model_index].feature_vector_size;
000002  000000     NOP
000004  000B9A     NOP
675:               }
000010  000B66     NOP
000012  00091A     NOP
676:               
677:               void kb_get_feature_vector_v2(int32_t model_index, uint8_t *fv_arr)
678:               {
679:                   for (int32_t i = 0; i < kb_models[model_index].feature_vector_size; i++)
000000  040200     GOTO __resetPRI, __reset
00001A  000920     NOP
000022  000BF6     NOP
000024  000920     NOP
680:                   {
681:                       fv_arr[i] = kb_models[model_index].feature_vector[i];
00000E  000920     NOP
00001E  000920     NOP
682:                   }
683:               }
000030  000920     NOP
000032  000920     NOP
684:               
685:               void kb_get_feature_vector(int32_t model_index, uint8_t *fv_arr, uint8_t *p_fv_len)
686:               {
000000  040200     GOTO __resetPRI, __reset
687:                   int32_t i;
688:                   for (i = 0; i < kb_models[model_index].feature_vector_size; i++)
000002  000000     NOP
00001E  000920     NOP
000026  000920     NOP
689:                   {
690:                       fv_arr[i] = kb_models[model_index].feature_vector[i];
000012  00091A     NOP
000022  000BF6     NOP
691:                   }
692:                   *p_fv_len = kb_models[model_index].feature_vector_size;
000034  000920     NOP
693:               }
000036  000920     NOP
00003A  000920     NOP
694:               
695:               int32_t kb_set_feature_vector_unscaled(int32_t model_index, float *feature_vector)
696:               {
000000  040200     GOTO __resetPRI, __reset
697:                   int32_t i;
698:               
699:                   for (i = 0; i < kb_models[model_index].feature_vector_size; i++)
000002  000000     NOP
00001E  000920     NOP
00002A  000C36     NOP
700:                   {
701:                       kb_models[model_index].pFeatures[i] = feature_vector[i];
000012  00091A     NOP
000022  000BF6     NOP
702:                   };
703:               
704:                   return i;
705:               }
000038  000920     NOP
00003E  000920     NOP
706:               
707:               int32_t kb_get_feature_vector_unscaled_size(int32_t model_index)
708:               {
000000  040200     GOTO __resetPRI, __reset
709:                   return kb_models[model_index].feature_vector_size;
000002  000000     NOP
710:               }
000010  000B66     NOP
000012  00091A     NOP
711:               
712:               int32_t kb_get_feature_vector_unscaled(int32_t model_index, float *fv_arr)
713:               {
000000  040200     GOTO __resetPRI, __reset
714:                   int32_t i;
715:               
716:                   for (i = 0; i < kb_models[model_index].feature_vector_size; i++)
000002  000000     NOP
00001E  000920     NOP
00002A  000C36     NOP
717:                   {
718:                       fv_arr[i] = kb_models[model_index].pFeatures[i];
000012  00091A     NOP
000022  000BF6     NOP
719:                   };
720:               
721:                   return i;
722:               }
000038  000920     NOP
00003E  000920     NOP
723:               
724:               void sml_get_segment_length(int32_t model_index, int32_t *p_seg_len)
725:               {
000000  040200     GOTO __resetPRI, __reset
726:                   *p_seg_len = (kb_models[model_index].sg_length + ((kb_models[model_index].feature_bank_number - 1) * segParams[model_index].delta)) * kb_models[model_index].streaming_filter_length;
000002  000000     NOP
727:               }
000030  000920     NOP
000034  000920     NOP
728:               
729:               void sml_get_feature_bank_number(int32_t model_index, int32_t *p_feature_bank_number)
730:               {
731:                   *p_feature_bank_number = kb_models[model_index].feature_bank_number;
000000  040200     GOTO __resetPRI, __reset
732:               }
000010  000B66     NOP
000012  00091A     NOP
733:               
734:               int32_t kb_get_segment_length(int32_t model_index)
735:               {
000000  040200     GOTO __resetPRI, __reset
736:                   return (kb_models[model_index].sg_length + ((kb_models[model_index].feature_bank_number - 1) * segParams[model_index].delta)) * kb_models[model_index].streaming_filter_length;
000004  000B9A     NOP
737:               }
000030  000920     NOP
000034  000920     NOP
738:               
739:               int32_t kb_get_model_sg_length(int32_t model_index)
740:               {
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
741:                   return kb_models[model_index].sg_length;
000002  000000     NOP
742:               }
00000E  000920     NOP
000010  000B66     NOP
000012  00091A     NOP
000014  000920     NOP
743:               
744:               int32_t kb_get_model_framelen(int32_t model_index)
745:               {
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
746:                   return kb_models[model_index].framelen;
000002  000000     NOP
747:               }
00000E  000920     NOP
000010  000B66     NOP
748:               
749:               void kb_get_segment_data(int32_t model_index, int32_t number_samples, int32_t index, SENSOR_DATA_T *p_sample_data)
00002E  000920     NOP
000092  000920     NOP
750:               {
000000  040200     GOTO __resetPRI, __reset
751:                   int32_t t = 0;
000022  000BF6     NOP
752:                   for (int32_t col = 0; col < kb_models[model_index].framelen; col++)
000012  00091A     NOP
000026  000920     NOP
000056  000920     NOP
753:                   {
754:                       for (int32_t i = 0; i < number_samples; i++)
00003C  000920     NOP
000084  000920     NOP
755:                       {
756:                           p_sample_data[t] = get_axis_data(kb_models[model_index].pringb + col, index + i);
000036  000920     NOP
000072  000920     NOP
757:                           t++;
758:                       };
759:                   };
760:               }
00009E  000920     NOP
0000AA  000920     NOP
761:               
762:               int32_t kb_set_feature_vector(int32_t model_index, uint8_t *feature_vector)
763:               {
764:                   int32_t i;
765:               
766:                   for (i = 0; i < kb_models[model_index].feature_vector_size; i++)
000000  040200     GOTO __resetPRI, __reset
00001C  000920     NOP
000024  000920     NOP
767:                   {
768:                       kb_models[model_index].feature_vector[i] = feature_vector[i];
000010  000B66     NOP
000020  000920     NOP
769:                   };
770:               
771:                   return i;
772:               }
000032  000920     NOP
000036  000920     NOP
773:               
774:               int32_t kb_recognize_feature_vector(int32_t model_index)
775:               {
776:                   return (int32_t)kb_recognize(model_index);
000000  040200     GOTO __resetPRI, __reset
777:               }
000004  000B9A     NOP
000006  000B2E     NOP
778:               
779:               int32_t kb_get_classification_result_info(int32_t model_index, void *model_results)
780:               {
781:                   int32_t ret = 1;
00001E  000920     NOP
782:                   switch (kb_models[model_index].classifier_type)
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
783:                   {
784:                       	case(2):
785:               		{
786:               	tree_ensemble_model_results_object(kb_models[model_index].classifier_id, (model_results_t *)model_results);
000010  000B66     NOP
787:               }
788:               		break;
789:               
790:               
791:                   default:
792:                       ret = 0;
00000A  000BD2     NOP
793:                       break;
794:                   }
795:               
796:                   return ret;
797:               }
000022  000BF6     NOP
000024  000920     NOP
798:               
799:               int32_t kb_print_model_score(int32_t model_index)
800:               {
801:                   int32_t ret = 1;
802:                   switch (kb_models[model_index].classifier_type)
803:                   {
804:                   	case(0):
805:               		ret = 0;
806:               		break;
807:               
808:                   default:
809:                       ret = 0;
810:                       break;
811:                   }
812:                   return ret;
813:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
814:               
815:               // returns the starting index of the very last segment
816:               // before cascading
817:               int32_t kb_get_sg_start_index(int32_t model_index)
818:               {
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
819:                   return kb_models[model_index].sg_index;
000002  000000     NOP
000004  000B9A     NOP
820:               }
00000E  000920     NOP
000010  000B66     NOP
821:               
822:               // returns the beginning of the last segment used for
823:               // generating inference, after applying cascading
824:               int32_t kb_get_segment_start(int32_t model_index)
825:               {
000000  040200     GOTO __resetPRI, __reset
826:                   return (kb_models[model_index].sg_index - ((kb_models[model_index].feature_bank_number - 1) * segParams[model_index].delta)) * kb_models[model_index].streaming_filter_length;
000002  000000     NOP
827:               }
00002E  000920     NOP
000030  000920     NOP
828:               
829:               bool kb_is_profiling_enabled(int32_t model_index)
830:               {
000000  040200     GOTO __resetPRI, __reset
00000C  000BB6     NOP
831:                   return kb_models[model_index].m_profile.enabled;
000002  000000     NOP
000004  000B9A     NOP
000006  000B2E     NOP
832:               }
00000E  000920     NOP
000010  000B66     NOP
833:               
834:               void kb_get_feature_gen_times(int32_t model_index, float *time_arr)
835:               {
000000  040200     GOTO __resetPRI, __reset
836:                   if (!kb_models[model_index].m_profile.enabled)
000002  000000     NOP
837:                   {
838:                       return;
839:                   }
840:                   for (int32_t i = 0; i < kb_models[model_index].feature_vector_size; i++)
00000E  000920     NOP
000022  000BF6     NOP
00002E  000920     NOP
841:                   {
842:                       time_arr[i] = kb_models[model_index].m_profile.feature_gen_times[i];
000018  000920     NOP
000026  000920     NOP
843:                   }
844:               }
00003C  000920     NOP
000040  000920     NOP
845:               
846:               void kb_get_feature_gen_cycles(int32_t model_index, uint32_t *cycle_arr)
847:               {
000000  040200     GOTO __resetPRI, __reset
848:                   if (!kb_models[model_index].m_profile.enabled)
000002  000000     NOP
000004  000B9A     NOP
849:                   {
850:                       return;
851:                   }
852:                   for (int32_t i = 0; i < kb_models[model_index].feature_vector_size; i++)
00000E  000920     NOP
000022  000BF6     NOP
00002E  000920     NOP
853:                   {
854:                       cycle_arr[i] = kb_models[model_index].m_profile.feature_gen_cycles[i];
000018  000920     NOP
000026  000920     NOP
855:                   }
856:               }
00003C  000920     NOP
000040  000920     NOP
857:               
858:               float kb_get_classifier_time(int32_t model_index)
859:               {
860:                   if (!kb_models[model_index].m_profile.enabled)
000000  040200     GOTO __resetPRI, __reset
861:                   {
862:                       return -1.0f;
000018  000920     NOP
863:                   }
864:                   return kb_models[model_index].m_profile.classifier_time;
00000C  000BB6     NOP
00000E  000920     NOP
865:               }
00001C  000920     NOP
00001E  000920     NOP
000020  000920     NOP
000022  000BF6     NOP
866:               
867:               uint32_t kb_get_classifier_cycles(int32_t model_index)
868:               {
869:                   if (!kb_models[model_index].m_profile.enabled)
000000  040200     GOTO __resetPRI, __reset
00000A  000BD2     NOP
870:                   {
871:                       return 0;
000008  000B4A     NOP
872:                   }
873:                   return kb_models[model_index].m_profile.classifier_cycles;
00000E  000920     NOP
874:               }
000018  000920     NOP
00001C  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/imfcc.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include <stdio.h>
26:                #include <stdint.h>
27:                #include <math.h>
28:                #include <string.h>
29:                #include "kbutils.h"
30:                #include "imfcc.h"
31:                #include "imfcc_rom.h"
32:                
33:                #include "fftr.h"
34:                #include "fixlog.h"
35:                
36:                #include "kb_typedefs.h"
37:                
38:                #ifndef NULL
39:                #define NULL ((void *)0)
40:                #endif
41:                
42:                /* Only one parameterization exists */
43:                #define WINDOW_SIZE 400
44:                #define WINDOW_LOG_SIZE 9
45:                #define NUM_FILTERS 23
46:                /* HPFbeta * (1<<13) */
47:                #define HPF_BETA_13 164
48:                /* sqrt(1.0 / NUM_CEPS) * (1<<11) */
49:                #define SQRT_INV_N 427
50:                /* sqrt(2.0 / NUM_CEPS) * (1<<11) */
51:                #define SQRT_INV_2N 604
52:                /* Pre-emphasis beta is 0.97 * 32767 */
53:                #define PRE_EMPHASIS 31784
54:                /* Left-shift of hanning window values */
55:                #define WIN_HANNING_Q 14
56:                
57:                
58:                void IMFCC_PreEmphasis(int16_t *data, int16_t length)
59:                {
000000  040200     GOTO __resetPRI, __reset
60:                    /* Signal is shifted right by 1 to avoid overflow */
61:                
62:                    int32_t prior = 0;
000010  000B66     NOP
63:                    int32_t i;
64:                    int32_t sample;
65:                    for (i = 0; i < length; i++)
000006  000B2E     NOP
000008  000B4A     NOP
00000A  000BD2     NOP
00000C  000BB6     NOP
000032  000920     NOP
66:                    {
67:                        sample = (int32_t)data[i];
000018  000920     NOP
68:                        data[i] = (int16_t)(((sample << 15) - (prior * PRE_EMPHASIS)) >> 16);
000012  00091A     NOP
00001C  000920     NOP
69:                        prior = sample;
000016  000920     NOP
70:                    }
71:                
72:                    // pre_emphasis_prior = prior;
73:                    // return pre_emphasis_prior;
74:                    //prior design need to be revisited
75:                }
00003C  000920     NOP
76:                
77:                /* Returns max(abs(samples)) */
78:                int32_t IMFCC_HannWindow(int16_t *buffer)
00000A  000BD2     NOP
00003E  000920     NOP
000044  000C16     NOP
79:                {
000000  040200     GOTO __resetPRI, __reset
80:                    int32_t i;
81:                    int32_t max_value = 0;
000010  000B66     NOP
82:                
83:                    /* Left part of the window */
84:                    for (i = 0; i < WINDOW_SIZE / 2; i++)
00003A  000920     NOP
000042  000920     NOP
85:                    {
86:                        int32_t product = (int32_t)buffer[i] * (int32_t)kHannWindow[i];
000012  00091A     NOP
87:                        int16_t sample = (int16_t)(product >> HANN_WINDOW_Q);
000018  000920     NOP
88:                        buffer[i] = sample;
00001E  000920     NOP
000028  000920     NOP
89:                
90:                        // printf("### HannWindow | %3d | %6" PRId16 " | %10f\n",i, buffer[i], Qint16_to_float(buffer[i],14));
91:                
92:                        if (sample > max_value)
000022  000BF6     NOP
000024  000920     NOP
000026  000920     NOP
000028  000920     NOP
93:                            max_value = sample;
94:                        if (-sample > max_value)
000020  000920     NOP
95:                            max_value = -sample;
96:                    }
97:                
98:                    /* Right part of the window */
99:                    for (i = WINDOW_SIZE / 2; i < WINDOW_SIZE; i++)
000070  000920     NOP
100:                   {
101:                       int32_t product = (int32_t)buffer[i] * (int32_t)kHannWindow[WINDOW_SIZE - 1 - i];
000048  000920     NOP
102:                       int16_t sample = (int16_t)(product >> HANN_WINDOW_Q);
00004E  000920     NOP
103:                       buffer[i] = sample;
000054  000920     NOP
00005E  000920     NOP
104:               
105:                       // printf("### HannWindow | %3d | %6" PRId16 " | %10f\n",i, buffer[i], Qint16_to_float(buffer[i],14));
106:               
107:                       if (sample > max_value)
000058  000920     NOP
00005A  000920     NOP
108:                           max_value = sample;
109:                       if (-sample > max_value)
000056  000920     NOP
000058  000920     NOP
00005A  000920     NOP
00005C  000920     NOP
110:                           max_value = -sample;
111:                   }
112:               
113:                   return max_value;
114:               }
000080  000920     NOP
00008E  000920     NOP
000090  000920     NOP
000092  000920     NOP
115:               
116:               void IMFCC_PowerTriFilter(const int16_t *samples,
000048  000920     NOP
0000F0  000920     NOP
0000F2  000920     NOP
0000F4  000920     NOP
117:                                         int32_t shift, int32_t *output)
118:               {
000000  040200     GOTO __resetPRI, __reset
119:                   /* TODO (jhofer): Could probably be done in 32 bit instead of 64 bit */
120:                   int32_t i, j;
121:                   /* Current index of the weight-bin */
122:                   int32_t weight_index = 0;
000018  000920     NOP
123:               
124:                   for (i = 0; i < NUM_FILTERS; i++)
000138  000920     NOP
00013A  000920     NOP
00013C  000920     NOP
125:                   {
126:                       uint64_t sum = 0;
000036  000920     NOP
127:                       int32_t start_bin = kFirstMelBankBin[i];
00001E  000920     NOP
000020  000920     NOP
128:                       int32_t num_bins = kMelBankNumBins[i];
000024  000920     NOP
129:                       uint32_t a1s;
130:                       uint32_t a2;
131:                       int32_t la1;
132:                       int32_t la2;
133:                       int32_t power;
134:               
135:                       for (j = 0; j < num_bins; j++)
000042  000920     NOP
00005A  000920     NOP
0000D8  000920     NOP
0000DA  000920     NOP
0000F6  00084A     NOP
0000F8  00087E     NOP
136:                       {
137:                           int32_t bin = start_bin + j;
138:                           int64_t real = (int64_t)samples[2 * bin];
000060  000920     NOP
000062  000920     NOP
000064  000920     NOP
139:                           int64_t imag = (int64_t)samples[2 * bin + 1];
00006E  000B0E     NOP
140:                           uint64_t power =
00008C  000920     NOP
141:                               (uint64_t)(real * real) +
00007E  000920     NOP
142:                               (uint64_t)(imag * imag);
000074  000920     NOP
143:                           power <<= 2 * shift;
00000C  000BB6     NOP
00000E  000920     NOP
000094  000920     NOP
144:                           power >>= 10;
0000A4  000920     NOP
0000A6  000920     NOP
145:                           sum += power * (uint64_t)kMelBinWeights[weight_index];
0000B8  000920     NOP
146:                           weight_index++;
147:                       }
148:               
149:                       /* log(sum) = log( a1 + a2 ) = log_add( log(a1), log(a2) ) */
150:                       a1s = sum >> 32;
000102  000920     NOP
151:                       a2 = sum & 0x00000000ffffffffLL;
152:                       la1 = sphinx_fixlog(a1s) + 90852; /* ... + 2**12 log(2**32) */
00010C  000920     NOP
000118  000920     NOP
00011A  000920     NOP
00011C  000920     NOP
00011E  000920     NOP
153:                       la2 = sphinx_fixlog(a2);
000110  000920     NOP
000112  000920     NOP
154:                       power = sphinx_fe_log_add(la1, la2);
000120  000920     NOP
155:                       /* floor to avoid overflow later */
156:                       if (power < 49125)
000124  000920     NOP
000126  000920     NOP
000128  000920     NOP
157:                           power = 49125;
00012E  000920     NOP
158:                       output[i] = power;
000132  000920     NOP
159:               
160:                       //printf("### PowerTriFilter | %3d | %6d\n", i, output[i]);
161:                   }
162:               }
000140  000920     NOP
00014C  000920     NOP
163:               
164:               void IMFCC_DCT(int32_t *input, int32_t *output, int32_t num_cepstra)
0000C2  000920     NOP
165:               {
000000  040200     GOTO __resetPRI, __reset
166:                   int32_t i, j;
167:                   int32_t value;
168:                   int32_t num_features = num_cepstra;
169:               
170:                   value = input[0];
00000E  000920     NOP
00001A  000920     NOP
171:                   for (j = 1; j < NUM_FILTERS; j++)
000012  00091A     NOP
000014  000920     NOP
000022  000BF6     NOP
172:                       value += input[j];
00001C  000920     NOP
173:                   value = ((value >> (COS_RADIX - 10)) * SQRT_INV_N) >> 10;
00002C  000920     NOP
174:                   output[0] = value;
000040  000920     NOP
175:               
176:                   for (i = 1; i < num_features; ++i)
000042  000920     NOP
0000AC  000920     NOP
177:                   {
178:                       value = 0;
179:                       for (j = 0; j < NUM_FILTERS; j++)
000076  000920     NOP
000078  000920     NOP
180:                       {
181:                           value += (input[j] >> (COS_RADIX - 10)) * (kDCTMatrix[i][j]);
00005E  000920     NOP
182:                       }
183:                       value = ((value >> COS_RADIX) * SQRT_INV_2N) >> 10;
000056  000920     NOP
000084  000920     NOP
184:                       output[i] = value;
0000A6  000920     NOP
185:                       //printf("### DCT | %3d | %6d\n", i, output[i]);
186:                   }
187:               }
0000D6  000920     NOP
0000E2  0007AE     NOP
188:               
189:               void IMFCC_Liftering(int32_t *MFCCs, int32_t num_cepstra)
00000E  000920     NOP
000010  000B66     NOP
190:               {
000000  040200     GOTO __resetPRI, __reset
191:                   int32_t i;
192:                   int32_t num_features = num_cepstra;
193:               
194:                   for (i = 0; i < num_features; i++)
000004  000B9A     NOP
000006  000B2E     NOP
00002E  000920     NOP
195:                   {
196:                       int32_t value = MFCCMUL(MFCCs[i], kLifters[i]);
000012  00091A     NOP
197:                       MFCCs[i] = value;
198:                       //printf("### Lifter | %3d | %10d | %10f\n", i, MFCCs[i] , Qint32_to_float(MFCCs[i],13));
199:                   }
200:               }
000032  000920     NOP
000038  000920     NOP
201:               
202:               void IMFCC_ProcessFrame(int16_t *samples,
000032  000920     NOP
00007A  000920     NOP
00007C  000920     NOP
00008C  000920     NOP
203:                                       int16_t sample_nrow,
204:                                       int16_t window_size,
205:                                       int32_t num_cepstra)
206:               {
000000  040200     GOTO __resetPRI, __reset
207:               
208:                   int32_t i;
209:                   const int32_t kMagicNumber = -190131; /* For power spectrum case */
210:                   int32_t shift;
211:                   int32_t max_value;
212:                   
213:                   int32_t tri_outputs[NUM_FILTERS];
214:               
215:                   //using the features buffer as int32_t, values will be converted back to float before function completes
216:                   int32_t *dct_outputs = (int32_t *)samples;
217:               
218:                   IMFCC_PreEmphasis(samples, sample_nrow);
000010  000B66     NOP
219:               
220:                   max_value = IMFCC_HannWindow(samples);
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
00001C  000920     NOP
00001E  000920     NOP
000020  000920     NOP
000022  000BF6     NOP
221:               
222:                   /* Shift samples left to fully utilize 16 bits */
223:                   shift = 6;
00001A  000920     NOP
000026  000920     NOP
000050  000920     NOP
000052  000920     NOP
224:                   while (((max_value << (6 - shift)) < 16384) && shift > 0)
000018  000920     NOP
00001E  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
000034  000920     NOP
000058  000920     NOP
225:                       shift--;
00002E  000920     NOP
226:                   for (i = 0; i < WINDOW_SIZE; i++)
000052  000920     NOP
000066  000920     NOP
227:                   {
228:                       samples[i] <<= 6 - shift;
000060  000920     NOP
229:                   }
230:               
231:                   /* Zero padding to FFT size */
232:                   for (i = window_size; i < sample_nrow; i++)
000070  000920     NOP
000090  000920     NOP
233:                   {
234:                       samples[i] = 0;
000084  000920     NOP
235:                   }
236:               
237:                   shift += FFTR_512(samples);
000096  000920     NOP
238:               
239:                   /* Created in samples array, as it is large enough */
240:                   IMFCC_PowerTriFilter(samples, shift, tri_outputs);
00009E  000920     NOP
241:               
242:                   IMFCC_DCT(tri_outputs, dct_outputs, num_cepstra);
0000A6  000920     NOP
243:               
244:                   IMFCC_Liftering(dct_outputs, num_cepstra);
0000B0  000920     NOP
245:               
246:                   dct_outputs[0] += kMagicNumber;
0000B6  000920     NOP
247:               }
0000BE  000920     NOP
0000C0  000920     NOP
0000C2  000920     NOP
0000C4  000920     NOP
0000C6  000920     NOP
0000CA  0008B2     NOP
248:               
249:               
250:               
251:               void IMFE_ProcessFrame(int16_t *samples,
000032  000920     NOP
00007C  000920     NOP
00007E  000920     NOP
000080  000920     NOP
000082  000920     NOP
000084  000920     NOP
000086  000920     NOP
00008E  000920     NOP
0000AC  000920     NOP
0000AE  000920     NOP
0000B0  000920     NOP
0000B2  000920     NOP
252:                                       int16_t sample_nrow,
253:                                       int16_t window_size)
254:               {
000000  040200     GOTO __resetPRI, __reset
255:               
256:                   int32_t i;
257:                   int32_t shift;
258:                   int32_t max_value;
259:                   int32_t *output = (int32_t*)samples;
260:                   
261:                   int32_t tri_outputs[NUM_FILTERS];
262:               
263:                   IMFCC_PreEmphasis(samples, sample_nrow);
00000E  000920     NOP
264:               
265:                   max_value = IMFCC_HannWindow(samples);
000014  000920     NOP
266:               
267:                   /* Shift samples left to fully utilize 16 bits */
268:                   shift = 6;
00001A  000920     NOP
000026  000920     NOP
000028  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
00002E  000920     NOP
000030  000920     NOP
000050  000920     NOP
269:                   while (((max_value << (6 - shift)) < 16384) && shift > 0)
000018  000920     NOP
00001E  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
000034  000920     NOP
000036  000920     NOP
000038  000920     NOP
00005A  000920     NOP
270:                       shift--;
00002E  000920     NOP
271:                   for (i = 0; i < WINDOW_SIZE; i++)
000054  000920     NOP
000068  000920     NOP
272:                   {
273:                       samples[i] <<= 6 - shift;
000062  000920     NOP
274:                   }
275:               
276:                   /* Zero padding to FFT size */
277:                   for (i = window_size; i < sample_nrow; i++)
000072  000920     NOP
000074  000920     NOP
000076  000920     NOP
000092  000920     NOP
000094  000920     NOP
000096  000920     NOP
000098  000920     NOP
00009A  000920     NOP
278:                   {
279:                       samples[i] = 0;
000086  000920     NOP
280:                   }
281:               
282:                   shift += FFTR_512(samples);
000098  000920     NOP
283:               
284:                   /* Created in samples array, as it is large enough */
285:                   IMFCC_PowerTriFilter(samples, shift, tri_outputs);
0000A0  000920     NOP
286:               
287:                   for (i=0; i < NUM_FILTERS; i++)
0000B4  000920     NOP
288:                   {
289:                       output[i] = tri_outputs[i];
0000AE  000920     NOP
290:                   }
291:                   
292:               }
0000B8  000920     NOP
0000C2  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fixlog.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "fixlog.h"
26:                
27:                #include <stdint.h>
28:                
29:                /* Internal log-addition table for natural log with radix point at 8
30:                 * bits.  Each entry is 256 * log(1 + e^{-n/256}).  This is used in the
31:                 * log-add computation:
32:                 *
33:                 * e^z = e^x + e^y
34:                 * e^z = e^x(1 + e^{y-x})     = e^y(1 + e^{x-y})
35:                 * z   = x + log(1 + e^{y-x}) = y + log(1 + e^{x-y})
36:                 *
37:                 * So when y > x, z = y + logadd_table[-(x-y)]
38:                 *    when x > y, z = x + logadd_table[-(y-x)]
39:                 */
40:                static const uint8_t fe_logadd_table[] = {
41:                    177, 177, 176, 176, 175, 175, 174, 174, 173, 173,
42:                    172, 172, 172, 171, 171, 170, 170, 169, 169, 168,
43:                    168, 167, 167, 166, 166, 165, 165, 164, 164, 163,
44:                    163, 162, 162, 161, 161, 161, 160, 160, 159, 159,
45:                    158, 158, 157, 157, 156, 156, 155, 155, 155, 154,
46:                    154, 153, 153, 152, 152, 151, 151, 151, 150, 150,
47:                    149, 149, 148, 148, 147, 147, 147, 146, 146, 145,
48:                    145, 144, 144, 144, 143, 143, 142, 142, 141, 141,
49:                    141, 140, 140, 139, 139, 138, 138, 138, 137, 137,
50:                    136, 136, 136, 135, 135, 134, 134, 134, 133, 133,
51:                    132, 132, 131, 131, 131, 130, 130, 129, 129, 129,
52:                    128, 128, 128, 127, 127, 126, 126, 126, 125, 125,
53:                    124, 124, 124, 123, 123, 123, 122, 122, 121, 121,
54:                    121, 120, 120, 119, 119, 119, 118, 118, 118, 117,
55:                    117, 117, 116, 116, 115, 115, 115, 114, 114, 114,
56:                    113, 113, 113, 112, 112, 112, 111, 111, 110, 110,
57:                    110, 109, 109, 109, 108, 108, 108, 107, 107, 107,
58:                    106, 106, 106, 105, 105, 105, 104, 104, 104, 103,
59:                    103, 103, 102, 102, 102, 101, 101, 101, 100, 100,
60:                    100, 99, 99, 99, 98, 98, 98, 97, 97, 97,
61:                    96, 96, 96, 96, 95, 95, 95, 94, 94, 94,
62:                    93, 93, 93, 92, 92, 92, 92, 91, 91, 91,
63:                    90, 90, 90, 89, 89, 89, 89, 88, 88, 88,
64:                    87, 87, 87, 87, 86, 86, 86, 85, 85, 85,
65:                    85, 84, 84, 84, 83, 83, 83, 83, 82, 82,
66:                    82, 82, 81, 81, 81, 80, 80, 80, 80, 79,
67:                    79, 79, 79, 78, 78, 78, 78, 77, 77, 77,
68:                    77, 76, 76, 76, 75, 75, 75, 75, 74, 74,
69:                    74, 74, 73, 73, 73, 73, 72, 72, 72, 72,
70:                    71, 71, 71, 71, 71, 70, 70, 70, 70, 69,
71:                    69, 69, 69, 68, 68, 68, 68, 67, 67, 67,
72:                    67, 67, 66, 66, 66, 66, 65, 65, 65, 65,
73:                    64, 64, 64, 64, 64, 63, 63, 63, 63, 63,
74:                    62, 62, 62, 62, 61, 61, 61, 61, 61, 60,
75:                    60, 60, 60, 60, 59, 59, 59, 59, 59, 58,
76:                    58, 58, 58, 58, 57, 57, 57, 57, 57, 56,
77:                    56, 56, 56, 56, 55, 55, 55, 55, 55, 54,
78:                    54, 54, 54, 54, 53, 53, 53, 53, 53, 52,
79:                    52, 52, 52, 52, 52, 51, 51, 51, 51, 51,
80:                    50, 50, 50, 50, 50, 50, 49, 49, 49, 49,
81:                    49, 49, 48, 48, 48, 48, 48, 48, 47, 47,
82:                    47, 47, 47, 47, 46, 46, 46, 46, 46, 46,
83:                    45, 45, 45, 45, 45, 45, 44, 44, 44, 44,
84:                    44, 44, 43, 43, 43, 43, 43, 43, 43, 42,
85:                    42, 42, 42, 42, 42, 41, 41, 41, 41, 41,
86:                    41, 41, 40, 40, 40, 40, 40, 40, 40, 39,
87:                    39, 39, 39, 39, 39, 39, 38, 38, 38, 38,
88:                    38, 38, 38, 37, 37, 37, 37, 37, 37, 37,
89:                    37, 36, 36, 36, 36, 36, 36, 36, 35, 35,
90:                    35, 35, 35, 35, 35, 35, 34, 34, 34, 34,
91:                    34, 34, 34, 34, 33, 33, 33, 33, 33, 33,
92:                    33, 33, 32, 32, 32, 32, 32, 32, 32, 32,
93:                    32, 31, 31, 31, 31, 31, 31, 31, 31, 31,
94:                    30, 30, 30, 30, 30, 30, 30, 30, 30, 29,
95:                    29, 29, 29, 29, 29, 29, 29, 29, 28, 28,
96:                    28, 28, 28, 28, 28, 28, 28, 28, 27, 27,
97:                    27, 27, 27, 27, 27, 27, 27, 27, 26, 26,
98:                    26, 26, 26, 26, 26, 26, 26, 26, 25, 25,
99:                    25, 25, 25, 25, 25, 25, 25, 25, 25, 24,
100:                   24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
101:                   23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
102:                   23, 23, 22, 22, 22, 22, 22, 22, 22, 22,
103:                   22, 22, 22, 22, 21, 21, 21, 21, 21, 21,
104:                   21, 21, 21, 21, 21, 21, 21, 20, 20, 20,
105:                   20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
106:                   19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
107:                   19, 19, 19, 19, 18, 18, 18, 18, 18, 18,
108:                   18, 18, 18, 18, 18, 18, 18, 18, 18, 17,
109:                   17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
110:                   17, 17, 17, 17, 16, 16, 16, 16, 16, 16,
111:                   16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
112:                   16, 15, 15, 15, 15, 15, 15, 15, 15, 15,
113:                   15, 15, 15, 15, 15, 15, 15, 15, 14, 14,
114:                   14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
115:                   14, 14, 14, 14, 14, 14, 14, 13, 13, 13,
116:                   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
117:                   13, 13, 13, 13, 13, 13, 13, 12, 12, 12,
118:                   12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
119:                   12, 12, 12, 12, 12, 12, 12, 12, 12, 11,
120:                   11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
121:                   11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
122:                   11, 11, 11, 10, 10, 10, 10, 10, 10, 10,
123:                   10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
124:                   10, 10, 10, 10, 10, 10, 10, 10, 10, 9,
125:                   9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
126:                   9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
127:                   9, 9, 9, 9, 9, 9, 9, 9, 8, 8,
128:                   8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
129:                   8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
130:                   8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
131:                   7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
132:                   7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
133:                   7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
134:                   7, 7, 7, 7, 7, 7, 7, 7, 6, 6,
135:                   6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
136:                   6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
137:                   6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
138:                   6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
139:                   6, 5, 5, 5, 5, 5, 5, 5, 5, 5,
140:                   5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
141:                   5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
142:                   5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
143:                   5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
144:                   5, 5, 5, 4, 4, 4, 4, 4, 4, 4,
145:                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
146:                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
147:                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
148:                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
149:                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
150:                   4, 4, 4, 4, 4, 4, 4, 4, 3, 3,
151:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
152:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
153:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
154:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
155:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
156:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
157:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
158:                   3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
159:                   3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
160:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
161:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
162:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
163:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
164:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
165:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
166:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
167:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
168:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
169:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
170:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
171:                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
172:                   2, 2, 2, 2, 2, 2, 1, 1, 1, 1,
173:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
174:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
175:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
176:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
177:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
178:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
179:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
180:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
181:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
182:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
183:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
184:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
185:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
186:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
187:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
188:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
189:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
190:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
191:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
192:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
193:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
194:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
195:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
196:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
197:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
198:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
199:                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
200:                   1, 1, 1, 1, 1, 1, 1, 0};
201:               static const int32_t fe_logadd_table_size =
202:                   (int32_t)(sizeof(fe_logadd_table) / sizeof(fe_logadd_table[0]));
203:               
204:               int32_t sphinx_fe_log_add(int32_t x, int32_t y)
205:               {
206:                   int32_t d, r;
207:               
208:                   if (x > y)
000000  040200     GOTO __resetPRI, __reset
209:                   {
210:                       d = (x - y) >> (DEFAULT_RADIX - 8);
000006  000B2E     NOP
211:                       r = x;
212:                   }
213:                   else
214:                   {
215:                       d = (y - x) >> (DEFAULT_RADIX - 8);
000014  000920     NOP
216:                       r = y;
000020  000920     NOP
217:                   }
218:                   if (d > fe_logadd_table_size - 1)
000022  000BF6     NOP
219:                       return r;
220:                   else
221:                   {
222:                       r += ((int32_t)fe_logadd_table[d] << (DEFAULT_RADIX - 8));
00002A  000C36     NOP
223:                       /*
224:                       printf("%d + %d = %d | %f + %f = %f | %f + %f = %f\n",
225:                              x, y, r, FIX2FLOAT(x), FIX2FLOAT(y), FIX2FLOAT(r),
226:                              exp(FIX2FLOAT(x)), exp(FIX2FLOAT(y)), exp(FIX2FLOAT(r)));
227:               */
228:                       return r;
229:                   }
230:               }
00003E  000920     NOP
231:               
232:               /* Table of log2(x/64)*(1<<DEFAULT_RADIX) */
233:               static const uint16_t logtable[] = {
234:                   0, 92, 182, 271, 358, 445, 530, 613, 696, 778,
235:                   858, 937, 1016, 1093, 1169, 1244, 1319, 1392, 1465, 1536,
236:                   1607, 1677, 1746, 1814, 1882, 1949, 2015, 2080, 2145, 2208,
237:                   2272, 2334, 2396, 2457, 2518, 2578, 2637, 2696, 2754, 2812,
238:                   2869, 2926, 2982, 3037, 3092, 3146, 3200, 3254, 3307, 3359,
239:                   3412, 3463, 3514, 3565, 3615, 3665, 3715, 3764, 3812, 3861,
240:                   3908, 3956, 4003, 4050};
241:               
242:               int32_t sphinx_fixlog2(uint32_t x)
243:               {
244:                   uint32_t y;
245:               
246:                   if (x == 0)
000000  040200     GOTO __resetPRI, __reset
247:                       return MIN_FIXLOG2;
00003C  000920     NOP
248:               
249:                   /* Get the exponent. */
250:                   for (y = 31; y > 0; --y)
00001C  000920     NOP
000046  000920     NOP
00004C  000920     NOP
251:                   {
252:                       if (x & 0x80000000)
000006  000B2E     NOP
253:                           break;
254:                       x <<= 1;
000018  000920     NOP
000042  000920     NOP
255:                   }
256:                   y <<= DEFAULT_RADIX;
00002E  000920     NOP
257:                   /* Do a table lookup for the MSB of the mantissa. */
258:                   x = (x >> 25) & 0x3f;
000022  000BF6     NOP
259:               
260:                   return y + logtable[x];
000026  000920     NOP
000036  000920     NOP
261:               }
000040  000920     NOP
262:               
263:               int32_t sphinx_fixlog(uint32_t x)
264:               {
265:                   int32_t y;
266:               
267:                   if (x == 0)
000000  040200     GOTO __resetPRI, __reset
268:                       return MIN_FIXLOG;
000022  000BF6     NOP
269:               
270:                   y = sphinx_fixlog2(x);
000006  000B2E     NOP
271:                   return FIXMUL(y, FIXLN_2);
000008  000B4A     NOP
272:               }
000026  000920     NOP
000028  000920     NOP
273:               
274:               int32_t sphinx_get_fixlog_rom_size(void)
275:               {
276:                   return (int32_t)(sizeof(logtable) + sizeof(fe_logadd_table));
277:               }
000000  040200     GOTO __resetPRI, __reset
000006  000B2E     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fg_stats_skewness.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t fg_stats_skewness(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV)
007BC2  97BD0F     MOV [W15-16], W10
28:                {
007BA0  4787EE     ADD W15, #0xE, W15
007BA2  BE9F88     MOV.D W8, [W15++]
007BA4  BE9F8A     MOV.D W10, [W15++]
007BA6  BE9F8C     MOV.D W12, [W15++]
007BA8  781F8E     MOV W14, [W15++]
007BAA  780700     MOV W0, W14
007BAC  9FB7B2     MOV W2, [W15-26]
007BAE  9FB7C3     MOV W3, [W15-24]
29:                	int32_t i;
30:                
31:                #if SML_DEBUG
32:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
33:                		return 0;
34:                #endif
35:                
36:                	for (i = 0; i < num_cols; i++)
007BB0  510FE0     SUB W2, #0x0, [W15]
007BB2  598FE0     SUBB W3, #0x0, [W15]
007BB4  34003E     BRA LE, .L2
007BB6  9FBF81     MOV W1, [W15-16]
007BB8  9FB7D5     MOV W5, [W15-22]
007BBA  B80060     MUL.UU W0, #0x0, W0
007BBC  9FB7E0     MOV W0, [W15-20]
007BBE  9FB7F1     MOV W1, [W15-18]
007C1C  97B36F     MOV [W15-20], W6
007C1E  97B3FF     MOV [W15-18], W7
007C20  430361     ADD W6, #0x1, W6
007C22  4B83E0     ADDC W7, #0x0, W7
007C24  9FB7E6     MOV W6, [W15-20]
007C26  9FB7F7     MOV W7, [W15-18]
007C28  97B03F     MOV [W15-26], W0
007C2A  97B0CF     MOV [W15-24], W1
007C2C  500F86     SUB W0, W6, [W15]
007C2E  588F87     SUBB W1, W7, [W15]
007C30  3CFFC8     BRA GT, .LBE2, .L5
37:                	{
38:                
39:                		FLOAT m2 = stat_moment(kb_model->pringb + cols_to_use[i], kb_model->sg_index, kb_model->sg_length, 2);
007BC4  90016E     MOV [W14+12], W2
007BC6  9001FE     MOV [W14+14], W3
007BC8  78001A     MOV [W10], W0
007BCA  B900EC     MULW.SU W0, #0xC, W0
007BCC  9010CE     MOV [W14+40], W1
007BCE  408000     ADD W1, W0, W0
007BD0  200026     MOV #0x2, W6
007BD2  200007     MOV #0x0, W7
007BD4  90024E     MOV [W14+8], W4
007BD6  9002DE     MOV [W14+10], W5
007BD8  071198     RCALL stat_moment
007BDA  BE0400     MOV.D W0, W8
007BDC  97B90F     MOV [W15-16], W2
007BDE  410164     ADD W2, #0x4, W2
007BE0  9FBF82     MOV W2, [W15-16]
40:                		FLOAT m3 = stat_moment(kb_model->pringb + cols_to_use[i], kb_model->sg_index, kb_model->sg_length, 3);
007BE2  90016E     MOV [W14+12], W2
007BE4  9001FE     MOV [W14+14], W3
007BE6  78001A     MOV [W10], W0
007BE8  B900EC     MULW.SU W0, #0xC, W0
007BEA  9010CE     MOV [W14+40], W1
007BEC  408000     ADD W1, W0, W0
007BEE  200036     MOV #0x3, W6
007BF0  200007     MOV #0x0, W7
007BF2  90024E     MOV [W14+8], W4
007BF4  9002DE     MOV [W14+10], W5
007BF6  071189     RCALL stat_moment
007BF8  BE0500     MOV.D W0, W10
41:                		FLOAT fval = 0.0f;
007C14  BE000C     MOV.D W12, W0
42:                
43:                		if (m2 != 0)
007BC0  B86660     MUL.UU W12, #0x0, W12
007BFA  BE010C     MOV.D W12, W2
007BFC  BE0008     MOV.D W8, W0
007BFE  07C8E7     RCALL ___nesf2
007C00  E00000     CP0 W0
007C02  320008     BRA Z, .L9
44:                		{
45:                			fval = m3 / (float)POW(m2, 1.5f);
007C04  200002     MOV #0x0, W2
007C06  23FC03     MOV #0x3FC0, W3
007C08  BE0008     MOV.D W8, W0
007C0A  07CDD2     RCALL _powf
007C0C  BE0100     MOV.D W0, W2
007C0E  BE000A     MOV.D W10, W0
007C10  07CA2B     RCALL ___divsf3, ___divsf3x
007C12  370001     BRA .L3
46:                		}
47:                		*(pFV + i) = fval;
007C16  97B1DF     MOV [W15-22], W3
007C18  BE9980     MOV.D W0, [W3++]
007C1A  9FB7D3     MOV W3, [W15-22]
48:                	}
49:                
50:                	return num_cols;
51:                }
007C32  97B03F     MOV [W15-26], W0
007C34  97B0CF     MOV [W15-24], W1
007C36  78074F     MOV [--W15], W14
007C38  BE064F     MOV.D [--W15], W12
007C3A  BE054F     MOV.D [--W15], W10
007C3C  BE044F     MOV.D [--W15], W8
007C3E  B100EF     SUB #0xE, W15
007C40  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fg_stats_pct075.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t fg_stats_pct075(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV)
28:                {
008594  FA0008     LNK #0x8
008596  BE9F88     MOV.D W8, [W15++]
008598  BE9F8A     MOV.D W10, [W15++]
00859A  781F8C     MOV W12, [W15++]
00859C  780500     MOV W0, W10
00859E  BE0402     MOV.D W2, W8
29:                	SENSOR_DATA_T *temp;
30:                	int32_t icol;
31:                
32:                #if SML_DEBUG
33:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
34:                		return 0;
35:                #endif
36:                
37:                	for (icol = 0; icol < num_cols; icol++)
0085A0  510FE0     SUB W2, #0x0, [W15]
0085A2  598FE0     SUBB W3, #0x0, [W15]
0085A4  340026     BRA LE, .L2
0085A6  780601     MOV W1, W12
0085A8  780585     MOV W5, W11
0085AA  B80060     MUL.UU W0, #0x0, W0
0085AC  9FB7F0     MOV W0, [W15-18]
0085AE  9FBF81     MOV W1, [W15-16]
0085E0  440461     ADD W8, #0x1, W8
0085E2  4C84E0     ADDC W9, #0x0, W9
0085E4  4585E4     ADD W11, #0x4, W11
0085E6  97B81F     MOV [W15-14], W0
0085E8  97B8AF     MOV [W15-12], W1
0085EA  500F88     SUB W0, W8, [W15]
0085EC  588F89     SUBB W1, W9, [W15]
0085EE  3CFFE3     BRA GT, .L5
0085F0  BE0400     MOV.D W0, W8
38:                	{
39:                
40:                		temp = sorted_copy(kb_model->pringb + cols_to_use[icol], kb_model->sg_index, kb_model->sg_length, 0);
0085B6  BE003C     MOV.D [W12++], W0
0085B8  90016A     MOV [W10+12], W2
0085BA  9001FA     MOV [W10+14], W3
0085BC  B900EC     MULW.SU W0, #0xC, W0
0085BE  9010CA     MOV [W10+40], W1
0085C0  408000     ADD W1, W0, W0
0085C2  B83360     MUL.UU W6, #0x0, W6
0085C4  90024A     MOV [W10+8], W4
0085C6  9002DA     MOV [W10+10], W5
0085C8  070391     RCALL sorted_copy
41:                		if (temp)
0085CA  E00000     CP0 W0
0085CC  320007     BRA Z, .L3
42:                		{
43:                			pFV[icol] = stats_percentile_presorted(temp, kb_model->sg_length, 0.75f);
0085B0  9FBF92     MOV W2, [W15-14]
0085B2  9FBFA3     MOV W3, [W15-12]
0085B4  B84460     MUL.UU W8, #0x0, W8
0085CE  90014A     MOV [W10+8], W2
0085D0  9001DA     MOV [W10+10], W3
0085D2  200004     MOV #0x0, W4
0085D4  23F405     MOV #0x3F40, W5
0085D6  07F6E7     RCALL stats_percentile_presorted
0085D8  BE8D80     MOV.D W0, [W11]
0085DA  370002     BRA .L4
44:                		}
45:                		else
46:                		{
47:                			pFV[icol] = 0;
0085DC  B80060     MUL.UU W0, #0x0, W0
0085DE  BE8D80     MOV.D W0, [W11]
48:                		}
49:                	}
50:                	return num_cols;
51:                }
0085F2  BE0008     MOV.D W8, W0
0085F4  78064F     MOV [--W15], W12
0085F6  BE054F     MOV.D [--W15], W10
0085F8  BE044F     MOV.D [--W15], W8
0085FA  FA8000     ULNK
0085FC  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fg_stats_pct025.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t fg_stats_pct025(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV)
28:                {
00852A  FA0008     LNK #0x8
00852C  BE9F88     MOV.D W8, [W15++]
00852E  BE9F8A     MOV.D W10, [W15++]
008530  781F8C     MOV W12, [W15++]
008532  780500     MOV W0, W10
008534  BE0402     MOV.D W2, W8
29:                	SENSOR_DATA_T *temp;
30:                	int32_t icol;
31:                
32:                #if SML_DEBUG
33:                	if (!kb_model || kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || !pFV)
34:                		return 0;
35:                #endif
36:                
37:                	// Process each column individually
38:                	for (icol = 0; icol < num_cols; icol++)
008536  510FE0     SUB W2, #0x0, [W15]
008538  598FE0     SUBB W3, #0x0, [W15]
00853A  340026     BRA LE, .L2
00853C  780601     MOV W1, W12
00853E  780585     MOV W5, W11
008540  B80060     MUL.UU W0, #0x0, W0
008542  9FB7F0     MOV W0, [W15-18]
008544  9FBF81     MOV W1, [W15-16]
008576  440461     ADD W8, #0x1, W8
008578  4C84E0     ADDC W9, #0x0, W9
00857A  4585E4     ADD W11, #0x4, W11
00857C  97B81F     MOV [W15-14], W0
00857E  97B8AF     MOV [W15-12], W1
008580  500F88     SUB W0, W8, [W15]
008582  588F89     SUBB W1, W9, [W15]
008584  3CFFE3     BRA GT, .L5
008586  BE0400     MOV.D W0, W8
39:                	{
40:                
41:                		temp = sorted_copy(kb_model->pringb + cols_to_use[icol], kb_model->sg_index, kb_model->sg_length, 0);
00854C  BE003C     MOV.D [W12++], W0
00854E  90016A     MOV [W10+12], W2
008550  9001FA     MOV [W10+14], W3
008552  B900EC     MULW.SU W0, #0xC, W0
008554  9010CA     MOV [W10+40], W1
008556  408000     ADD W1, W0, W0
008558  B83360     MUL.UU W6, #0x0, W6
00855A  90024A     MOV [W10+8], W4
00855C  9002DA     MOV [W10+10], W5
00855E  0703C6     RCALL sorted_copy
42:                		if (temp)
008560  E00000     CP0 W0
008562  320007     BRA Z, .L3
43:                		{
44:                			pFV[icol] = stats_percentile_presorted(temp, kb_model->sg_length, 0.25f);
008546  9FBF92     MOV W2, [W15-14]
008548  9FBFA3     MOV W3, [W15-12]
00854A  B84460     MUL.UU W8, #0x0, W8
008564  90014A     MOV [W10+8], W2
008566  9001DA     MOV [W10+10], W3
008568  200004     MOV #0x0, W4
00856A  23E805     MOV #0x3E80, W5
00856C  07F71C     RCALL stats_percentile_presorted
00856E  BE8D80     MOV.D W0, [W11]
008570  370002     BRA .L4
45:                		}
46:                		else
47:                		{
48:                			pFV[icol] = 0;
008572  B80060     MUL.UU W0, #0x0, W0
008574  BE8D80     MOV.D W0, [W11]
49:                		}
50:                	}
51:                	return num_cols;
52:                }
008588  BE0008     MOV.D W8, W0
00858A  78064F     MOV [--W15], W12
00858C  BE054F     MOV.D [--W15], W10
00858E  BE044F     MOV.D [--W15], W8
008590  FA8000     ULNK
008592  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fg_area_power_spectrum_density.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbalgorithms.h"
26:                
27:                int32_t fg_area_power_spectrum_density(kb_model_t *kb_model, int32_t *cols_to_use, int32_t num_cols, FLOAT *params, int32_t num_params, FLOAT *pFV)
007B26  97B65F     MOV [W15-22], W12
007B28  97B6EF     MOV [W15-20], W13
007B2A  42060C     ADD W4, W12, W12
007B2C  4A868D     ADDC W5, W13, W13
007B2E  9FB7FC     MOV W12, [W15-18]
007B30  9FBF8D     MOV W13, [W15-16]
28:                {
007AFC  4787F6     ADD W15, #0x16, W15
007AFE  BE9F88     MOV.D W8, [W15++]
007B00  BE9F8A     MOV.D W10, [W15++]
007B02  BE9F8C     MOV.D W12, [W15++]
007B04  781F8E     MOV W14, [W15++]
007B06  780505     MOV W5, W10
29:                
30:                #define FG_AREA_POWER_SPECTRUM_DENSITY_NUM_PARAMS 1
31:                #define FG_AREA_POWER_SPECTRUM_DENSITY_SAMPLE_RATE_PARAM_IDX 0
32:                	int32_t row, icol;
33:                	int32_t sum;
34:                	int32_t base_index = kb_model->sg_index;
35:                	ringb *rb;
36:                
37:                #if SML_DEBUG
38:                	if (kb_model->sg_length <= 0 || !cols_to_use || num_cols <= 0 || num_params != 1 || !params || !pFV)
39:                	{
40:                		return 0;
41:                	}
42:                #endif
43:                
44:                	FLOAT sample_rate = params[FG_AREA_POWER_SPECTRUM_DENSITY_SAMPLE_RATE_PARAM_IDX];
007B08  BE0414     MOV.D [W4], W8
45:                
46:                	for (icol = 0, sum = 0; icol < num_cols; icol++)
007B0A  B83360     MUL.UU W6, #0x0, W6
007B0C  510FE0     SUB W2, #0x0, [W15]
007B0E  598FE0     SUBB W3, #0x0, [W15]
007B10  34003A     BRA LE, .L2
007B22  B83360     MUL.UU W6, #0x0, W6
007B24  B80060     MUL.UU W0, #0x0, W0
007B74  440461     ADD W8, #0x1, W8
007B76  4C84E0     ADDC W9, #0x0, W9
007B78  97B23F     MOV [W15-26], W4
007B7A  97B2CF     MOV [W15-24], W5
007B7C  540F84     SUB W8, W4, [W15]
007B7E  5C8F85     SUBB W9, W5, [W15]
007B80  3AFFE1     BRA NZ, .L5
007B82  97AC7F     MOV [W15-34], W8
007B84  97B48F     MOV [W15-32], W9
47:                	{
48:                		rb = kb_model->pringb + cols_to_use[icol];
007B12  901740     MOV [W0+40], W14
007B44  BE003B     MOV.D [W11++], W0
007B46  B900EC     MULW.SU W0, #0xC, W0
007B48  470000     ADD W14, W0, W0
49:                		base_index = kb_model->sg_index;
007B14  900260     MOV [W0+12], W4
007B16  9002F0     MOV [W0+14], W5
007B32  9FB794     MOV W4, [W15-30]
007B34  9FB7A5     MOV W5, [W15-28]
007B36  9FAFF8     MOV W8, [W15-34]
007B38  9FB789     MOV W9, [W15-32]
007B3A  BE0400     MOV.D W0, W8
007B3C  9FB7B2     MOV W2, [W15-26]
007B3E  9FB7C3     MOV W3, [W15-24]
007B40  97B67F     MOV [W15-18], W12
007B42  97BE8F     MOV [W15-16], W13
007B58  97B01F     MOV [W15-30], W0
007B5A  97B0AF     MOV [W15-28], W1
50:                		for (row = 0; row < kb_model->sg_length; row++)
007B18  900340     MOV [W0+8], W6
007B1A  9003D0     MOV [W0+10], W7
007B1C  9FB7D6     MOV W6, [W15-22]
007B1E  9FB7E7     MOV W7, [W15-20]
007B20  780581     MOV W1, W11
007B4A  97B15F     MOV [W15-22], W2
007B4C  97B1EF     MOV [W15-20], W3
007B4E  510FE0     SUB W2, #0x0, [W15]
007B50  598FE0     SUBB W3, #0x0, [W15]
007B52  340010     BRA LE, .L3
007B6E  500F8C     SUB W0, W12, [W15]
007B70  588F8D     SUBB W1, W13, [W15]
007B72  3AFFF4     BRA NZ, .L4
51:                		{
52:                			int32_t data = MOD_READ_RINGBUF(rb, base_index++);
007B54  9002B0     MOV [W0+6], W5
007B56  900220     MOV [W0+4], W4
007B5C  620100     AND W4, W0, W2
007B5E  410102     ADD W2, W2, W2
007B60  428102     ADD W5, W2, W2
007B62  780112     MOV [W2], W2
007B64  400061     ADD W0, #0x1, W0
007B66  4880E0     ADDC W1, #0x0, W1
53:                			sum += data * data;
007B68  B99102     MUL.SS W2, W2, W2
007B6A  410306     ADD W2, W6, W6
007B6C  498387     ADDC W3, W7, W7
54:                		}
55:                	}
56:                
57:                	*pFV = sum * sample_rate;
007B86  BE0006     MOV.D W6, W0
007B88  07C8F0     RCALL ___floatsisf
007B8A  BE0108     MOV.D W8, W2
007B8C  07CB4C     RCALL ___mulsf3x, ___mulsf3
007B8E  BE8D00     MOV.D W0, [W10]
58:                
59:                	return 1;
60:                }
007B90  200010     MOV #0x1, W0
007B92  200001     MOV #0x0, W1
007B94  78074F     MOV [--W15], W14
007B96  BE064F     MOV.D [--W15], W12
007B98  BE054F     MOV.D [--W15], W10
007B9A  BE044F     MOV.D [--W15], W8
007B9C  B1016F     SUB #0x16, W15
007B9E  060000     RETURN
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fftr_utils.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include <stdint.h>
26:                #include <stddef.h>
27:                #include <stdbool.h>
28:                #include "fftr_utils.h"
29:                #include "fftr.h"
30:                #include "kbutils.h"
31:                
32:                #ifdef UTEST
33:                // comment out the next line before committing:
34:                // #define DBG_UTEST
35:                #endif
36:                #ifdef DBG_UTEST
37:                #include <stdio.h>
38:                #endif
39:                
40:                // local params:
41:                static uint8_t autoScale = false;
42:                static uint8_t removeMean = false;
43:                
44:                #ifdef DBG_UTEST
45:                // local functions for debugging:
46:                static void dump_data_float(FLOAT *pData, int32_t len)
47:                {
48:                    int32_t idx;
49:                    int32_t cnt = 0;
50:                
51:                    for (idx = 0; idx < len; idx++)
52:                    {
53:                        printf("%.6f, ", *pData++);
54:                        cnt++;
55:                        if ((cnt % 8) == 0)
56:                        {
57:                            printf("\n");
58:                        }
59:                    }
60:                    if (len % 8)
61:                    {
62:                        printf("\n");
63:                    }
64:                }
65:                
66:                static void dump_data_int(int16_t *pData, int32_t len)
67:                {
68:                    int32_t idx;
69:                    int32_t cnt = 0;
70:                
71:                    for (idx = 0; idx < len; idx++)
72:                    {
73:                        printf("%5d, ", *pData++);
74:                        cnt++;
75:                        if ((cnt % 8) == 0)
76:                        {
77:                            printf("\n");
78:                        }
79:                    }
80:                    if (len % 8)
81:                    {
82:                        printf("\n");
83:                    }
84:                }
85:                
86:                static void dump_FFTR(int16_t *pData)
87:                {
88:                    int32_t idx;
89:                
90:                    for (idx = 0; idx < NUM_FFTR; idx += 2)
91:                    {
92:                        printf("%5d, %5d\n", pData[idx], pData[idx + 1]);
93:                    }
94:                }
95:                #endif
96:                
97:                // The basic float-based wrapper, applies Hanning window to data, converts FLOAT inputs to int16, calls FFTR_512(),
98:                // and converts results back to FLOAT.
99:                struct compx *fftr_fl(FLOAT *input_data, int32_t len)
00007C  000920     NOP
000098  000920     NOP
100:               {
000000  040200     GOTO __resetPRI, __reset
101:                   int16_t *pInt16 = (int16_t *)input_data;
102:                   FLOAT *pFloat = input_data;
103:                   int32_t rShifts;
104:                   int32_t idx;
105:               
106:                   // check inputs:
107:                   if ((!input_data) || (len < 8))
00000E  000920     NOP
108:                   {
109:                       return NULL;
00000C  000BB6     NOP
110:                   }
111:               
112:                   if (len % 2)
000018  000920     NOP
113:                   {
114:                       len -= 1;
00001C  000920     NOP
115:                   }
116:               
117:                   if (len > NUM_FFTR)
118:                   {
119:                       len = NUM_FFTR;
120:                   }
121:               
122:               #ifdef DBG_UTEST
123:                   printf("\nInput Data:\n");
124:                   dump_data_float(input_data, len);
125:               #endif
126:               
127:                   // first, remove the mean:
128:                   if (removeMean)
00002E  000920     NOP
129:                   {
130:                       remove_mean_data_float(input_data, len);
000032  000920     NOP
131:                       removeMean = false;
000038  000920     NOP
132:               #ifdef DBG_UTEST
133:                       printf("\nDemeaned data:\n");
134:                       dump_data_float(input_data, len);
135:               #endif
136:                   }
137:               
138:                   // apply Hanning window:
139:                   apply_hanning_float(input_data, len);
00003A  000920     NOP
140:               #ifdef DBG_UTEST
141:                   printf("\nHanning applied to Data:\n");
142:                   dump_data_float(input_data, len);
143:               #endif
144:               
145:                   // handle auto-scaling
146:                   if (autoScale)
000040  000920     NOP
147:                   {
148:                       autoscale_data_float(input_data, len);
000044  000C16     NOP
149:                       autoScale = false;
00004A  000920     NOP
150:               #ifdef DBG_UTEST
151:                       printf("\nAutoscaled data:\n");
152:                       dump_data_float(input_data, len);
153:               #endif
154:                   }
155:               
156:                   // convert floats to 16-bit ints:
157:                   for (idx = 0; idx < len; idx++)
00004C  000920     NOP
000062  000920     NOP
158:                   {
159:                       pInt16[idx] = (int16_t)(pFloat[idx]);
00005C  000920     NOP
160:                   }
161:               
162:                   // if len < expected, zero pad at the end:
163:                   if (len < NUM_FFTR)
000074  000920     NOP
164:                   {
165:                       for (idx = len; idx < NUM_FFTR; idx++)
000084  000920     NOP
00008A  000920     NOP
166:                       {
167:                           pInt16[idx] = 0;
000082  000920     NOP
000088  000920     NOP
00008A  000920     NOP
168:                       }
169:                   }
170:               
171:                   // get FFT (results returned in given buffer):
172:                   rShifts = FFTR_512(pInt16);
000094  000920     NOP
173:               #ifdef DBG_UTEST
174:                   printf("\nfftr results (rShifts = %d):\n", rShifts);
175:                   dump_FFTR(pInt16);
176:               #else
177:                   // ignore rShifts:
178:                   (void)rShifts;
179:               #endif
180:               
181:                   // convert 16-bit ints to floats, working backwards because the ints are up front:
182:                   for (idx = NUM_FFTR - 1; idx >= 0; idx--)
0000A0  000920     NOP
0000B0  000920     NOP
183:                   {
184:                       pFloat[idx] = (FLOAT)pInt16[idx];
0000A8  000920     NOP
185:                   }
186:               
187:                   // done!
188:                   return ((struct compx *)input_data);
0000BA  000920     NOP
189:               }
0000BC  000920     NOP
190:               
191:               // This applies Hanning and then auto-scales:
192:               struct compx *fftr_fl_as(FLOAT *input_data, int32_t len)
193:               {
194:                   struct compx *pRet;
195:               
196:                   autoScale = true;
000000  040200     GOTO __resetPRI, __reset
197:                   removeMean = false;
000006  000B2E     NOP
198:                   pRet = fftr_fl(input_data, len);
000008  000B4A     NOP
199:                   return pRet;
200:               }
00000A  000BD2     NOP
00000C  000BB6     NOP
201:               
202:               // This removes the mean, applies Hanning, and then auto-scales:
203:               struct compx *fftr_fl_rm_as(FLOAT *input_data, int32_t len)
204:               {
205:                   struct compx *pRet;
206:               
207:                   autoScale = true;
000000  040200     GOTO __resetPRI, __reset
208:                   removeMean = true;
000006  000B2E     NOP
209:                   pRet = fftr_fl(input_data, len);
00000A  000BD2     NOP
210:                   return pRet;
211:               }
00000C  000BB6     NOP
00000E  000920     NOP
212:               
213:               // The basic int16-based wrapper, applies Hanning window and calls FFTR_512():
214:               struct compx_int16_t *fftr(int16_t *input_data, int32_t len)
000048  000920     NOP
215:               {
000000  040200     GOTO __resetPRI, __reset
216:                   int32_t rShifts;
217:                   int32_t idx;
218:               
219:                   // check inputs:
220:                   if ((!input_data) || (len < 8))
000008  000B4A     NOP
221:                   {
222:                       return NULL;
000006  000B2E     NOP
223:                   }
224:               
225:                   if (len > NUM_FFTR)
226:                   {
227:                       len = NUM_FFTR;
228:                   }
229:               
230:               #ifdef DBG_UTEST
231:                   printf("\nInput Data:\n");
232:                   dump_data_int(input_data, len);
233:               #endif
234:               
235:                   // first, remove the mean
236:                   if (removeMean)
000020  000920     NOP
237:                   {
238:                       remove_mean_data_int(input_data, len);
000024  000920     NOP
239:                       removeMean = false;
00002A  000C36     NOP
240:               #ifdef DBG_UTEST
241:                       printf("\nDemeaned data:\n");
242:                       dump_data_int(input_data, len);
243:               #endif
244:                   }
245:               
246:                   // apply Hanning window
247:                   apply_hanning_int(input_data, len);
00002C  000920     NOP
248:               #ifdef DBG_UTEST
249:                   printf("\nHanning applied to Data:\n");
250:                   dump_data_int(input_data, len);
251:               #endif
252:               
253:                   // handle auto-scaling
254:                   if (autoScale)
000032  000920     NOP
255:                   {
256:                       autoscale_data_int(input_data, NUM_FFTR);
000036  000920     NOP
257:                       autoScale = false;
00003E  000920     NOP
258:               #ifdef DBG_UTEST
259:                       printf("\nAutoscaled data:\n");
260:                       dump_data_int(input_data, len);
261:               #endif
262:                   }
263:               
264:                   // if len < expected, zero pad at the end:
265:                   if (len < NUM_FFTR)
000040  000920     NOP
266:                   {
267:                       for (idx = len; idx < NUM_FFTR; idx++)
000050  000920     NOP
000056  000920     NOP
268:                       {
269:                           input_data[idx] = 0;
00004E  000920     NOP
000054  000920     NOP
270:                       }
271:                   }
272:               
273:                   // get FFT (results returned in given buffer):
274:                   rShifts = FFTR_512(input_data);
000060  000920     NOP
275:               #ifdef DBG_UTEST
276:                   printf("\nfftr results (rShifts = %d):\n", rShifts);
277:                   dump_FFTR(input_data);
278:               #else
279:                   // ignore rShifts:
280:                   (void)rShifts;
281:               #endif
282:               
283:                   // done!
284:                   return ((struct compx_int16_t *)input_data);
000064  000920     NOP
285:               }
000066  000920     NOP
00006C  000920     NOP
286:               
287:               // This applies Hanning and then auto-scales:
288:               struct compx_int16_t *fftr_as(int16_t *input_data, int32_t len)
289:               {
290:                   struct compx_int16_t *pRet;
291:               
292:                   autoScale = true;
000000  040200     GOTO __resetPRI, __reset
293:                   removeMean = false;
000006  000B2E     NOP
294:                   pRet = fftr(input_data, len);
000008  000B4A     NOP
295:                   return pRet;
296:               }
00000A  000BD2     NOP
00000C  000BB6     NOP
297:               
298:               // This removes the mean, applies Hanning, and then auto-scales:
299:               struct compx_int16_t *fftr_rm_as(int16_t *input_data, int32_t len)
300:               {
301:                   struct compx_int16_t *pRet;
302:               
303:                   autoScale = true;
000000  040200     GOTO __resetPRI, __reset
304:                   removeMean = true;
000006  000B2E     NOP
305:                   pRet = fftr(input_data, len);
00000A  000BD2     NOP
306:                   return pRet;
307:               }
00000C  000BB6     NOP
00000E  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/fftr.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include <stdint.h>
26:                
27:                #include "fftr.h"
28:                
29:                #ifndef NULL
30:                #define NULL ((void *)0)
31:                #endif
32:                
33:                #define N_WAVE 512
34:                #define LOG2_N_WAVE 9 /* log2(N_WAVE) */
35:                
36:                /* 3 / 4 of a full cycle of a sine wave,
37:                 * Computed with:
38:                 * awk 'BEGIN{for (i = 0; i < 512-128; i++)
39:                 *      {printf("%d,", int32_t(sin(i*3.1415926536*2/512)*32767));
40:                 *      if(i%8==7){printf("\n")}else{printf(" ")}}}'/
41:                 */
42:                static const int16_t kSine512[N_WAVE - N_WAVE / 4] = {
43:                    0,
44:                    402,
45:                    804,
46:                    1206,
47:                    1607,
48:                    2009,
49:                    2410,
50:                    2811,
51:                    3211,
52:                    3611,
53:                    4011,
54:                    4409,
55:                    4807,
56:                    5205,
57:                    5601,
58:                    5997,
59:                    6392,
60:                    6786,
61:                    7179,
62:                    7571,
63:                    7961,
64:                    8351,
65:                    8739,
66:                    9126,
67:                    9511,
68:                    9895,
69:                    10278,
70:                    10659,
71:                    11038,
72:                    11416,
73:                    11792,
74:                    12166,
75:                    12539,
76:                    12909,
77:                    13278,
78:                    13645,
79:                    14009,
80:                    14372,
81:                    14732,
82:                    15090,
83:                    15446,
84:                    15799,
85:                    16150,
86:                    16499,
87:                    16845,
88:                    17189,
89:                    17530,
90:                    17868,
91:                    18204,
92:                    18537,
93:                    18867,
94:                    19194,
95:                    19519,
96:                    19840,
97:                    20159,
98:                    20474,
99:                    20787,
100:                   21096,
101:                   21402,
102:                   21705,
103:                   22004,
104:                   22301,
105:                   22594,
106:                   22883,
107:                   23169,
108:                   23452,
109:                   23731,
110:                   24006,
111:                   24278,
112:                   24546,
113:                   24811,
114:                   25072,
115:                   25329,
116:                   25582,
117:                   25831,
118:                   26077,
119:                   26318,
120:                   26556,
121:                   26789,
122:                   27019,
123:                   27244,
124:                   27466,
125:                   27683,
126:                   27896,
127:                   28105,
128:                   28309,
129:                   28510,
130:                   28706,
131:                   28897,
132:                   29085,
133:                   29268,
134:                   29446,
135:                   29621,
136:                   29790,
137:                   29955,
138:                   30116,
139:                   30272,
140:                   30424,
141:                   30571,
142:                   30713,
143:                   30851,
144:                   30984,
145:                   31113,
146:                   31236,
147:                   31356,
148:                   31470,
149:                   31580,
150:                   31684,
151:                   31785,
152:                   31880,
153:                   31970,
154:                   32056,
155:                   32137,
156:                   32213,
157:                   32284,
158:                   32350,
159:                   32412,
160:                   32468,
161:                   32520,
162:                   32567,
163:                   32609,
164:                   32646,
165:                   32678,
166:                   32705,
167:                   32727,
168:                   32744,
169:                   32757,
170:                   32764,
171:                   32767,
172:                   32764,
173:                   32757,
174:                   32744,
175:                   32727,
176:                   32705,
177:                   32678,
178:                   32646,
179:                   32609,
180:                   32567,
181:                   32520,
182:                   32468,
183:                   32412,
184:                   32350,
185:                   32284,
186:                   32213,
187:                   32137,
188:                   32056,
189:                   31970,
190:                   31880,
191:                   31785,
192:                   31684,
193:                   31580,
194:                   31470,
195:                   31356,
196:                   31236,
197:                   31113,
198:                   30984,
199:                   30851,
200:                   30713,
201:                   30571,
202:                   30424,
203:                   30272,
204:                   30116,
205:                   29955,
206:                   29790,
207:                   29621,
208:                   29446,
209:                   29268,
210:                   29085,
211:                   28897,
212:                   28706,
213:                   28510,
214:                   28309,
215:                   28105,
216:                   27896,
217:                   27683,
218:                   27466,
219:                   27244,
220:                   27019,
221:                   26789,
222:                   26556,
223:                   26318,
224:                   26077,
225:                   25831,
226:                   25582,
227:                   25329,
228:                   25072,
229:                   24811,
230:                   24546,
231:                   24278,
232:                   24006,
233:                   23731,
234:                   23452,
235:                   23169,
236:                   22883,
237:                   22594,
238:                   22301,
239:                   22004,
240:                   21705,
241:                   21402,
242:                   21096,
243:                   20787,
244:                   20474,
245:                   20159,
246:                   19840,
247:                   19519,
248:                   19194,
249:                   18867,
250:                   18537,
251:                   18204,
252:                   17868,
253:                   17530,
254:                   17189,
255:                   16845,
256:                   16499,
257:                   16150,
258:                   15799,
259:                   15446,
260:                   15090,
261:                   14732,
262:                   14372,
263:                   14009,
264:                   13645,
265:                   13278,
266:                   12909,
267:                   12539,
268:                   12166,
269:                   11792,
270:                   11416,
271:                   11038,
272:                   10659,
273:                   10278,
274:                   9895,
275:                   9511,
276:                   9126,
277:                   8739,
278:                   8351,
279:                   7961,
280:                   7571,
281:                   7179,
282:                   6786,
283:                   6392,
284:                   5997,
285:                   5601,
286:                   5205,
287:                   4807,
288:                   4409,
289:                   4011,
290:                   3611,
291:                   3211,
292:                   2811,
293:                   2410,
294:                   2009,
295:                   1607,
296:                   1206,
297:                   804,
298:                   402,
299:                   0,
300:                   -402,
301:                   -804,
302:                   -1206,
303:                   -1607,
304:                   -2009,
305:                   -2410,
306:                   -2811,
307:                   -3211,
308:                   -3611,
309:                   -4011,
310:                   -4409,
311:                   -4807,
312:                   -5205,
313:                   -5601,
314:                   -5997,
315:                   -6392,
316:                   -6786,
317:                   -7179,
318:                   -7571,
319:                   -7961,
320:                   -8351,
321:                   -8739,
322:                   -9126,
323:                   -9511,
324:                   -9895,
325:                   -10278,
326:                   -10659,
327:                   -11038,
328:                   -11416,
329:                   -11792,
330:                   -12166,
331:                   -12539,
332:                   -12909,
333:                   -13278,
334:                   -13645,
335:                   -14009,
336:                   -14372,
337:                   -14732,
338:                   -15090,
339:                   -15446,
340:                   -15799,
341:                   -16150,
342:                   -16499,
343:                   -16845,
344:                   -17189,
345:                   -17530,
346:                   -17868,
347:                   -18204,
348:                   -18537,
349:                   -18867,
350:                   -19194,
351:                   -19519,
352:                   -19840,
353:                   -20159,
354:                   -20474,
355:                   -20787,
356:                   -21096,
357:                   -21402,
358:                   -21705,
359:                   -22004,
360:                   -22301,
361:                   -22594,
362:                   -22883,
363:                   -23169,
364:                   -23452,
365:                   -23731,
366:                   -24006,
367:                   -24278,
368:                   -24546,
369:                   -24811,
370:                   -25072,
371:                   -25329,
372:                   -25582,
373:                   -25831,
374:                   -26077,
375:                   -26318,
376:                   -26556,
377:                   -26789,
378:                   -27019,
379:                   -27244,
380:                   -27466,
381:                   -27683,
382:                   -27896,
383:                   -28105,
384:                   -28309,
385:                   -28510,
386:                   -28706,
387:                   -28897,
388:                   -29085,
389:                   -29268,
390:                   -29446,
391:                   -29621,
392:                   -29790,
393:                   -29955,
394:                   -30116,
395:                   -30272,
396:                   -30424,
397:                   -30571,
398:                   -30713,
399:                   -30851,
400:                   -30984,
401:                   -31113,
402:                   -31236,
403:                   -31356,
404:                   -31470,
405:                   -31580,
406:                   -31684,
407:                   -31785,
408:                   -31880,
409:                   -31970,
410:                   -32056,
411:                   -32137,
412:                   -32213,
413:                   -32284,
414:                   -32350,
415:                   -32412,
416:                   -32468,
417:                   -32520,
418:                   -32567,
419:                   -32609,
420:                   -32646,
421:                   -32678,
422:                   -32705,
423:                   -32727,
424:                   -32744,
425:                   -32757,
426:                   -32764,
427:               };
428:               
429:               /* Bit reverse table for a single Byte.
430:                * Computed with:
431:                * awk 'BEGIN{for (i=0;i<256;i++) {o = 0; for (j=0;j<8;j++)
432:                *           {if(and(lshift(1,j), i)){o+= lshift(1, 7-j)}};
433:                *           printf("%d,", o);if(i%16==15){printf("\n")}else{printf(" ")}}}'
434:                */
435:               static const uint8_t kBitReverseTable256[] = {
436:                   0,
437:                   128,
438:                   64,
439:                   192,
440:                   32,
441:                   160,
442:                   96,
443:                   224,
444:                   16,
445:                   144,
446:                   80,
447:                   208,
448:                   48,
449:                   176,
450:                   112,
451:                   240,
452:                   8,
453:                   136,
454:                   72,
455:                   200,
456:                   40,
457:                   168,
458:                   104,
459:                   232,
460:                   24,
461:                   152,
462:                   88,
463:                   216,
464:                   56,
465:                   184,
466:                   120,
467:                   248,
468:                   4,
469:                   132,
470:                   68,
471:                   196,
472:                   36,
473:                   164,
474:                   100,
475:                   228,
476:                   20,
477:                   148,
478:                   84,
479:                   212,
480:                   52,
481:                   180,
482:                   116,
483:                   244,
484:                   12,
485:                   140,
486:                   76,
487:                   204,
488:                   44,
489:                   172,
490:                   108,
491:                   236,
492:                   28,
493:                   156,
494:                   92,
495:                   220,
496:                   60,
497:                   188,
498:                   124,
499:                   252,
500:                   2,
501:                   130,
502:                   66,
503:                   194,
504:                   34,
505:                   162,
506:                   98,
507:                   226,
508:                   18,
509:                   146,
510:                   82,
511:                   210,
512:                   50,
513:                   178,
514:                   114,
515:                   242,
516:                   10,
517:                   138,
518:                   74,
519:                   202,
520:                   42,
521:                   170,
522:                   106,
523:                   234,
524:                   26,
525:                   154,
526:                   90,
527:                   218,
528:                   58,
529:                   186,
530:                   122,
531:                   250,
532:                   6,
533:                   134,
534:                   70,
535:                   198,
536:                   38,
537:                   166,
538:                   102,
539:                   230,
540:                   22,
541:                   150,
542:                   86,
543:                   214,
544:                   54,
545:                   182,
546:                   118,
547:                   246,
548:                   14,
549:                   142,
550:                   78,
551:                   206,
552:                   46,
553:                   174,
554:                   110,
555:                   238,
556:                   30,
557:                   158,
558:                   94,
559:                   222,
560:                   62,
561:                   190,
562:                   126,
563:                   254,
564:                   1,
565:                   129,
566:                   65,
567:                   193,
568:                   33,
569:                   161,
570:                   97,
571:                   225,
572:                   17,
573:                   145,
574:                   81,
575:                   209,
576:                   49,
577:                   177,
578:                   113,
579:                   241,
580:                   9,
581:                   137,
582:                   73,
583:                   201,
584:                   41,
585:                   169,
586:                   105,
587:                   233,
588:                   25,
589:                   153,
590:                   89,
591:                   217,
592:                   57,
593:                   185,
594:                   121,
595:                   249,
596:                   5,
597:                   133,
598:                   69,
599:                   197,
600:                   37,
601:                   165,
602:                   101,
603:                   229,
604:                   21,
605:                   149,
606:                   85,
607:                   213,
608:                   53,
609:                   181,
610:                   117,
611:                   245,
612:                   13,
613:                   141,
614:                   77,
615:                   205,
616:                   45,
617:                   173,
618:                   109,
619:                   237,
620:                   29,
621:                   157,
622:                   93,
623:                   221,
624:                   61,
625:                   189,
626:                   125,
627:                   253,
628:                   3,
629:                   131,
630:                   67,
631:                   195,
632:                   35,
633:                   163,
634:                   99,
635:                   227,
636:                   19,
637:                   147,
638:                   83,
639:                   211,
640:                   51,
641:                   179,
642:                   115,
643:                   243,
644:                   11,
645:                   139,
646:                   75,
647:                   203,
648:                   43,
649:                   171,
650:                   107,
651:                   235,
652:                   27,
653:                   155,
654:                   91,
655:                   219,
656:                   59,
657:                   187,
658:                   123,
659:                   251,
660:                   7,
661:                   135,
662:                   71,
663:                   199,
664:                   39,
665:                   167,
666:                   103,
667:                   231,
668:                   23,
669:                   151,
670:                   87,
671:                   215,
672:                   55,
673:                   183,
674:                   119,
675:                   247,
676:                   15,
677:                   143,
678:                   79,
679:                   207,
680:                   47,
681:                   175,
682:                   111,
683:                   239,
684:                   31,
685:                   159,
686:                   95,
687:                   223,
688:                   63,
689:                   191,
690:                   127,
691:                   255,
692:               };
693:               
694:               /** Multiplication of 0.15 and 15.0 integers */
695:               static inline int16_t FIX_MULTIPLY(int16_t a, int16_t b)
696:               {
697:                   return (int16_t)((((int32_t)a * (int32_t)b) + 1) >> 15);
00004C  000920     NOP
000076  000920     NOP
0000E2  0007AE     NOP
0000E4  000920     NOP
0000E6  000920     NOP
0000E8  00092A     NOP
000118  000920     NOP
698:               }
699:               
700:               /* Complex 256-bin FFT. real/complex values are interleaved in samples */
701:               static int32_t FFT_256(int16_t *samples)
00000C  000BB6     NOP
00004C  000920     NOP
000076  000920     NOP
000084  000920     NOP
0000CA  0008B2     NOP
000158  000920     NOP
00015A  000920     NOP
702:               {
000000  040200     GOTO __resetPRI, __reset
703:                   const int32_t kNumSamples = 256;
704:                   int32_t sample_index;
705:                   int32_t sub_fft_length;
706:                   int32_t sine_table_log_step;
707:                   int32_t total_right_shift = 0;
708:               
709:                   /* Bit-reversal of elements in sample array */
710:                   for (sample_index = 1; sample_index < kNumSamples; sample_index++)
000012  00091A     NOP
000030  000920     NOP
711:                   {
712:                       int32_t reverse_index = (int32_t)kBitReverseTable256[sample_index];
00001A  000920     NOP
713:                       int32_t *complex_samples = (int32_t *)samples;
714:                       int32_t temp_value;
715:               
716:                       if (reverse_index <= sample_index)
00001E  000920     NOP
717:                           continue;
718:               
719:                       temp_value = complex_samples[sample_index];
000024  000920     NOP
720:                       complex_samples[sample_index] = complex_samples[reverse_index];
000026  000920     NOP
721:                       complex_samples[reverse_index] = temp_value;
00002E  000920     NOP
722:                   }
723:               
724:                   sub_fft_length = 1;
725:                   /* sine_table_log_step is LOG2_N_WAVE - sub_fft_log_length */
726:                   sine_table_log_step = LOG2_N_WAVE - 1;
727:                   while (sub_fft_length < kNumSamples)
00018C  000920     NOP
728:                   {
729:                       total_right_shift += 1; /* Always do a right-shift */
730:               
731:                       int32_t sample_step = sub_fft_length << 1;
00005C  000920     NOP
732:                       int32_t start_pos;
733:                       for (start_pos = 0; start_pos < sub_fft_length; start_pos++)
000068  000920     NOP
00007E  000920     NOP
000166  000920     NOP
000168  000920     NOP
00016A  000920     NOP
00016C  000920     NOP
734:                       {
735:                           int32_t i;
736:                           /* phase_index maps from 0..pi to 0..N_WAVE */
737:                           int32_t phase_index = start_pos << sine_table_log_step;
000090  000920     NOP
738:                           int16_t weight_real = kSine512[phase_index + N_WAVE / 4];
0000AA  000920     NOP
739:                           int16_t weight_imag = -kSine512[phase_index];
0000B6  000920     NOP
740:               
741:                           for (i = start_pos; i < kNumSamples; i += sample_step)
0000BC  000920     NOP
00015C  000920     NOP
00015E  000920     NOP
000160  000920     NOP
000162  000920     NOP
742:                           {
743:                               int32_t s_index = i + sub_fft_length;
744:               
745:                               int16_t q_real = samples[2 * i] >> 1;
0000D6  000920     NOP
746:                               int16_t q_imag = samples[2 * i + 1] >> 1;
0000D8  000920     NOP
747:                               int16_t s_real = samples[2 * s_index] >> 1;
0000DC  000920     NOP
0000DE  000746     NOP
0000E0  00077A     NOP
0000E2  0007AE     NOP
748:                               int16_t s_imag = samples[2 * s_index + 1] >> 1;
0000DE  000746     NOP
749:               
750:                               int16_t t_real = FIX_MULTIPLY(weight_real, s_real) -
000112  000920     NOP
751:                                                FIX_MULTIPLY(weight_imag, s_imag);
752:                               int16_t t_imag = FIX_MULTIPLY(weight_real, s_imag) +
00013C  000920     NOP
753:                                                FIX_MULTIPLY(weight_imag, s_real);
754:                               samples[2 * s_index] = q_real - t_real;
000140  000920     NOP
755:                               samples[2 * s_index + 1] = q_imag - t_imag;
000142  000920     NOP
756:                               samples[2 * i] = q_real + t_real;
000146  000920     NOP
000148  000920     NOP
00014A  000920     NOP
00014C  000920     NOP
757:                               samples[2 * i + 1] = q_imag + t_imag;
000148  000920     NOP
758:                           }
759:                       }
760:                       sine_table_log_step--;
00019A  000920     NOP
761:                       sub_fft_length <<= 1;
0001A2  FFFFFF     NOPR
0001A4  FFFFFF     NOPR
0001A6  FFFFFF     NOPR
0001A8  FFFFFF     NOPR
0001AA  FFFFFF     NOPR
762:                   }
763:               
764:                   return total_right_shift;
765:               }
0001AC  FFFFFF     NOPR
766:               
767:               int32_t FFTR_512(int16_t *samples)
00001C  000920     NOP
768:               {
000000  040200     GOTO __resetPRI, __reset
769:                   const int32_t kComplexFFTLength = 256;
770:                   int32_t k;
771:                   int32_t total_right_shift;
772:               
773:                   total_right_shift = FFT_256(samples);
00000C  000BB6     NOP
774:                   total_right_shift++; /* Always do a right-shift */
000010  000B66     NOP
775:               
776:                   /* Final butterfly pass, ignoring bin 0 and bin 256 (which does not exist) */
777:                   for (k = 1; k < kComplexFFTLength / 2; k++)
000028  000920     NOP
0000A0  000920     NOP
778:                   {
779:                       /* Assumes kLogNumSamples == LOG2_N_WAVE */
780:                       int16_t weight_real = kSine512[k + N_WAVE / 4 + N_WAVE / 4];
000032  000920     NOP
781:                       int16_t weight_imag = -kSine512[k + N_WAVE / 4];
000038  000920     NOP
782:               
783:                       int16_t q_real = samples[2 * k] >> 1;
00003A  000920     NOP
784:                       int16_t q_imag = samples[2 * k + 1] >> 1;
00003C  000920     NOP
785:                       int16_t s_real = samples[2 * (kComplexFFTLength - k)] >> 1;
00003E  000920     NOP
786:                       int16_t s_imag = -samples[2 * (kComplexFFTLength - k) + 1] >> 1;
000040  000920     NOP
787:               
788:                       int16_t f1_real = q_real + s_real;
000044  000C16     NOP
789:                       int16_t f1_imag = q_imag + s_imag;
000046  000920     NOP
790:                       int16_t f2_real = q_real - s_real;
000048  000920     NOP
791:                       int16_t f2_imag = q_imag - s_imag;
00004A  000920     NOP
792:                       int16_t t_real = FIX_MULTIPLY(weight_real, f2_real) -
000070  000920     NOP
793:                                        FIX_MULTIPLY(weight_imag, f2_imag);
794:                       int16_t t_imag = FIX_MULTIPLY(weight_real, f2_imag) +
000094  000920     NOP
795:                                        FIX_MULTIPLY(weight_imag, f2_real);
796:               
797:                       samples[2 * k] = f1_real + t_real;
000098  000920     NOP
798:                       samples[2 * k + 1] = f1_imag + t_imag;
00009A  000920     NOP
799:                       samples[2 * (kComplexFFTLength - k)] = f1_real - t_real;
00009C  000920     NOP
800:                       samples[2 * (kComplexFFTLength - k) + 1] = t_imag - f1_imag;
00009E  000920     NOP
801:                   }
802:               
803:                   return total_right_shift;
804:               }
0000BE  000920     NOP
0000C0  000920     NOP
0000CE  000920     NOP
0000D0  000920     NOP
805:               
806:               int32_t FFTR_GetRomSize(void)
807:               {
808:                   return (int32_t)(sizeof(kSine512) + sizeof(kBitReverseTable256));
809:               }
000000  040200     GOTO __resetPRI, __reset
000006  000B2E     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/dsp_lsup_distance.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kb_opt.h"
26:                
27:                /**
28:                 * @brief LSUP Distance Calculation for uint8_t vectors
29:                 *
30:                 * @param[in]       *pSrcA points to the first input vector
31:                 * @param[in]       *pSrcB points to the second input vector
32:                 * @param[out]      *pDst points to an array that can hold the distances computed
33:                 * @param[out]      *pDist points to the
34:                 * @param[in]       blockSize number of samples in each vector
35:                 * @return none.
36:                 *
37:                 * <b>Scaling and Overflow Behavior:</b>
38:                 * \par
39:                 * The function uses saturating arithmetic.
40:                 * Results outside of the allowable Q7 range [0x80 0x7F] will be saturated.
41:                 */
42:                
43:                void lsup_distance(
44:                    uint8_t *pSrcA,
45:                    uint8_t *pSrcB,
46:                    uint8_t *pDist,
47:                    uint8_t *pMaxDist,
48:                    uint32_t blockSize)
49:                {
000000  040200     GOTO __resetPRI, __reset
50:                    uint32_t blkCnt; /* loop counter */
51:                
52:                    /* Run the below code for Cortex-M4 and Cortex-M3 */
53:                
54:                    /*loop Unrolling */
55:                    blkCnt = blockSize;
00001A  000920     NOP
56:                
57:                    /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
58:                   ** a second loop below computes the remaining 1 to 3 samples. */
59:                    while (blkCnt > 0u)
000012  00091A     NOP
00001E  000920     NOP
000036  000920     NOP
60:                    {
61:                        /* C = |A - B| */
62:                        /* Absolute Difference. */
63:                        *pDist++ = (uint8_t)bitwise_absolute_value(*pSrcA++ - *pSrcB++);
000020  000920     NOP
64:                
65:                        /* Decrement the loop counter */
66:                        blkCnt--;
00002A  000C36     NOP
67:                    }
68:                
69:                    array_max_uint8(pDist - blockSize, blockSize, pMaxDist);
00003E  000920     NOP
70:                }
000046  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/dsp_l1_distance.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kb_opt.h"
26:                
27:                /**
28:                 * @brief L1 Distance Calculation for uint8_t vectors
29:                 *
30:                 * @param[in]       *pSrcA points to the first input vector
31:                 * @param[in]       *pSrcB points to the second input vector
32:                 * @param[out]      *pDst points to output distance
33:                 * @param[in]       blockSize number of samples in each vector
34:                 * @return none.
35:                 *
36:                 * <b>Scaling and Overflow Behavior:</b>
37:                 * \par
38:                 * The function uses saturating arithmetic.
39:                 * Results outside of the allowable Q7 range [0x80 0x7F] will be saturated.
40:                 */
41:                
42:                void l1_distance(
43:                    uint8_t *pSrcA,
44:                    uint8_t *pSrcB,
45:                    uint32_t *pDist,
46:                    uint32_t blockSize)
47:                {
000000  040200     GOTO __resetPRI, __reset
48:                    uint32_t blkCnt; /* loop counter */
49:                    uint32_t sum = 0;
00000C  000BB6     NOP
000018  000920     NOP
50:                
51:                #ifdef OPT_ARM_M4_DSP
52:                
53:                    /* Run the below code for Cortex-M4 and Cortex-M3 */
54:                
55:                    /*loop Unrolling */
56:                    blkCnt = blockSize >> 2u;
57:                
58:                    /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
59:                   ** a second loop below computes the remaining 1 to 3 samples. */
60:                    while (blkCnt > 0u)
61:                    {
62:                        /* C = A - B */
63:                        /* Subtract and then store the results in the destination buffer 4 samples at a time. */
64:                        sum = __USADA8(*__SIMD32(pSrcA)++, *__SIMD32(pSrcB)++, sum);
65:                
66:                        /* Decrement the loop counter */
67:                        blkCnt--;
68:                    }
69:                
70:                    /* If the blockSize is not a multiple of 4, compute any remaining output samples here.
71:                   ** No loop unrolling is used. */
72:                    blkCnt = blockSize % 0x4u;
73:                
74:                    while (blkCnt > 0u)
75:                    {
76:                        /* C = A - B */
77:                        /* Subtract and then store the result in the destination buffer. */
78:                        sum += bitwise_absolute_value(*pSrcA++ - *pSrcB++);
79:                
80:                        /* Decrement the loop counter */
81:                        blkCnt--;
82:                    }
83:                
84:                #else
85:                
86:                    /* Run the below code for Cortex-M0 */
87:                
88:                    /* Initialize blkCnt with number of samples */
89:                    blkCnt = blockSize;
000016  000920     NOP
90:                
91:                    while (blkCnt > 0u)
00000E  000920     NOP
00002A  000C36     NOP
92:                    {
93:                        /* C = A - B */
94:                        /* Subtract and then store the result in the destination buffer. */
95:                        sum += bitwise_absolute_value(*pSrcA++ - *pSrcB++);
00001A  000920     NOP
96:                
97:                        /* Decrement the loop counter */
98:                        blkCnt--;
000026  000920     NOP
99:                    }
100:               
101:               #endif /* #ifndef ARM_MATH_CM0_FAMILY */
102:               
103:                   *pDist = sum;
00002C  000920     NOP
104:               }
00002E  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/dsp_dtw_distance.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kb_opt.h"
26:                
27:                //FILL_ENABLE_DTW_DISTANCE
28:                #ifdef ENABLE_DTW_DISTANCE
29:                
30:                //FILL_MAX_WARP_LENGTH
31:                #ifndef MAX_WARP_LENGTH
32:                #define MAX_WARP_LENGTH 2048
33:                #endif
34:                
35:                int32_t globdist[MAX_WARP_LENGTH][MAX_WARP_LENGTH];
36:                int32_t Dist[MAX_WARP_LENGTH][MAX_WARP_LENGTH];
37:                
38:                unsigned short move[MAX_WARP_LENGTH][MAX_WARP_LENGTH];
39:                unsigned short warp[2 * MAX_WARP_LENGTH][2];
40:                unsigned short temp[2 * MAX_WARP_LENGTH][2];
41:                
42:                #define DTW_DEBUG 0
43:                
44:                int32_t get_distance_matrix_value(int32_t i, int32_t j)
45:                {
46:                    return Dist[i][j];
47:                }
48:                
49:                int32_t get_globdist(int32_t i, int32_t j)
50:                {
51:                    return globdist[i][j];
52:                }
53:                
54:                void compute_distance_matrix(unsigned char *x, unsigned char *y, int32_t x_size, int32_t y_size, uint8_t num_channels)
55:                {
56:                    /*Compute distance matrix*/
57:                    int32_t i;
58:                    int32_t j;
59:                    int32_t k;
60:                    int32_t channel_i_delta = 0;
61:                    int32_t channel_j_delta = 0;
62:                    int32_t total;
63:                
64:                #if DTW_DEBUG
65:                    printf("\nx = [");
66:                    for (i = 0; i < x_size * num_channels; i++)
67:                    {
68:                        printf("%d, ", x[i]);
69:                    }
70:                    printf("]\ny = [");
71:                    for (i = 0; i < y_size * num_channels; i++)
72:                    {
73:                        printf("%d, ", y[i]);
74:                    }
75:                    printf("]\n");
76:                #endif
77:                    if (num_channels > 1)
78:                    {
79:                        for (i = 0; i < x_size; i++)
80:                        {
81:                            channel_i_delta = num_channels * i;
82:                            for (j = 0; j < y_size; j++)
83:                            {
84:                                channel_j_delta = num_channels * j;
85:                                total = 0;
86:                                for (k = 0; k < num_channels; k++)
87:                                {
88:                                    total = total + ((x[channel_i_delta + k] - y[channel_j_delta + k]) * (x[channel_i_delta + k] - y[channel_j_delta + k]));
89:                                }
90:                                Dist[i][j] = total;
91:                
92:                #if DTW_DEBUG
93:                                printf("Dist: %d %d %d\n", i, j, Dist[i][j]);
94:                #endif
95:                            }
96:                        }
97:                    }
98:                    else
99:                    {
100:                       for (i = 0; i < x_size; i++)
101:                       {
102:                           for (j = 0; j < y_size; j++)
103:                           {
104:               
105:                               Dist[i][j] = ((x[i] - y[j]) * (x[i] - y[j]));
106:               
107:               #if DTW_DEBUG
108:                               printf("Dist: %d %d %d\n", i, j, Dist[i][j]);
109:               #endif
110:                           }
111:                       }
112:                   }
113:               }
114:               
115:               int32_t compute_warping_distance(int32_t x_size, int32_t y_size)
116:               {
117:                   int32_t i, j;
118:               
119:                   int32_t top, mid, bot, cheapest;
120:                   /*% for first frame, only possible match is at (0,0)*/
121:               
122:                   int32_t warping_distance = Dist[x_size - 1][y_size - 1];
123:               
124:                   globdist[0][0] = Dist[0][0];
125:               
126:                   for (i = 1; i < x_size; i++)
127:                   {
128:                       globdist[i][0] = globdist[i - 1][0] + Dist[i][0];
129:                   }
130:               
131:                   for (j = 1; j < y_size; j++)
132:                   {
133:                       globdist[0][j] = globdist[0][j - 1] + Dist[0][j];
134:                   }
135:               
136:                   for (i = 1; i < x_size; i++)
137:                   {
138:                       for (j = 1; j < y_size; j++)
139:                       {
140:                           top = globdist[i - 1][j];     //Vert
141:                           mid = globdist[i - 1][j - 1]; //diag
142:                           bot = globdist[i][j - 1];     //Horiz
143:               
144:                           if ((top < mid) && (top < bot) && top != mid)
145:                           {
146:                               cheapest = top;
147:                           }
148:                           else if (mid <= bot)
149:                           {
150:                               cheapest = mid;
151:                           }
152:                           else
153:                           {
154:                               cheapest = bot;
155:                           }
156:               
157:                           globdist[i][j] = cheapest + Dist[i][j];
158:                       }
159:                   }
160:               
161:                   i = x_size - 1;
162:                   j = y_size - 1;
163:                   while (i > 0 || j > 0)
164:                   {
165:                       if (i == 0)
166:                           j--;
167:                       else if (j == 0)
168:                           i--;
169:                       else
170:                       {
171:                           top = globdist[i - 1][j];     //Vert
172:                           mid = globdist[i - 1][j - 1]; //diag
173:                           bot = globdist[i][j - 1];     //Horiz
174:               
175:                           if ((top < mid) && (top < bot) && top != mid)
176:                           {
177:                               i--;
178:                           }
179:                           else if (mid <= bot)
180:                           {
181:                               j--;
182:                               i--;
183:                           }
184:                           else
185:                           {
186:                               j--;
187:                           }
188:                       }
189:               
190:                       warping_distance += Dist[i][j];
191:               
192:               #if DTW_DEBUG
193:                       printf("[%d][%d] = %d\n", i, j, warping_distance);
194:               #endif
195:                   }
196:               
197:                   if (warping_distance > USHRT_MAX)
198:                   {
199:                       return USHRT_MAX;
200:                   }
201:               
202:                   return warping_distance;
203:               }
204:               #else
205:               
206:               void compute_distance_matrix(unsigned char *x, unsigned char *y, int32_t x_size, int32_t y_size, uint8_t num_channels) {}
207:               int32_t compute_warping_distance(int32_t x_size, int32_t y_size)
208:               {
209:                   return 0;
210:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
211:               int32_t get_distance_matrix_value(int32_t i, int32_t j)
212:               {
213:                   return 0;
214:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
215:               
216:               int32_t get_globdist(int32_t i, int32_t j)
217:               {
218:                   return 0;
219:               }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
220:               #endif //USW_PME_DTW
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/crossing_rate.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                /*
27:                 * crossing_rate
28:                 *    Original version in KB transcode
29:                 */
30:                FLOAT crossing_rate(ringb *rb, int32_t base_index, int32_t num_rows, FLOAT threshold)
31:                {
000000  040200     GOTO __resetPRI, __reset
32:                	int32_t ncrossings;
33:                	int32_t int_threshold;
34:                
35:                	int_threshold = (int32_t) threshold;
00000E  000920     NOP
36:                	ncrossings = utils_model_crossing_rate(rb, base_index, num_rows, int_threshold, 0, CROSSING_RATE);
000012  00091A     NOP
37:                	
38:                	float f = (FLOAT)ncrossings / num_rows;
00002C  000920     NOP
39:                
40:                	if (!num_rows)
000022  000BF6     NOP
000026  000920     NOP
41:                		return 0.0f;
000024  000920     NOP
42:                	else
43:                		return f;
44:                }
00003C  000920     NOP
45:                
46:                /*
47:                 * crossing_rate_over_zero
48:                 *    Added for zero crossing optimization
49:                 */
50:                FLOAT crossing_rate_over_zero(ringb *rb, int32_t base_index, int32_t num_rows)
51:                {
000000  040200     GOTO __resetPRI, __reset
52:                	// return right away if num_rows is 0
53:                	if (!num_rows)
00000A  000BD2     NOP
54:                	{
55:                		// should print out error: unexpected num_rows = 0 here!
56:                
57:                		return 0.0f;
000008  000B4A     NOP
00000A  000BD2     NOP
58:                	}
59:                	int32_t ncrossings = utils_model_crossing_rate(rb, base_index, num_rows, 0, 0, CROSSING_RATE_OVER_ZERO);
000010  000B66     NOP
60:                
61:                	return ((FLOAT)ncrossings / num_rows);
00001C  000920     NOP
62:                }
00002C  000920     NOP
000032  000920     NOP
63:                
64:                /*
65:                 * crossing_rate_over_sum
66:                 *    Added for mean crossing optimization
67:                 */
68:                FLOAT crossing_rate_over_sum(ringb *rb, int32_t base_index, int32_t num_rows, int32_t sum)
69:                {
000000  040200     GOTO __resetPRI, __reset
70:                #if SML_DEBUG
71:                	// return right away if num_rows is 0
72:                	if (!num_rows)
73:                	{
74:                		// should print out error: unexpected num_rows = 0 here!
75:                		return 0.0f;
76:                	}
77:                #endif //SML_DEBUG
78:                
79:                	int32_t ncrossings = utils_model_crossing_rate(rb, base_index, num_rows, sum, 0, CROSSING_RATE_OVER_SUM);
000006  000B2E     NOP
00001C  000920     NOP
80:                
81:                	return ((FLOAT)ncrossings) / num_rows;
00000E  000920     NOP
82:                }
00001E  000920     NOP
000024  000920     NOP
83:                
84:                int32_t number_of_crossings_over_threshold(ringb *rb, int32_t base_index, int32_t num_rows, int32_t threshold)
85:                {
86:                	return utils_model_crossing_rate(rb, base_index, num_rows, threshold, 0, NUMBER_OF_CROSSINGS_OVER_THRESHOLD);
000000  040200     GOTO __resetPRI, __reset
87:                }
00000A  000BD2     NOP
00000C  000BB6     NOP
88:                
89:                int32_t number_of_positive_crossings_over_threshold(ringb *rb, int32_t base_index, int32_t num_rows, int32_t threshold)
90:                {
91:                	return utils_model_crossing_rate(rb, base_index, num_rows, threshold, 0, NUMBER_OF_POSITIVE_CROSSINGS_OVER_THRESHOLD);
000000  040200     GOTO __resetPRI, __reset
92:                }
00000A  000BD2     NOP
00000C  000BB6     NOP
93:                
94:                int32_t number_of_negative_crossings_over_threshold(ringb *rb, int32_t base_index, int32_t num_rows, int32_t threshold)
95:                {
96:                	return utils_model_crossing_rate(rb, base_index, num_rows, threshold, 0, NUMBER_OF_NEGATIVE_CROSSINGS_OVER_THRESHOLD);
000000  040200     GOTO __resetPRI, __reset
97:                }
00000A  000BD2     NOP
00000C  000BB6     NOP
98:                
99:                int32_t number_of_crossings_over_threshold_regions(ringb *rb, int32_t base_index, int32_t num_rows, int32_t positive_threshold, int32_t negative_threshold)
100:               {
000000  040200     GOTO __resetPRI, __reset
101:               	return utils_model_crossing_rate(rb, base_index, num_rows, positive_threshold, negative_threshold, NUMBER_OF_CROSSINGS_OVER_THRESHOLD_REGIONS);
000004  000B9A     NOP
102:               }
000010  000B66     NOP
000016  000920     NOP
103:               
104:               int32_t number_of_positive_crossings_over_threshold_regions(ringb *rb, int32_t base_index, int32_t num_rows, int32_t positive_threshold, int32_t negative_threshold)
105:               {
000000  040200     GOTO __resetPRI, __reset
106:               	return utils_model_crossing_rate(rb, base_index, num_rows, positive_threshold, negative_threshold, NUMBER_OF_POSITIVE_CROSSINGS_OVER_THRESHOLD_REGIONS);
000004  000B9A     NOP
107:               }
000010  000B66     NOP
000016  000920     NOP
108:               
109:               int32_t number_of_negative_crossings_over_threshold_regions(ringb *rb, int32_t base_index, int32_t num_rows, int32_t positive_threshold, int32_t negative_threshold)
110:               {
000000  040200     GOTO __resetPRI, __reset
111:               	return utils_model_crossing_rate(rb, base_index, num_rows, positive_threshold, negative_threshold, NUMBER_OF_NEGATIVE_CROSSINGS_OVER_THRESHOLD_REGIONS);
000004  000B9A     NOP
112:               }
000010  000B66     NOP
000016  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/column_to_row_complex.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                void column_to_row_complex(ringb *pringb, int32_t col, int32_t nrows, struct compx *cmpxData, int32_t complen)
28:                {
000000  040200     GOTO __resetPRI, __reset
29:                	int32_t irow;
30:                	int32_t base_index = 0; // REPLACE THIS WHNE THE FUNCTION IS UPDATED
31:                	ringb *rb;
32:                
33:                	if (nrows > complen)
34:                		nrows = complen;
35:                
36:                	rb = pringb + col;
00001C  000920     NOP
37:                
38:                	for (irow = 0; irow < nrows; irow++) // For each value in the row
00000E  000920     NOP
000020  000920     NOP
000048  000920     NOP
39:                	{
40:                		cmpxData[irow].real = (FLOAT)MOD_READ_RINGBUF(rb, base_index++); // Copy sensor data to real part
000030  000920     NOP
41:                		cmpxData[irow].imag = 0.0f;
000042  000920     NOP
000044  000C16     NOP
42:                	}
43:                
44:                	for (; irow < complen; irow++)
000058  000920     NOP
00006A  000920     NOP
45:                	{
46:                		cmpxData[irow].real = 0.0f;
00005E  000920     NOP
47:                		cmpxData[irow].imag = 0.0f;
000066  000920     NOP
48:                	}
49:                }
000076  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/calc_area.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "rb.h"
26:                #include "kbutils.h"
27:                
28:                #define MIN(x, y) (x < y ? x : y)
29:                
30:                /*
31:                * calc_area - compute various areas of a waveform
32:                *
33:                * Inputs
34:                *       col - which column to analyze
35:                *		nrows - number of rows in the array
36:                *       sample_rate - samples/sec.
37:                *		smoothing factor (how many data points on either side of a sample to use to compute the mean.)
38:                *		mode - conversion to perform on raw data values before the operation is performed
39:                *			 0 = raw data
40:                *			 1 = Low frequency
41:                *			 2 = high frequency
42:                *		op - operation to perform on converted data
43:                *
44:                * Output : FLOAT resultant value.
45:                *
46:                * The moving average for the signal is computed by starting with the average of
47:                * the first sample, over 'smoothing_factor' samples on either side of the sample.
48:                * The samples to the left of the first sample are assumed to be identical to the
49:                * first sample. Likewise, for samples to the right of the last sample.
50:                * Once this is done the average for each successive sample is computed as follows:
51:                * Sum = Sum - 1st sample in the last sum + sample following the last summed value
52:                * Avg = Sum/(smoothing factor + 1)
53:                * This is repeated for each sample.
54:                * This method avoids creating temporary arrays to hold the intermediate averages.
55:                */
56:                FLOAT calc_area(ringb *pringb, int32_t col, int32_t nrows, FLOAT sample_rate, int32_t smoothing_factor, int32_t mode, int32_t op)
000060  000920     NOP
57:                {
000000  040200     GOTO __resetPRI, __reset
58:                	int32_t irow;
59:                	FLOAT dsum = 0.0, asum = 0.0;
00000E  000920     NOP
60:                	FLOAT darea = 0.0;
61:                	FLOAT davg = 0.0;
62:                	FLOAT dval = 0.0;	// Data value
63:                	int32_t base_index = 0; // REPLACE THIS WITH AN INPUT WHEN THIS FUNCTION IS READY
64:                	ringb *rb;
65:                	int32_t start_index;
66:                
67:                	// Process the samples
68:                	for (irow = 0; irow < nrows; irow++)
000010  000B66     NOP
000022  000BF6     NOP
000024  000920     NOP
000026  000920     NOP
00013E  000920     NOP
69:                	{
70:                		int32_t icnt;
71:                
72:                		asum = 0.0;
000050  000920     NOP
73:                		rb = pringb + col;
000016  000920     NOP
74:                		start_index = (base_index + irow ) & rb->mask;
00001A  000920     NOP
000028  000920     NOP
000038  000920     NOP
00005C  000920     NOP
75:                		for (icnt = 0; icnt < smoothing_factor; icnt++)
000052  000920     NOP
00005E  000920     NOP
000086  000920     NOP
76:                		{
77:                			if (icnt + irow < nrows)
000068  000920     NOP
78:                				asum += (FLOAT)rb->buff[start_index];
000072  000920     NOP
79:                			start_index = ( start_index + 1 ) & rb->mask;
000094  000920     NOP
000096  000920     NOP
80:                		}
81:                		davg = asum / MIN(smoothing_factor, nrows - irow);
0000AA  000920     NOP
82:                		start_index = (base_index + irow ) & rb->mask;
83:                		dval = (FLOAT)rb->buff[start_index];
0000CE  000920     NOP
0000E6  000920     NOP
84:                
85:                		if (mode == MOD_HF) // Use high-frequency components
0000D8  000920     NOP
86:                		{
87:                			dval -= davg; // Subtract the mean to get the high freq components.
0000EA  000920     NOP
88:                		}
89:                		else
90:                		{
91:                			dval = davg; // Use the mean for the low freq components.
92:                		}
93:                
94:                		// Perform the operation on the remaining 'modified' samples
95:                		if (op == OP_ABS_SUM)
0000F0  000920     NOP
96:                			dsum += dval / sample_rate;
0000FA  000920     NOP
0000FC  000920     NOP
97:                		else if (op == OP_SUM_ABS)
000030  000920     NOP
000110  000920     NOP
98:                			dsum += (dval < 0 ? -dval : dval) / sample_rate;
00011E  000920     NOP
000120  000920     NOP
99:                	}
100:               	darea = dsum;
101:               	if (op == OP_ABS_SUM)
000164  000920     NOP
00017E  000920     NOP
102:               	{
103:               		if (dsum < 0.0)
00016E  000920     NOP
000182  000920     NOP
104:               			darea = -dsum;
000178  000920     NOP
105:               	}
106:               	return darea;
107:               }
000184  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/mplabml/src/array_contains.c
1:                 
2:                 /*******************************************************************************
3:                 * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries.
4:                 *
5:                 * Subject to your compliance with these terms, you may use Microchip software
6:                 * and any derivatives exclusively with Microchip products. It is your
7:                 * responsibility to comply with third party license terms applicable to your
8:                 * use of third party software (including open source software) that may
9:                 * accompany Microchip software.
10:                *
11:                * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                * PARTICULAR PURPOSE.
15:                *
16:                * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                 *******************************************************************************/
24:                
25:                #include "kbutils.h"
26:                
27:                //              array_contains.c
28:                //
29:                //
30:                //
31:                
32:                bool selection_contains(int32_t feature, int32_t num_feature_selection,
33:                                        int32_t *feature_selection)
34:                //
35:                // Given a feature number, return [is this feature in the list?]
36:                // If the list is NULL, then return true.
37:                //
38:                {
39:                    int32_t i;
40:                
41:                    if (num_feature_selection == 0)
000002  000000     NOP
42:                        return true;
000000  040200     GOTO __resetPRI, __reset
43:                
44:                    for (i = num_feature_selection; i > 0; i--)
00000A  000BD2     NOP
000022  000BF6     NOP
45:                    {
46:                        if (*feature_selection++ == feature)
000012  00091A     NOP
47:                        {
48:                            return true;
000010  000B66     NOP
00002E  000920     NOP
49:                        }
50:                    }
51:                
52:                    return false;
000008  000B4A     NOP
00002A  000C36     NOP
53:                }
000030  000920     NOP
54:                
55:                int32_t selection_index(int32_t feature, int32_t num_feature_selection,
56:                                    int32_t *feature_selection)
57:                //
58:                // Given a feature number, return the correct bin index.
59:                // In other words, translate a selected feature back into the correct bin index.
60:                // If the feature is not found, return -1.
61:                //
62:                //
63:                {
000000  040200     GOTO __resetPRI, __reset
64:                    int32_t i;
65:                
66:                    for (i = 0; i < num_feature_selection; i++)
000006  000B2E     NOP
000014  000920     NOP
000020  000920     NOP
67:                    {
68:                        if (*feature_selection++ == feature)
00000E  000920     NOP
000010  000B66     NOP
000018  000920     NOP
69:                        {
70:                            return i;
71:                        }
72:                    }
73:                
74:                    return -1;
000002  000000     NOP
00002A  000C36     NOP
75:                }
00002E  000920     NOP
000030  000920     NOP
000034  000920     NOP
76:                
77:                //
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/application/sml_recognition_run.c
1:                 #include "../mplabml/inc/kb.h"
2:                 #include "sml_output.h"
3:                 #include "sml_recognition_run.h"
4:                 
5:                 //FILL_USE_TEST_DATA
6:                 
7:                 #ifdef SML_USE_TEST_DATA
8:                 #include "testdata.h"
9:                 int32_t td_index = 0;
10:                #endif //SML_USE_TEST_DATA
11:                
12:                
13:                int32_t sml_recognition_run(signed short *data_batch, int32_t batch_sz, uint8_t num_sensors, uint32_t sensor_id)
14:                {
000000  040200     GOTO __resetPRI, __reset
15:                	int32_t ret;
16:                
17:                	int32_t batch_index = 0;
18:                	signed short* data;
19:                	for(batch_index=0; batch_index < batch_sz; batch_index++)
00000E  000920     NOP
00001C  000920     NOP
00003C  000920     NOP
20:                	{
21:                	#ifdef SML_USE_TEST_DATA
22:                	ret = kb_run_model((SENSOR_DATA_T*)&testdata[td_index++], TD_NUMCOLS, 0);
23:                	if(td_index >= TD_NUMROWS)
24:                	{
25:                		td_index = 0;
26:                	}
27:                	if(ret >= 0)
28:                	{
29:                		sml_output_results(0, ret);
30:                		kb_reset_model(0);
31:                	}
32:                	#else
33:                	data = &data_batch[batch_index*num_sensors];
000014  000920     NOP
34:                	//FILL_RUN_MODEL_MOTION
35:                	//FILL_RUN_MODEL_AUDIO
36:                	//FILL_RUN_MODEL_CUSTOM
37:                       ret = kb_run_model((SENSOR_DATA_T *)data, num_sensors, KB_MODEL_PIPELINE_1_RANK_0_INDEX);
000022  000BF6     NOP
38:                	   if (ret >= 0){
000032  000920     NOP
39:                			//sml_output_results(KB_MODEL_PIPELINE_1_RANK_0_INDEX, ret);
40:                			kb_reset_model(0);
000038  000920     NOP
41:                		};
42:                	#endif //SML_USE_TEST_DATA
43:                  
44:                	}
45:                    
46:                	return ret;
47:                }
00005A  000920     NOP
---  D:/ML/DSPIC/bitbucket_SLMAD/anomaly-detection-ml-33ck256mp508-lvmc.X/knowledgepack/application/sml_output.c
1:                 #include "sml_output.h"
2:                 #include "../mplabml/inc/kb.h"
3:                 
4:                 #define SERIAL_OUT_CHARS_MAX 512
5:                 
6:                 #ifdef __GNUC__
7:                 #pragma GCC diagnostic ignored "-Wunused-function"
8:                 #endif
9:                 
10:                
11:                static char serial_out_buf[SERIAL_OUT_CHARS_MAX];
12:                static uint8_t recent_fv[MAX_VECTOR_SIZE];
13:                static uint8_t recent_fv_len;
14:                static uint8_t write_features = 0;
15:                
16:                static void sml_output_serial(uint16_t model, uint16_t classification)
17:                {
000000  040200     GOTO __resetPRI, __reset
18:                    int32_t written = 0;
19:                    int32_t j=0;
20:                    memset(serial_out_buf, 0, SERIAL_OUT_CHARS_MAX);
000002  000000     NOP
21:                    written += snprintf(serial_out_buf, sizeof(serial_out_buf)-1,
00000A  000BD2     NOP
22:                               "{\"ModelNumber\":%d,\"Classification\":%d", model, classification);
23:                    if(write_features)
24:                    {
25:                        written += snprintf(serial_out_buf, sizeof(serial_out_buf)-written,
26:                               ",\"FeatureLength\":%d,\"FeatureVector\":[",recent_fv_len);
27:                        for(j=0; j < recent_fv_len; j++)
28:                        {
29:                            written += snprintf(&serial_out_buf[written],sizeof(serial_out_buf)-written,"%d",recent_fv[j]);
30:                            if(j < recent_fv_len -1)
31:                            {
32:                                serial_out_buf[written++] = ',';
33:                            }
34:                        }
35:                        serial_out_buf[written++] = ']';
36:                    }
37:                    serial_out_buf[written++] = '}';
000018  000920     NOP
38:                
39:                    printf("%s\r\n", serial_out_buf);
00001E  000920     NOP
40:                }
000028  000920     NOP
41:                
42:                uint32_t sml_output_results(uint16_t model, uint16_t classification)
43:                {
000000  040200     GOTO __resetPRI, __reset
44:                    sml_get_feature_vector(model, recent_fv, &recent_fv_len);
000004  000B9A     NOP
45:                    memset(serial_out_buf, 0, SERIAL_OUT_CHARS_MAX);
00000C  000BB6     NOP
46:                    sml_output_serial(model, classification);
000012  00091A     NOP
47:                    return 0;
48:                }
000016  000920     NOP
00001C  000920     NOP
49:                
50:                uint32_t sml_output_init(void *p_module)
51:                {
52:                    //unused for now
53:                    return 0;
54:                }
000000  040200     GOTO __resetPRI, __reset
000004  000B9A     NOP
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/X2CScopeWrapper.c  -------------------------------
007EBE  BE9F88     MOV.D W8, [W15++]
007EC0  781F8A     MOV W10, [W15++]
007EC2  BE0400     MOV.D W0, W8
007EC4  070840     RCALL initTableStruct
007EC6  212180     MOV #0x1218, W0
007EC8  070A63     RCALL initSerialGeneric
007ECA  B3C013     MOV.B #0x1, W3
007ECC  EBC100     SETM.B W2
007ECE  2106C1     MOV #0x106C, W1
007ED0  212020     MOV #0x1202, W0
007ED2  07ED10     RCALL initLNet
007ED4  21202A     MOV #0x1202, W10
007ED6  78000A     MOV W10, W0
007ED8  07EAF3     RCALL initServiceTable
007EDA  78000A     MOV W10, W0
007EDC  07EAFB     RCALL addCoreServices
007EDE  78000A     MOV W10, W0
007EE0  07F1C6     RCALL addBlockServices
007EE2  78000A     MOV W10, W0
007EE4  07F1CC     RCALL addExtendedBlockServices
007EE6  78000A     MOV W10, W0
007EE8  070840     RCALL addTableStructProtocol
007EEA  212181     MOV #0x1218, W1
007EEC  78000A     MOV W10, W0
007EEE  070A5D     RCALL linkSerial
007EF0  809350     MOV 0x126A, W0
007EF2  200011     MOV #0x1, W1
007EF4  980031     MOV W1, [W0+6]
007EF6  070FC9     RCALL initVersionInfo
007EF8  809350     MOV 0x126A, W0
007EFA  2B95A1     MOV #0xB95A, W1
007EFC  980011     MOV W1, [W0+2]
007EFE  2B9721     MOV #0xB972, W1
007F00  780801     MOV W1, [W0]
007F12  BE0008     MOV.D W8, W0
007F14  070F31     RCALL X2C_Init
007F16  78054F     MOV [--W15], W10
007F18  BE044F     MOV.D [--W15], W8
007F1A  060000     RETURN
007F1C  212020     MOV #0x1202, W0
007F1E  809011     MOV protocol, W1
007F20  010401     GOTO W1
007F22  370F2E     BRA X2C_Update
007F24  889000     MOV W0, sendSerialFcn
007F26  888FF1     MOV W1, receiveSerialFcn
007F28  888FE2     MOV W2, isReceiveDataAvailableFcn
007F2A  888FD3     MOV W3, isSendReadyFcn
007F2C  060000     RETURN
007EAC  784001     MOV.B W1, W0
007EAE  809001     MOV sendSerialFcn, W1
007EB0  010401     GOTO W1
007EB2  808FF0     MOV receiveSerialFcn, W0
007EB4  010400     GOTO W0
007EB6  808FE0     MOV isReceiveDataAvailableFcn, W0
007EB8  010400     GOTO W0
007EBA  808FD0     MOV isSendReadyFcn, W0
007EBC  010400     GOTO W0
007F02  27EAC0     MOV #0x7EAC, W0
007F2E  27EAC1     MOV #0x7EAC, W1
007F30  780801     MOV W1, [W0]
007F06  27EB20     MOV #0x7EB2, W0
007F32  27EB21     MOV #0x7EB2, W1
007F34  980011     MOV W1, [W0+2]
007F0A  27EB60     MOV #0x7EB6, W0
007F36  27EB61     MOV #0x7EB6, W1
007F38  980021     MOV W1, [W0+4]
007F0E  27EBA0     MOV #0x7EBA, W0
007F3A  27EBA1     MOV #0x7EBA, W1
007F3C  980031     MOV W1, [W0+6]
007F3E  060000     RETURN
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/X2C.c  -------------------------------------------
009D78  780101     MOV W1, W2
009D7A  780080     MOV W0, W1
009D7C  2116C0     MOV #0x116C, W0
009D7E  37CFF1     BRA Scope_Main_Init
009D80  2116C0     MOV #0x116C, W0
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/VersionInfo.c  -----------------------------------
009E8A  980821     MOV W1, [W0+20]
009E8C  2B97A1     MOV #0xB97A, W1
009E8E  980831     MOV W1, [W0+22]
009E90  060000     RETURN
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/TableStruct.c  -----------------------------------
008F46  809350     MOV 0x126A, W0
008F48  EB0080     CLR W1
008F4A  780801     MOV W1, [W0]
008F4C  980011     MOV W1, [W0+2]
008F4E  980021     MOV W1, [W0+4]
008F50  980031     MOV W1, [W0+6]
008F52  980041     MOV W1, [W0+8]
008F54  B81160     MUL.UU W2, #0x0, W2
008F56  980052     MOV W2, [W0+10]
008F58  980063     MOV W3, [W0+12]
008F5A  980071     MOV W1, [W0+14]
008F5C  980801     MOV W1, [W0+16]
008F5E  980811     MOV W1, [W0+18]
008F60  980821     MOV W1, [W0+20]
008F62  980831     MOV W1, [W0+22]
008F64  980841     MOV W1, [W0+24]
008F66  980851     MOV W1, [W0+26]
008F68  060000     RETURN
008F6A  809351     MOV 0x126A, W1
008F6C  900171     MOV [W1+14], W2
008F6E  510FE1     SUB W2, #0x1, [W15]
008F70  360001     BRA LEU, .L7
008F72  060000     RETURN
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
008F74  900171     MOV [W1+14], W2
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/Services.c  --------------------------------------
004F7A  B3C021     MOV.B #0x2, W1
004F7C  984041     MOV.B W1, [W0+4]
004F7E  9000B0     MOV [W0+6], W1
004F80  B3C212     MOV.B #0x21, W2
004F82  984092     MOV.B W2, [W1+1]
004F84  900090     MOV [W0+2], W1
004F86  010401     GOTO W1
005106  B3C021     MOV.B #0x2, W1
0051EC  B3C021     MOV.B #0x2, W1
00529E  B3C020     MOV.B #0x2, W0
0052C4  B3C020     MOV.B #0x2, W0
0052DC  B3C021     MOV.B #0x2, W1
0052DE  984441     MOV.B W1, [W8+4]
0052EA  B3C020     MOV.B #0x2, W0
00530C  B3C020     MOV.B #0x2, W0
005356  B3C021     MOV.B #0x2, W1
0053C6  B3C020     MOV.B #0x2, W0
0053DC  B3C021     MOV.B #0x2, W1
0053DE  984441     MOV.B W1, [W8+4]
0053EA  B3C020     MOV.B #0x2, W0
0054B4  B3C022     MOV.B #0x2, W2
0054B6  984042     MOV.B W2, [W0+4]
00510A  9000B0     MOV [W0+6], W1
0051F0  784B80     MOV.B W0, [W7]
0052A2  B3C410     MOV.B #0x41, W0
0052C8  900038     MOV [W8+6], W0
0052E0  784B80     MOV.B W0, [W7]
0052EE  900038     MOV [W8+6], W0
005310  B3C440     MOV.B #0x44, W0
00535A  784B00     MOV.B W0, [W6]
0053CA  B3C410     MOV.B #0x41, W0
0053E0  784B00     MOV.B W0, [W6]
0053EE  B3C440     MOV.B #0x44, W0
0054B8  900130     MOV [W0+6], W2
0054BA  984111     MOV.B W1, [W2+1]
005110  900090     MOV [W0+2], W1
0051F2  900098     MOV [W8+2], W1
0052A6  900098     MOV [W8+2], W1
0052CE  900098     MOV [W8+2], W1
0052E2  900098     MOV [W8+2], W1
0052E4  780008     MOV W8, W0
0052E6  010001     CALL W1
0052E8  37FF87     BRA .LBE32, .L13
0052F4  900098     MOV [W8+2], W1
005314  900098     MOV [W8+2], W1
00535C  900098     MOV [W8+2], W1
0053CE  900098     MOV [W8+2], W1
0053E2  900098     MOV [W8+2], W1
0053E4  780008     MOV W8, W0
0053E6  010001     CALL W1
0053E8  37FFBC     BRA .LBE52, .L47
0053F2  900098     MOV [W8+2], W1
0054BC  900090     MOV [W0+2], W1
0054BE  010401     GOTO W1
004F88  904150     MOV.B [W0+5], W2
004F8A  B3C2D1     MOV.B #0x2D, W1
004F8C  514F81     SUB.B W2, W1, [W15]
004F8E  3600BB     BRA LEU, getDeviceInfo::sendError
004F90  B3C2E2     MOV.B #0x2E, W2
004F92  984042     MOV.B W2, [W0+4]
004F94  9001B0     MOV [W0+6], W3
004F96  EB4100     CLR.B W2
004F98  984192     MOV.B W2, [W3+1]
004F9A  9001B0     MOV [W0+6], W3
004F9C  B3C054     MOV.B #0x5, W4
004F9E  9841A4     MOV.B W4, [W3+2]
004FA0  9001B0     MOV [W0+6], W3
004FA2  9841B2     MOV.B W2, [W3+3]
004FA8  900130     MOV [W0+6], W2
004FA4  809352     MOV 0x126A, W2
004FA6  9009A2     MOV [W2+20], W3
004FAA  984143     MOV.B W3, [W2+4]
004FAC  809352     MOV 0x126A, W2
004FAE  9009A2     MOV [W2+20], W3
004FB0  900130     MOV [W0+6], W2
004FB2  DE19C8     LSR W3, #8, W3
004FB4  984153     MOV.B W3, [W2+5]
004FB6  900130     MOV [W0+6], W2
004FB8  9041D0     MOV.B [W0+5], W3
004FBA  984163     MOV.B W3, [W2+6]
004FBC  900130     MOV [W0+6], W2
004FBE  B3C103     MOV.B #0x10, W3
004FC0  984173     MOV.B W3, [W2+7]
004FC2  900130     MOV [W0+6], W2
004FC4  B3C823     MOV.B #0x82, W3
004FC6  984903     MOV.B W3, [W2+8]
004FC8  900130     MOV [W0+6], W2
004FCA  B3C443     MOV.B #0x44, W3
004FCC  984913     MOV.B W3, [W2+9]
004FCE  900130     MOV [W0+6], W2
004FD0  B3C653     MOV.B #0x65, W3
004FD2  984923     MOV.B W3, [W2+10]
004FD4  900130     MOV [W0+6], W2
004FD6  E9C183     DEC2.B W3, W3
004FD8  984933     MOV.B W3, [W2+11]
004FDA  9001B0     MOV [W0+6], W3
004FDC  B3C312     MOV.B #0x31, W2
004FDE  9849C2     MOV.B W2, [W3+12]
004FE0  9001B0     MOV [W0+6], W3
004FE2  B3C384     MOV.B #0x38, W4
004FE4  9849D4     MOV.B W4, [W3+13]
004FE6  9001B0     MOV [W0+6], W3
004FE8  524266     SUB.B W4, #0x6, W4
004FEA  9849E4     MOV.B W4, [W3+14]
004FEC  900230     MOV [W0+6], W4
004FEE  B3C303     MOV.B #0x30, W3
004FF0  984A73     MOV.B W3, [W4+15]
004FF2  900230     MOV [W0+6], W4
004FF4  985202     MOV.B W2, [W4+16]
004FF6  900230     MOV [W0+6], W4
004FF8  B3C395     MOV.B #0x39, W5
004FFA  985215     MOV.B W5, [W4+17]
004FFC  900230     MOV [W0+6], W4
004FFE  985222     MOV.B W2, [W4+18]
005000  900130     MOV [W0+6], W2
005002  985133     MOV.B W3, [W2+19]
005004  900130     MOV [W0+6], W2
005006  41C1E3     ADD.B W3, #0x3, W3
005008  985143     MOV.B W3, [W2+20]
00500A  900130     MOV [W0+6], W2
00500C  E84183     INC.B W3, W3
00500E  985153     MOV.B W3, [W2+21]
005010  809352     MOV 0x126A, W2
005012  9009B2     MOV [W2+22], W3
005014  E00003     CP0 W3
005016  32007E     BRA Z, .L11
005114  900130     MOV [W0+6], W2
005116  986121     MOV.B W1, [W2+34]
005118  900130     MOV [W0+6], W2
00511A  986111     MOV.B W1, [W2+33]
00511C  900130     MOV [W0+6], W2
00511E  986101     MOV.B W1, [W2+32]
005120  900130     MOV [W0+6], W2
005122  985971     MOV.B W1, [W2+31]
005124  900130     MOV [W0+6], W2
005126  985961     MOV.B W1, [W2+30]
005128  900130     MOV [W0+6], W2
00512A  985951     MOV.B W1, [W2+29]
00512C  900130     MOV [W0+6], W2
00512E  985941     MOV.B W1, [W2+28]
005130  900130     MOV [W0+6], W2
005132  985931     MOV.B W1, [W2+27]
005134  900130     MOV [W0+6], W2
005136  985921     MOV.B W1, [W2+26]
005138  900130     MOV [W0+6], W2
00513A  985911     MOV.B W1, [W2+25]
00513C  900130     MOV [W0+6], W2
00513E  985901     MOV.B W1, [W2+24]
005140  900130     MOV [W0+6], W2
005142  985171     MOV.B W1, [W2+23]
005144  900130     MOV [W0+6], W2
005146  985161     MOV.B W1, [W2+22]
005018  900932     MOV [W2+22], W2
00501A  9000B0     MOV [W0+6], W1
00501C  784112     MOV.B [W2], W2
00501E  9850E2     MOV.B W2, [W1+22]
005020  809351     MOV 0x126A, W1
005022  900931     MOV [W1+22], W2
005024  9000B0     MOV [W0+6], W1
005026  904112     MOV.B [W2+1], W2
005028  9850F2     MOV.B W2, [W1+23]
00502A  809351     MOV 0x126A, W1
00502C  900931     MOV [W1+22], W2
00502E  9000B0     MOV [W0+6], W1
005030  904122     MOV.B [W2+2], W2
005032  985882     MOV.B W2, [W1+24]
005034  809351     MOV 0x126A, W1
005036  900931     MOV [W1+22], W2
005038  9000B0     MOV [W0+6], W1
00503A  904142     MOV.B [W2+4], W2
00503C  985892     MOV.B W2, [W1+25]
00503E  809351     MOV 0x126A, W1
005040  900931     MOV [W1+22], W2
005042  9000B0     MOV [W0+6], W1
005044  904152     MOV.B [W2+5], W2
005046  9858A2     MOV.B W2, [W1+26]
005048  809351     MOV 0x126A, W1
00504A  900931     MOV [W1+22], W2
00504C  9000B0     MOV [W0+6], W1
00504E  904172     MOV.B [W2+7], W2
005050  9858B2     MOV.B W2, [W1+27]
005052  809351     MOV 0x126A, W1
005054  900931     MOV [W1+22], W2
005056  9000B0     MOV [W0+6], W1
005058  904902     MOV.B [W2+8], W2
00505A  9858C2     MOV.B W2, [W1+28]
00505C  809351     MOV 0x126A, W1
00505E  900931     MOV [W1+22], W2
005060  9000B0     MOV [W0+6], W1
005062  904912     MOV.B [W2+9], W2
005064  9858D2     MOV.B W2, [W1+29]
005066  809351     MOV 0x126A, W1
005068  900931     MOV [W1+22], W2
00506A  9000B0     MOV [W0+6], W1
00506C  904922     MOV.B [W2+10], W2
00506E  9858E2     MOV.B W2, [W1+30]
005070  809351     MOV 0x126A, W1
005072  900931     MOV [W1+22], W2
005074  9000B0     MOV [W0+6], W1
005076  904932     MOV.B [W2+11], W2
005078  9858F2     MOV.B W2, [W1+31]
00507A  809351     MOV 0x126A, W1
00507C  900931     MOV [W1+22], W2
00507E  9000B0     MOV [W0+6], W1
005080  904942     MOV.B [W2+12], W2
005082  986082     MOV.B W2, [W1+32]
005084  809351     MOV 0x126A, W1
005086  900931     MOV [W1+22], W2
005088  9000B0     MOV [W0+6], W1
00508A  904962     MOV.B [W2+14], W2
00508C  986092     MOV.B W2, [W1+33]
00508E  809351     MOV 0x126A, W1
005090  900931     MOV [W1+22], W2
005092  9000B0     MOV [W0+6], W1
005094  904972     MOV.B [W2+15], W2
005096  9860A2     MOV.B W2, [W1+34]
005098  809351     MOV 0x126A, W1
00509A  900131     MOV [W1+6], W2
00509C  9000B0     MOV [W0+6], W1
00509E  9860B2     MOV.B W2, [W1+35]
005148  809351     MOV 0x126A, W1
00514A  900131     MOV [W1+6], W2
00514C  9000B0     MOV [W0+6], W1
00514E  9860B2     MOV.B W2, [W1+35]
0050A0  809351     MOV 0x126A, W1
0050A2  900141     MOV [W1+8], W2
0050A4  9000B0     MOV [W0+6], W1
0050A6  9860C2     MOV.B W2, [W1+36]
005150  809351     MOV 0x126A, W1
005152  900141     MOV [W1+8], W2
005154  9000B0     MOV [W0+6], W1
005156  9860C2     MOV.B W2, [W1+36]
0050A8  809351     MOV 0x126A, W1
0050AA  900141     MOV [W1+8], W2
0050AC  9000B0     MOV [W0+6], W1
0050AE  DE1148     LSR W2, #8, W2
0050B0  9860D2     MOV.B W2, [W1+37]
005158  809351     MOV 0x126A, W1
00515A  900141     MOV [W1+8], W2
00515C  9000B0     MOV [W0+6], W1
00515E  DE1148     LSR W2, #8, W2
005160  9860D2     MOV.B W2, [W1+37]
0050B2  809351     MOV 0x126A, W1
0050B4  900151     MOV [W1+10], W2
0050B6  9001E1     MOV [W1+12], W3
0050B8  9000B0     MOV [W0+6], W1
0050BA  9860E2     MOV.B W2, [W1+38]
005162  809351     MOV 0x126A, W1
005164  900151     MOV [W1+10], W2
005166  9001E1     MOV [W1+12], W3
005168  9000B0     MOV [W0+6], W1
00516A  9860E2     MOV.B W2, [W1+38]
0050BC  809351     MOV 0x126A, W1
0050BE  900151     MOV [W1+10], W2
0050C0  9001E1     MOV [W1+12], W3
0050C2  9000B0     MOV [W0+6], W1
0050C4  DD1A48     SL W3, #8, W4
0050C6  DE1148     LSR W2, #8, W2
0050C8  720102     IOR W4, W2, W2
0050CA  DE19C8     LSR W3, #8, W3
0050CC  9860F2     MOV.B W2, [W1+39]
00516C  809351     MOV 0x126A, W1
00516E  900151     MOV [W1+10], W2
005170  9001E1     MOV [W1+12], W3
005172  9000B0     MOV [W0+6], W1
005174  DD1A48     SL W3, #8, W4
005176  DE1148     LSR W2, #8, W2
005178  720102     IOR W4, W2, W2
00517A  DE19C8     LSR W3, #8, W3
00517C  9860F2     MOV.B W2, [W1+39]
0050CE  809351     MOV 0x126A, W1
0050D0  900151     MOV [W1+10], W2
0050D2  9001E1     MOV [W1+12], W3
0050D4  9000B0     MOV [W0+6], W1
0050D6  986883     MOV.B W3, [W1+40]
00517E  809351     MOV 0x126A, W1
005180  900151     MOV [W1+10], W2
005182  9001E1     MOV [W1+12], W3
005184  9000B0     MOV [W0+6], W1
005186  986883     MOV.B W3, [W1+40]
0050D8  809351     MOV 0x126A, W1
0050DA  900151     MOV [W1+10], W2
0050DC  9001E1     MOV [W1+12], W3
0050DE  9000B0     MOV [W0+6], W1
0050E0  DE1948     LSR W3, #8, W2
0050E2  986892     MOV.B W2, [W1+41]
005188  809351     MOV 0x126A, W1
00518A  900151     MOV [W1+10], W2
00518C  9001E1     MOV [W1+12], W3
00518E  9000B0     MOV [W0+6], W1
005190  DE1948     LSR W3, #8, W2
005192  986892     MOV.B W2, [W1+41]
0050E4  809352     MOV 0x126A, W2
0050E6  DE91CF     ASR W2, #15, W3
005194  809352     MOV 0x126A, W2
005196  DE91CF     ASR W2, #15, W3
0050E8  9000B0     MOV [W0+6], W1
0050EA  9868A2     MOV.B W2, [W1+42]
005198  9000B0     MOV [W0+6], W1
00519A  9868A2     MOV.B W2, [W1+42]
0050EC  9000B0     MOV [W0+6], W1
0050EE  DE1AC8     LSR W3, #8, W5
0050F0  DD1B48     SL W3, #8, W6
0050F2  DE1248     LSR W2, #8, W4
0050F4  730204     IOR W6, W4, W4
0050F6  9868B4     MOV.B W4, [W1+43]
00519C  9000B0     MOV [W0+6], W1
00519E  DE1AC8     LSR W3, #8, W5
0051A0  DD1B48     SL W3, #8, W6
0051A2  DE1248     LSR W2, #8, W4
0051A4  730204     IOR W6, W4, W4
0051A6  9868B4     MOV.B W4, [W1+43]
0050F8  9000B0     MOV [W0+6], W1
0050FA  9868C3     MOV.B W3, [W1+44]
0051A8  9000B0     MOV [W0+6], W1
0051AA  9868C3     MOV.B W3, [W1+44]
0050FC  9000B0     MOV [W0+6], W1
0050FE  DE1948     LSR W3, #8, W2
005100  9868D2     MOV.B W2, [W1+45]
0051AC  9000B0     MOV [W0+6], W1
0051AE  DE1948     LSR W3, #8, W2
0051B0  9868D2     MOV.B W2, [W1+45]
005102  900090     MOV [W0+2], W1
005104  010401     GOTO W1
0051B2  900090     MOV [W0+2], W1
0051B4  010401     GOTO W1
0051DA  428064     ADD W5, #0x4, W0
0051B6  781F88     MOV W8, [W15++]
0051B8  780400     MOV W0, W8
0051BA  9000B8     MOV [W8+6], W1
0051BC  904221     MOV.B [W1+2], W4
0051BE  780381     MOV W1, W7
0051C0  784057     MOV.B [++W7], W0
0051CA  DD2248     SL W4, #8, W4
0051CC  FB8000     ZE W0, W0
0051CE  420200     ADD W4, W0, W4
0051C2  809352     MOV 0x126A, W2
0051C4  780292     MOV [W2], W5
005202  9001A2     MOV [W2+4], W3
005204  E00003     CP0 W3
005206  32001A     BRA Z, .L17
005208  9002A2     MOV [W2+4], W5
00520A  EB0180     CLR W3
00520C  120F95     SUBR W4, [W5], [W15]
00520E  320012     BRA Z, .L18
005212  200043     MOV #0x4, W3
005214  E00015     CP0 [W5]
005216  320074     BRA Z, .L38
005218  9002A2     MOV [W2+4], W5
00521A  7982E5     MOV [W5+W3], W5
00521C  528F84     SUB W5, W4, [W15]
00521E  32000A     BRA Z, .L18
005224  7982E5     MOV [W5+W3], W5
005226  E00005     CP0 W5
005228  320005     BRA Z, .L18
00522A  780186     MOV W6, W3
00522C  9002A2     MOV [W2+4], W5
00522E  7982E5     MOV [W5+W3], W5
005230  528F84     SUB W5, W4, [W15]
005232  3AFFF6     BRA NZ, .L39
005300  EB0180     CLR W3
005210  9002A2     MOV [W2+4], W5
005220  9002A2     MOV [W2+4], W5
005222  418364     ADD W3, #0x4, W6
005234  900222     MOV [W2+4], W4
005236  798264     MOV [W4+W3], W4
005238  E00004     CP0 W4
00523A  3A003B     BRA NZ, .L40
005302  900222     MOV [W2+4], W4
005304  798264     MOV [W4+W3], W4
005306  E00004     CP0 W4
005308  32FF99     BRA Z, .L17
00530A  37FFD3     BRA .L40
0052B2  900122     MOV [W2+4], W2
0052B4  410183     ADD W2, W3, W3
0052B6  904148     MOV.B [W8+4], W2
0052B8  514163     SUB.B W2, #0x3, W2
0052BA  4080E3     ADD W1, #0x3, W1
0052BC  900193     MOV [W3+2], W3
0052BE  010003     CALL W3
0052C0  E00400     CP0.B W0
0052C2  32FF9A     BRA Z, .LBE32, .L13
00523C  900192     MOV [W2+2], W3
00523E  E00003     CP0 W3
005240  320065     BRA Z, saveParameter::sendError
005242  780310     MOV [W0], W6
005244  900212     MOV [W2+2], W4
005246  EB0180     CLR W3
005248  130F94     SUBR W6, [W4], [W15]
00524A  320012     BRA Z, .L23
00524C  900212     MOV [W2+2], W4
00524E  E00014     CP0 [W4]
005250  32000F     BRA Z, .L23
005252  2000C3     MOV #0xC, W3
005254  900212     MOV [W2+2], W4
005256  798264     MOV [W4+W3], W4
005258  520F86     SUB W4, W6, [W15]
00525A  32000A     BRA Z, .L23
00525C  900212     MOV [W2+2], W4
00525E  4182EC     ADD W3, #0xC, W5
005260  798264     MOV [W4+W3], W4
005262  E00004     CP0 W4
005264  320005     BRA Z, .L23
005266  780185     MOV W5, W3
005268  900212     MOV [W2+2], W4
00526A  798264     MOV [W4+W3], W4
00526C  520F86     SUB W4, W6, [W15]
00526E  3AFFF6     BRA NZ, .L42
005270  900212     MOV [W2+2], W4
005272  798264     MOV [W4+W3], W4
005274  E00004     CP0 W4
005276  320013     BRA Z, saveParameter::sendError
005278  900112     MOV [W2+2], W2
00527A  410183     ADD W2, W3, W3
00527C  904148     MOV.B [W8+4], W2
00527E  514163     SUB.B W2, #0x3, W2
005280  4080E3     ADD W1, #0x3, W1
005282  9001C3     MOV [W3+8], W3
005284  010003     CALL W3
005286  E00400     CP0.B W0
005288  3A0030     BRA NZ, saveParameter::sendError
00528A  B3C021     MOV.B #0x2, W1
00528C  984441     MOV.B W1, [W8+4]
00528E  9000B8     MOV [W8+6], W1
005290  984090     MOV.B W0, [W1+1]
005292  900098     MOV [W8+2], W1
005294  780008     MOV W8, W0
005296  010001     CALL W1
0051F8  78044F     MOV [--W15], W8
0051FA  060000     RETURN
005298  78044F     MOV [--W15], W8
00529A  060000     RETURN
00529C  37FFAF     BRA .L15, .L45
0052AC  78044F     MOV [--W15], W8
0052AE  060000     RETURN
0052B0  37FFA5     BRA .L15, .L45
0052D4  78044F     MOV [--W15], W8
0052D6  060000     RETURN
0052D8  37FF91     BRA .L15, .L45
0052FA  78044F     MOV [--W15], W8
0052FC  060000     RETURN
0052FE  37FF7E     BRA .L15, .L45
00531A  78044F     MOV [--W15], W8
00531C  060000     RETURN
00531E  37FF6E     BRA .L15, .L45
005344  420064     ADD W4, #0x4, W0
005320  781F88     MOV W8, [W15++]
005322  780400     MOV W0, W8
005324  900338     MOV [W8+6], W6
005326  E88086     INC2 W6, W1
005328  784291     MOV.B [W1], W5
00532A  784056     MOV.B [++W6], W0
005334  DD2AC8     SL W5, #8, W5
005336  FB8000     ZE W0, W0
005338  428280     ADD W5, W0, W5
00532C  809353     MOV 0x126A, W3
00532E  780213     MOV [W3], W4
00536C  900113     MOV [W3+2], W2
00536E  E00002     CP0 W2
005370  32003C     BRA Z, loadParameter::sendError
005372  780390     MOV [W0], W7
005374  900213     MOV [W3+2], W4
005376  EB0100     CLR W2
005378  138F94     SUBR W7, [W4], [W15]
00537A  320012     BRA Z, .L54
00537C  900213     MOV [W3+2], W4
00537E  E00014     CP0 [W4]
005380  32000F     BRA Z, .L54
005382  2000C2     MOV #0xC, W2
005384  900213     MOV [W3+2], W4
005386  790264     MOV [W4+W2], W4
005388  520F87     SUB W4, W7, [W15]
00538A  32000A     BRA Z, .L54
00538C  900213     MOV [W3+2], W4
00538E  4102EC     ADD W2, #0xC, W5
005390  790264     MOV [W4+W2], W4
005392  E00004     CP0 W4
005394  320005     BRA Z, .L54
005396  780105     MOV W5, W2
005398  900213     MOV [W3+2], W4
00539A  790264     MOV [W4+W2], W4
00539C  520F87     SUB W4, W7, [W15]
00539E  3AFFF6     BRA NZ, .L67
0053A0  900213     MOV [W3+2], W4
0053A2  790264     MOV [W4+W2], W4
0053A4  E00004     CP0 W4
0053A6  32000F     BRA Z, loadParameter::sendError
0053A8  900193     MOV [W3+2], W3
0053AA  418102     ADD W3, W2, W2
0053AC  900132     MOV [W2+6], W2
0053AE  010002     CALL W2
0053B0  E8C000     INC2.B W0, W0
0053B2  984440     MOV.B W0, [W8+4]
0053B4  900038     MOV [W8+6], W0
0053B6  EB4080     CLR.B W1
0053B8  984011     MOV.B W1, [W0+1]
0053BA  900098     MOV [W8+2], W1
0053BC  780008     MOV W8, W0
0053BE  010001     CALL W1
005362  78044F     MOV [--W15], W8
005364  060000     RETURN
0053C0  78044F     MOV [--W15], W8
0053C2  060000     RETURN
0053C4  37FFD0     BRA .L49, .L69
0053D4  78044F     MOV [--W15], W8
0053D6  060000     RETURN
0053D8  37FFC6     BRA .L49, .L69
0053F8  78044F     MOV [--W15], W8
0053FA  060000     RETURN
0053FC  37FFB4     BRA .L49, .L69
005414  EB4100     CLR.B W2
00542A  EB4100     CLR.B W2
005454  EB4100     CLR.B W2
005468  EB4100     CLR.B W2
00547C  EB4100     CLR.B W2
005490  EB4100     CLR.B W2
0053FE  9000B0     MOV [W0+6], W1
005400  784151     MOV.B [++W1], W2
005402  514FE2     SUB.B W2, #0x2, [W15]
005404  320038     BRA Z, .L75
005406  36000C     BRA LEU, .L82, .L86
005408  514FE4     SUB.B W2, #0x4, [W15]
00540A  32003F     BRA Z, .L77
00540C  31001E     BRA C, .L83
005420  E00402     CP0.B W2
005422  3A000A     BRA NZ, .L84
005438  514FE1     SUB.B W2, #0x1, [W15]
00543A  320013     BRA Z, .L85
00544A  514FE5     SUB.B W2, #0x5, [W15]
00544C  3AFFF7     BRA NZ, .L80
005424  EB0180     CLR W3
005426  809352     MOV 0x126A, W2
005428  980133     MOV W3, [W2+6]
005462  200013     MOV #0x1, W3
005464  809352     MOV 0x126A, W2
005466  980133     MOV W3, [W2+6]
005476  200023     MOV #0x2, W3
005478  809352     MOV 0x126A, W2
00547A  980133     MOV W3, [W2+6]
00540E  200033     MOV #0x3, W3
005410  809352     MOV 0x126A, W2
005412  980133     MOV W3, [W2+6]
00548A  200043     MOV #0x4, W3
00548C  809352     MOV 0x126A, W2
00548E  980133     MOV W3, [W2+6]
00544E  200053     MOV #0x5, W3
005450  809352     MOV 0x126A, W2
005452  980133     MOV W3, [W2+6]
00543C  B3C222     MOV.B #0x22, W2
005416  784882     MOV.B W2, [W1]
00542C  784882     MOV.B W2, [W1]
00543E  784882     MOV.B W2, [W1]
005456  784882     MOV.B W2, [W1]
00546A  784882     MOV.B W2, [W1]
00547E  784882     MOV.B W2, [W1]
005492  784882     MOV.B W2, [W1]
005418  B3C021     MOV.B #0x2, W1
00541A  984041     MOV.B W1, [W0+4]
00542E  B3C021     MOV.B #0x2, W1
005430  984041     MOV.B W1, [W0+4]
005440  B3C021     MOV.B #0x2, W1
005442  984041     MOV.B W1, [W0+4]
005458  B3C021     MOV.B #0x2, W1
00545A  984041     MOV.B W1, [W0+4]
00546C  B3C021     MOV.B #0x2, W1
00546E  984041     MOV.B W1, [W0+4]
005480  B3C021     MOV.B #0x2, W1
005482  984041     MOV.B W1, [W0+4]
005494  B3C021     MOV.B #0x2, W1
005496  984041     MOV.B W1, [W0+4]
00541C  900090     MOV [W0+2], W1
00541E  010401     GOTO W1
005432  900090     MOV [W0+2], W1
005434  010401     GOTO W1
005436  37FFF4     BRA .L82, .L86
005444  900090     MOV [W0+2], W1
005446  010401     GOTO W1
005448  37FFEB     BRA .L82, .L86
00545C  900090     MOV [W0+2], W1
00545E  010401     GOTO W1
005460  37FFDF     BRA .L82, .L86
005470  900090     MOV [W0+2], W1
005472  010401     GOTO W1
005474  37FFD5     BRA .L82, .L86
005484  900090     MOV [W0+2], W1
005486  010401     GOTO W1
005488  37FFCB     BRA .L82, .L86
005498  900090     MOV [W0+2], W1
00549A  010401     GOTO W1
00549C  37FFC1     BRA .L82, .L86
00549E  9000B0     MOV [W0+6], W1
0054A0  EB4100     CLR.B W2
0054A2  984092     MOV.B W2, [W1+1]
0054A4  809351     MOV 0x126A, W1
0054A6  900131     MOV [W1+6], W2
0054A8  9000B0     MOV [W0+6], W1
0054AA  9840A2     MOV.B W2, [W1+2]
0054AC  B3C031     MOV.B #0x3, W1
0054AE  984041     MOV.B W1, [W0+4]
0054B0  900090     MOV [W0+2], W1
0054B2  010401     GOTO W1
0054C2  200363     MOV #0x36, W3
0054C4  418181     ADD W3, W1, W3
0054C6  24F7A2     MOV #0x4F7A, W2
0054C0  211C21     MOV #0x11C2, W1
0054CA  508F83     SUB W1, W3, [W15]
0054CC  3AFFFD     BRA NZ, .L95
0054C8  782882     MOV W2, [++W1]
0054CE  211C41     MOV #0x11C4, W1
0054D0  980041     MOV W1, [W0+8]
0054D2  060000     RETURN
0054D4  900040     MOV [W0+8], W0
0054D6  24F881     MOV #0x4F88, W1
0054D8  780801     MOV W1, [W0]
0054DA  2549E1     MOV #0x549E, W1
0054DC  980011     MOV W1, [W0+2]
0054DE  253FE1     MOV #0x53FE, W1
0054E0  980021     MOV W1, [W0+4]
0054E2  251B61     MOV #0x51B6, W1
0054E4  981021     MOV W1, [W0+36]
0054E6  253201     MOV #0x5320, W1
0054E8  981011     MOV W1, [W0+34]
0054EA  060000     RETURN
0051C6  E00005     CP0 W5
005330  E00004     CP0 W4
005330  E00004     CP0 W4
0052DA  B3C430     MOV.B #0x43, W0
0053DA  B3C430     MOV.B #0x43, W0
0051D0  780195     MOV [W5], W3
0051D2  520F83     SUB W4, W3, [W15]
0051D4  320013     BRA Z, .L15, .L45
0051D6  E00003     CP0 W3
0051D8  320008     BRA Z, .L29
0051DC  780280     MOV W0, W5
0051DE  780190     MOV [W0], W3
0051E0  520F83     SUB W4, W3, [W15]
0051E2  32000C     BRA Z, .L15, .L45
0051E4  400064     ADD W0, #0x4, W0
0051E6  E00003     CP0 W3
0051E8  3AFFF9     BRA NZ, .L16
00533A  780114     MOV [W4], W2
00533C  528F82     SUB W5, W2, [W15]
00533E  320013     BRA Z, .L49, .L69
005340  E00002     CP0 W2
005342  320008     BRA Z, .L59
005346  780200     MOV W0, W4
005348  780110     MOV [W0], W2
00534A  528F82     SUB W5, W2, [W15]
00534C  32000C     BRA Z, .L49, .L69
00534E  400064     ADD W0, #0x4, W0
005350  E00002     CP0 W2
005352  3AFFF9     BRA NZ, .L50
0051FC  E00003     CP0 W3
0051FE  32FFF5     BRA Z, .L29
005366  E00002     CP0 W2
005368  32FFF5     BRA Z, .L59
0051EA  B3C400     MOV.B #0x40, W0
005354  B3C400     MOV.B #0x40, W0
005200  900015     MOV [W5+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
00536A  900014     MOV [W4+2], W0
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/SerialGeneric.c  ---------------------------------
009390  293841     MOV #0x9384, W1
009392  780801     MOV W1, [W0]
009394  293861     MOV #0x9386, W1
009396  980011     MOV W1, [W0+2]
009398  293881     MOV #0x9388, W1
00939A  980021     MOV W1, [W0+4]
00939C  2938A1     MOV #0x938A, W1
00939E  980031     MOV W1, [W0+6]
0093A0  2938C1     MOV #0x938C, W1
0093A2  980041     MOV W1, [W0+8]
0093A4  2938E1     MOV #0x938E, W1
0093A6  980051     MOV W1, [W0+10]
0093A8  060000     RETURN
0093AA  980051     MOV W1, [W0+10]
0093AC  060000     RETURN
009384  060000     RETURN
009386  050000     RETLW #0x0, W0
009388  050000     RETLW #0x0, W0
00938A  050000     RETLW #0x0, W0
00938C  050000     RETLW #0x0, W0
00938E  060000     RETURN
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/Scope_Main.c  ------------------------------------
003D62  BE9F88     MOV.D W8, [W15++]
003D64  BE9F8A     MOV.D W10, [W15++]
003D66  EB8800     SETM [W0]
003D68  EB0180     CLR W3
003D6A  980013     MOV W3, [W0+2]
003D70  980023     MOV W3, [W0+4]
003D74  980033     MOV W3, [W0+6]
003D78  980043     MOV W3, [W0+8]
003D7C  980053     MOV W3, [W0+10]
003D80  980063     MOV W3, [W0+12]
003D84  980073     MOV W3, [W0+14]
003D88  980803     MOV W3, [W0+16]
003D6C  EB4200     CLR.B W4
003D6E  985023     MOV.B W3, [W0+18]
003D72  985034     MOV.B W4, [W0+19]
003D76  985044     MOV.B W4, [W0+20]
003D7A  985054     MOV.B W4, [W0+21]
003D7E  985064     MOV.B W4, [W0+22]
003D82  985074     MOV.B W4, [W0+23]
003D86  985804     MOV.B W4, [W0+24]
003D8A  985814     MOV.B W4, [W0+25]
003D8C  980851     MOV W1, [W0+26]
003D8E  B84460     MUL.UU W8, #0x0, W8
003D90  B85560     MUL.UU W10, #0x0, W10
003D92  981008     MOV W8, [W0+32]
003D94  981019     MOV W9, [W0+34]
003D96  98102A     MOV W10, [W0+36]
003D98  98103B     MOV W11, [W0+38]
003D9A  981048     MOV W8, [W0+40]
003D9C  981059     MOV W9, [W0+42]
003D9E  98106A     MOV W10, [W0+44]
003DA0  98107B     MOV W11, [W0+46]
003DA2  981803     MOV W3, [W0+48]
003DA4  987024     MOV.B W4, [W0+50]
003DA6  981823     MOV W3, [W0+52]
003DA8  B83360     MUL.UU W6, #0x0, W6
003DAA  981836     MOV W6, [W0+54]
003DAC  981847     MOV W7, [W0+56]
003DAE  987824     MOV.B W4, [W0+58]
003DB0  987834     MOV.B W4, [W0+59]
003DB2  981863     MOV W3, [W0+60]
003DB4  981873     MOV W3, [W0+62]
003DB6  982003     MOV W3, [W0+64]
003DB8  98C024     MOV.B W4, [W0+66]
003DBA  982026     MOV W6, [W0+68]
003DBC  982037     MOV W7, [W0+70]
003DBE  982046     MOV W6, [W0+72]
003DC0  982057     MOV W7, [W0+74]
003DC2  98C844     MOV.B W4, [W0+76]
003DC4  982076     MOV W6, [W0+78]
003DC6  982807     MOV W7, [W0+80]
003DC8  982812     MOV W2, [W0+82]
003DCA  982823     MOV W3, [W0+84]
003DCC  200011     MOV #0x1, W1
003DCE  982831     MOV W1, [W0+86]
003DD0  980862     MOV W2, [W0+28]
003DD2  980873     MOV W3, [W0+30]
003DD4  809351     MOV 0x126A, W1
003DD6  9808C0     MOV W0, [W1+24]
003DD8  BE054F     MOV.D [--W15], W10
003DDA  BE044F     MOV.D [--W15], W8
003DDC  060000     RETURN
003DDE  FA0008     LNK #0x8
003DE0  BE9F88     MOV.D W8, [W15++]
003DE2  BE9F8A     MOV.D W10, [W15++]
003DE4  BE9F8C     MOV.D W12, [W15++]
003DE6  780600     MOV W0, W12
003DE8  90182C     MOV [W12+52], W0
003DEA  500FE6     SUB W0, #0x6, [W15]
003DEC  3E0019     BRA GTU, .L126, .L172
003DEE  500FE5     SUB W0, #0x5, [W15]
003DF0  390037     BRA NC, .L164
003E20  500FE7     SUB W0, #0x7, [W15]
003E22  320084     BRA Z, .L124
003E24  500FE8     SUB W0, #0x8, [W15]
003E26  3AFFF7     BRA NZ, .L118
003E60  500FE2     SUB W0, #0x2, [W15]
003E62  3200A4     BRA Z, .L121
003E64  500FE4     SUB W0, #0x4, [W15]
003E66  3200D8     BRA Z, .L122
003E68  500FE1     SUB W0, #0x1, [W15]
003E6A  3AFFD5     BRA NZ, .L118
004018  90200C     MOV [W12+64], W0
00401A  E80000     INC W0, W0
00401C  982600     MOV W0, [W12+64]
00401E  90187C     MOV [W12+62], W0
004020  E80000     INC W0, W0
004022  981E70     MOV W0, [W12+62]
003FAC  90187C     MOV [W12+62], W0
003FAE  9018EC     MOV [W12+60], W1
003FB0  E80100     INC W0, W2
003FB2  981E72     MOV W2, [W12+62]
003FB4  500F81     SUB W0, W1, [W15]
003FB6  390027     BRA NC, .L127
003FB8  EB0000     CLR W0
003FBA  981E70     MOV W0, [W12+62]
003FBC  90193C     MOV [W12+54], W2
003FBE  9019CC     MOV [W12+56], W3
003FC2  FB8388     ZE W8, W7
003FEE  90782C     MOV.B [W12+58], W0
003FF0  FB8000     ZE W0, W0
003FF2  EB0080     CLR W1
003FF4  400102     ADD W0, W2, W2
003FF6  488183     ADDC W1, W3, W3
003FF8  90086C     MOV [W12+28], W0
003FFA  9008FC     MOV [W12+30], W1
003FFC  510F80     SUB W2, W0, [W15]
003FFE  598F81     SUBB W3, W1, [W15]
004000  360002     BRA LEU, .L127
004002  EB0000     CLR W0
004004  981E20     MOV W0, [W12+52]
004006  90200C     MOV [W12+64], W0
004008  E80000     INC W0, W0
00400A  982600     MOV W0, [W12+64]
003E02  97B26F     MOV [W15-20], W4
003E04  97B2FF     MOV [W15-18], W5
003E06  97BB0F     MOV [W15-16], W6
003E08  97BB9F     MOV [W15-14], W7
003E0A  78000C     MOV W12, W0
003E0C  07FDC0     RCALL isTriggerEvent
003E0E  E00400     CP0.B W0
003E10  320119     BRA Z, .L136
003E12  200040     MOV #0x4, W0
003E14  981E20     MOV W0, [W12+52]
004044  97B06F     MOV [W15-20], W0
004046  97B0FF     MOV [W15-18], W1
004048  97B90F     MOV [W15-16], W2
00404A  97B99F     MOV [W15-14], W3
00404C  981640     MOV W0, [W12+40]
00404E  981651     MOV W1, [W12+42]
004050  981662     MOV W2, [W12+44]
004052  981673     MOV W3, [W12+46]
003E6C  90187C     MOV [W12+62], W0
003E6E  9018EC     MOV [W12+60], W1
003E70  E80100     INC W0, W2
003E72  981E72     MOV W2, [W12+62]
003E74  500F81     SUB W0, W1, [W15]
003E76  39002D     BRA NC, .L137
003E78  EB0000     CLR W0
003E7A  981E70     MOV W0, [W12+62]
003E7C  90193C     MOV [W12+54], W2
003E7E  9019CC     MOV [W12+56], W3
003E80  907A2C     MOV.B [W12+58], W4
003E82  FB8204     ZE W4, W4
003E84  EB0280     CLR W5
003E86  410204     ADD W2, W4, W4
003E88  498285     ADDC W3, W5, W5
003E8A  90086C     MOV [W12+28], W0
003E8C  9008FC     MOV [W12+30], W1
003E8E  520F80     SUB W4, W0, [W15]
003E90  5A8F81     SUBB W5, W1, [W15]
003E92  360003     BRA LEU, .L138
003E94  B81160     MUL.UU W2, #0x0, W2
003E96  981E32     MOV W2, [W12+54]
003E98  981E43     MOV W3, [W12+56]
003E9A  EB4680     CLR.B W13
003E9C  FB838D     ZE W13, W7
003E9E  EB4000     CLR.B W0
003EA0  E80307     INC W7, W6
003EA2  4383F2     ADD W7, #0x12, W7
003EA6  9008DC     MOV [W12+26], W1
003EAC  7A42E5     MOV.B [W5+W4], W5
003EAE  797085     MOV.B W5, [W1+W2]
003EB0  410161     ADD W2, #0x1, W2
003EB2  4981E0     ADDC W3, #0x0, W3
003EB4  981E32     MOV W2, [W12+54]
003EB6  981E43     MOV W3, [W12+56]
003EA4  430306     ADD W6, W6, W6
003EA8  FB8200     ZE W0, W4
003EAA  7B02EC     MOV [W12+W6], W5
003EB8  E84000     INC.B W0, W0
003EBA  7BC0EC     MOV.B [W12+W7], W1
003EBC  504F81     SUB.B W0, W1, [W15]
003EBE  39FFF3     BRA NC, .L139
003EC0  E8468D     INC.B W13, W13
003EC2  90783C     MOV.B [W12+59], W0
003EC4  56CF80     SUB.B W13, W0, [W15]
003EC6  39FFEA     BRA NC, .L140
003EC8  90207C     MOV [W12+78], W0
003ECA  90288C     MOV [W12+80], W1
003ECC  500F82     SUB W0, W2, [W15]
003ECE  588F83     SUBB W1, W3, [W15]
003ED0  3600E3     BRA LEU, .L166
004098  B3C010     MOV.B #0x1, W0
00409A  98CE40     MOV.B W0, [W12+76]
00409C  37FF1A     BRA .L137
003EE2  BE0208     MOV.D W8, W4
003EE4  BE030A     MOV.D W10, W6
003EE6  78000C     MOV W12, W0
003EE8  07FD52     RCALL isTriggerEvent
003EEA  E00400     CP0.B W0
003EEC  3200A1     BRA Z, .L147
003EEE  90C84C     MOV.B [W12+76], W0
003EF0  E00400     CP0.B W0
003EF2  32009E     BRA Z, .L147
003EF4  90202C     MOV [W12+68], W0
003EF6  9020BC     MOV [W12+70], W1
003EF8  500FE0     SUB W0, #0x0, [W15]
003EFA  588FE0     SUBB W1, #0x0, [W15]
003EFC  3500E8     BRA LT, .L168
0040CE  982640     MOV W0, [W12+72]
0040D0  982651     MOV W1, [W12+74]
0040D2  B82260     MUL.UU W4, #0x0, W4
0040D4  981E34     MOV W4, [W12+54]
0040D6  981E45     MOV W5, [W12+56]
0040D8  200080     MOV #0x8, W0
0040DA  981E20     MOV W0, [W12+52]
003EFE  90183C     MOV [W12+54], W0
003F00  9018CC     MOV [W12+56], W1
003F02  500FE0     SUB W0, #0x0, [W15]
003F04  588FE0     SUBB W1, #0x0, [W15]
003F06  3200F0     BRA Z, .L149
003F08  90197C     MOV [W12+62], W2
003F0A  E00002     CP0 W2
003F0C  3A00F4     BRA NZ, .L162
003F0E  90792C     MOV.B [W12+58], W2
003F10  FB8102     ZE W2, W2
003F12  EB0180     CLR W3
003F14  500002     SUB W0, W2, W0
003F16  588083     SUBB W1, W3, W1
003F18  982640     MOV W0, [W12+72]
003F1A  982651     MOV W1, [W12+74]
0040E8  90782C     MOV.B [W12+58], W0
0040EA  FB8000     ZE W0, W0
0040EC  EB0080     CLR W1
0040EE  90291C     MOV [W12+82], W2
0040F0  9029AC     MOV [W12+84], W3
0040F2  510000     SUB W2, W0, W0
0040F4  598081     SUBB W3, W1, W1
0040F6  982640     MOV W0, [W12+72]
0040F8  982651     MOV W1, [W12+74]
003F1C  200070     MOV #0x7, W0
003F1E  981E20     MOV W0, [W12+52]
0040FA  200070     MOV #0x7, W0
0040FC  981E20     MOV W0, [W12+52]
0040FE  37FF10     BRA .L171
004030  981648     MOV W8, [W12+40]
004032  981659     MOV W9, [W12+42]
004034  98166A     MOV W10, [W12+44]
004036  98167B     MOV W11, [W12+46]
003E28  90187C     MOV [W12+62], W0
003E2A  9018EC     MOV [W12+60], W1
003E2C  E80100     INC W0, W2
003E2E  981E72     MOV W2, [W12+62]
003E30  500F81     SUB W0, W1, [W15]
003E32  39FFF1     BRA NC, .L118
003E34  EB0000     CLR W0
003E36  981E70     MOV W0, [W12+62]
003E38  90782C     MOV.B [W12+58], W0
003E3A  FB8000     ZE W0, W0
003E3C  EB0080     CLR W1
003E3E  90214C     MOV [W12+72], W2
003E40  9021DC     MOV [W12+74], W3
003E42  410000     ADD W2, W0, W0
003E44  498081     ADDC W3, W1, W1
003E46  982640     MOV W0, [W12+72]
003E48  982651     MOV W1, [W12+74]
003E4A  500FE0     SUB W0, #0x0, [W15]
003E4C  588FE0     SUBB W1, #0x0, [W15]
003E4E  35FFE3     BRA LT, .L118
003E50  200020     MOV #0x2, W0
003E52  981E20     MOV W0, [W12+52]
003F2C  90187C     MOV [W12+62], W0
003F2E  9018EC     MOV [W12+60], W1
003F30  E80100     INC W0, W2
003F32  981E72     MOV W2, [W12+62]
003F34  500F81     SUB W0, W1, [W15]
003F36  39FF6F     BRA NC, .L118
003F38  EB0000     CLR W0
003F3A  981E70     MOV W0, [W12+62]
003F3C  90193C     MOV [W12+54], W2
003F3E  9019CC     MOV [W12+56], W3
003F40  907A2C     MOV.B [W12+58], W4
003F42  FB8204     ZE W4, W4
003F44  EB0280     CLR W5
003F46  410204     ADD W2, W4, W4
003F48  498285     ADDC W3, W5, W5
003F4A  90086C     MOV [W12+28], W0
003F4C  9008FC     MOV [W12+30], W1
003F4E  520F80     SUB W4, W0, [W15]
003F50  5A8F81     SUBB W5, W1, [W15]
003F52  360004     BRA LEU, .L152
003F54  B83360     MUL.UU W6, #0x0, W6
003F56  981E36     MOV W6, [W12+54]
003F58  981E47     MOV W7, [W12+56]
003F5A  B81160     MUL.UU W2, #0x0, W2
003F5C  EB4400     CLR.B W8
003F5E  FB8388     ZE W8, W7
003F8A  90204C     MOV [W12+72], W0
003F8C  9020DC     MOV [W12+74], W1
003F8E  500102     SUB W0, W2, W2
003F90  588183     SUBB W1, W3, W3
003F92  90202C     MOV [W12+68], W0
003F94  9020BC     MOV [W12+70], W1
003F96  510F80     SUB W2, W0, [W15]
003F98  598F81     SUBB W3, W1, [W15]
003F9A  3E0074     BRA GTU, .L169
00408C  500F82     SUB W0, W2, [W15]
00408E  588F83     SUBB W1, W3, [W15]
004090  39FEC2     BRA NC, .L118
004084  902A1C     MOV [W12+82], W4
004086  902AAC     MOV [W12+84], W5
004088  420102     ADD W4, W2, W2
00408A  4A8183     ADDC W5, W3, W3
003F9C  EB0000     CLR W0
003F9E  981E20     MOV W0, [W12+52]
004092  EB0000     CLR W0
004094  981E20     MOV W0, [W12+52]
004096  37FF84     BRA .L170
003E16  BE064F     MOV.D [--W15], W12
003E18  BE054F     MOV.D [--W15], W10
003E1A  BE044F     MOV.D [--W15], W8
003E1C  FA8000     ULNK
003E1E  060000     RETURN
003E54  BE064F     MOV.D [--W15], W12
003E56  BE054F     MOV.D [--W15], W10
003E58  BE044F     MOV.D [--W15], W8
003E5A  FA8000     ULNK
003E5C  060000     RETURN
003E5E  37FFE0     BRA .L126, .L172
003F20  BE064F     MOV.D [--W15], W12
003F22  BE054F     MOV.D [--W15], W10
003F24  BE044F     MOV.D [--W15], W8
003F26  FA8000     ULNK
003F28  060000     RETURN
003F2A  37FF7A     BRA .L126, .L172
003FA0  BE064F     MOV.D [--W15], W12
003FA2  BE054F     MOV.D [--W15], W10
003FA4  BE044F     MOV.D [--W15], W8
003FA6  FA8000     ULNK
003FA8  060000     RETURN
003FAA  37FF3A     BRA .L126, .L172
00400C  BE064F     MOV.D [--W15], W12
00400E  BE054F     MOV.D [--W15], W10
004010  BE044F     MOV.D [--W15], W8
004012  FA8000     ULNK
004014  060000     RETURN
004016  37FF04     BRA .L126, .L172
004024  BE064F     MOV.D [--W15], W12
004026  BE054F     MOV.D [--W15], W10
004028  BE044F     MOV.D [--W15], W8
00402A  FA8000     ULNK
00402C  060000     RETURN
00402E  37FEF8     BRA .L126, .L172
004038  BE064F     MOV.D [--W15], W12
00403A  BE054F     MOV.D [--W15], W10
00403C  BE044F     MOV.D [--W15], W8
00403E  FA8000     ULNK
004040  060000     RETURN
004042  37FEEE     BRA .L126, .L172
004054  BE064F     MOV.D [--W15], W12
004056  BE054F     MOV.D [--W15], W10
004058  BE044F     MOV.D [--W15], W8
00405A  FA8000     ULNK
00405C  060000     RETURN
00405E  37FEE0     BRA .L126, .L172
0040DC  BE064F     MOV.D [--W15], W12
0040DE  BE054F     MOV.D [--W15], W10
0040E0  BE044F     MOV.D [--W15], W8
0040E2  FA8000     ULNK
0040E4  060000     RETURN
0040E6  37FE9C     BRA .L126, .L172
004118  907140     MOV.B [W0+52], W2
00411A  784882     MOV.B W2, [W1]
00411C  907A30     MOV.B [W0+59], W4
00411E  984094     MOV.B W4, [W1+1]
004120  907940     MOV.B [W0+60], W2
004122  9840A2     MOV.B W2, [W1+2]
004124  907A50     MOV.B [W0+61], W4
004126  9840B4     MOV.B W4, [W1+3]
004128  907160     MOV.B [W0+54], W2
00412A  9840C2     MOV.B W2, [W1+4]
00412C  901930     MOV [W0+54], W2
00412E  9019C0     MOV [W0+56], W3
004130  DD1A48     SL W3, #8, W4
004132  DE1148     LSR W2, #8, W2
004134  720102     IOR W4, W2, W2
004136  DE19C8     LSR W3, #8, W3
004138  9840D2     MOV.B W2, [W1+5]
00413A  907900     MOV.B [W0+56], W2
00413C  9840E2     MOV.B W2, [W1+6]
00413E  907A10     MOV.B [W0+57], W4
004140  9840F4     MOV.B W4, [W1+7]
004142  905920     MOV.B [W0+26], W2
004144  984882     MOV.B W2, [W1+8]
004146  900950     MOV [W0+26], W2
004148  DE91CF     ASR W2, #15, W3
00414A  DD1A48     SL W3, #8, W4
00414C  DE1148     LSR W2, #8, W2
00414E  720102     IOR W4, W2, W2
004150  DE19C8     LSR W3, #8, W3
004152  984892     MOV.B W2, [W1+9]
004154  900950     MOV [W0+26], W2
004156  DE91CF     ASR W2, #15, W3
004158  9848A3     MOV.B W3, [W1+10]
00415A  900950     MOV [W0+26], W2
00415C  DE91CF     ASR W2, #15, W3
00415E  DE1948     LSR W3, #8, W2
004160  9848B2     MOV.B W2, [W1+11]
004162  90C140     MOV.B [W0+68], W2
004164  9848C2     MOV.B W2, [W1+12]
004166  902120     MOV [W0+68], W2
004168  9021B0     MOV [W0+70], W3
00416A  DD1A48     SL W3, #8, W4
00416C  DE1148     LSR W2, #8, W2
00416E  720102     IOR W4, W2, W2
004170  9848D2     MOV.B W2, [W1+13]
004172  90C160     MOV.B [W0+70], W2
004174  9848E2     MOV.B W2, [W1+14]
004176  90C270     MOV.B [W0+71], W4
004178  9848F4     MOV.B W4, [W1+15]
00417A  90C900     MOV.B [W0+72], W2
00417C  985082     MOV.B W2, [W1+16]
00417E  902140     MOV [W0+72], W2
004180  9021D0     MOV [W0+74], W3
004182  DD1A48     SL W3, #8, W4
004184  DE1148     LSR W2, #8, W2
004186  720102     IOR W4, W2, W2
004188  985092     MOV.B W2, [W1+17]
00418A  90C920     MOV.B [W0+74], W2
00418C  9850A2     MOV.B W2, [W1+18]
00418E  90CA30     MOV.B [W0+75], W4
004190  9850B4     MOV.B W4, [W1+19]
004192  90D120     MOV.B [W0+82], W2
004194  9850C2     MOV.B W2, [W1+20]
004196  902910     MOV [W0+82], W2
004198  9029A0     MOV [W0+84], W3
00419A  DD1A48     SL W3, #8, W4
00419C  DE1148     LSR W2, #8, W2
00419E  720102     IOR W4, W2, W2
0041A0  DE19C8     LSR W3, #8, W3
0041A2  9850D2     MOV.B W2, [W1+21]
0041A4  90D140     MOV.B [W0+84], W2
0041A6  9850E2     MOV.B W2, [W1+22]
0041A8  90D250     MOV.B [W0+85], W4
0041AA  9850F4     MOV.B W4, [W1+23]
0041AC  905940     MOV.B [W0+28], W2
0041AE  985882     MOV.B W2, [W1+24]
0041B0  900960     MOV [W0+28], W2
0041B2  9009F0     MOV [W0+30], W3
0041B4  DD1A48     SL W3, #8, W4
0041B6  DE1148     LSR W2, #8, W2
0041B8  720102     IOR W4, W2, W2
0041BA  DE19C8     LSR W3, #8, W3
0041BC  985892     MOV.B W2, [W1+25]
0041BE  905960     MOV.B [W0+30], W2
0041C0  9858A2     MOV.B W2, [W1+26]
0041C2  905870     MOV.B [W0+31], W0
0041C4  9858B0     MOV.B W0, [W1+27]
0041C6  B3C820     MOV.B #0x82, W0
0041C8  9858C0     MOV.B W0, [W1+28]
0041CA  0501D0     RETLW #0x1D, W0
0043B4  410064     ADD W2, #0x4, W0
0043E8  410064     ADD W2, #0x4, W0
004430  428064     ADD W5, #0x4, W0
0044EC  4280EC     ADD W5, #0xC, W1
0045BA  418064     ADD W3, #0x4, W0
0045BC  97E8EF     MOV.B [W15-18], W1
0047A0  418064     ADD W3, #0x4, W0
0047A2  97E8EF     MOV.B [W15-18], W1
0047DC  410064     ADD W2, #0x4, W0
0048F4  41006C     ADD W2, #0xC, W0
0041CC  B0026F     ADD #0x26, W15
0041CE  BE9F88     MOV.D W8, [W15++]
0041D0  BE9F8A     MOV.D W10, [W15++]
0041D2  BE9F8C     MOV.D W12, [W15++]
0041D4  781F8E     MOV W14, [W15++]
0041D6  BE0400     MOV.D W0, W8
0041D8  784682     MOV.B W2, W13
0041DC  56CFE3     SUB.B W13, #0x3, [W15]
0041DE  3600C6     BRA LEU, .L178
0041DA  B3C01A     MOV.B #0x1, W10
0041E0  780609     MOV W9, W12
0041E2  78405C     MOV.B [++W12], W0
0041E4  504FE8     SUB.B W0, #0x8, [W15]
0041E6  3E00C2     BRA GTU, .L178
0041E8  E00400     CP0.B W0
0041EA  3200C0     BRA Z, .L178
0041EC  EB0080     CLR W1
0041EE  981C21     MOV W1, [W8+52]
0041F0  EB4000     CLR.B W0
0041F2  987C31     MOV.B W1, [W8+59]
0041F4  982401     MOV W1, [W8+64]
0041F6  B81160     MUL.UU W2, #0x0, W2
0041F8  981C32     MOV W2, [W8+54]
0041FA  981C43     MOV W3, [W8+56]
0041FC  904139     MOV.B [W9+3], W2
0041FE  DD1148     SL W2, #8, W2
004200  9040A9     MOV.B [W9+2], W1
004202  FB8081     ZE W1, W1
004204  410081     ADD W2, W1, W1
004206  981C61     MOV W1, [W8+60]
004208  981C71     MOV W1, [W8+62]
00420A  B82260     MUL.UU W4, #0x0, W4
00420C  B83360     MUL.UU W6, #0x0, W6
00420E  981444     MOV W4, [W8+40]
004210  981455     MOV W5, [W8+42]
004212  981466     MOV W6, [W8+44]
004214  981477     MOV W7, [W8+46]
004216  987C20     MOV.B W0, [W8+58]
004218  B3C021     MOV.B #0x2, W1
00421A  98C421     MOV.B W1, [W8+66]
00421C  98CC40     MOV.B W0, [W8+76]
00421E  B82260     MUL.UU W4, #0x0, W4
004220  982444     MOV W4, [W8+72]
004222  982455     MOV W5, [W8+74]
004224  E0041C     CP0.B [W12]
004226  3202A7     BRA Z, .L232
004228  B3C04A     MOV.B #0x4, W10
00422A  784580     MOV.B W0, W11
00422C  78070C     MOV W12, W14
00422E  9FE7ED     MOV.B W13, [W15-26]
004230  E8408A     INC.B W10, W1
004294  15CF9E     SUBR.B W11, [W14], [W15]
004296  3EFFCC     BRA GTU, .L193
004298  78060E     MOV W14, W12
00429A  97E6EF     MOV.B [W15-26], W13
00429C  FB808A     ZE W10, W1
00429E  E8450A     INC.B W10, W10
0042A0  FB800A     ZE W10, W0
0042A2  E8458A     INC.B W10, W11
0044CE  15CF9E     SUBR.B W11, [W14], [W15]
0044D0  3EFEAF     BRA GTU, .L193
0044D2  37FEE2     BRA .L298
004548  15CF9E     SUBR.B W11, [W14], [W15]
00454A  3EFE72     BRA GTU, .L193
00454C  37FEA5     BRA .L298
00458A  15CF9E     SUBR.B W11, [W14], [W15]
00458C  3EFE51     BRA GTU, .L193
00458E  37FE84     BRA .L298
004776  B3C06B     MOV.B #0x6, W11
004778  200050     MOV #0x5, W0
00477A  200041     MOV #0x4, W1
00477C  37FD93     BRA .L179
004232  FB800A     ZE W10, W0
004234  784069     MOV.B [W9+W0], W0
004236  504FE1     SUB.B W0, #0x1, [W15]
004238  3200E1     BRA Z, .L181
00423A  31009F     BRA C, .L290, .L301
00437A  504FE2     SUB.B W0, #0x2, [W15]
00437C  320025     BRA Z, .L182
00437E  504FE3     SUB.B W0, #0x3, [W15]
004380  320009     BRA Z, .L293
0043FC  FB8081     ZE W1, W1
0043FE  78C1E9     MOV.B [W9+W1], W3
004400  448601     ADD W9, W1, W12
004402  90421C     MOV.B [W12+1], W4
00450A  DD20C8     SL W4, #8, W1
00450C  FB8183     ZE W3, W3
00450E  408083     ADD W1, W3, W1
004404  9040AC     MOV.B [W12+2], W1
004406  90433C     MOV.B [W12+3], W6
004420  DD3348     SL W6, #8, W6
004422  FB8081     ZE W1, W1
004424  430301     ADD W6, W1, W6
004408  809352     MOV 0x126A, W2
00440A  780292     MOV [W2], W5
0044DA  E00000     CP0 W0
0044DC  32FF52     BRA Z, .L267
0044DE  780310     MOV [W0], W6
0044E0  900292     MOV [W2+2], W5
004504  E00005     CP0 W5
004506  32FF3D     BRA Z, .L267
004508  FB868B     ZE W11, W13
004510  900155     MOV [W5+10], W2
004512  010002     CALL W2
004514  E8008D     INC W13, W1
004516  408081     ADD W1, W1, W1
004518  78B400     MOV W0, [W8+W1]
00451A  E00000     CP0 W0
00451C  32FF32     BRA Z, .L267
0043C8  FB8081     ZE W1, W1
0043CA  448601     ADD W9, W1, W12
0043CC  9040AC     MOV.B [W12+2], W1
0043CE  9041BC     MOV.B [W12+3], W3
0043D8  DD19C8     SL W3, #8, W3
0043DA  FB8081     ZE W1, W1
0043DC  418181     ADD W3, W1, W3
0043D0  809350     MOV 0x126A, W0
0043D2  780110     MOV [W0], W2
004554  E00001     CP0 W1
004556  32FF15     BRA Z, .L267
004558  FB868B     ZE W11, W13
00455A  E8000D     INC W13, W0
00455C  400000     ADD W0, W0, W0
00455E  783401     MOV W1, [W8+W0]
004394  FB8081     ZE W1, W1
004396  448601     ADD W9, W1, W12
004398  9040AC     MOV.B [W12+2], W1
00439A  9041BC     MOV.B [W12+3], W3
0043A4  DD19C8     SL W3, #8, W3
0043A6  FB8081     ZE W1, W1
0043A8  418181     ADD W3, W1, W3
00439C  809350     MOV 0x126A, W0
00439E  780110     MOV [W0], W2
004498  E00001     CP0 W1
00449A  32FF73     BRA Z, .L267
00449C  FB868B     ZE W11, W13
00449E  E8000D     INC W13, W0
0044A0  400000     ADD W0, W0, W0
0044A2  783411     MOV [W1], [W8+W0]
00423C  FB868B     ZE W11, W13
00423E  FB8081     ZE W1, W1
004240  E8000D     INC W13, W0
004242  400000     ADD W0, W0, W0
004244  448601     ADD W9, W1, W12
004246  90411C     MOV.B [W12+1], W2
004248  FB8102     ZE W2, W2
00424A  EB0180     CLR W3
00424C  DD1A48     SL W3, #8, W4
00424E  DE12C8     LSR W2, #8, W5
004250  720285     IOR W4, W5, W5
004252  DD1248     SL W2, #8, W4
00425A  410204     ADD W2, W4, W4
00425C  498285     ADDC W3, W5, W5
00425E  78C169     MOV.B [W9+W1], W2
004260  FB8102     ZE W2, W2
004262  EB0180     CLR W3
004264  410104     ADD W2, W4, W2
004266  498185     ADDC W3, W5, W3
004254  90412C     MOV.B [W12+2], W2
004256  FB8182     ZE W2, W3
004258  200002     MOV #0x0, W2
004268  783402     MOV W2, [W8+W0]
00426A  90404C     MOV.B [W12+4], W0
00426C  44068D     ADD W8, W13, W13
00426E  9856A0     MOV.B W0, [W13+18]
0044A4  90404C     MOV.B [W12+4], W0
0044A6  44068D     ADD W8, W13, W13
0044A8  9856A0     MOV.B W0, [W13+18]
00451E  90404C     MOV.B [W12+4], W0
004520  44068D     ADD W8, W13, W13
004522  9856A0     MOV.B W0, [W13+18]
004560  90404C     MOV.B [W12+4], W0
004562  44068D     ADD W8, W13, W13
004564  9856A0     MOV.B W0, [W13+18]
004270  907928     MOV.B [W8+58], W2
004272  404102     ADD.B W0, W2, W2
004274  987C22     MOV.B W2, [W8+58]
0044AA  907928     MOV.B [W8+58], W2
0044AC  404102     ADD.B W0, W2, W2
0044AE  987C22     MOV.B W2, [W8+58]
004524  907928     MOV.B [W8+58], W2
004526  404102     ADD.B W0, W2, W2
004528  987C22     MOV.B W2, [W8+58]
004566  907928     MOV.B [W8+58], W2
004568  404102     ADD.B W0, W2, W2
00456A  987C22     MOV.B W2, [W8+58]
004276  90C0A8     MOV.B [W8+66], W1
004278  40C000     ADD.B W1, W0, W0
00427A  98C420     MOV.B W0, [W8+66]
0044B0  90C0A8     MOV.B [W8+66], W1
0044B2  40C000     ADD.B W1, W0, W0
0044B4  98C420     MOV.B W0, [W8+66]
00452A  90C0A8     MOV.B [W8+66], W1
00452C  40C000     ADD.B W1, W0, W0
00452E  98C420     MOV.B W0, [W8+66]
00456C  90C0A8     MOV.B [W8+66], W1
00456E  40C000     ADD.B W1, W0, W0
004570  98C420     MOV.B W0, [W8+66]
004288  560000     SUB W12, W0, W0
00428A  5E8081     SUBB W13, W1, W1
00428C  982C10     MOV W0, [W8+82]
00428E  982C21     MOV W1, [W8+84]
004290  454566     ADD.B W10, #0x6, W10
0044C2  560000     SUB W12, W0, W0
0044C4  5E8081     SUBB W13, W1, W1
0044C6  982C10     MOV W0, [W8+82]
0044C8  982C21     MOV W1, [W8+84]
0044CA  454566     ADD.B W10, #0x6, W10
00453C  560000     SUB W12, W0, W0
00453E  5E8081     SUBB W13, W1, W1
004540  982C10     MOV W0, [W8+82]
004542  982C21     MOV W1, [W8+84]
004544  454566     ADD.B W10, #0x6, W10
00457E  560000     SUB W12, W0, W0
004580  5E8081     SUBB W13, W1, W1
004582  982C10     MOV W0, [W8+82]
004584  982C21     MOV W1, [W8+84]
004586  454566     ADD.B W10, #0x6, W10
00427C  900E68     MOV [W8+28], W12
00427E  900EF8     MOV [W8+30], W13
004280  FB8102     ZE W2, W2
004282  EB0180     CLR W3
004284  BE000C     MOV.D W12, W0
004286  07E5FF     RCALL ___umodsi3
0044B6  900E68     MOV [W8+28], W12
0044B8  900EF8     MOV [W8+30], W13
0044BA  FB8102     ZE W2, W2
0044BC  EB0180     CLR W3
0044BE  BE000C     MOV.D W12, W0
0044C0  07E4E2     RCALL ___umodsi3
004530  900E68     MOV [W8+28], W12
004532  900EF8     MOV [W8+30], W13
004534  FB8102     ZE W2, W2
004536  EB0180     CLR W3
004538  BE000C     MOV.D W12, W0
00453A  07E4A5     RCALL ___umodsi3
004572  900E68     MOV [W8+28], W12
004574  900EF8     MOV [W8+30], W13
004576  FB8102     ZE W2, W2
004578  EB0180     CLR W3
00457A  BE000C     MOV.D W12, W0
00457C  07E484     RCALL ___umodsi3
004292  E8458B     INC.B W11, W11
0044CC  E8458B     INC.B W11, W11
004546  E8458B     INC.B W11, W11
004588  E8458B     INC.B W11, W11
0042A4  78C0E9     MOV.B [W9+W1], W1
0042A6  9FEFE1     MOV.B W1, [W15-18]
0042A8  987421     MOV.B W1, [W8+50]
0042AA  784069     MOV.B [W9+W0], W0
0042AC  504FE1     SUB.B W0, #0x1, [W15]
0042AE  320283     BRA Z, .L195
0042B0  31016F     BRA C, .L291
004590  504FE2     SUB.B W0, #0x2, [W15]
004592  3200F5     BRA Z, .L196
004594  504FE3     SUB.B W0, #0x3, [W15]
004596  3AFEF5     BRA NZ, .L267
0047B6  FB808B     ZE W11, W1
0047B8  78C3E9     MOV.B [W9+W1], W7
0047BA  448081     ADD W9, W1, W1
0047BC  904311     MOV.B [W1+1], W6
004912  DD30C8     SL W6, #8, W1
004914  FB8007     ZE W7, W0
004916  408080     ADD W1, W0, W1
0047BE  9041A1     MOV.B [W1+2], W3
0047C0  9040B1     MOV.B [W1+3], W1
0047CC  DD08C8     SL W1, #8, W1
0047CE  FB8183     ZE W3, W3
0047D0  408183     ADD W1, W3, W3
0047C2  809355     MOV 0x126A, W5
0047C4  780115     MOV [W5], W2
0048E2  E00004     CP0 W4
0048E4  32FD43     BRA Z, .L178
0047C6  784500     MOV.B W0, W10
0048DA  B3C01A     MOV.B #0x1, W10
0048E6  780194     MOV [W4], W3
0048E8  900115     MOV [W5+2], W2
00490E  E00002     CP0 W2
004910  32FD2D     BRA Z, .L178
004908  B3C01A     MOV.B #0x1, W10
004918  900152     MOV [W2+10], W2
00491A  780004     MOV W4, W0
00491C  010002     CALL W2
00491E  981C00     MOV W0, [W8+48]
004920  E00000     CP0 W0
004922  32FD24     BRA Z, .L178
004924  9072A8     MOV.B [W8+50], W5
004926  9FEFE5     MOV.B W5, [W15-18]
004928  784305     MOV.B W5, W6
00492A  37FCD8     BRA .L202
00477E  FB800B     ZE W11, W0
004780  448000     ADD W9, W0, W0
004782  904220     MOV.B [W0+2], W4
004784  904130     MOV.B [W0+3], W2
004790  DD1148     SL W2, #8, W2
004792  FB8204     ZE W4, W4
004794  410204     ADD W2, W4, W4
004786  809350     MOV 0x126A, W0
004788  780190     MOV [W0], W3
0048BA  E00000     CP0 W0
0048BC  32FD57     BRA Z, .L178
00478A  B3C01A     MOV.B #0x1, W10
0048B2  B3C01A     MOV.B #0x1, W10
004598  FB800B     ZE W11, W0
00459A  448000     ADD W9, W0, W0
00459C  904220     MOV.B [W0+2], W4
00459E  904130     MOV.B [W0+3], W2
0045AA  DD1148     SL W2, #8, W2
0045AC  FB8204     ZE W4, W4
0045AE  410204     ADD W2, W4, W4
0045A0  809350     MOV 0x126A, W0
0045A2  780190     MOV [W0], W3
0048CE  E00000     CP0 W0
0048D0  32FD4D     BRA Z, .L178
0045A4  B3C01A     MOV.B #0x1, W10
0048C6  B3C01A     MOV.B #0x1, W10
0048BE  981C00     MOV W0, [W8+48]
0048C0  97EB6F     MOV.B [W15-18], W6
0048D2  780010     MOV [W0], W0
0048D4  981C00     MOV W0, [W8+48]
0048D6  97EB6F     MOV.B [W15-18], W6
0048D8  37FD01     BRA .L202
0048C2  37FD0C     BRA .L202
0048C4  9FEFE1     MOV.B W1, [W15-18]
0042B2  FB820B     ZE W11, W4
0042B4  448004     ADD W9, W4, W0
0042B6  904110     MOV.B [W0+1], W2
0042B8  FB8102     ZE W2, W2
0042BA  EB0180     CLR W3
0042BC  DD1B48     SL W3, #8, W6
0042BE  DE13C8     LSR W2, #8, W7
0042C0  730387     IOR W6, W7, W7
0042C2  DD1348     SL W2, #8, W6
0042CA  410306     ADD W2, W6, W6
0042CC  498387     ADDC W3, W7, W7
0042CE  7A4169     MOV.B [W9+W4], W2
0042D0  FB8102     ZE W2, W2
0042D2  EB0180     CLR W3
0042D4  410106     ADD W2, W6, W2
0042D6  498187     ADDC W3, W7, W3
0042C4  904120     MOV.B [W0+2], W2
0042C6  FB8182     ZE W2, W3
0042C8  200002     MOV #0x0, W2
0042D8  981C02     MOV W2, [W8+48]
0042DA  97EB6F     MOV.B [W15-18], W6
0042DC  45C5E4     ADD.B W11, #0x4, W11
0042DE  9FEFFB     MOV.B W11, [W15-17]
0042E0  63476F     AND.B W6, #0xF, W14
0042E2  574FE2     SUB.B W14, #0x2, [W15]
0042E4  320285     BRA Z, .L208
0042E6  3E019E     BRA GTU, .L211
0042E8  574FE1     SUB.B W14, #0x1, [W15]
0042EA  3A004B     BRA NZ, .L267
004624  574FE4     SUB.B W14, #0x4, [W15]
004626  3200F3     BRA Z, .L209
004628  574FE8     SUB.B W14, #0x8, [W15]
00462A  3AFEAB     BRA NZ, .L267
0042EC  97EBFF     MOV.B [W15-17], W7
0042EE  FB8187     ZE W7, W3
0042F0  79C269     MOV.B [W9+W3], W4
0042F2  FB8204     ZE W4, W4
0042F4  EB0280     CLR W5
0042F6  B83360     MUL.UU W6, #0x0, W6
0042F8  981404     MOV W4, [W8+32]
0042FA  981415     MOV W5, [W8+34]
0042FC  981426     MOV W6, [W8+36]
0042FE  981437     MOV W7, [W8+38]
0047F2  FB820A     ZE W10, W4
0047F4  448184     ADD W9, W4, W3
0047F6  904193     MOV.B [W3+1], W3
0047F8  DD19C8     SL W3, #8, W3
0047FA  7A4269     MOV.B [W9+W4], W4
0047FC  FB8204     ZE W4, W4
0047FE  418204     ADD W3, W4, W4
004800  EB0280     CLR W5
004802  B83360     MUL.UU W6, #0x0, W6
004804  981404     MOV W4, [W8+32]
004806  981415     MOV W5, [W8+34]
004808  981426     MOV W6, [W8+36]
00480A  981437     MOV W7, [W8+38]
00480C  37FD79     BRA .L212
00480E  97EDFF     MOV.B [W15-17], W11
004810  FB830B     ZE W11, W6
004812  448186     ADD W9, W6, W3
004814  904213     MOV.B [W3+1], W4
004816  FB8204     ZE W4, W4
004818  EB0280     CLR W5
00481A  DD2D48     SL W5, #8, W10
00481C  DE25C8     LSR W4, #8, W11
00481E  75058B     IOR W10, W11, W11
004820  DD2548     SL W4, #8, W10
004828  42050A     ADD W4, W10, W10
00482A  4A858B     ADDC W5, W11, W11
00482C  7B4269     MOV.B [W9+W6], W4
00482E  FB8204     ZE W4, W4
004830  EB0280     CLR W5
004832  42050A     ADD W4, W10, W10
004834  4A858B     ADDC W5, W11, W11
004840  B83360     MUL.UU W6, #0x0, W6
004842  981404     MOV W4, [W8+32]
004844  981415     MOV W5, [W8+34]
004846  981426     MOV W6, [W8+36]
004848  981437     MOV W7, [W8+38]
004822  904223     MOV.B [W3+2], W4
004824  FB8284     ZE W4, W5
004826  200004     MOV #0x0, W4
004836  904233     MOV.B [W3+3], W4
004838  DD22C8     SL W4, #8, W5
00483A  200004     MOV #0x0, W4
00483C  42020A     ADD W4, W10, W4
00483E  4A828B     ADDC W5, W11, W5
00484A  37FD5A     BRA .L212
00462C  97E87F     MOV.B [W15-17], W0
00462E  FB8500     ZE W0, W10
004630  44808A     ADD W9, W10, W1
004632  9FBF81     MOV W1, [W15-16]
004634  904591     MOV.B [W1+1], W11
004636  FB820B     ZE W11, W4
004638  EB0280     CLR W5
00463A  B83360     MUL.UU W6, #0x0, W6
00463C  DD3BC8     SL W7, #8, W7
00463E  DE35C8     LSR W6, #8, W11
004640  758387     IOR W11, W7, W7
004642  DD3348     SL W6, #8, W6
004644  DE2DC8     LSR W5, #8, W11
004646  758306     IOR W11, W6, W6
004648  DD2AC8     SL W5, #8, W5
00464A  DE25C8     LSR W4, #8, W11
00464C  758285     IOR W11, W5, W5
00464E  DD2248     SL W4, #8, W4
004650  9FB7B4     MOV W4, [W15-26]
004652  9FB7C5     MOV W5, [W15-24]
004654  9FB7D6     MOV W6, [W15-22]
004656  9FB7E7     MOV W7, [W15-20]
004668  97B03F     MOV [W15-26], W0
00466A  97B0CF     MOV [W15-24], W1
00466C  97B15F     MOV [W15-22], W2
00466E  97B1EF     MOV [W15-20], W3
004670  400004     ADD W0, W4, W0
004672  488085     ADDC W1, W5, W1
004674  490106     ADDC W2, W6, W2
004676  498187     ADDC W3, W7, W3
004678  9FAFB0     MOV W0, [W15-42]
00467A  9FAFC1     MOV W1, [W15-40]
00467C  9FAFD2     MOV W2, [W15-38]
00467E  9FAFE3     MOV W3, [W15-36]
004680  7D4269     MOV.B [W9+W10], W4
004682  FB8004     ZE W4, W0
004684  EB0080     CLR W1
004686  B81160     MUL.UU W2, #0x0, W2
004688  97AA3F     MOV [W15-42], W4
00468A  97AACF     MOV [W15-40], W5
00468C  97AB5F     MOV [W15-38], W6
00468E  97ABEF     MOV [W15-36], W7
004690  420200     ADD W4, W0, W4
004692  4A8281     ADDC W5, W1, W5
004694  4B0302     ADDC W6, W2, W6
004696  4B8383     ADDC W7, W3, W7
004698  9FB7B4     MOV W4, [W15-26]
00469A  9FB7C5     MOV W5, [W15-24]
00469C  9FB7D6     MOV W6, [W15-22]
00469E  9FB7E7     MOV W7, [W15-20]
004658  904021     MOV.B [W1+2], W0
00465A  FB8200     ZE W0, W4
00465C  EB0280     CLR W5
00465E  B83360     MUL.UU W6, #0x0, W6
004660  780386     MOV W6, W7
004662  780305     MOV W5, W6
004664  780284     MOV W4, W5
004666  EB0200     CLR W4
0046A0  97BA8F     MOV [W15-16], W5
0046A2  904235     MOV.B [W5+3], W4
0046A4  FB8004     ZE W4, W0
0046A6  EB0080     CLR W1
0046A8  B81160     MUL.UU W2, #0x0, W2
0046AA  DD11C8     SL W2, #8, W3
0046AC  DE0A48     LSR W1, #8, W4
0046AE  720183     IOR W4, W3, W3
0046B0  DD0948     SL W1, #8, W2
0046B2  DE0248     LSR W0, #8, W4
0046B4  720102     IOR W4, W2, W2
0046B6  DD00C8     SL W0, #8, W1
0046B8  EB0000     CLR W0
0046BA  97B23F     MOV [W15-26], W4
0046BC  97B2CF     MOV [W15-24], W5
0046BE  97B35F     MOV [W15-22], W6
0046C0  97B3EF     MOV [W15-20], W7
0046C2  420000     ADD W4, W0, W0
0046C4  4A8081     ADDC W5, W1, W1
0046C6  4B0102     ADDC W6, W2, W2
0046C8  4B8183     ADDC W7, W3, W3
0046CA  9FAFB0     MOV W0, [W15-42]
0046CC  9FAFC1     MOV W1, [W15-40]
0046CE  9FAFD2     MOV W2, [W15-38]
0046D0  9FAFE3     MOV W3, [W15-36]
0046E0  97AA3F     MOV [W15-42], W4
0046E2  97AACF     MOV [W15-40], W5
0046E4  97AB5F     MOV [W15-38], W6
0046E6  97ABEF     MOV [W15-36], W7
0046E8  420000     ADD W4, W0, W0
0046EA  4A8081     ADDC W5, W1, W1
0046EC  4B0102     ADDC W6, W2, W2
0046EE  4B8183     ADDC W7, W3, W3
0046F0  9FB7B0     MOV W0, [W15-26]
0046F2  9FB7C1     MOV W1, [W15-24]
0046F4  9FB7D2     MOV W2, [W15-22]
0046F6  9FB7E3     MOV W3, [W15-20]
0046D2  97BA8F     MOV [W15-16], W5
0046D4  904245     MOV.B [W5+4], W4
0046D6  FB8004     ZE W4, W0
0046D8  EB0080     CLR W1
0046DA  B81160     MUL.UU W2, #0x0, W2
0046DC  BE0100     MOV.D W0, W2
0046DE  B80060     MUL.UU W0, #0x0, W0
0046F8  97BA8F     MOV [W15-16], W5
0046FA  904255     MOV.B [W5+5], W4
0046FC  FB8004     ZE W4, W0
0046FE  EB0080     CLR W1
004700  B81160     MUL.UU W2, #0x0, W2
004702  DD09C8     SL W1, #8, W3
004704  DE0248     LSR W0, #8, W4
004706  720183     IOR W4, W3, W3
004708  DD0148     SL W0, #8, W2
00470A  B80060     MUL.UU W0, #0x0, W0
00470C  97B23F     MOV [W15-26], W4
00470E  97B2CF     MOV [W15-24], W5
004710  97B35F     MOV [W15-22], W6
004712  97B3EF     MOV [W15-20], W7
004714  420000     ADD W4, W0, W0
004716  4A8081     ADDC W5, W1, W1
004718  4B0102     ADDC W6, W2, W2
00471A  4B8183     ADDC W7, W3, W3
00471C  9FAFB0     MOV W0, [W15-42]
00471E  9FAFC1     MOV W1, [W15-40]
004720  9FAFD2     MOV W2, [W15-38]
004722  9FAFE3     MOV W3, [W15-36]
004734  97AA3F     MOV [W15-42], W4
004736  97AACF     MOV [W15-40], W5
004738  97AB5F     MOV [W15-38], W6
00473A  97ABEF     MOV [W15-36], W7
00473C  420000     ADD W4, W0, W0
00473E  4A8081     ADDC W5, W1, W1
004740  4B0102     ADDC W6, W2, W2
004742  4B8183     ADDC W7, W3, W3
004744  9FB7B0     MOV W0, [W15-26]
004746  9FB7C1     MOV W1, [W15-24]
004748  9FB7D2     MOV W2, [W15-22]
00474A  9FB7E3     MOV W3, [W15-20]
004724  97BA8F     MOV [W15-16], W5
004726  904265     MOV.B [W5+6], W4
004728  FB8004     ZE W4, W0
00472A  EB0080     CLR W1
00472C  B81160     MUL.UU W2, #0x0, W2
00472E  780180     MOV W0, W3
004730  EB0100     CLR W2
004732  B80060     MUL.UU W0, #0x0, W0
00474C  97BA8F     MOV [W15-16], W5
00474E  904275     MOV.B [W5+7], W4
004750  FB8004     ZE W4, W0
004752  EB0080     CLR W1
004754  B81160     MUL.UU W2, #0x0, W2
004756  DD01C8     SL W0, #8, W3
004758  EB0100     CLR W2
00475A  B80060     MUL.UU W0, #0x0, W0
00475C  97B23F     MOV [W15-26], W4
00475E  97B2CF     MOV [W15-24], W5
004760  97B35F     MOV [W15-22], W6
004762  97B3EF     MOV [W15-20], W7
004764  420000     ADD W4, W0, W0
004766  4A8081     ADDC W5, W1, W1
004768  4B0102     ADDC W6, W2, W2
00476A  4B8183     ADDC W7, W3, W3
00476C  981400     MOV W0, [W8+32]
00476E  981411     MOV W1, [W8+34]
004770  981422     MOV W2, [W8+36]
004772  981433     MOV W3, [W8+38]
004774  37FDC5     BRA .L212
004382  B3C01A     MOV.B #0x1, W10
0043C4  B3C01A     MOV.B #0x1, W10
0043C6  37FFDE     BRA .L294
0043F8  B3C01A     MOV.B #0x1, W10
0043FA  37FFC4     BRA .L294
004440  B3C01A     MOV.B #0x1, W10
004442  37FFA0     BRA .L294
0044FC  B3C01A     MOV.B #0x1, W10
0044FE  37FF42     BRA .L294
0045CC  B3C01A     MOV.B #0x1, W10
0045CE  37FEDA     BRA .L294
0047B2  B3C01A     MOV.B #0x1, W10
0047B4  37FDE7     BRA .L294
0047EC  B3C01A     MOV.B #0x1, W10
0047EE  37FDCA     BRA .L294
0047F0  78450B     MOV.B W11, W10
004904  B3C01A     MOV.B #0x1, W10
004906  37FD3E     BRA .L294
004300  97EAEF     MOV.B [W15-18], W5
004302  E00405     CP0.B W5
004304  35018C     BRA LT, .L213
004306  784085     MOV.B W5, W1
004308  A05401     BSET.B W1, #5
00430A  987421     MOV.B W1, [W8+50]
00430C  97EB7F     MOV.B [W15-17], W6
00430E  434564     ADD.B W6, #0x4, W10
00461E  97EBFF     MOV.B [W15-17], W7
004620  474507     ADD.B W14, W7, W10
004622  37FE76     BRA .LBE98, .L214
004310  FB810A     ZE W10, W2
004312  448082     ADD W9, W2, W1
004314  904211     MOV.B [W1+1], W4
004316  FB8204     ZE W4, W4
004318  EB0280     CLR W5
00431A  DD2B48     SL W5, #8, W6
00431C  DE23C8     LSR W4, #8, W7
00431E  730387     IOR W6, W7, W7
004320  DD2348     SL W4, #8, W6
004322  904021     MOV.B [W1+2], W0
004324  FB8280     ZE W0, W5
004326  200004     MOV #0x0, W4
004328  420306     ADD W4, W6, W6
00432A  4A8387     ADDC W5, W7, W7
00432C  794169     MOV.B [W9+W2], W2
00432E  FB8202     ZE W2, W4
004330  EB0280     CLR W5
004332  420106     ADD W4, W6, W2
004334  4A8187     ADDC W5, W7, W3
00433C  400002     ADD W0, W2, W0
00433E  488083     ADDC W1, W3, W1
004340  982420     MOV W0, [W8+68]
004342  982431     MOV W1, [W8+70]
004336  904031     MOV.B [W1+3], W0
004338  DD00C8     SL W0, #8, W1
00433A  200000     MOV #0x0, W0
004344  0716FA     RCALL getAbsValI32
004346  982470     MOV W0, [W8+78]
004348  982C01     MOV W1, [W8+80]
00434A  454064     ADD.B W10, #0x4, W0
00434C  FB8000     ZE W0, W0
00434E  784069     MOV.B [W9+W0], W0
004350  FB8000     ZE W0, W0
004352  982C30     MOV W0, [W8+86]
004354  454565     ADD.B W10, #0x5, W10
004356  56CF8A     SUB.B W13, W10, [W15]
004358  36013B     BRA LEU, .L215
00435A  FB850A     ZE W10, W10
00435C  7D4069     MOV.B [W9+W10], W0
00435E  504FE1     SUB.B W0, #0x1, [W15]
004360  320071     BRA Z, .L292
004454  97A07F     MOV [W15-50], W0
004456  97A88F     MOV [W15-48], W1
004458  97A91F     MOV [W15-46], W2
00445A  97A9AF     MOV [W15-44], W3
00445C  981440     MOV W0, [W8+40]
00445E  981451     MOV W1, [W8+42]
004460  981462     MOV W2, [W8+44]
004462  981473     MOV W3, [W8+46]
004480  97A07F     MOV [W15-50], W0
004482  97A88F     MOV [W15-48], W1
004484  97A91F     MOV [W15-46], W2
004486  97A9AF     MOV [W15-44], W3
004488  981440     MOV W0, [W8+40]
00448A  981451     MOV W1, [W8+42]
00448C  981462     MOV W2, [W8+44]
00448E  981473     MOV W3, [W8+46]
004490  37FFE9     BRA .L297
004940  97A07F     MOV [W15-50], W0
004942  97A88F     MOV [W15-48], W1
004944  97A91F     MOV [W15-46], W2
004946  97A9AF     MOV [W15-44], W3
004948  981440     MOV W0, [W8+40]
00494A  981451     MOV W1, [W8+42]
00494C  981462     MOV W2, [W8+44]
00494E  981473     MOV W3, [W8+46]
004950  37FD89     BRA .L297
004960  97A07F     MOV [W15-50], W0
004962  97A88F     MOV [W15-48], W1
004964  97A91F     MOV [W15-46], W2
004966  97A9AF     MOV [W15-44], W3
004968  981440     MOV W0, [W8+40]
00496A  981451     MOV W1, [W8+42]
00496C  981462     MOV W2, [W8+44]
00496E  981473     MOV W3, [W8+46]
004970  37FD79     BRA .L297
00497E  97A07F     MOV [W15-50], W0
004980  97A88F     MOV [W15-48], W1
004982  97A91F     MOV [W15-46], W2
004984  97A9AF     MOV [W15-44], W3
004986  981440     MOV W0, [W8+40]
004988  981451     MOV W1, [W8+42]
00498A  981462     MOV W2, [W8+44]
00498C  981473     MOV W3, [W8+46]
00498E  37FD6A     BRA .L297
0045E0  97A87F     MOV [W15-34], W0
0045E2  97B08F     MOV [W15-32], W1
0045E4  97B11F     MOV [W15-30], W2
0045E6  97B1AF     MOV [W15-28], W3
0045E8  981440     MOV W0, [W8+40]
0045EA  981451     MOV W1, [W8+42]
0045EC  981462     MOV W2, [W8+44]
0045EE  981473     MOV W3, [W8+46]
00460C  97A87F     MOV [W15-34], W0
00460E  97B08F     MOV [W15-32], W1
004610  97B11F     MOV [W15-30], W2
004612  97B1AF     MOV [W15-28], W3
004614  981440     MOV W0, [W8+40]
004616  981451     MOV W1, [W8+42]
004618  981462     MOV W2, [W8+44]
00461A  981473     MOV W3, [W8+46]
00461C  37FFE9     BRA .L300
004860  97A87F     MOV [W15-34], W0
004862  97B08F     MOV [W15-32], W1
004864  97B11F     MOV [W15-30], W2
004866  97B1AF     MOV [W15-28], W3
004868  981440     MOV W0, [W8+40]
00486A  981451     MOV W1, [W8+42]
00486C  981462     MOV W2, [W8+44]
00486E  981473     MOV W3, [W8+46]
004870  37FEBF     BRA .L300
004880  97A87F     MOV [W15-34], W0
004882  97B08F     MOV [W15-32], W1
004884  97B11F     MOV [W15-30], W2
004886  97B1AF     MOV [W15-28], W3
004888  981440     MOV W0, [W8+40]
00488A  981451     MOV W1, [W8+42]
00488C  981462     MOV W2, [W8+44]
00488E  981473     MOV W3, [W8+46]
004890  37FEAF     BRA .L300
00489E  97A87F     MOV [W15-34], W0
0048A0  97B08F     MOV [W15-32], W1
0048A2  97B11F     MOV [W15-30], W2
0048A4  97B1AF     MOV [W15-28], W3
0048A6  981440     MOV W0, [W8+40]
0048A8  981451     MOV W1, [W8+42]
0048AA  981462     MOV W2, [W8+44]
0048AC  981473     MOV W3, [W8+46]
0048AE  37FEA0     BRA .L300
0048B0  9FEFE1     MOV.B W1, [W15-18]
004362  78461C     MOV.B [W12], W12
004364  987C3C     MOV.B W12, [W8+59]
004464  78461C     MOV.B [W12], W12
004466  987C3C     MOV.B W12, [W8+59]
0045F0  78461C     MOV.B [W12], W12
0045F2  987C3C     MOV.B W12, [W8+59]
004366  FB8019     ZE [W9], W0
004368  981C20     MOV W0, [W8+52]
004468  FB8019     ZE [W9], W0
00446A  981C20     MOV W0, [W8+52]
0045F4  FB8019     ZE [W9], W0
0045F6  981C20     MOV W0, [W8+52]
00436A  EB4500     CLR.B W10
00446C  EB4500     CLR.B W10
00446E  37FF7E     BRA .L178
0045F8  EB4500     CLR.B W10
0045FA  37FEB8     BRA .L178
00436C  78400A     MOV.B W10, W0
00436E  78074F     MOV [--W15], W14
004370  BE064F     MOV.D [--W15], W12
004372  BE054F     MOV.D [--W15], W10
004374  BE044F     MOV.D [--W15], W8
004376  B1026F     SUB #0x26, W15
004378  060000     RETURN
004384  78400A     MOV.B W10, W0
004386  78074F     MOV [--W15], W14
004388  BE064F     MOV.D [--W15], W12
00438A  BE054F     MOV.D [--W15], W10
00438C  BE044F     MOV.D [--W15], W8
00438E  B1026F     SUB #0x26, W15
004390  060000     RETURN
004392  37FFF3     BRA .L290, .L301
004410  784000     MOV.B W0, W0
004412  78074F     MOV [--W15], W14
004414  BE064F     MOV.D [--W15], W12
004416  BE054F     MOV.D [--W15], W10
004418  BE044F     MOV.D [--W15], W8
00441A  B1026F     SUB #0x26, W15
00441C  060000     RETURN
00441E  37FFAD     BRA .L290, .L301
004990  050000     RETLW #0x0, W0
0039DE  784601     MOV.B W1, W12
0039E0  504F84     SUB.B W0, W4, [W15]
0039E2  35FFE6     BRA LT, .LBB11, .L65
003A0E  784601     MOV.B W1, W12
003A10  504F84     SUB.B W0, W4, [W15]
003A12  39FFCE     BRA NC, .LBB11, .L65
003AA6  B3C01C     MOV.B #0x1, W12
003AA8  500F83     SUB W0, W3, [W15]
003AAA  35FF82     BRA LT, .LBB11, .L65
003ACC  B3C01C     MOV.B #0x1, W12
003ACE  500F83     SUB W0, W3, [W15]
003AD0  39FF6F     BRA NC, .LBB11, .L65
003B22  B3C01C     MOV.B #0x1, W12
003B24  97B23F     MOV [W15-26], W4
003B26  97B2CF     MOV [W15-24], W5
003B28  97B35F     MOV [W15-22], W6
003B2A  97B3EF     MOV [W15-20], W7
003B2C  E10004     CP W0, W4
003B2E  E18805     CPB W1, W5
003B30  E19006     CPB W2, W6
003B32  E19807     CPB W3, W7
003B34  35FF3D     BRA LT, .LBB11, .L65
003B86  B3C01C     MOV.B #0x1, W12
003B88  97B23F     MOV [W15-26], W4
003B8A  97B2CF     MOV [W15-24], W5
003B8C  97B35F     MOV [W15-22], W6
003B8E  97B3EF     MOV [W15-20], W7
003B90  E10004     CP W0, W4
003B92  E18805     CPB W1, W5
003B94  E19006     CPB W2, W6
003B96  E19807     CPB W3, W7
003B98  39FF0B     BRA NC, .LBB11, .L65
003BC2  B3C01C     MOV.B #0x1, W12
003BC4  500F86     SUB W0, W6, [W15]
003BC6  588F87     SUBB W1, W7, [W15]
003BC8  39FEF3     BRA NC, .LBB11, .L65
003BF2  B3C01C     MOV.B #0x1, W12
003BF4  500F86     SUB W0, W6, [W15]
003BF6  588F87     SUBB W1, W7, [W15]
003BF8  35FEDB     BRA LT, .LBB11, .L65
003C0E  784602     MOV.B W2, W12
003C10  504F84     SUB.B W0, W4, [W15]
003C12  3EFECE     BRA GTU, .LBB11, .L65
003C28  784602     MOV.B W2, W12
003C2A  504F84     SUB.B W0, W4, [W15]
003C2C  3CFEC1     BRA GT, .LBB11, .L65
003C42  784601     MOV.B W1, W12
003C44  500F83     SUB W0, W3, [W15]
003C46  3EFEB4     BRA GTU, .LBB11, .L65
003C5C  784601     MOV.B W1, W12
003C5E  500F83     SUB W0, W3, [W15]
003C60  3CFEA7     BRA GT, .LBB11, .L65
003C78  784602     MOV.B W2, W12
003C7A  500F86     SUB W0, W6, [W15]
003C7C  588F87     SUBB W1, W7, [W15]
003C7E  3CFE98     BRA GT, .LBB11, .L65
003C96  784602     MOV.B W2, W12
003C98  500F86     SUB W0, W6, [W15]
003C9A  588F87     SUBB W1, W7, [W15]
003C9C  3EFE89     BRA GTU, .LBB11, .L65
003CC0  784605     MOV.B W5, W12
003CC2  97B23F     MOV [W15-26], W4
003CC4  97B2CF     MOV [W15-24], W5
003CC6  97B35F     MOV [W15-22], W6
003CC8  97B3EF     MOV [W15-20], W7
003CCA  E10004     CP W0, W4
003CCC  E18805     CPB W1, W5
003CCE  E19006     CPB W2, W6
003CD0  E19807     CPB W3, W7
003CD2  3EFE6E     BRA GTU, .LBB11, .L65
003CF6  784605     MOV.B W5, W12
003CF8  97B23F     MOV [W15-26], W4
003CFA  97B2CF     MOV [W15-24], W5
003CFC  97B35F     MOV [W15-22], W6
003CFE  97B3EF     MOV [W15-20], W7
003D00  E10004     CP W0, W4
003D02  E18805     CPB W1, W5
003D04  E19006     CPB W2, W6
003D06  E19807     CPB W3, W7
003D08  3CFE53     BRA GT, .LBB11, .L65
00398E  FA0018     LNK #0x18
003990  BE9F88     MOV.D W8, [W15++]
003992  BE9F8A     MOV.D W10, [W15++]
003994  781F8C     MOV W12, [W15++]
003996  780600     MOV W0, W12
003998  9FAFF4     MOV W4, [W15-34]
00399A  9FB785     MOV W5, [W15-32]
00399C  9FB796     MOV W6, [W15-30]
00399E  9FB7A7     MOV W7, [W15-28]
0039A0  90702C     MOV.B [W12+50], W0
0039A2  6040EF     AND.B W0, #0xF, W1
0039B0  EB4600     CLR.B W12
003A48  EB4600     CLR.B W12
003A4A  37FFB3     BRA .LBE11, .L3
003A90  EB4600     CLR.B W12
003A92  37FF8F     BRA .LBE11, .L3
0039A4  A36800     BTST.Z W0, #6
0039A6  32000B     BRA Z, .L2, .L113
0039A8  50CFE4     SUB.B W1, #0x4, [W15]
0039AA  32003B     BRA Z, .LBB30, .L4
0039AC  50CFE8     SUB.B W1, #0x8, [W15]
0039AE  32004E     BRA Z, .LBB32, .L102
003A22  90104C     MOV [W12+40], W0
003A24  9010DC     MOV [W12+42], W1
003A26  90140C     MOV [W12+32], W8
003A28  90149C     MOV [W12+34], W9
003A2A  97AD7F     MOV [W15-34], W10
003A2C  97B58F     MOV [W15-32], W11
003A2E  902E3C     MOV [W12+86], W12
003A30  560FE1     SUB W12, #0x1, [W15]
003A32  320187     BRA Z, .L105
003D42  BE0108     MOV.D W8, W2
003D44  07E7C2     RCALL ___ltsf2, ___eqsf2, ___lesf2
003D46  E00000     CP0 W0
003D48  3DFE33     BRA GE, .LBB11, .L65
003D4A  BE0108     MOV.D W8, W2
003D4C  BE000A     MOV.D W10, W0
003D4E  07E7BF     RCALL ___gesf2, ___gtsf2
003D50  E00000     CP0 W0
003D52  35FE2E     BRA LT, .LBB11, .L65
003A34  BE0108     MOV.D W8, W2
003A36  07E94B     RCALL ___gesf2, ___gtsf2
003A38  E00000     CP0 W0
003A3A  34FFBA     BRA LE, .LBB11, .L65
003A3C  B3C01C     MOV.B #0x1, W12
003A3E  BE0108     MOV.D W8, W2
003A40  BE000A     MOV.D W10, W0
003A42  07E943     RCALL ___ltsf2, ___eqsf2, ___lesf2
003A44  E00000     CP0 W0
003A46  34FFB5     BRA LE, .LBE11, .L3
003A4C  90104C     MOV [W12+40], W0
003A4E  9010DC     MOV [W12+42], W1
003A50  90116C     MOV [W12+44], W2
003A52  9011FC     MOV [W12+46], W3
003A54  90140C     MOV [W12+32], W8
003A56  90149C     MOV [W12+34], W9
003A58  90152C     MOV [W12+36], W10
003A5A  9015BC     MOV [W12+38], W11
003A5C  97AA7F     MOV [W15-34], W4
003A5E  97B28F     MOV [W15-32], W5
003A60  97B31F     MOV [W15-30], W6
003A62  97B3AF     MOV [W15-28], W7
003A64  9FB7B4     MOV W4, [W15-26]
003A66  9FB7C5     MOV W5, [W15-24]
003A68  9FB7D6     MOV W6, [W15-22]
003A6A  9FB7E7     MOV W7, [W15-20]
003A6C  902E3C     MOV [W12+86], W12
003A6E  560FE1     SUB W12, #0x1, [W15]
003A70  320153     BRA Z, .L106
003D18  BE0208     MOV.D W8, W4
003D1A  BE030A     MOV.D W10, W6
003D1C  07E7CC     RCALL ___ltdf2, ___eqdf2, ___ledf2
003D1E  E00000     CP0 W0
003D20  3DFE47     BRA GE, .LBB11, .L65
003D22  BE0208     MOV.D W8, W4
003D24  BE030A     MOV.D W10, W6
003D26  97B03F     MOV [W15-26], W0
003D28  97B0CF     MOV [W15-24], W1
003D2A  97B15F     MOV [W15-22], W2
003D2C  97B1EF     MOV [W15-20], W3
003D2E  07E7C8     RCALL ___gtdf2, ___gedf2
003D30  E00000     CP0 W0
003D32  35FE3E     BRA LT, .LBB11, .L65
003A72  BE0208     MOV.D W8, W4
003A74  BE030A     MOV.D W10, W6
003A76  07E924     RCALL ___gtdf2, ___gedf2
003A78  E00000     CP0 W0
003A7A  34FF9A     BRA LE, .LBB11, .L65
003A7C  B3C01C     MOV.B #0x1, W12
003A7E  BE0208     MOV.D W8, W4
003A80  BE030A     MOV.D W10, W6
003A82  97B03F     MOV [W15-26], W0
003A84  97B0CF     MOV [W15-24], W1
003A86  97B15F     MOV [W15-22], W2
003A88  97B1EF     MOV [W15-20], W3
003A8A  07E915     RCALL ___ltdf2, ___eqdf2, ___ledf2
003A8C  E00000     CP0 W0
003A8E  34FF91     BRA LE, .LBE11, .L3
0039BE  A35800     BTST.Z W0, #5
0039C0  320018     BRA Z, .L16
0039C2  50CFE2     SUB.B W1, #0x2, [W15]
0039C4  320067     BRA Z, .LBB18, .L18
0039C6  3E008C     BRA GTU, .L21
0039C8  50CFE1     SUB.B W1, #0x1, [W15]
0039CA  3AFFF2     BRA NZ, .LBB11, .L65
003AE0  50CFE4     SUB.B W1, #0x4, [W15]
003AE2  32007A     BRA Z, .LBB23, .L19
003AE4  50CFE8     SUB.B W1, #0x8, [W15]
003AE6  3AFF64     BRA NZ, .LBB11, .L65
0039CC  90698C     MOV.B [W12+40], W3
0039CE  90600C     MOV.B [W12+32], W0
0039D0  97DA6F     MOV.B [W15-34], W4
0039D2  90293C     MOV [W12+86], W2
0039D4  510FE1     SUB W2, #0x1, [W15]
0039D6  320125     BRA Z, .L103
003C24  51CF80     SUB.B W3, W0, [W15]
003C26  3DFEC5     BRA GE, .LBE11, .L3
003C22  EB4600     CLR.B W12
0039DA  51CF80     SUB.B W3, W0, [W15]
0039DC  34FFEA     BRA LE, .LBE11, .L3
0039D8  EB4600     CLR.B W12
003A94  90114C     MOV [W12+40], W2
003A96  90100C     MOV [W12+32], W0
003A98  97A9FF     MOV [W15-34], W3
003A9A  9028BC     MOV [W12+86], W1
003A9C  508FE1     SUB W1, #0x1, [W15]
003A9E  3200DB     BRA Z, .L107
003C58  510F80     SUB W2, W0, [W15]
003C5A  3DFEAB     BRA GE, .LBE11, .L3
003C56  EB4600     CLR.B W12
003AA2  510F80     SUB W2, W0, [W15]
003AA4  34FF86     BRA LE, .LBE11, .L3
003AA0  EB4600     CLR.B W12
003BD8  90124C     MOV [W12+40], W4
003BDA  9012DC     MOV [W12+42], W5
003BDC  90100C     MOV [W12+32], W0
003BDE  90109C     MOV [W12+34], W1
003BE0  97AB7F     MOV [W15-34], W6
003BE2  97B38F     MOV [W15-32], W7
003BE4  90293C     MOV [W12+86], W2
003BE6  510FE1     SUB W2, #0x1, [W15]
003BE8  320043     BRA Z, .L112
003C72  520F80     SUB W4, W0, [W15]
003C74  5A8F81     SUBB W5, W1, [W15]
003C76  3DFE9D     BRA GE, .LBE11, .L3
003C70  EB4600     CLR.B W12
003BEC  520F80     SUB W4, W0, [W15]
003BEE  5A8F81     SUBB W5, W1, [W15]
003BF0  34FEE0     BRA LE, .LBE11, .L3
003BEA  EB4600     CLR.B W12
003AE8  90144C     MOV [W12+40], W8
003AEA  9014DC     MOV [W12+42], W9
003AEC  90156C     MOV [W12+44], W10
003AEE  9015FC     MOV [W12+46], W11
003AF0  9FB7F8     MOV W8, [W15-18]
003AF2  9FBF89     MOV W9, [W15-16]
003AF4  9FBF9A     MOV W10, [W15-14]
003AF6  9FBFAB     MOV W11, [W15-12]
003AF8  90100C     MOV [W12+32], W0
003AFA  90109C     MOV [W12+34], W1
003AFC  90112C     MOV [W12+36], W2
003AFE  9011BC     MOV [W12+38], W3
003B00  9FB7B4     MOV W4, [W15-26]
003B02  9FB7C5     MOV W5, [W15-24]
003B04  9FB7D6     MOV W6, [W15-22]
003B06  9FB7E7     MOV W7, [W15-20]
003B08  902ABC     MOV [W12+86], W5
003B0A  528FE1     SUB W5, #0x1, [W15]
003B0C  3200EA     BRA Z, .L109
003CE4  97B47F     MOV [W15-18], W8
003CE6  97BC8F     MOV [W15-16], W9
003CE8  97BD1F     MOV [W15-14], W10
003CEA  97BDAF     MOV [W15-12], W11
003CEC  E14000     CP W8, W0
003CEE  E1C801     CPB W9, W1
003CF0  E1D002     CPB W10, W2
003CF2  E1D803     CPB W11, W3
003CF4  3DFE5E     BRA GE, .LBE11, .L3
003CE2  EB4600     CLR.B W12
003B10  97B47F     MOV [W15-18], W8
003B12  97BC8F     MOV [W15-16], W9
003B14  97BD1F     MOV [W15-14], W10
003B16  97BDAF     MOV [W15-12], W11
003B18  E14000     CP W8, W0
003B1A  E1C801     CPB W9, W1
003B1C  E1D002     CPB W10, W2
003B1E  E1D803     CPB W11, W3
003B20  34FF48     BRA LE, .LBE11, .L3
003B0E  EB4600     CLR.B W12
0039F2  50CFE2     SUB.B W1, #0x2, [W15]
0039F4  320062     BRA Z, .LBB21, .L35
0039F6  3E00A6     BRA GTU, .L38
0039F8  50CFE1     SUB.B W1, #0x1, [W15]
0039FA  3AFFDA     BRA NZ, .LBB11, .L65
003B44  50CFE4     SUB.B W1, #0x4, [W15]
003B46  320030     BRA Z, .LBB16, .L36
003B48  50CFE8     SUB.B W1, #0x8, [W15]
003B4A  3AFF32     BRA NZ, .LBB11, .L65
0039FC  90698C     MOV.B [W12+40], W3
0039FE  90600C     MOV.B [W12+32], W0
003A00  97DA6F     MOV.B [W15-34], W4
003A02  90293C     MOV [W12+86], W2
003A04  510FE1     SUB W2, #0x1, [W15]
003A06  320100     BRA Z, .L104
003C0A  51CF80     SUB.B W3, W0, [W15]
003C0C  31FED2     BRA C, .LBE11, .L3
003C08  EB4600     CLR.B W12
003A0A  51CF80     SUB.B W3, W0, [W15]
003A0C  36FFD2     BRA LEU, .LBE11, .L3
003A08  EB4600     CLR.B W12
003ABA  90114C     MOV [W12+40], W2
003ABC  90100C     MOV [W12+32], W0
003ABE  97A9FF     MOV [W15-34], W3
003AC0  9028BC     MOV [W12+86], W1
003AC2  508FE1     SUB W1, #0x1, [W15]
003AC4  3200BB     BRA Z, .L108
003C3E  510F80     SUB W2, W0, [W15]
003C40  31FEB8     BRA C, .LBE11, .L3
003C3C  EB4600     CLR.B W12
003AC8  510F80     SUB W2, W0, [W15]
003ACA  36FF73     BRA LEU, .LBE11, .L3
003AC6  EB4600     CLR.B W12
003BA8  90124C     MOV [W12+40], W4
003BAA  9012DC     MOV [W12+42], W5
003BAC  90100C     MOV [W12+32], W0
003BAE  90109C     MOV [W12+34], W1
003BB0  97AB7F     MOV [W15-34], W6
003BB2  97B38F     MOV [W15-32], W7
003BB4  90293C     MOV [W12+86], W2
003BB6  510FE1     SUB W2, #0x1, [W15]
003BB8  32006A     BRA Z, .L111
003C90  520F80     SUB W4, W0, [W15]
003C92  5A8F81     SUBB W5, W1, [W15]
003C94  31FE8E     BRA C, .LBE11, .L3
003C8E  EB4600     CLR.B W12
003BBC  520F80     SUB W4, W0, [W15]
003BBE  5A8F81     SUBB W5, W1, [W15]
003BC0  36FEF8     BRA LEU, .LBE11, .L3
003BBA  EB4600     CLR.B W12
003B4C  90144C     MOV [W12+40], W8
003B4E  9014DC     MOV [W12+42], W9
003B50  90156C     MOV [W12+44], W10
003B52  9015FC     MOV [W12+46], W11
003B54  9FB7F8     MOV W8, [W15-18]
003B56  9FBF89     MOV W9, [W15-16]
003B58  9FBF9A     MOV W10, [W15-14]
003B5A  9FBFAB     MOV W11, [W15-12]
003B5C  90100C     MOV [W12+32], W0
003B5E  90109C     MOV [W12+34], W1
003B60  90112C     MOV [W12+36], W2
003B62  9011BC     MOV [W12+38], W3
003B64  9FB7B4     MOV W4, [W15-26]
003B66  9FB7C5     MOV W5, [W15-24]
003B68  9FB7D6     MOV W6, [W15-22]
003B6A  9FB7E7     MOV W7, [W15-20]
003B6C  902ABC     MOV [W12+86], W5
003B6E  528FE1     SUB W5, #0x1, [W15]
003B70  32009D     BRA Z, .L110
003CAE  97B47F     MOV [W15-18], W8
003CB0  97BC8F     MOV [W15-16], W9
003CB2  97BD1F     MOV [W15-14], W10
003CB4  97BDAF     MOV [W15-12], W11
003CB6  E14000     CP W8, W0
003CB8  E1C801     CPB W9, W1
003CBA  E1D002     CPB W10, W2
003CBC  E1D803     CPB W11, W3
003CBE  31FE79     BRA C, .LBE11, .L3
003CAC  EB4600     CLR.B W12
003B74  97B47F     MOV [W15-18], W8
003B76  97BC8F     MOV [W15-16], W9
003B78  97BD1F     MOV [W15-14], W10
003B7A  97BDAF     MOV [W15-12], W11
003B7C  E14000     CP W8, W0
003B7E  E1C801     CPB W9, W1
003B80  E1D002     CPB W10, W2
003B82  E1D803     CPB W11, W3
003B84  36FF16     BRA LEU, .LBE11, .L3
003B72  EB4600     CLR.B W12
0039B2  78400C     MOV.B W12, W0
0039B4  78064F     MOV [--W15], W12
0039B6  BE054F     MOV.D [--W15], W10
0039B8  BE044F     MOV.D [--W15], W8
0039BA  FA8000     ULNK
0039BC  060000     RETURN
0039E4  78400C     MOV.B W12, W0
0039E6  78064F     MOV [--W15], W12
0039E8  BE054F     MOV.D [--W15], W10
0039EA  BE044F     MOV.D [--W15], W8
0039EC  FA8000     ULNK
0039EE  060000     RETURN
0039F0  37FFE6     BRA .L2, .L113
003A14  78400C     MOV.B W12, W0
003A16  78064F     MOV [--W15], W12
003A18  BE054F     MOV.D [--W15], W10
003A1A  BE044F     MOV.D [--W15], W8
003A1C  FA8000     ULNK
003A1E  060000     RETURN
003A20  37FFCE     BRA .L2, .L113
003AAC  78400C     MOV.B W12, W0
003AAE  78064F     MOV [--W15], W12
003AB0  BE054F     MOV.D [--W15], W10
003AB2  BE044F     MOV.D [--W15], W8
003AB4  FA8000     ULNK
003AB6  060000     RETURN
003AB8  37FF82     BRA .L2, .L113
003AD2  78400C     MOV.B W12, W0
003AD4  78064F     MOV [--W15], W12
003AD6  BE054F     MOV.D [--W15], W10
003AD8  BE044F     MOV.D [--W15], W8
003ADA  FA8000     ULNK
003ADC  060000     RETURN
003ADE  37FF6F     BRA .L2, .L113
003B36  78400C     MOV.B W12, W0
003B38  78064F     MOV [--W15], W12
003B3A  BE054F     MOV.D [--W15], W10
003B3C  BE044F     MOV.D [--W15], W8
003B3E  FA8000     ULNK
003B40  060000     RETURN
003B42  37FF3D     BRA .L2, .L113
003B9A  78400C     MOV.B W12, W0
003B9C  78064F     MOV [--W15], W12
003B9E  BE054F     MOV.D [--W15], W10
003BA0  BE044F     MOV.D [--W15], W8
003BA2  FA8000     ULNK
003BA4  060000     RETURN
003BA6  37FF0B     BRA .L2, .L113
003BCA  78400C     MOV.B W12, W0
003BCC  78064F     MOV [--W15], W12
003BCE  BE054F     MOV.D [--W15], W10
003BD0  BE044F     MOV.D [--W15], W8
003BD2  FA8000     ULNK
003BD4  060000     RETURN
003BD6  37FEF3     BRA .L2, .L113
003BFA  78400C     MOV.B W12, W0
003BFC  78064F     MOV [--W15], W12
003BFE  BE054F     MOV.D [--W15], W10
003C00  BE044F     MOV.D [--W15], W8
003C02  FA8000     ULNK
003C04  060000     RETURN
003C06  37FEDB     BRA .L2, .L113
003C14  78400C     MOV.B W12, W0
003C16  78064F     MOV [--W15], W12
003C18  BE054F     MOV.D [--W15], W10
003C1A  BE044F     MOV.D [--W15], W8
003C1C  FA8000     ULNK
003C1E  060000     RETURN
003C20  37FECE     BRA .L2, .L113
003C2E  78400C     MOV.B W12, W0
003C30  78064F     MOV [--W15], W12
003C32  BE054F     MOV.D [--W15], W10
003C34  BE044F     MOV.D [--W15], W8
003C36  FA8000     ULNK
003C38  060000     RETURN
003C3A  37FEC1     BRA .L2, .L113
003C48  78400C     MOV.B W12, W0
003C4A  78064F     MOV [--W15], W12
003C4C  BE054F     MOV.D [--W15], W10
003C4E  BE044F     MOV.D [--W15], W8
003C50  FA8000     ULNK
003C52  060000     RETURN
003C54  37FEB4     BRA .L2, .L113
003C62  78400C     MOV.B W12, W0
003C64  78064F     MOV [--W15], W12
003C66  BE054F     MOV.D [--W15], W10
003C68  BE044F     MOV.D [--W15], W8
003C6A  FA8000     ULNK
003C6C  060000     RETURN
003C6E  37FEA7     BRA .L2, .L113
003C80  78400C     MOV.B W12, W0
003C82  78064F     MOV [--W15], W12
003C84  BE054F     MOV.D [--W15], W10
003C86  BE044F     MOV.D [--W15], W8
003C88  FA8000     ULNK
003C8A  060000     RETURN
003C8C  37FE98     BRA .L2, .L113
003C9E  78400C     MOV.B W12, W0
003CA0  78064F     MOV [--W15], W12
003CA2  BE054F     MOV.D [--W15], W10
003CA4  BE044F     MOV.D [--W15], W8
003CA6  FA8000     ULNK
003CA8  060000     RETURN
003CAA  37FE89     BRA .L2, .L113
003CD4  78400C     MOV.B W12, W0
003CD6  78064F     MOV [--W15], W12
003CD8  BE054F     MOV.D [--W15], W10
003CDA  BE044F     MOV.D [--W15], W8
003CDC  FA8000     ULNK
003CDE  060000     RETURN
003CE0  37FE6E     BRA .L2, .L113
003D0A  78400C     MOV.B W12, W0
003D0C  78064F     MOV [--W15], W12
003D0E  BE054F     MOV.D [--W15], W10
003D10  BE044F     MOV.D [--W15], W8
003D12  FA8000     ULNK
003D14  060000     RETURN
003D16  37FE53     BRA .L2, .L113
003D34  78400C     MOV.B W12, W0
003D36  78064F     MOV [--W15], W12
003D38  BE054F     MOV.D [--W15], W10
003D3A  BE044F     MOV.D [--W15], W8
003D3C  FA8000     ULNK
003D3E  060000     RETURN
003D40  37FE3E     BRA .L2, .L113
003D54  78400C     MOV.B W12, W0
003D56  78064F     MOV [--W15], W12
003D58  BE054F     MOV.D [--W15], W10
003D5A  BE044F     MOV.D [--W15], W8
003D5C  FA8000     ULNK
003D5E  060000     RETURN
003D60  37FE2E     BRA .L2, .L113
003DF4  90702C     MOV.B [W12+50], W0
003ED4  90702C     MOV.B [W12+50], W0
004446  907028     MOV.B [W8+50], W0
0045D2  907028     MOV.B [W8+50], W0
0045D4  60406F     AND.B W0, #0xF, W0
003DF8  504FE2     SUB.B W0, #0x2, [W15]
003ED8  504FE2     SUB.B W0, #0x2, [W15]
004060  504FE4     SUB.B W0, #0x4, [W15]
004062  320026     BRA Z, .L133
004064  504FE8     SUB.B W0, #0x8, [W15]
004066  3AFECD     BRA NZ, .LBE57, .LBE59, .L130
004076  504FE4     SUB.B W0, #0x4, [W15]
004078  320022     BRA Z, .L144
00407A  504FE8     SUB.B W0, #0x8, [W15]
00407C  3AFF32     BRA NZ, .LBE62, .LBE64, .L141
00444A  504FE2     SUB.B W0, #0x2, [W15]
0045D6  504FE2     SUB.B W0, #0x2, [W15]
0045D8  32014C     BRA Z, .L225
0045DA  3E0138     BRA GTU, .L228
0045DC  504FE1     SUB.B W0, #0x1, [W15]
0045DE  32000E     BRA Z, .L299
00484C  504FE4     SUB.B W0, #0x4, [W15]
00484E  320021     BRA Z, .L226
004850  504FE8     SUB.B W0, #0x8, [W15]
004852  3AFEC6     BRA NZ, .LBE139, .LBE142, .L223
00492C  504FE4     SUB.B W0, #0x4, [W15]
00492E  320021     BRA Z, .L220
004930  504FE8     SUB.B W0, #0x8, [W15]
004932  3AFD90     BRA NZ, .LBE118, .LBE121, .L217
00409E  784011     MOV.B [W1], W0
0040A0  FB8200     ZE W0, W4
0040A2  EB0280     CLR W5
0040A4  B83360     MUL.UU W6, #0x0, W6
0040A6  9FB7E4     MOV W4, [W15-20]
0040A8  9FB7F5     MOV W5, [W15-18]
0040AA  9FBF86     MOV W6, [W15-16]
0040AC  9FBF97     MOV W7, [W15-14]
0040AE  37FEA9     BRA .LBE57, .LBE59, .L130
0040C4  784411     MOV.B [W1], W8
0040C6  FB8408     ZE W8, W8
0040C8  EB0480     CLR W9
0040CA  B85560     MUL.UU W10, #0x0, W10
0040CC  37FF0A     BRA .LBE62, .LBE64, .L141
004470  784011     MOV.B [W1], W0
004472  FB8200     ZE W0, W4
004474  EB0280     CLR W5
004476  B83360     MUL.UU W6, #0x0, W6
004478  9FA7F4     MOV W4, [W15-50]
00447A  9FAF85     MOV W5, [W15-48]
00447C  9FAF96     MOV W6, [W15-46]
00447E  9FAFA7     MOV W7, [W15-44]
0045FC  784011     MOV.B [W1], W0
0045FE  FB8200     ZE W0, W4
004600  EB0280     CLR W5
004602  B83360     MUL.UU W6, #0x0, W6
004604  9FAFF4     MOV W4, [W15-34]
004606  9FB785     MOV W5, [W15-32]
004608  9FB796     MOV W6, [W15-30]
00460A  9FB7A7     MOV W7, [W15-28]
004100  780011     MOV [W1], W0
004102  B80261     MUL.UU W0, #0x1, W4
004104  B83360     MUL.UU W6, #0x0, W6
004106  9FB7E4     MOV W4, [W15-20]
004108  9FB7F5     MOV W5, [W15-18]
00410A  9FBF86     MOV W6, [W15-16]
00410C  9FBF97     MOV W7, [W15-14]
00410E  37FE79     BRA .LBE57, .LBE59, .L130
004110  780411     MOV [W1], W8
004112  EB0480     CLR W9
004114  B85560     MUL.UU W10, #0x0, W10
004116  37FEE5     BRA .LBE62, .LBE64, .L141
004872  780011     MOV [W1], W0
004874  B80261     MUL.UU W0, #0x1, W4
004876  B83360     MUL.UU W6, #0x0, W6
004878  9FAFF4     MOV W4, [W15-34]
00487A  9FB785     MOV W5, [W15-32]
00487C  9FB796     MOV W6, [W15-30]
00487E  9FB7A7     MOV W7, [W15-28]
004952  780011     MOV [W1], W0
004954  B80261     MUL.UU W0, #0x1, W4
004956  B83360     MUL.UU W6, #0x0, W6
004958  9FA7F4     MOV W4, [W15-50]
00495A  9FAF85     MOV W5, [W15-48]
00495C  9FAF96     MOV W6, [W15-46]
00495E  9FAFA7     MOV W7, [W15-44]
0040B0  BE0211     MOV.D [W1], W4
0040B2  B83360     MUL.UU W6, #0x0, W6
0040B4  9FB7E4     MOV W4, [W15-20]
0040B6  9FB7F5     MOV W5, [W15-18]
0040B8  9FBF86     MOV W6, [W15-16]
0040BA  9FBF97     MOV W7, [W15-14]
0040BC  37FEA2     BRA .LBE57, .LBE59, .L130
0040BE  BE0411     MOV.D [W1], W8
0040C0  B85560     MUL.UU W10, #0x0, W10
0040C2  37FF0F     BRA .LBE62, .LBE64, .L141
004892  BE0211     MOV.D [W1], W4
004894  B83360     MUL.UU W6, #0x0, W6
004896  9FAFF4     MOV W4, [W15-34]
004898  9FB785     MOV W5, [W15-32]
00489A  9FB796     MOV W6, [W15-30]
00489C  9FB7A7     MOV W7, [W15-28]
004972  BE0211     MOV.D [W1], W4
004974  B83360     MUL.UU W6, #0x0, W6
004976  9FA7F4     MOV W4, [W15-50]
004978  9FAF85     MOV W5, [W15-48]
00497A  9FAF96     MOV W6, [W15-46]
00497C  9FAFA7     MOV W7, [W15-44]
004068  BE0231     MOV.D [W1++], W4
00406A  BE0321     MOV.D [W1--], W6
00406C  9FB7E4     MOV W4, [W15-20]
00406E  9FB7F5     MOV W5, [W15-18]
004070  9FBF86     MOV W6, [W15-16]
004072  9FBF97     MOV W7, [W15-14]
004074  37FEC6     BRA .LBE57, .LBE59, .L130
00407E  BE0431     MOV.D [W1++], W8
004080  BE0521     MOV.D [W1--], W10
004082  37FF2F     BRA .LBE62, .LBE64, .L141
004854  BE0231     MOV.D [W1++], W4
004856  BE0321     MOV.D [W1--], W6
004858  9FAFF4     MOV W4, [W15-34]
00485A  9FB785     MOV W5, [W15-32]
00485C  9FB796     MOV W6, [W15-30]
00485E  9FB7A7     MOV W7, [W15-28]
004934  BE0231     MOV.D [W1++], W4
004936  BE0321     MOV.D [W1--], W6
004938  9FA7F4     MOV W4, [W15-50]
00493A  9FAF85     MOV W5, [W15-48]
00493C  9FAF96     MOV W6, [W15-46]
00493E  9FAFA7     MOV W7, [W15-44]
003FC0  EB4400     CLR.B W8
003F60  EB4000     CLR.B W0
003F62  E80307     INC W7, W6
003F64  4383F2     ADD W7, #0x12, W7
003FC4  EB4000     CLR.B W0
003FC6  E80307     INC W7, W6
003FC8  4383F2     ADD W7, #0x12, W7
003F68  9008DC     MOV [W12+26], W1
003F6E  7A42E5     MOV.B [W5+W4], W5
003FCC  9008DC     MOV [W12+26], W1
003FD2  7A42E5     MOV.B [W5+W4], W5
003F66  430306     ADD W6, W6, W6
003F6A  FB8200     ZE W0, W4
003FCA  430306     ADD W6, W6, W6
003FCE  FB8200     ZE W0, W4
003F7A  E84000     INC.B W0, W0
003FDE  E84000     INC.B W0, W0
003F7C  7BC0EC     MOV.B [W12+W7], W1
003FE0  7BC0EC     MOV.B [W12+W7], W1
003F82  E84408     INC.B W8, W8
003FE6  E84408     INC.B W8, W8
003F84  90783C     MOV.B [W12+59], W0
003FE8  90783C     MOV.B [W12+59], W0
0044E2  780115     MOV [W5], W2
0044EE  780281     MOV W1, W5
0048EA  780092     MOV [W2], W1
0048EC  518F81     SUB W3, W1, [W15]
0048EE  32000C     BRA Z, .L200
0048F0  E00001     CP0 W1
0048F2  32FD3C     BRA Z, .L178
0048F6  780100     MOV W0, W2
0048F8  780090     MOV [W0], W1
0048FA  518F81     SUB W3, W1, [W15]
0048FC  320005     BRA Z, .L200
0048FE  40006C     ADD W0, #0xC, W0
004900  E00001     CP0 W1
004902  3AFFF9     BRA NZ, .L201
004500  E00002     CP0 W2
004502  32FF3F     BRA Z, .L267
00490A  E00001     CP0 W1
00490C  32FD2F     BRA Z, .L178
0043A0  E00002     CP0 W2
0043D4  E00002     CP0 W2
00440C  E00005     CP0 W5
0045A6  E00003     CP0 W3
00478C  E00003     CP0 W3
00478E  32FDEE     BRA Z, .L178
0047C8  E00002     CP0 W2
0047CA  32FDD0     BRA Z, .L178
0043AA  780092     MOV [W2], W1
0043AC  518F81     SUB W3, W1, [W15]
0043AE  320071     BRA Z, .L191
0043B0  E00001     CP0 W1
0043B2  32FFE7     BRA Z, .L267
0043B6  780100     MOV W0, W2
0043B8  780090     MOV [W0], W1
0043BA  518F81     SUB W3, W1, [W15]
0043BC  32006A     BRA Z, .L191
0043BE  400064     ADD W0, #0x4, W0
0043C0  E00001     CP0 W1
0043C2  3AFFF9     BRA NZ, .L192
0043DE  780092     MOV [W2], W1
0043E0  518F81     SUB W3, W1, [W15]
0043E2  3200B5     BRA Z, .L189
0043E4  E00001     CP0 W1
0043E6  32FFCD     BRA Z, .L267
0043EA  780100     MOV W0, W2
0043EC  780090     MOV [W0], W1
0043EE  518F81     SUB W3, W1, [W15]
0043F0  3200AE     BRA Z, .L189
0043F2  400064     ADD W0, #0x4, W0
0043F4  E00001     CP0 W1
0043F6  3AFFF9     BRA NZ, .L190
004426  780095     MOV [W5], W1
004428  530F81     SUB W6, W1, [W15]
00442A  320054     BRA Z, .L184
00442C  E00001     CP0 W1
00442E  32FFF0     BRA Z, .LBE112, .LBE114, .L235
004432  780280     MOV W0, W5
004434  780090     MOV [W0], W1
004436  530F81     SUB W6, W1, [W15]
004438  32004D     BRA Z, .L184
00443A  400064     ADD W0, #0x4, W0
00443C  E00001     CP0 W1
00443E  3AFFF9     BRA NZ, .L185
0045B0  780113     MOV [W3], W2
0045B2  520F82     SUB W4, W2, [W15]
0045B4  320188     BRA Z, .L205
0045B6  E00002     CP0 W2
0045B8  32FED9     BRA Z, .L178
0045BE  780180     MOV W0, W3
0045C0  780110     MOV [W0], W2
0045C2  520F82     SUB W4, W2, [W15]
0045C4  32017F     BRA Z, .L286
0045C6  400064     ADD W0, #0x4, W0
0045C8  E00002     CP0 W2
0045CA  3AFFF9     BRA NZ, .L206
004796  780113     MOV [W3], W2
004798  520F82     SUB W4, W2, [W15]
00479A  32008B     BRA Z, .L203
00479C  E00002     CP0 W2
00479E  32FDE6     BRA Z, .L178
0047A4  780180     MOV W0, W3
0047A6  780110     MOV [W0], W2
0047A8  520F82     SUB W4, W2, [W15]
0047AA  320082     BRA Z, .L285
0047AC  400064     ADD W0, #0x4, W0
0047AE  E00002     CP0 W2
0047B0  3AFFF9     BRA NZ, .L204
0047D2  780092     MOV [W2], W1
0047D4  518F81     SUB W3, W1, [W15]
0047D6  320081     BRA Z, .L198
0047D8  E00001     CP0 W1
0047DA  32FDC8     BRA Z, .L178
0047DE  780100     MOV W0, W2
0047E0  780090     MOV [W0], W1
0047E2  518F81     SUB W3, W1, [W15]
0047E4  32007A     BRA Z, .L198
0047E6  400064     ADD W0, #0x4, W0
0047E8  E00001     CP0 W1
0047EA  3AFFF9     BRA NZ, .L199
004492  E00001     CP0 W1
004494  32FF76     BRA Z, .L267
0044D4  E00001     CP0 W1
0044D6  32FF55     BRA Z, .L267
00454E  E00001     CP0 W1
004550  32FF18     BRA Z, .L267
0048B4  E00002     CP0 W2
0048B6  32FD5A     BRA Z, .L178
0048C8  E00002     CP0 W2
0048CA  32FD50     BRA Z, .L178
0048DC  E00001     CP0 W1
0048DE  32FD46     BRA Z, .L178
004496  900092     MOV [W2+2], W1
0044D8  900015     MOV [W5+2], W0
004552  900092     MOV [W2+2], W1
0048B8  900013     MOV [W3+2], W0
0048CC  900013     MOV [W3+2], W0
0048E0  900212     MOV [W2+2], W4
003DF2  90188C     MOV [W12+48], W1
003ED2  90188C     MOV [W12+48], W1
004444  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
0045D0  901888     MOV [W8+48], W1
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/LNet.c  ------------------------------------------
0054EC  200011     MOV #0x1, W1
0054EE  980811     MOV W1, [W0+18]
0054F0  EB0080     CLR W1
0054F2  980801     MOV W1, [W0+16]
0054F4  060000     RETURN
0055D6  EB0000     CLR W0
0055F8  EB0000     CLR W0
005612  EB0000     CLR W0
005614  980C10     MOV W0, [W8+18]
005902  EB0080     CLR W1
0055DA  980470     MOV W0, [W8+14]
0055FC  980470     MOV W0, [W8+14]
005616  980470     MOV W0, [W8+14]
005906  980071     MOV W1, [W0+14]
0054F6  4787E4     ADD W15, #0x4, W15
0054F8  BE9F88     MOV.D W8, [W15++]
0054FA  BE9F8A     MOV.D W10, [W15++]
0054FC  BE9F8C     MOV.D W12, [W15++]
0054FE  781F8E     MOV W14, [W15++]
005500  780400     MOV W0, W8
005508  548FE1     SUB W9, #0x1, [W15]
00550A  3A0015     BRA NZ, .L28
00550C  900058     MOV [W8+10], W0
00550E  9000B0     MOV [W0+6], W1
005510  010001     CALL W1
005512  E00400     CP0.B W0
005514  320023     BRA Z, .L39
005532  548FE1     SUB W9, #0x1, [W15]
005534  32FFEB     BRA Z, .L75
005516  900808     MOV [W8+16], W0
005518  500FE2     SUB W0, #0x2, [W15]
00551A  320105     BRA Z, .L9
00551C  3E0057     BRA GTU, .L13
00551E  E00000     CP0 W0
005520  3A009F     BRA NZ, .L74
0055CC  500FE4     SUB W0, #0x4, [W15]
0055CE  320085     BRA Z, .L11
0055D0  39008C     BRA NC, .L10
0055D2  500FE5     SUB W0, #0x5, [W15]
0055D4  320005     BRA Z, .L82
005660  500FE1     SUB W0, #0x1, [W15]
005662  3AFFB9     BRA NZ, communicate::enableReceive
005522  98544A     MOV.B W10, [W8+20]
005524  985450     MOV.B W0, [W8+21]
005526  900058     MOV [W8+10], W0
005528  780110     MOV [W0], W2
00552A  78408A     MOV.B W10, W1
00552C  010002     CALL W2
00552E  980C09     MOV W9, [W8+16]
005530  900C98     MOV [W8+18], W9
005664  9040C8     MOV.B [W8+4], W1
005666  905048     MOV.B [W8+20], W0
005668  404001     ADD.B W0, W1, W0
00566A  985440     MOV.B W0, [W8+20]
00566C  900058     MOV [W8+10], W0
00566E  780110     MOV [W0], W2
005670  010002     CALL W2
005672  904048     MOV.B [W8+4], W0
005726  9048C8     MOV.B [W8+12], W1
005728  905048     MOV.B [W8+20], W0
00572A  404001     ADD.B W0, W1, W0
00572C  985440     MOV.B W0, [W8+20]
00572E  900058     MOV [W8+10], W0
005730  780110     MOV [W0], W2
005732  010002     CALL W2
005734  904848     MOV.B [W8+12], W0
0056EA  9050D8     MOV.B [W8+21], W1
0056EC  FB8081     ZE W1, W1
0056EE  900038     MOV [W8+6], W0
0056F0  400081     ADD W0, W1, W1
0056F2  905048     MOV.B [W8+20], W0
0056F4  404011     ADD.B W0, [W1], W0
0056F6  985440     MOV.B W0, [W8+20]
0056F8  900058     MOV [W8+10], W0
0056FA  780110     MOV [W0], W2
0056FC  784091     MOV.B [W1], W1
0056FE  010002     CALL W2
005700  9050D8     MOV.B [W8+21], W1
005702  FB8001     ZE W1, W0
005704  E80180     INC W0, W3
005706  904148     MOV.B [W8+4], W2
005708  FB8102     ZE W2, W2
00570A  518F82     SUB W3, W2, [W15]
00570C  350027     BRA LT, .L19
00570E  900138     MOV [W8+6], W2
005710  784062     MOV.B [W2+W0], W0
00575C  900138     MOV [W8+6], W2
00575E  784062     MOV.B [W2+W0], W0
00571E  E84081     INC.B W1, W1
005720  985451     MOV.B W1, [W8+21]
005722  900C98     MOV [W8+18], W9
00576A  E84081     INC.B W1, W1
00576C  985451     MOV.B W1, [W8+21]
00576E  900C98     MOV [W8+18], W9
005770  37FECB     BRA .LBE74, .L69
0057B6  E84081     INC.B W1, W1
0057B8  985451     MOV.B W1, [W8+21]
0057BA  900C98     MOV [W8+18], W9
0057BC  37FEA5     BRA .LBE74, .L69
0057C8  E84081     INC.B W1, W1
0057CA  985451     MOV.B W1, [W8+21]
0057CC  900C98     MOV [W8+18], W9
0057CE  37FE9C     BRA .LBE74, .L69
005724  37FEF1     BRA .LBE74, .L69
0056DA  900058     MOV [W8+10], W0
0056DC  780110     MOV [W0], W2
0056DE  EB4080     CLR.B W1
0056E0  010002     CALL W2
0056E2  809360     MOV nextGlobalState, W0
0056E4  980C00     MOV W0, [W8+16]
0056E6  900C98     MOV [W8+18], W9
0056E8  37FF0F     BRA .LBE74, .L69
0055E0  9050C8     MOV.B [W8+20], W1
0055E2  B3C550     MOV.B #0x55, W0
0055E4  50CF80     SUB.B W1, W0, [W15]
0055E6  32000D     BRA Z, .L25
0055E8  50CFE2     SUB.B W1, #0x2, [W15]
0055EA  32000B     BRA Z, .L25
005602  EAC081     COM.B W1, W1
005604  985441     MOV.B W1, [W8+20]
0055EC  900058     MOV [W8+10], W0
0055EE  780110     MOV [W0], W2
0055F0  010002     CALL W2
005606  900058     MOV [W8+10], W0
005608  780110     MOV [W0], W2
00560A  010002     CALL W2
0055F2  900058     MOV [W8+10], W0
0055F4  9000D0     MOV [W0+10], W1
0055F6  010001     CALL W1
00560C  900058     MOV [W8+10], W0
00560E  9000D0     MOV [W0+10], W1
005610  010001     CALL W1
0055FE  EB0480     CLR W9
005600  37FF9C     BRA .L70
005618  EB0480     CLR W9
00561A  37FF8F     BRA .L70
0055DC  EB0480     CLR W9
0055DE  37FFAD     BRA .L70
005536  E00009     CP0 W9
005538  3A0014     BRA NZ, .L60
00553A  900058     MOV [W8+10], W0
00553C  9000A0     MOV [W0+4], W1
00553E  010001     CALL W1
005540  E00400     CP0.B W0
005542  32000F     BRA Z, .L60
00555E  E00009     CP0 W9
005560  32FFEC     BRA Z, .L70
005544  900058     MOV [W8+10], W0
005546  900090     MOV [W0+2], W1
005548  010001     CALL W1
00554A  9000F8     MOV [W8+14], W1
00554C  508FE2     SUB W1, #0x2, [W15]
00554E  3200B6     BRA Z, .L34
005550  3E0017     BRA GTU, .L38, .L87
005552  E00001     CP0 W1
005554  3A0063     BRA NZ, .L76
005580  508FE4     SUB W1, #0x4, [W15]
005582  320080     BRA Z, .LBE89, .L36
005584  390085     BRA NC, .L35
005586  508FE5     SUB W1, #0x5, [W15]
005588  320004     BRA Z, .L79
00561C  508FE1     SUB W1, #0x1, [W15]
00561E  3AFFB5     BRA NZ, .L31
005556  B3C551     MOV.B #0x55, W1
005558  504F81     SUB.B W0, W1, [W15]
00555A  320118     BRA Z, .L77
00578C  985440     MOV.B W0, [W8+20]
00578E  200010     MOV #0x1, W0
005790  980470     MOV W0, [W8+14]
0056BC  9048C8     MOV.B [W8+12], W1
0056BE  50CF80     SUB.B W1, W0, [W15]
0056C0  3AFFCC     BRA NZ, .L54
0056C2  905048     MOV.B [W8+20], W0
0056C4  404001     ADD.B W0, W1, W0
0056C6  985440     MOV.B W0, [W8+20]
005690  9050C8     MOV.B [W8+20], W1
005692  40C080     ADD.B W1, W0, W1
005694  985441     MOV.B W1, [W8+20]
005696  9050D8     MOV.B [W8+21], W1
005698  FB8081     ZE W1, W1
00569A  900138     MOV [W8+6], W2
00569C  78F100     MOV.B W0, [W2+W1]
00569E  9050D8     MOV.B [W8+21], W1
0056A0  E84081     INC.B W1, W1
0056A2  985451     MOV.B W1, [W8+21]
0056A4  904148     MOV.B [W8+4], W2
0056A6  50CF82     SUB.B W1, W2, [W15]
0056A8  39004D     BRA NC, .L48
005684  E00400     CP0.B W0
005686  3AFFE4     BRA NZ, .L53
005688  809360     MOV nextGlobalState, W0
00568A  980470     MOV W0, [W8+14]
005650  B3C551     MOV.B #0x55, W1
005652  212502     MOV #0x1250, W2
005654  784112     MOV.B [W2], W2
005656  514F81     SUB.B W2, W1, [W15]
005658  3200CB     BRA Z, .L83
00565A  980479     MOV W9, [W8+14]
005592  9050C8     MOV.B [W8+20], W1
005594  B3C552     MOV.B #0x55, W2
005596  50CF82     SUB.B W1, W2, [W15]
005598  320010     BRA Z, .L56
00559A  50CFE2     SUB.B W1, #0x2, [W15]
00559C  32000E     BRA Z, .L56
0055BA  EAC081     COM.B W1, W1
0055BC  985441     MOV.B W1, [W8+20]
00559E  504F81     SUB.B W0, W1, [W15]
0055A0  3A0010     BRA NZ, .L58
0055BE  504F81     SUB.B W0, W1, [W15]
0055C0  32FFF0     BRA Z, .L81
0055A2  900038     MOV [W8+6], W0
0055A4  784010     MOV.B [W0], W0
0055A6  504FFA     SUB.B W0, #0x1A, [W15]
0055A8  3E00F6     BRA GTU, .L59
0055AA  FB8000     ZE W0, W0
0055AC  9000C8     MOV [W8+8], W1
0055AE  400000     ADD W0, W0, W0
0055B0  7800E1     MOV [W1+W0], W1
0055B2  780008     MOV W8, W0
0055B4  010001     CALL W1
005796  B3C211     MOV.B #0x21, W1
005798  780008     MOV W8, W0
00579A  07FE8C     RCALL sendError
0055C2  B3C131     MOV.B #0x13, W1
0055C4  780008     MOV W8, W0
0055C6  07FF76     RCALL sendError
00558A  EB0000     CLR W0
00558C  980470     MOV W0, [W8+14]
00555C  900C98     MOV [W8+18], W9
00558E  900C98     MOV [W8+18], W9
005590  37FFE6     BRA .L80
0055B6  900C98     MOV [W8+18], W9
0055B8  37FFD2     BRA .L80
0055C8  900C98     MOV [W8+18], W9
0055CA  37FFC9     BRA .L80
00564C  900C98     MOV [W8+18], W9
00564E  37FF87     BRA .L80
00565C  900C98     MOV [W8+18], W9
00565E  37FF7F     BRA .L80
00568C  900C98     MOV [W8+18], W9
00568E  37FF67     BRA .L80
0056B8  900C98     MOV [W8+18], W9
0056BA  37FF51     BRA .L80
0056D6  900C98     MOV [W8+18], W9
0056D8  37FF42     BRA .L80
005758  900C98     MOV [W8+18], W9
00575A  37FF01     BRA .L80
005792  900C98     MOV [W8+18], W9
005794  37FEE4     BRA .L80
00579C  900C98     MOV [W8+18], W9
00579E  37FEDF     BRA .L80
0057AA  900C98     MOV [W8+18], W9
0057AC  37FED8     BRA .L80
0057DC  900C98     MOV [W8+18], W9
0057DE  37FEBF     BRA .L80
0057EC  900C98     MOV [W8+18], W9
0057EE  37FEB7     BRA .L80
005804  900C98     MOV [W8+18], W9
005806  37FEAB     BRA .L80
005574  78074F     MOV [--W15], W14
005576  BE064F     MOV.D [--W15], W12
005578  BE054F     MOV.D [--W15], W10
00557A  BE044F     MOV.D [--W15], W8
00557C  B1004F     SUB #0x4, W15
00557E  060000     RETURN
005836  78074F     MOV [--W15], W14
005838  BE064F     MOV.D [--W15], W12
00583A  BE054F     MOV.D [--W15], W10
00583C  BE044F     MOV.D [--W15], W8
00583E  B1004F     SUB #0x4, W15
005840  060000     RETURN
005842  37FE9E     BRA .L38, .L87
0058DA  78074F     MOV [--W15], W14
0058DC  BE064F     MOV.D [--W15], W12
0058DE  BE054F     MOV.D [--W15], W10
0058E0  BE044F     MOV.D [--W15], W8
0058E2  B1004F     SUB #0x4, W15
0058E4  060000     RETURN
0058E6  37FE4C     BRA .L38, .L87
005504  B3C55A     MOV.B #0x55, W10
005638  784082     MOV.B W2, W1
005674  504F8A     SUB.B W0, W10, [W15]
005676  320083     BRA Z, .L15
005678  504FE2     SUB.B W0, #0x2, [W15]
00567A  320081     BRA Z, .L15
0056AA  B3C551     MOV.B #0x55, W1
0056AC  504F81     SUB.B W0, W1, [W15]
0056AE  320078     BRA Z, .L49
0056B0  504FE2     SUB.B W0, #0x2, [W15]
0056B2  320076     BRA Z, .L49
0056C8  B3C550     MOV.B #0x55, W0
0056CA  50CF80     SUB.B W1, W0, [W15]
0056CC  320081     BRA Z, .L46
0056CE  50CFE2     SUB.B W1, #0x2, [W15]
0056D0  32007F     BRA Z, .L46
005712  504F8A     SUB.B W0, W10, [W15]
005714  320054     BRA Z, .L20
005716  504FE2     SUB.B W0, #0x2, [W15]
005718  320052     BRA Z, .L20
005736  504F8A     SUB.B W0, W10, [W15]
005738  32001C     BRA Z, .L17
00573A  504FE2     SUB.B W0, #0x2, [W15]
00573C  32001A     BRA Z, .L17
005744  B3C551     MOV.B #0x55, W1
005746  504F81     SUB.B W0, W1, [W15]
005748  320002     BRA Z, .L51
00574A  504FE2     SUB.B W0, #0x2, [W15]
00574C  3AFFC2     BRA NZ, communicate::checkFill
005760  504F8A     SUB.B W0, W10, [W15]
005762  320025     BRA Z, .L23
005764  504FE2     SUB.B W0, #0x2, [W15]
005766  320023     BRA Z, .L23
005642  B7F250     MOV.B WREG, lastSyn
00574E  B7F250     MOV.B WREG, lastSyn
005772  B7F250     MOV.B WREG, lastSyn
00577E  B7F250     MOV.B WREG, lastSyn
0057A0  B7F250     MOV.B WREG, lastSyn
0057AE  B7F250     MOV.B WREG, lastSyn
0057BE  B7F250     MOV.B WREG, lastSyn
0057D0  212500     MOV #0x1250, W0
0057D2  784801     MOV.B W1, [W0]
005506  20003B     MOV #0x3, W11
005644  200020     MOV #0x2, W0
005750  200030     MOV #0x3, W0
005752  889360     MOV W0, nextGlobalState
005774  88936B     MOV W11, nextGlobalState
005780  200020     MOV #0x2, W0
005782  889360     MOV W0, nextGlobalState
0057A2  200050     MOV #0x5, W0
0057A4  889360     MOV W0, nextGlobalState
0057B0  88936B     MOV W11, nextGlobalState
0057C0  200050     MOV #0x5, W0
0057C2  889360     MOV W0, nextGlobalState
0057D4  200030     MOV #0x3, W0
0057D6  889360     MOV W0, nextGlobalState
005648  200040     MOV #0x4, W0
005754  200040     MOV #0x4, W0
005756  980470     MOV W0, [W8+14]
005776  200040     MOV #0x4, W0
005778  980C00     MOV W0, [W8+16]
00577A  900C98     MOV [W8+18], W9
00577C  37FEC5     BRA .LBE74, .L69
005784  200040     MOV #0x4, W0
005786  980C00     MOV W0, [W8+16]
005788  900C98     MOV [W8+18], W9
00578A  37FEBE     BRA .LBE74, .L69
0057A6  200040     MOV #0x4, W0
0057A8  980470     MOV W0, [W8+14]
0057B2  200040     MOV #0x4, W0
0057B4  980C00     MOV W0, [W8+16]
0057C4  200040     MOV #0x4, W0
0057C6  980C00     MOV W0, [W8+16]
0057D8  200040     MOV #0x4, W0
0057DA  980470     MOV W0, [W8+14]
00567C  200020     MOV #0x2, W0
00567E  980C00     MOV W0, [W8+16]
005680  900C98     MOV [W8+18], W9
005682  37FF42     BRA .LBE74, .L69
0056B4  200050     MOV #0x5, W0
0056B6  980470     MOV W0, [W8+14]
0056D2  200030     MOV #0x3, W0
0056D4  980470     MOV W0, [W8+14]
00571A  200050     MOV #0x5, W0
00571C  980C00     MOV W0, [W8+16]
00573E  980C0B     MOV W11, [W8+16]
005740  900C98     MOV [W8+18], W9
005742  37FEE2     BRA .LBE74, .L69
005768  980C0B     MOV W11, [W8+16]
005564  809350     MOV 0x126A, W0
005566  9008C0     MOV [W0+24], W1
005568  E00001     CP0 W1
00556A  320004     BRA Z, .L4
00556C  9008C0     MOV [W0+24], W1
00556E  9018A1     MOV [W1+52], W1
005570  508FE4     SUB W1, #0x4, [W15]
005572  32014A     BRA Z, .L78
005808  900840     MOV [W0+24], W0
00580A  90C4A0     MOV.B [W0+66], W9
00580C  FB8489     ZE W9, W9
00580E  4484E3     ADD W9, #0x3, W9
005810  900058     MOV [W8+10], W0
005812  9000C0     MOV [W0+8], W1
005814  010001     CALL W1
005816  FB8000     ZE W0, W0
005818  548F80     SUB W9, W0, [W15]
00581A  3D0007     BRA GE, .L63
005822  901972     MOV [W2+62], W2
005824  9018E1     MOV [W1+60], W1
005826  510F81     SUB W2, W1, [W15]
005828  31000D     BRA C, .L84
00581C  809350     MOV 0x126A, W0
00581E  900940     MOV [W0+24], W2
005820  9008C0     MOV [W0+24], W1
005844  900840     MOV [W0+24], W0
005846  EB0080     CLR W1
005848  981871     MOV W1, [W0+62]
00584A  900058     MOV [W8+10], W0
00584C  780110     MOV [W0], W2
00584E  B3C021     MOV.B #0x2, W1
005850  010002     CALL W2
005852  900058     MOV [W8+10], W0
005854  809351     MOV 0x126A, W1
005856  9008C1     MOV [W1+24], W1
005858  90C0A1     MOV.B [W1+66], W1
00585A  780110     MOV [W0], W2
00585C  010002     CALL W2
00585E  900058     MOV [W8+10], W0
005860  9048C8     MOV.B [W8+12], W1
005862  780110     MOV [W0], W2
005864  010002     CALL W2
005866  900058     MOV [W8+10], W0
005868  809351     MOV 0x126A, W1
00586A  9008C1     MOV [W1+24], W1
00586C  902081     MOV [W1+64], W1
00586E  780110     MOV [W0], W2
005870  010002     CALL W2
005872  900058     MOV [W8+10], W0
005874  809351     MOV 0x126A, W1
005876  9008C1     MOV [W1+24], W1
005878  902081     MOV [W1+64], W1
00587A  DE08C8     LSR W1, #8, W1
00587C  780110     MOV [W0], W2
00587E  010002     CALL W2
005880  809350     MOV 0x126A, W0
005882  9009C0     MOV [W0+24], W3
005888  90C223     MOV.B [W3+66], W4
00588A  9049C8     MOV.B [W8+12], W3
00588C  424183     ADD.B W4, W3, W3
00588E  E8C183     INC2.B W3, W3
005890  902081     MOV [W1+64], W1
005892  41C081     ADD.B W3, W1, W1
005896  45C581     ADD.B W11, W1, W11
005884  9008C0     MOV [W0+24], W1
005886  900940     MOV [W0+24], W2
005894  90C592     MOV.B [W2+65], W11
005898  EB0700     CLR W14
00589A  EB0480     CLR W9
00589C  E8008E     INC W14, W1
00589E  9FBF81     MOV W1, [W15-16]
0058A0  470772     ADD W14, #0x12, W14
0058A2  408681     ADD W1, W1, W13
0058A4  900840     MOV [W0+24], W0
0058A6  7E8060     MOV [W0+W13], W0
0058A8  7CC560     MOV.B [W0+W9], W10
0058AA  78001C     MOV [W12], W0
0058AC  780110     MOV [W0], W2
0058AE  78408A     MOV.B W10, W1
0058B0  010002     CALL W2
0058B2  45C58A     ADD.B W11, W10, W11
0058B4  E80489     INC W9, W9
0058B6  809350     MOV 0x126A, W0
0058B8  9008C0     MOV [W0+24], W1
0058BA  7F40E1     MOV.B [W1+W14], W1
0058BC  FB8081     ZE W1, W1
0058BE  548F81     SUB W9, W1, [W15]
0058C0  39FFF1     BRA NC, .L64
0058C2  97BF0F     MOV [W15-16], W14
0058C4  9008C0     MOV [W0+24], W1
0058C6  9078B1     MOV.B [W1+59], W1
0058C8  FB8081     ZE W1, W1
0058CA  570F81     SUB W14, W1, [W15]
0058CC  39FFE6     BRA NC, .L65
0058CE  55CFE2     SUB.B W11, #0x2, [W15]
0058D0  32000B     BRA Z, .L85
005502  900C98     MOV [W8+18], W9
0058E8  B3CFDB     MOV.B #0xFD, W11
0058D2  900058     MOV [W8+10], W0
0058D4  780110     MOV [W0], W2
0058D6  78408B     MOV.B W11, W1
0058D8  010002     CALL W2
0058EA  900058     MOV [W8+10], W0
0058EC  780110     MOV [W0], W2
0058EE  78408B     MOV.B W11, W1
0058F0  010002     CALL W2
0058F2  37FFF3     BRA .L86
00582A  809290     MOV txBufFull, W0
00582C  8092A1     MOV 0x1254, W1
00582E  400061     ADD W0, #0x1, W0
005830  4880E0     ADDC W1, #0x0, W1
005832  889290     MOV W0, txBufFull
005834  8892A1     MOV W1, 0x1254
005620  E00400     CP0.B W0
005624  9040D8     MOV.B [W8+5], W1
0057F0  9040D8     MOV.B [W8+5], W1
0057F2  504F81     SUB.B W0, W1, [W15]
0057F4  3EFFF5     BRA GTU, communicate::receiveSize
0057E0  980479     MOV W9, [W8+14]
00562A  B3C552     MOV.B #0x55, W2
0057F6  B3C552     MOV.B #0x55, W2
0057F8  404082     ADD.B W0, W2, W1
0057FA  985441     MOV.B W1, [W8+20]
005630  984440     MOV.B W0, [W8+4]
0057FC  984440     MOV.B W0, [W8+4]
005632  985459     MOV.B W9, [W8+21]
0057FE  985459     MOV.B W9, [W8+21]
005634  200021     MOV #0x2, W1
005800  200020     MOV #0x2, W0
005802  980470     MOV W0, [W8+14]
0057E2  900038     MOV [W8+6], W0
0057E4  EB4800     CLR.B [W0]
0057E6  B3C151     MOV.B #0x15, W1
0057E8  780008     MOV W8, W0
0057EA  07FE64     RCALL sendError
0058F4  980031     MOV W1, [W0+6]
0058F6  984052     MOV.B W2, [W0+5]
0058F8  984843     MOV.B W3, [W0+12]
0058FA  254F61     MOV #0x54F6, W1
0058FC  780801     MOV W1, [W0]
0058FE  254EC1     MOV #0x54EC, W1
005900  980011     MOV W1, [W0+2]
005562  44066A     ADD W8, #0xA, W12
005908  060000     RETURN
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/CommonFcts.c  ------------------------------------
007106  060000     RETURN
007108  060000     RETURN
00710A  050000     RETLW #0x0, W0
00710C  FB8002     ZE W2, W0
00710E  EA0000     NEG W0, W0
007110  DE004F     LSR W0, #15, W0
007112  060000     RETURN
007114  050000     RETLW #0x0, W0
007116  784080     MOV.B W0, W1
00711A  B3C802     MOV.B #0x80, W2
00711C  50CF82     SUB.B W1, W2, [W15]
00711E  320003     BRA Z, .L17
007120  FB0001     SE W1, W0
007122  A7F000     BTSC W0, #15
007124  EA0000     NEG W0, W0
007118  B3C7F0     MOV.B #0x7F, W0
007126  060000     RETURN
007128  780080     MOV W0, W1
00712C  280002     MOV #0x8000, W2
00712E  508F82     SUB W1, W2, [W15]
007130  320003     BRA Z, .L22
007132  780001     MOV W1, W0
007134  A7F000     BTSC W0, #15
007136  EA0000     NEG W0, W0
00712A  27FFF0     MOV #0x7FFF, W0
007138  060000     RETURN
00713E  200004     MOV #0x0, W4
007140  280005     MOV #0x8000, W5
007142  500F84     SUB W0, W4, [W15]
007144  588F85     SUBB W1, W5, [W15]
007146  320004     BRA Z, .L27
007148  BE0100     MOV.D W0, W2
00714A  500FE0     SUB W0, #0x0, [W15]
00714C  588FE0     SUBB W1, #0x0, [W15]
00714E  350002     BRA LT, .L31, .L32
007154  100160     SUBR W0, #0x0, W2
007156  1881E0     SUBBR W1, #0x0, W3
00713A  2FFFF2     MOV #0xFFFF, W2
00713C  27FFF3     MOV #0x7FFF, W3
007150  BE0002     MOV.D W2, W0
007152  060000     RETURN
007158  BE0002     MOV.D W2, W0
00715A  060000     RETURN
00715C  37FFFB     BRA .L31, .L32
00715E  B82260     MUL.UU W4, #0x0, W4
007160  200006     MOV #0x0, W6
007162  280007     MOV #0x8000, W7
007164  E10004     CP W0, W4
007166  E18805     CPB W1, W5
007168  E19006     CPB W2, W6
00716A  E19807     CPB W3, W7
00716C  320014     BRA Z, .L37
00716E  BE0302     MOV.D W2, W6
007170  BE0200     MOV.D W0, W4
007172  500FE0     SUB W0, #0x0, [W15]
007174  588FE0     SUBB W1, #0x0, [W15]
007176  590FE0     SUBB W2, #0x0, [W15]
007178  598FE0     SUBB W3, #0x0, [W15]
00717A  350003     BRA LT, .L39, .L40
007182  B80060     MUL.UU W0, #0x0, W0
007184  B81160     MUL.UU W2, #0x0, W2
007186  500204     SUB W0, W4, W4
007188  588285     SUBB W1, W5, W5
00718A  590306     SUBB W2, W6, W6
00718C  598387     SUBB W3, W7, W7
007196  2FFFF4     MOV #0xFFFF, W4
007198  2FFFF5     MOV #0xFFFF, W5
00719A  2FFFF6     MOV #0xFFFF, W6
00719C  27FFF7     MOV #0x7FFF, W7
00717C  BE0004     MOV.D W4, W0
00717E  BE0106     MOV.D W6, W2
007180  060000     RETURN
00718E  BE0004     MOV.D W4, W0
007190  BE0106     MOV.D W6, W2
007192  060000     RETURN
007194  37FFF6     BRA .L39, .L40
00719E  BE0004     MOV.D W4, W0
0071A0  BE0106     MOV.D W6, W2
0071A2  060000     RETURN
0071A4  37FFEE     BRA .L39, .L40
0071A6  BE9F88     MOV.D W8, [W15++]
0071A8  BE0400     MOV.D W0, W8
0071AA  B81160     MUL.UU W2, #0x0, W2
0071AC  07CD8E     RCALL ___ltsf2, ___eqsf2, ___lesf2
0071AE  E00000     CP0 W0
0071B0  3D0001     BRA GE, .L43
0071B2  A2F009     BTG W9, #15
0071B4  780188     MOV W8, W3
0071B6  780109     MOV W9, W2
0071B8  780003     MOV W3, W0
0071BA  780082     MOV W2, W1
0071BC  BE044F     MOV.D [--W15], W8
0071BE  060000     RETURN
0071C0  BE9F88     MOV.D W8, [W15++]
0071C2  BE9F8A     MOV.D W10, [W15++]
0071C4  BE0400     MOV.D W0, W8
0071C6  BE0502     MOV.D W2, W10
0071C8  B82260     MUL.UU W4, #0x0, W4
0071CA  B83360     MUL.UU W6, #0x0, W6
0071CC  07CD74     RCALL ___ltdf2, ___eqdf2, ___ledf2
0071CE  E00000     CP0 W0
0071D0  3D0001     BRA GE, .L49
0071D2  A2F00B     BTG W11, #15
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
0071D4  780388     MOV W8, W7
---  C:/Tools/X2C_Scope/x2c-scope_library/trunk/source/BlockServicesX2C.c  ------------------------------
00626E  900040     MOV [W0+8], W0
006270  260BC1     MOV #0x60BC, W1
006272  980811     MOV W1, [W0+18]
006274  25FC61     MOV #0x5FC6, W1
006276  980071     MOV W1, [W0+14]
006278  260381     MOV #0x6038, W1
00627A  980801     MOV W1, [W0+16]
00627C  060000     RETURN
00627E  900040     MOV [W0+8], W0
006280  261821     MOV #0x6182, W1
006282  980821     MOV W1, [W0+20]
006284  060000     RETURN
0061C6  4480E4     ADD W9, #0x4, W1
006248  4480E4     ADD W9, #0x4, W1
006182  BE9F88     MOV.D W8, [W15++]
006184  781F8A     MOV W10, [W15++]
006186  780500     MOV W0, W10
006188  9004BA     MOV [W10+6], W9
00618A  780289     MOV W9, W5
00618C  904399     MOV.B [W9+1], W7
0061A6  FB8387     ZE W7, W7
0061A8  420207     ADD W4, W7, W4
00618E  904229     MOV.B [W9+2], W4
0061A4  DD2248     SL W4, #8, W4
006190  9041CA     MOV.B [W10+4], W3
006192  51C1E4     SUB.B W3, #0x4, W3
006194  904139     MOV.B [W9+3], W2
006196  FB8183     ZE W3, W3
006198  FB8302     ZE W2, W6
00619A  090005     REPEAT #0x5
00619C  D88186     DIV.UW W3, W6
00619E  780301     MOV W1, W6
0061A0  E00006     CP0 W6
0061A2  3A0009     BRA NZ, .L67
0061AA  514FE2     SUB.B W2, #0x2, [W15]
0061AC  32004B     BRA Z, .LBB9, .L58
0061AE  514FE4     SUB.B W2, #0x4, [W15]
0061B0  320008     BRA Z, .LBB5, .L59, .L74
0061B2  514FE1     SUB.B W2, #0x1, [W15]
0061B4  32002E     BRA Z, .L71
006212  E00003     CP0 W3
006214  32FFF3     BRA Z, .L60
006216  EB0100     CLR W2
00621E  E80102     INC W2, W2
006220  510F83     SUB W2, W3, [W15]
006222  310007     BRA C, .L72
006224  9004BA     MOV [W10+6], W9
00622C  E80102     INC W2, W2
00622E  510F83     SUB W2, W3, [W15]
006230  39FFF9     BRA NC, .L68
006232  9002BA     MOV [W10+6], W5
006218  448082     ADD W9, W2, W1
00621A  9040C1     MOV.B [W1+4], W1
00621C  785A01     MOV.B W1, [W4++]
006226  448082     ADD W9, W2, W1
006228  9040C1     MOV.B [W1+4], W1
00622A  785A01     MOV.B W1, [W4++]
006244  D10183     LSR W3, W3
006246  32FFDA     BRA Z, .L60
00624A  EB0100     CLR W2
006254  E80102     INC W2, W2
006256  E88081     INC2 W1, W1
006258  518F82     SUB W3, W2, [W15]
00625A  36FFD0     BRA LEU, .L60
006264  E80102     INC W2, W2
006266  E88081     INC2 W1, W1
006268  518F82     SUB W3, W2, [W15]
00626A  3EFFF0     BRA GTU, .L62
00626C  37FFC7     BRA .L60
006250  FB8311     ZE [W1], W6
006252  439A06     ADD W7, W6, [W4++]
006260  FB8311     ZE [W1], W6
006262  439A06     ADD W7, W6, [W4++]
00624C  904391     MOV.B [W1+1], W7
00624E  DD3BC8     SL W7, #8, W7
00625C  904391     MOV.B [W1+1], W7
00625E  DD3BC8     SL W7, #8, W7
0061C2  DE19C2     LSR W3, #2, W3
0061C4  32001B     BRA Z, .L60
0061C8  EB0100     CLR W2
0061F8  510F83     SUB W2, W3, [W15]
0061FA  39FFE7     BRA NC, .LBE6, .L63
0061CA  E80102     INC W2, W2
0061E0  440406     ADD W8, W6, W8
0061E2  4C8487     ADDC W9, W7, W9
0061E4  FB8311     ZE [W1], W6
0061E6  EB0380     CLR W7
0061F6  4080E4     ADD W1, #0x4, W1
0061CC  904411     MOV.B [W1+1], W8
0061CE  FB8408     ZE W8, W8
0061D0  EB0480     CLR W9
0061D2  DD4B48     SL W9, #8, W6
0061D4  DE43C8     LSR W8, #8, W7
0061D6  730387     IOR W6, W7, W7
0061D8  DD4348     SL W8, #8, W6
0061E8  430408     ADD W6, W8, W8
0061EA  4B8489     ADDC W7, W9, W9
0061DA  904421     MOV.B [W1+2], W8
0061DC  FB8488     ZE W8, W9
0061DE  200008     MOV #0x0, W8
0061F2  441A06     ADD W8, W6, [W4++]
0061F4  4C9A07     ADDC W9, W7, [W4++]
0061EC  904331     MOV.B [W1+3], W6
0061EE  DD33C8     SL W6, #8, W7
0061F0  200006     MOV #0x0, W6
0061B6  B3C141     MOV.B #0x14, W1
0061B8  78000A     MOV W10, W0
0061BA  07F97C     RCALL sendError
0061FC  B3C021     MOV.B #0x2, W1
0061FE  984541     MOV.B W1, [W10+4]
006234  B3C021     MOV.B #0x2, W1
006236  984541     MOV.B W1, [W10+4]
006200  EB4080     CLR.B W1
006202  984291     MOV.B W1, [W5+1]
006238  EB4080     CLR.B W1
00623A  984291     MOV.B W1, [W5+1]
006204  90009A     MOV [W10+2], W1
006206  78000A     MOV W10, W0
006208  010001     CALL W1
00623C  90009A     MOV [W10+2], W1
00623E  78000A     MOV W10, W0
006240  010001     CALL W1
006242  37FFE3     BRA .L73
0061BC  78054F     MOV [--W15], W10
0061BE  BE044F     MOV.D [--W15], W8
0061C0  060000     RETURN
00620A  78054F     MOV [--W15], W10
00620C  BE044F     MOV.D [--W15], W8
00620E  060000     RETURN
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
006210  37FFD8     BRA .LBB5, .L59, .L74
0060BC  781F88     MOV W8, [W15++]
0060BE  900130     MOV [W0+6], W2
0060C0  780402     MOV W2, W8
0060C2  9042B2     MOV.B [W2+3], W5
0060C4  904342     MOV.B [W2+4], W6
0060C6  FB8205     ZE W5, W4
0060C8  E88384     INC2 W4, W7
0060CA  9041D0     MOV.B [W0+5], W3
0060CC  FB8183     ZE W3, W3
0060D0  538F83     SUB W7, W3, [W15]
0060D2  3E000C     BRA GTU, .L30
0060CE  B3C151     MOV.B #0x15, W1
0060D8  904092     MOV.B [W2+1], W1
0060DA  FB8081     ZE W1, W1
0060DC  418181     ADD W3, W1, W3
0060D4  9041A2     MOV.B [W2+2], W3
0060D6  DD19C8     SL W3, #8, W3
0060DE  534FE2     SUB.B W6, #0x2, [W15]
0060E0  320008     BRA Z, .LBB2, .L32, .L51
0060E2  534FE4     SUB.B W6, #0x4, [W15]
0060E4  320033     BRA Z, .LBE3, .LBB4, .L33
0060E8  534FE1     SUB.B W6, #0x1, [W15]
0060EA  320025     BRA Z, .LBB3, .L50
006136  E00004     CP0 W4
006138  32FFF5     BRA Z, .LBE2, .L34
00613A  EB0080     CLR W1
006142  E80081     INC W1, W1
006144  520F81     SUB W4, W1, [W15]
006146  36FFED     BRA LEU, .L48
006148  900130     MOV [W0+6], W2
00614A  37FFF8     BRA .L35
00613C  410101     ADD W2, W1, W2
00613E  784333     MOV.B [W3++], W6
006140  984126     MOV.B W6, [W2+2]
0060F2  E00004     CP0 W4
0060F4  320017     BRA Z, .LBE2, .L34
0060F6  EB0080     CLR W1
006108  520F81     SUB W4, W1, [W15]
00610A  36000B     BRA LEU, .L48
00610C  900130     MOV [W0+6], W2
00611E  520F81     SUB W4, W1, [W15]
006120  3EFFF5     BRA GTU, .L46
006122  900430     MOV [W0+6], W8
0060F8  E88081     INC2 W1, W1
0060FA  784413     MOV.B [W3], W8
0060FC  78F108     MOV.B W8, [W2+W1]
00610E  E88081     INC2 W1, W1
006110  784413     MOV.B [W3], W8
006112  78F108     MOV.B W8, [W2+W1]
0060FE  900130     MOV [W0+6], W2
006100  410101     ADD W2, W1, W2
006102  780333     MOV [W3++], W6
006104  DE3348     LSR W6, #8, W6
006106  984116     MOV.B W6, [W2+1]
006114  900130     MOV [W0+6], W2
006116  410101     ADD W2, W1, W2
006118  780333     MOV [W3++], W6
00611A  DE3348     LSR W6, #8, W6
00611C  984116     MOV.B W6, [W2+1]
00614C  E00004     CP0 W4
00614E  32FFEA     BRA Z, .LBE2, .L34
006150  EB0080     CLR W1
00617A  520F81     SUB W4, W1, [W15]
00617C  36FFD2     BRA LEU, .L48
00617E  900130     MOV [W0+6], W2
006180  37FFE8     BRA .L37
006152  410101     ADD W2, W1, W2
006154  784313     MOV.B [W3], W6
006156  984126     MOV.B W6, [W2+2]
006158  900130     MOV [W0+6], W2
00615A  410101     ADD W2, W1, W2
00615C  BE0313     MOV.D [W3], W6
00615E  DD3C48     SL W7, #8, W8
006160  DE3348     LSR W6, #8, W6
006162  740306     IOR W8, W6, W6
006164  DE3BC8     LSR W7, #8, W7
006166  984136     MOV.B W6, [W2+3]
006168  4080E4     ADD W1, #0x4, W1
00616A  900130     MOV [W0+6], W2
00616C  904323     MOV.B [W3+2], W6
00616E  78F106     MOV.B W6, [W2+W1]
006170  900130     MOV [W0+6], W2
006172  410101     ADD W2, W1, W2
006174  904433     MOV.B [W3+3], W8
006176  984118     MOV.B W8, [W2+1]
006178  4181E4     ADD W3, #0x4, W3
0060E6  B3C141     MOV.B #0x14, W1
006124  E8C285     INC2.B W5, W5
006126  984045     MOV.B W5, [W0+4]
006128  EB4080     CLR.B W1
00612A  984411     MOV.B W1, [W8+1]
00612C  900090     MOV [W0+2], W1
00612E  010001     CALL W1
0060EC  07F9E3     RCALL sendError
0060EE  78044F     MOV [--W15], W8
0060F0  060000     RETURN
006130  78044F     MOV [--W15], W8
006132  060000     RETURN
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006134  37FFDE     BRA .LBB2, .L32, .L51
006038  781F88     MOV W8, [W15++]
00603A  780400     MOV W0, W8
00603C  9000B8     MOV [W8+6], W1
006042  904011     MOV.B [W1+1], W0
006044  FB8000     ZE W0, W0
006046  410000     ADD W2, W0, W0
00603E  904121     MOV.B [W1+2], W2
006040  DD1148     SL W2, #8, W2
006048  780310     MOV [W0], W6
00604A  809353     MOV 0x126A, W3
00604C  900213     MOV [W3+2], W4
00604E  EB0100     CLR W2
006050  130F94     SUBR W6, [W4], [W15]
006052  320012     BRA Z, .L15
006054  900213     MOV [W3+2], W4
006056  E00014     CP0 [W4]
006058  32000F     BRA Z, .L15
00605A  2000C2     MOV #0xC, W2
00605C  900213     MOV [W3+2], W4
00605E  790264     MOV [W4+W2], W4
006060  520F86     SUB W4, W6, [W15]
006062  32000A     BRA Z, .L15
006064  900213     MOV [W3+2], W4
006066  4102EC     ADD W2, #0xC, W5
006068  790264     MOV [W4+W2], W4
00606A  E00004     CP0 W4
00606C  320005     BRA Z, .L15
00606E  780105     MOV W5, W2
006070  900213     MOV [W3+2], W4
006072  790264     MOV [W4+W2], W4
006074  520F86     SUB W4, W6, [W15]
006076  3AFFF6     BRA NZ, .L24
006078  900213     MOV [W3+2], W4
00607A  790264     MOV [W4+W2], W4
00607C  E00004     CP0 W4
00607E  320018     BRA Z, .L25
0060B0  B3C411     MOV.B #0x41, W1
0060B2  780008     MOV W8, W0
0060B4  07F9FF     RCALL sendError
006080  900193     MOV [W3+2], W3
006082  418182     ADD W3, W2, W3
006084  904148     MOV.B [W8+4], W2
006086  514163     SUB.B W2, #0x3, W2
006088  4080E3     ADD W1, #0x3, W1
00608A  9001C3     MOV [W3+8], W3
00608C  010003     CALL W3
00608E  E00400     CP0.B W0
006090  3A0009     BRA NZ, .L26, .L27
0060A4  B3C141     MOV.B #0x14, W1
0060A6  780008     MOV W8, W0
0060A8  07FA05     RCALL sendError
006092  B3C021     MOV.B #0x2, W1
006094  984441     MOV.B W1, [W8+4]
006096  9000B8     MOV [W8+6], W1
006098  984090     MOV.B W0, [W1+1]
00609A  900098     MOV [W8+2], W1
00609C  780008     MOV W8, W0
00609E  010001     CALL W1
0060A0  78044F     MOV [--W15], W8
0060A2  060000     RETURN
0060AA  78044F     MOV [--W15], W8
0060AC  060000     RETURN
0060AE  37FFFA     BRA .L26, .L27
0060B6  78044F     MOV [--W15], W8
0060B8  060000     RETURN
0060BA  37FFF4     BRA .L26, .L27
005FC6  781F88     MOV W8, [W15++]
005FC8  780400     MOV W0, W8
005FCA  900138     MOV [W8+6], W2
005FD2  904112     MOV.B [W2+1], W2
005FD4  FB8102     ZE W2, W2
005FD6  400002     ADD W0, W2, W0
005FCC  E88082     INC2 W2, W1
005FCE  FB8011     ZE [W1], W0
005FD0  DD0048     SL W0, #8, W0
005FD8  780310     MOV [W0], W6
005FDA  809353     MOV 0x126A, W3
005FDC  900213     MOV [W3+2], W4
005FDE  EB0100     CLR W2
005FE0  130F94     SUBR W6, [W4], [W15]
005FE2  320012     BRA Z, .L2
005FE4  900213     MOV [W3+2], W4
005FE6  E00014     CP0 [W4]
005FE8  32000F     BRA Z, .L2
005FEA  2000C2     MOV #0xC, W2
005FEC  900213     MOV [W3+2], W4
005FEE  790264     MOV [W4+W2], W4
005FF0  520F86     SUB W4, W6, [W15]
005FF2  32000A     BRA Z, .L2
005FF4  900213     MOV [W3+2], W4
005FF6  4102EC     ADD W2, #0xC, W5
005FF8  790264     MOV [W4+W2], W4
005FFA  E00004     CP0 W4
005FFC  320005     BRA Z, .L2
005FFE  780105     MOV W5, W2
006000  900213     MOV [W3+2], W4
006002  790264     MOV [W4+W2], W4
006004  520F86     SUB W4, W6, [W15]
006006  3AFFF6     BRA NZ, .L10
006008  900213     MOV [W3+2], W4
00600A  790264     MOV [W4+W2], W4
00600C  E00004     CP0 W4
00600E  32000E     BRA Z, .L11, .L12
00602C  B3C411     MOV.B #0x41, W1
00602E  780008     MOV W8, W0
006030  07FA41     RCALL sendError
006010  900193     MOV [W3+2], W3
006012  418102     ADD W3, W2, W2
006014  900132     MOV [W2+6], W2
006016  010002     CALL W2
006018  E8C000     INC2.B W0, W0
00601A  984440     MOV.B W0, [W8+4]
00601C  900038     MOV [W8+6], W0
00601E  EB4080     CLR.B W1
006020  984011     MOV.B W1, [W0+1]
006022  900098     MOV [W8+2], W1
006024  780008     MOV W8, W0
006026  010001     CALL W1
006028  78044F     MOV [--W15], W8
00602A  060000     RETURN
006032  78044F     MOV [--W15], W8
006034  060000     RETURN
006036  37FFFA     BRA .L11, .L12
---  /home/xc16/release-builds/build_20230327/src/libmf/src/unpackfx.s  ---------------------------------
0014D0  DE0A4F     LSR W1, #15, W4
0014D2  DE0947     LSR W1, #7, W2
0014D4  B207F1     AND #0x7F, W1
0014D6  B20FF2     AND #0xFF, W2
0014D8  32000B     BRA Z, zeroorden
0014DA  B107F2     SUB #0x7F, W2
0014DC  A07001     BSET W1, #7
0014DE  DD08C7     SL W1, #7, W1
0014E0  DE01C9     LSR W0, #9, W3
0014E2  708083     IOR W1, W3, W1
0014E4  DD0047     SL W0, #7, W0
0014E6  A60004     BTSS W4, #0
0014E8  060000     RETURN
0014EA  100060     SUBR W0, #0x0, W0
0014EC  1880E0     SUBBR W1, #0x0, W1
0014EE  060000     RETURN
0014F0  700F81     IOR W0, W1, [W15]
0014F2  3A0001     BRA NZ, denormal
0014F4  060000     RETURN
0014F6  CF8281     FF1L W1, W5
0014F8  E00005     CP0 W5
0014FA  3E0010     BRA GTU, skip1
0014FC  CF8280     FF1L W0, W5
0014FE  4282EE     ADD W5, #0xE, W5
001500  E12870     CP W5, #16
001502  390004     BRA NC, small
001504  3E0007     BRA GTU, big
001506  780080     MOV W0, W1
001508  EB0000     CLR W0
00150A  37000E     BRA fin
00150C  128370     SUBR W5, #0x10, W6
00150E  DE0086     LSR W0, W6, W1
001510  DD0005     SL W0, W5, W0
001512  37000A     BRA fin
001514  528370     SUB W5, #0x10, W6
001516  DD0086     SL W0, W6, W1
001518  EB0000     CLR W0
00151A  370006     BRA fin
00151C  5282E2     SUB W5, #0x2, W5
00151E  DD0885     SL W1, W5, W1
001520  128370     SUBR W5, #0x10, W6
001522  DE0306     LSR W0, W6, W6
001524  708086     IOR W1, W6, W1
001526  DD0005     SL W0, W5, W0
001528  B00775     ADD #0x77, W5
00152A  EA0105     NEG W5, W2
00152C  A60004     BTSS W4, #0
00152E  060000     RETURN
001530  100060     SUBR W0, #0x0, W0
001532  1880E0     SUBBR W1, #0x0, W1
001534  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/unpackdnrmfx.s  -----------------------------
001386  BE9F88     MOV.D W8, [W15++]
001388  EB0400     CLR W8
00138A  E13861     CP W7, #1
00138C  3A0016     BRA NZ, yregs
00138E  E00001     CP0 W1
001390  3A0008     BRA NZ, x1not0
001392  DE00C8     LSR W0, #8, W1
001394  DD0048     SL W0, #8, W0
001396  200088     MOV #0x8, W8
001398  E00001     CP0 W1
00139A  3A0003     BRA NZ, x1not0
00139C  DE00C8     LSR W0, #8, W1
00139E  DD0048     SL W0, #8, W0
0013A0  440468     ADD W8, #0x8, W8
0013A2  CF8481     FF1L W1, W9
0013A4  5484E9     SUB W9, #0x9, W9
0013A6  340006     BRA LE, x1noshift
0013A8  DD0889     SL W1, W9, W1
0013AA  1483F0     SUBR W9, #0x10, W7
0013AC  DE0387     LSR W0, W7, W7
0013AE  708087     IOR W1, W7, W1
0013B0  DD0009     SL W0, W9, W0
0013B2  440409     ADD W8, W9, W8
0013B4  140261     SUBR W8, #0x1, W4
0013B6  BE044F     MOV.D [--W15], W8
0013B8  060000     RETURN
0013BA  E00003     CP0 W3
0013BC  3A0008     BRA NZ, y1not0
0013BE  DE11C8     LSR W2, #8, W3
0013C0  DD1148     SL W2, #8, W2
0013C2  200088     MOV #0x8, W8
0013C4  E00003     CP0 W3
0013C6  3A0003     BRA NZ, y1not0
0013C8  DE11C8     LSR W2, #8, W3
0013CA  DD1148     SL W2, #8, W2
0013CC  440468     ADD W8, #0x8, W8
0013CE  CF8483     FF1L W3, W9
0013D0  5484E9     SUB W9, #0x9, W9
0013D2  340006     BRA LE, y1noshift
0013D4  DD1989     SL W3, W9, W3
0013D6  1483F0     SUBR W9, #0x10, W7
0013D8  DE1387     LSR W2, W7, W7
0013DA  718187     IOR W3, W7, W3
0013DC  DD1109     SL W2, W9, W2
0013DE  440409     ADD W8, W9, W8
0013E0  1402E1     SUBR W8, #0x1, W5
0013E2  37FFE9     BRA leave
---  /home/xc16/release-builds/build_20230327/src/libmf/src/typefx.s  -----------------------------------
0013E4  200027     MOV #0x2, W7
0013E6  A7F001     BTSC W1, #15
0013E8  200017     MOV #0x1, W7
0013EA  DE0B47     LSR W1, #7, W6
0013EC  B20FF6     AND #0xFF, W6
0013EE  320004     BRA Z, chkzeroordenorm
0013F0  E84306     INC.B W6, W6
0013F2  32000A     BRA Z, chknanorinf
0013F4  B30247     IOR #0x24, W7
0013F6  060000     RETURN
0013F8  780301     MOV W1, W6
0013FA  B207F6     AND #0x7F, W6
0013FC  700306     IOR W0, W6, W6
0013FE  3A0002     BRA NZ, denormal
001400  B30307     IOR #0x30, W7
001402  060000     RETURN
001404  B30287     IOR #0x28, W7
001406  060000     RETURN
001408  780301     MOV W1, W6
00140A  B207F6     AND #0x7F, W6
00140C  700306     IOR W0, W6, W6
00140E  320002     BRA Z, infinite
001410  A07007     BSET W7, #7
001412  060000     RETURN
001414  A06007     BSET W7, #6
001416  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/spackfx.s  ----------------------------------
00142A  700181     IOR W0, W1, W3
00142C  320027     BRA Z, zeroarg
00142E  EB0280     CLR W5
001430  A3F801     BTST.Z W1, #15
001432  320003     BRA Z, pos
001434  100060     SUBR W0, #0x0, W0
001436  1880E0     SUBBR W1, #0x0, W1
001438  200015     MOV #0x1, W5
00143A  2007F4     MOV #0x7F, W4
00143C  420202     ADD W4, W2, W4
00143E  340020     BRA LE, denorm
001440  2003F7     MOV #0x3F, W7
001442  600387     AND W0, W7, W7
001444  200406     MOV #0x40, W6
001446  630300     AND W6, W0, W6
001448  200802     MOV #0x80, W2
00144A  610100     AND W2, W0, W2
00144C  DE0047     LSR W0, #7, W0
00144E  DD09C9     SL W1, #9, W3
001450  718000     IOR W3, W0, W0
001452  DE08C7     LSR W1, #7, W1
001454  E00006     CP0 W6
001456  320008     BRA Z, fin
001458  710387     IOR W2, W7, W7
00145A  320006     BRA Z, fin
00145C  B00010     ADD #0x1, W0
00145E  B08001     ADDC #0x0, W1
001460  A38801     BTST.Z W1, #8
001462  320002     BRA Z, fin
001464  DE08C1     LSR W1, #1, W1
001466  E80204     INC W4, W4
001468  B207F1     AND #0x7F, W1
00146A  200FF3     MOV #0xFF, W3
00146C  E12003     CP W4, W3
00146E  3D0003     BRA GE, infinite
001470  DD2247     SL W4, #7, W4
001472  720081     IOR W4, W1, W1
001474  370029     BRA signfix
001476  27F801     MOV #0x7F80, W1
001478  EB0000     CLR W0
00147A  370026     BRA signfix
00147C  B80060     MUL.UU W0, #0x0, W0
00147E  060000     RETURN
001480  120268     SUBR W4, #0x8, W4
001482  E1207F     CP W4, #31
001484  340002     BRA LE, l2
001486  B80060     MUL.UU W0, #0x0, W0
001488  37001F     BRA signfix
00148A  B81160     MUL.UU W2, #0x0, W2
00148C  E12070     CP W4, #16
00148E  350004     BRA LT, l3
001490  780180     MOV W0, W3
001492  780001     MOV W1, W0
001494  EB0080     CLR W1
001496  520270     SUB W4, #0x10, W4
001498  E00004     CP0 W4
00149A  340009     BRA LE, l4
00149C  1203F0     SUBR W4, #0x10, W7
00149E  DD1907     SL W3, W7, W2
0014A0  DE1984     LSR W3, W4, W3
0014A2  DD0307     SL W0, W7, W6
0014A4  718186     IOR W3, W6, W3
0014A6  DE0004     LSR W0, W4, W0
0014A8  DD0B07     SL W1, W7, W6
0014AA  700006     IOR W0, W6, W0
0014AC  DE0884     LSR W1, W4, W1
0014AE  27FFF7     MOV #0x7FFF, W7
0014B0  638383     AND W7, W3, W7
0014B2  710387     IOR W2, W7, W7
0014B4  280006     MOV #0x8000, W6
0014B6  630303     AND W6, W3, W6
0014B8  320007     BRA Z, signfix
0014BA  E00007     CP0 W7
0014BC  3A0003     BRA NZ, l5
0014BE  600161     AND W0, #0x1, W2
0014C0  738102     IOR W7, W2, W2
0014C2  320002     BRA Z, signfix
0014C4  B00010     ADD #0x1, W0
0014C6  B08001     ADDC #0x0, W1
0014C8  A60005     BTSS W5, #0
0014CA  060000     RETURN
0014CC  A0F001     BSET W1, #15
0014CE  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/propnanfx.s  --------------------------------
001418  A37804     BTST.Z W4, #7
00141A  320004     BRA Z, returny
00141C  A37805     BTST.Z W5, #7
00141E  320003     BRA Z, leave
001420  A36801     BTST.Z W1, #6
001422  3A0001     BRA NZ, leave
001424  BE0002     MOV.D W2, W0
001426  A06001     BSET W1, #6
001428  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/mulsf3x.s  ----------------------------------
001226  688303     XOR W1, W3, W6
001228  280007     MOV #0x8000, W7
00122A  630307     AND W6, W7, W6
00122C  DE0A47     LSR W1, #7, W4
00122E  A18004     BCLR W4, #8
001230  DE1AC7     LSR W3, #7, W5
001232  A18005     BCLR W5, #8
001234  200FF7     MOV #0xFF, W7
001236  E12007     CP W4, W7
001238  320042     BRA Z, bigarg
00123A  E12807     CP W5, W7
00123C  320040     BRA Z, bigarg
00123E  BE9F88     MOV.D W8, [W15++]
001240  BE9F8A     MOV.D W10, [W15++]
001242  781F8C     MOV W12, [W15++]
001244  B207F1     AND #0x7F, W1
001246  B207F3     AND #0x7F, W3
001248  E00004     CP0 W4
00124A  320064     BRA Z, smallx
00124C  A07001     BSET W1, #7
00124E  E00005     CP0 W5
001250  320068     BRA Z, smally
001252  A07003     BSET W3, #7
001254  420585     ADD W4, W5, W11
001256  B107EB     SUB #0x7E, W11
001258  B80402     MUL.UU W0, W2, W8
00125A  B80203     MUL.UU W0, W3, W4
00125C  448484     ADD W9, W4, W9
00125E  4A8560     ADDC W5, #0x0, W10
001260  B80A02     MUL.UU W1, W2, W4
001262  448484     ADD W9, W4, W9
001264  4A850A     ADDC W5, W10, W10
001266  B80A03     MUL.UU W1, W3, W4
001268  450504     ADD W10, W4, W10
00126A  330004     BRA N, noadjust
00126C  D00408     SL W8, W8
00126E  D28489     RLC W9, W9
001270  D2850A     RLC W10, W10
001272  E9058B     DEC W11, W11
001274  E15861     CP W11, #1
001276  35003D     BRA LT, isdenorm
001278  201002     MOV #0x100, W2
00127A  610109     AND W2, W9, W2
00127C  200803     MOV #0x80, W3
00127E  618189     AND W3, W9, W3
001280  2007F7     MOV #0x7F, W7
001282  648387     AND W9, W7, W7
001284  738608     IOR W7, W8, W12
001286  DE4CC8     LSR W9, #8, W9
001288  DD53C8     SL W10, #8, W7
00128A  748487     IOR W9, W7, W9
00128C  DE5548     LSR W10, #8, W10
00128E  E00003     CP0 W3
001290  320006     BRA Z, noaddlsb
001292  760382     IOR W12, W2, W7
001294  320004     BRA Z, noaddlsb
001296  E80489     INC W9, W9
001298  4D0560     ADDC W10, #0x0, W10
00129A  A3880A     BTST.Z W10, #8
00129C  3A000C     BRA NZ, carrytob8
00129E  200FF7     MOV #0xFF, W7
0012A0  E15807     CP W11, W7
0012A2  3D0044     BRA GE, overflow
0012A4  A1700A     BCLR W10, #7
0012A6  DD5DC7     SL W11, #7, W11
0012A8  75850A     IOR W11, W10, W10
0012AA  73008A     IOR W6, W10, W1
0012AC  780009     MOV W9, W0
0012AE  78064F     MOV [--W15], W12
0012B0  BE054F     MOV.D [--W15], W10
0012B2  BE044F     MOV.D [--W15], W8
0012B4  060000     RETURN
0012B6  D1050A     LSR W10, W10
0012B8  D38489     RRC W9, W9
0012BA  E8058B     INC W11, W11
0012BC  37FFF0     BRA noaddlsb
0012BE  781F88     MOV W8, [W15++]
0012C0  780406     MOV W6, W8
0012C2  070090     RCALL __typef
0012C4  780207     MOV W7, W4
0012C6  FD0100     EXCH W0, W2
0012C8  FD0181     EXCH W1, W3
0012CA  07008C     RCALL __typef
0012CC  780287     MOV W7, W5
0012CE  720385     IOR W4, W5, W7
0012D0  A37807     BTST.Z W7, #7
0012D2  320005     BRA Z, checkfor0
0012D4  FD0100     EXCH W0, W2
0012D6  FD0181     EXCH W1, W3
0012D8  07009F     RCALL __propnanf
0012DA  78044F     MOV [--W15], W8
0012DC  060000     RETURN
0012DE  720385     IOR W4, W5, W7
0012E0  A34807     BTST.Z W7, #4
0012E2  320003     BRA Z, retinf
0012E4  2FFFF0     MOV #0xFFFF, W0
0012E6  27FFF1     MOV #0x7FFF, W1
0012E8  37FFF8     BRA leavebigarg
0012EA  200000     MOV #0x0, W0
0012EC  27F801     MOV #0x7F80, W1
0012EE  708088     IOR W1, W8, W1
0012F0  37FFF4     BRA leavebigarg
0012F2  780188     MOV W8, W3
0012F4  DD4848     SL W9, #8, W0
0012F6  718180     IOR W3, W0, W3
0012F8  DE4848     LSR W9, #8, W0
0012FA  DD50C8     SL W10, #8, W1
0012FC  700001     IOR W0, W1, W0
0012FE  DE50C8     LSR W10, #8, W1
001300  780406     MOV W6, W8
001302  78010B     MOV W11, W2
001304  070016     RCALL __dnrmpackf
001306  708088     IOR W1, W8, W1
001308  37FFD2     BRA leave
00130A  E00005     CP0 W5
00130C  320005     BRA Z, retsignedzero
00130E  200017     MOV #0x1, W7
001310  07003A     RCALL __unpackdnrmf
001312  37FF9D     BRA xback
001314  700381     IOR W0, W1, W7
001316  3AFFF9     BRA NZ, smallxchky
001318  780086     MOV W6, W1
00131A  78064F     MOV [--W15], W12
00131C  BE054F     MOV.D [--W15], W10
00131E  BE044F     MOV.D [--W15], W8
001320  050000     RETLW #0x0, W0
001322  710383     IOR W2, W3, W7
001324  32FFF9     BRA Z, retsignedzero
001326  200027     MOV #0x2, W7
001328  07002E     RCALL __unpackdnrmf
00132A  37FF94     BRA yback
00132C  27F801     MOV #0x7F80, W1
00132E  708086     IOR W1, W6, W1
001330  37FFF4     BRA leaveres0set0
---  /home/xc16/release-builds/build_20230327/src/libmf/src/dnrmpackfx.s  -------------------------------
001332  E00001     CP0 W1
001334  320026     BRA Z, ret0
001336  110161     SUBR W2, #0x1, W2
001338  E11078     CP W2, #24
00133A  3C0023     BRA GT, ret0
00133C  B82260     MUL.UU W4, #0x0, W4
00133E  E11070     CP W2, #16
001340  350004     BRA LT, sclt16
001342  780280     MOV W0, W5
001344  780001     MOV W1, W0
001346  EB0080     CLR W1
001348  510170     SUB W2, #0x10, W2
00134A  E00002     CP0 W2
00134C  340009     BRA LE, L1
00134E  110370     SUBR W2, #0x10, W6
001350  DD2A06     SL W5, W6, W4
001352  DE2A82     LSR W5, W2, W5
001354  DD0386     SL W0, W6, W7
001356  728287     IOR W5, W7, W5
001358  DE0002     LSR W0, W2, W0
00135A  DD0B86     SL W1, W6, W7
00135C  700007     IOR W0, W7, W0
00135E  DE0882     LSR W1, W2, W1
001360  718184     IOR W3, W4, W3
001362  27FFF4     MOV #0x7FFF, W4
001364  628204     AND W5, W4, W4
001366  718184     IOR W3, W4, W3
001368  280004     MOV #0x8000, W4
00136A  628284     AND W5, W4, W5
00136C  600261     AND W0, #0x1, W4
00136E  A6F005     BTSS W5, #15
001370  060000     RETURN
001372  718204     IOR W3, W4, W4
001374  320007     BRA Z, leave
001376  E80000     INC W0, W0
001378  4880E0     ADDC W1, #0x0, W1
00137A  060000     RETURN
00137C  BE0200     MOV.D W0, W4
00137E  B80060     MUL.UU W0, #0x0, W0
001380  37FFEF     BRA L1
001382  B80060     MUL.UU W0, #0x0, W0
001384  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/divsf3x.s  ----------------------------------
001068  BE9F88     MOV.D W8, [W15++]
00106A  BE9F8A     MOV.D W10, [W15++]
00106C  BE9F8C     MOV.D W12, [W15++]
00106E  20001B     MOV #0x1, W11
001070  BE0202     MOV.D W2, W4
001072  688605     XOR W1, W5, W12
001074  280006     MOV #0x8000, W6
001076  660606     AND W12, W6, W12
001078  DE0947     LSR W1, #7, W2
00107A  B20FF2     AND #0xFF, W2
00107C  320082     BRA Z, chkarg
00107E  E84302     INC.B W2, W6
001080  320080     BRA Z, chkarg
001082  DE29C7     LSR W5, #7, W3
001084  B20FF3     AND #0xFF, W3
001086  32007D     BRA Z, chkarg
001088  E84303     INC.B W3, W6
00108A  32007B     BRA Z, chkarg
00108C  B207F1     AND #0x7F, W1
00108E  A07001     BSET W1, #7
001090  B207F5     AND #0x7F, W5
001092  A07005     BSET W5, #7
001094  DD08C7     SL W1, #7, W1
001096  DE0349     LSR W0, #9, W6
001098  708086     IOR W1, W6, W1
00109A  DD0047     SL W0, #7, W0
00109C  DD2AC7     SL W5, #7, W5
00109E  DE2349     LSR W4, #9, W6
0010A0  728286     IOR W5, W6, W5
0010A2  DD2247     SL W4, #7, W4
0010A4  510503     SUB W2, W3, W10
0010A6  500304     SUB W0, W4, W6
0010A8  588385     SUBB W1, W5, W7
0010AA  310003     BRA C, l2
0010AC  400000     ADD W0, W0, W0
0010AE  488081     ADDC W1, W1, W1
0010B0  E9050A     DEC W10, W10
0010B2  781F8C     MOV W12, [W15++]
0010B4  BE9F8A     MOV.D W10, [W15++]
0010B6  500004     SUB W0, W4, W0
0010B8  588085     SUBB W1, W5, W1
0010BA  420204     ADD W4, W4, W4
0010BC  4A8285     ADDC W5, W5, W5
0010BE  400000     ADD W0, W0, W0
0010C0  488081     ADDC W1, W1, W1
0010C2  EB0500     CLR W10
0010C4  BE0400     MOV.D W0, W8
0010C6  B83360     MUL.UU W6, #0x0, W6
0010C8  BE0604     MOV.D W4, W12
0010CA  E1480D     CP W9, W13
0010CC  310056     BRA C, l4
0010CE  090005     REPEAT #0x5
0010D0  D8CC4D     DIV.UD W8, W13
0010D2  B8010C     MUL.UU W0, W12, W2
0010D4  B8020D     MUL.UU W0, W13, W4
0010D6  418184     ADD W3, W4, W3
0010D8  4A8260     ADDC W5, #0x0, W4
0010DA  538382     SUB W7, W2, W7
0010DC  5C0403     SUBB W8, W3, W8
0010DE  5C8484     SUBB W9, W4, W9
0010E0  5D0560     SUBB W10, #0x0, W10
0010E2  E0000A     CP0 W10
0010E4  3A0025     BRA NZ, l10a
0010E6  780580     MOV W0, W11
0010E8  E1400D     CP W8, W13
0010EA  310049     BRA C, l7
0010EC  780088     MOV W8, W1
0010EE  780007     MOV W7, W0
0010F0  090005     REPEAT #0x5
0010F2  D8884D     DIV.UD W0, W13
0010F4  B8010C     MUL.UU W0, W12, W2
0010F6  B8020D     MUL.UU W0, W13, W4
0010F8  418184     ADD W3, W4, W3
0010FA  4A8260     ADDC W5, #0x0, W4
0010FC  110360     SUBR W2, #0x0, W6
0010FE  5B8383     SUBB W7, W3, W7
001100  5C0404     SUBB W8, W4, W8
001102  5C84E0     SUBB W9, #0x0, W9
001104  E00009     CP0 W9
001106  3A0021     BRA NZ, l10b
001108  BE014F     MOV.D [--W15], W2
00110A  E00003     CP0 W3
00110C  32002B     BRA Z, l11
00110E  6001E3     AND W0, #0x3, W3
001110  730607     IOR W6, W7, W12
001112  71818C     IOR W3, W12, W3
001114  320001     BRA Z, l10
001116  700064     IOR W0, #0x4, W0
001118  DE0042     LSR W0, #2, W0
00111A  DD5E4E     SL W11, #14, W12
00111C  70000C     IOR W0, W12, W0
00111E  DE58C2     LSR W11, #2, W1
001120  A0E001     BSET W1, #14
001122  070183     RCALL __spackf
001124  7801CF     MOV [--W15], W3
001126  718081     IOR W3, W1, W1
001128  BE064F     MOV.D [--W15], W12
00112A  BE054F     MOV.D [--W15], W10
00112C  BE044F     MOV.D [--W15], W8
00112E  060000     RETURN
001130  43838C     ADD W7, W12, W7
001132  4C040D     ADDC W8, W13, W8
001134  4C84E0     ADDC W9, #0x0, W9
001136  4D0560     ADDC W10, #0x0, W10
001138  E90000     DEC W0, W0
00113A  E0000A     CP0 W10
00113C  32FFD4     BRA Z, l6
00113E  43838C     ADD W7, W12, W7
001140  4C040D     ADDC W8, W13, W8
001142  4C84E0     ADDC W9, #0x0, W9
001144  4D0560     ADDC W10, #0x0, W10
001146  E90000     DEC W0, W0
001148  37FFCE     BRA l6
00114A  43030C     ADD W6, W12, W6
00114C  4B838D     ADDC W7, W13, W7
00114E  4C0460     ADDC W8, #0x0, W8
001150  4C84E0     ADDC W9, #0x0, W9
001152  E90000     DEC W0, W0
001154  E00009     CP0 W9
001156  32FFD8     BRA Z, l9
001158  43030C     ADD W6, W12, W6
00115A  4B838D     ADDC W7, W13, W7
00115C  4C0460     ADDC W8, #0x0, W8
00115E  4C84E0     ADDC W9, #0x0, W9
001160  E90000     DEC W0, W0
001162  37FFD2     BRA l9
001164  DE0042     LSR W0, #2, W0
001166  DD5E4E     SL W11, #14, W12
001168  70000C     IOR W0, W12, W0
00116A  DE58C2     LSR W11, #2, W1
00116C  A0E001     BSET W1, #14
00116E  7801CF     MOV [--W15], W3
001170  E00003     CP0 W3
001172  32FFDA     BRA Z, final
001174  100060     SUBR W0, #0x0, W0
001176  1880E0     SUBBR W1, #0x0, W1
001178  37FFD7     BRA final
00117A  2FFFF0     MOV #0xFFFF, W0
00117C  37FFAA     BRA l5
00117E  2FFFF0     MOV #0xFFFF, W0
001180  37FFB9     BRA l8
001182  BE0404     MOV.D W4, W8
001184  07012F     RCALL __typef
001186  780687     MOV W7, W13
001188  FD0400     EXCH W0, W8
00118A  FD0481     EXCH W1, W9
00118C  07012B     RCALL __typef
00118E  668307     AND W13, W7, W6
001190  A37806     BTST.Z W6, #7
001192  320003     BRA Z, l12
001194  A76009     BTSC W9, #6
001196  BE0008     MOV.D W8, W0
001198  37002C     BRA setedom
00119A  A3780D     BTST.Z W13, #7
00119C  320002     BRA Z, l13
00119E  BE0008     MOV.D W8, W0
0011A0  370028     BRA setedom
0011A2  A37807     BTST.Z W7, #7
0011A4  3A0026     BRA NZ, setedom
0011A6  A1F001     BCLR W1, #15
0011A8  A1F009     BCLR W9, #15
0011AA  A36806     BTST.Z W6, #6
0011AC  320003     BRA Z, l14
0011AE  27FFF1     MOV #0x7FFF, W1
0011B0  2FFFF0     MOV #0xFFFF, W0
0011B2  37FFBA     BRA final
0011B4  A3680D     BTST.Z W13, #6
0011B6  320003     BRA Z, l15
0011B8  BE0008     MOV.D W8, W0
0011BA  70808C     IOR W1, W12, W1
0011BC  37FFB5     BRA final
0011BE  A36807     BTST.Z W7, #6
0011C0  3A0007     BRA NZ, retzero
0011C2  A34806     BTST.Z W6, #4
0011C4  320003     BRA Z, l16
0011C6  27FFF1     MOV #0x7FFF, W1
0011C8  2FFFF0     MOV #0xFFFF, W0
0011CA  37FFAE     BRA final
0011CC  A3480D     BTST.Z W13, #4
0011CE  320003     BRA Z, l17
0011D0  B80060     MUL.UU W0, #0x0, W0
0011D2  70808C     IOR W1, W12, W1
0011D4  37FFA9     BRA final
0011D6  A34807     BTST.Z W7, #4
0011D8  320004     BRA Z, l18
0011DA  27F801     MOV #0x7F80, W1
0011DC  200000     MOV #0x0, W0
0011DE  70808C     IOR W1, W12, W1
0011E0  37FFA3     BRA final
0011E2  070176     RCALL __unpackf
0011E4  FD0400     EXCH W0, W8
0011E6  FD0481     EXCH W1, W9
0011E8  780502     MOV W2, W10
0011EA  070172     RCALL __unpackf
0011EC  BE0208     MOV.D W8, W4
0011EE  78018A     MOV W10, W3
0011F0  37FF59     BRA divfsub
0011F2  A06001     BSET W1, #6
0011F4  200212     MOV #0x21, W2
0011F6  889372     MOV W2, _errno
0011F8  37FF97     BRA final
0011FA  E00001     CP0 W1
0011FC  320012     BRA Z, zero_res
0011FE  E00005     CP0 W5
001200  320010     BRA Z, zero_res
001202  BE9F88     MOV.D W8, [W15++]
001204  BE9F8A     MOV.D W10, [W15++]
001206  BE9F8C     MOV.D W12, [W15++]
001208  EB0600     CLR W12
00120A  A3F801     BTST.Z W1, #15
00120C  320003     BRA Z, testb
00120E  100060     SUBR W0, #0x0, W0
001210  1880E0     SUBBR W1, #0x0, W1
001212  A0F00C     BSET W12, #15
001214  A3F805     BTST.Z W5, #15
001216  320003     BRA Z, l1
001218  120260     SUBR W4, #0x0, W4
00121A  1A82E0     SUBBR W5, #0x0, W5
00121C  A2F00C     BTG W12, #15
00121E  EB0580     CLR W11
001220  37FF41     BRA divfsub
001222  B80060     MUL.UU W0, #0x0, W0
001224  050002     RETLW #0x0, W2
---  /home/xc16/release-builds/build_20230327/src/libmf/src/addsf3x.s  ----------------------------------
000E8C  27F807     MOV #0x7F80, W7
000E8E  618307     AND W3, W7, W6
000E90  E13806     CP W7, W6
000E92  3A0004     BRA NZ, subtoggle
000E94  2007F7     MOV #0x7F, W7
000E96  618387     AND W3, W7, W7
000E98  710387     IOR W2, W7, W7
000E9A  3A0001     BRA NZ, ___addsf3x, ___addsf3
000E9C  A2F003     BTG W3, #15
000E9E  BE9F88     MOV.D W8, [W15++]
000EA0  BE9F8A     MOV.D W10, [W15++]
000EA2  BE9F8C     MOV.D W12, [W15++]
000EA4  DE0A47     LSR W1, #7, W4
000EA6  A18004     BCLR W4, #8
000EA8  DE1AC7     LSR W3, #7, W5
000EAA  A18005     BCLR W5, #8
000EAC  280007     MOV #0x8000, W7
000EAE  608507     AND W1, W7, W10
000EB0  618587     AND W3, W7, W11
000EB2  200FF7     MOV #0xFF, W7
000EB4  E12007     CP W4, W7
000EB6  32009E     BRA Z, bigarg
000EB8  E12807     CP W5, W7
000EBA  32009C     BRA Z, bigarg
000EBC  780601     MOV W1, W12
000EBE  E00004     CP0 W4
000EC0  3200B4     BRA Z, smallx
000EC2  2007F7     MOV #0x7F, W7
000EC4  608087     AND W1, W7, W1
000EC6  A07001     BSET W1, #7
000EC8  E00005     CP0 W5
000ECA  3200C0     BRA Z, smally
000ECC  2007F7     MOV #0x7F, W7
000ECE  618187     AND W3, W7, W3
000ED0  A07003     BSET W3, #7
000ED2  520605     SUB W4, W5, W12
000ED4  3A000F     BRA NZ, xexpyexpnoteq
000ED6  E1500B     CP W10, W11
000ED8  32000B     BRA Z, signeq
000EDA  E10803     CP W1, W3
000EDC  3A0002     BRA NZ, x1y1noteq
000EDE  E10002     CP W0, W2
000EE0  32007E     BRA Z, return0
000EE2  500402     SUB W0, W2, W8
000EE4  588483     SUBB W1, W3, W9
000EE6  310004     BRA C, signeq
000EE8  FD0100     EXCH W0, W2
000EEA  FD0181     EXCH W1, W3
000EEC  FD0284     EXCH W4, W5
000EEE  FD058A     EXCH W10, W11
000EF0  B84460     MUL.UU W8, #0x0, W8
000EF2  370021     BRA bottomexp
000EF4  E12005     CP W4, W5
000EF6  3D0005     BRA GE, xexpgeyexp
000EF8  FD0100     EXCH W0, W2
000EFA  FD0181     EXCH W1, W3
000EFC  FD0284     EXCH W4, W5
000EFE  FD058A     EXCH W10, W11
000F00  520605     SUB W4, W5, W12
000F02  E1607A     CP W12, #26
000F04  350005     BRA LT, sclt26
000F06  A17001     BCLR W1, #7
000F08  DD2247     SL W4, #7, W4
000F0A  708084     IOR W1, W4, W1
000F0C  70808A     IOR W1, W10, W1
000F0E  370063     BRA leave
000F10  B84460     MUL.UU W8, #0x0, W8
000F12  6602EF     AND W12, #0xF, W5
000F14  2FFF07     MOV #0xFFF0, W7
000F16  660607     AND W12, W7, W12
000F18  E00005     CP0 W5
000F1A  340006     BRA LE, scnoshift
000F1C  1283F0     SUBR W5, #0x10, W7
000F1E  DD1487     SL W2, W7, W9
000F20  DE1105     LSR W2, W5, W2
000F22  DD1B07     SL W3, W7, W6
000F24  710106     IOR W2, W6, W2
000F26  DE1985     LSR W3, W5, W3
000F28  E16070     CP W12, #16
000F2A  350005     BRA LT, bottomexp
000F2C  780409     MOV W9, W8
000F2E  780482     MOV W2, W9
000F30  780103     MOV W3, W2
000F32  EB0180     CLR W3
000F34  560670     SUB W12, #0x10, W12
000F36  E1500B     CP W10, W11
000F38  3A0003     BRA NZ, dosubt
000F3A  400002     ADD W0, W2, W0
000F3C  488083     ADDC W1, W3, W1
000F3E  370004     BRA createres
000F40  140460     SUBR W8, #0x0, W8
000F42  1C84E0     SUBBR W9, #0x0, W9
000F44  580002     SUBB W0, W2, W0
000F46  588083     SUBB W1, W3, W1
000F48  A38801     BTST.Z W1, #8
000F4A  320006     BRA Z, nocarry
000F4C  D10081     LSR W1, W1
000F4E  D38000     RRC W0, W0
000F50  D38489     RRC W9, W9
000F52  D38408     RRC W8, W8
000F54  E80204     INC W4, W4
000F56  370027     BRA nonorm
000F58  A37801     BTST.Z W1, #7
000F5A  3A0025     BRA NZ, nonorm
000F5C  E00001     CP0 W1
000F5E  320003     BRA Z, l2
000F60  CF8681     FF1L W1, W13
000F62  568669     SUB W13, #0x9, W12
000F64  37000A     BRA l3
000F66  20008C     MOV #0x8, W12
000F68  E00000     CP0 W0
000F6A  3A0004     BRA NZ, l2not0
000F6C  780009     MOV W9, W0
000F6E  780488     MOV W8, W9
000F70  EB0400     CLR W8
000F72  520270     SUB W4, #0x10, W4
000F74  CF8680     FF1L W0, W13
000F76  46060D     ADD W12, W13, W12
000F78  E9060C     DEC W12, W12
000F7A  E16070     CP W12, #16
000F7C  350006     BRA LT, l4sclt16
000F7E  780080     MOV W0, W1
000F80  780009     MOV W9, W0
000F82  780488     MOV W8, W9
000F84  EB0400     CLR W8
000F86  560670     SUB W12, #0x10, W12
000F88  520270     SUB W4, #0x10, W4
000F8A  E0000C     CP0 W12
000F8C  34000C     BRA LE, nonorm
000F8E  DD088C     SL W1, W12, W1
000F90  1603F0     SUBR W12, #0x10, W7
000F92  DE0307     LSR W0, W7, W6
000F94  708086     IOR W1, W6, W1
000F96  DD000C     SL W0, W12, W0
000F98  DE4B07     LSR W9, W7, W6
000F9A  700006     IOR W0, W6, W0
000F9C  DD4C8C     SL W9, W12, W9
000F9E  DE4307     LSR W8, W7, W6
000FA0  748486     IOR W9, W6, W9
000FA2  DD440C     SL W8, W12, W8
000FA4  52020C     SUB W4, W12, W4
000FA6  E12061     CP W4, #1
000FA8  350020     BRA LT, resdenorm
000FAA  600161     AND W0, #0x1, W2
000FAC  280007     MOV #0x8000, W7
000FAE  648187     AND W9, W7, W3
000FB0  27FFF7     MOV #0x7FFF, W7
000FB2  648387     AND W9, W7, W7
000FB4  740307     IOR W8, W7, W6
000FB6  E00003     CP0 W3
000FB8  320006     BRA Z, noaddlsb
000FBA  730382     IOR W6, W2, W7
000FBC  320004     BRA Z, noaddlsb
000FBE  E80000     INC W0, W0
000FC0  4880E0     ADDC W1, #0x0, W1
000FC2  A38801     BTST.Z W1, #8
000FC4  3A000E     BRA NZ, carryb8
000FC6  200FF7     MOV #0xFF, W7
000FC8  E12007     CP W4, W7
000FCA  3D004A     BRA GE, overflow
000FCC  A17001     BCLR W1, #7
000FCE  DD2247     SL W4, #7, W4
000FD0  720081     IOR W4, W1, W1
000FD2  70808A     IOR W1, W10, W1
000FD4  BE0000     MOV.D W0, W0
000FD6  BE064F     MOV.D [--W15], W12
000FD8  BE054F     MOV.D [--W15], W10
000FDA  BE044F     MOV.D [--W15], W8
000FDC  060000     RETURN
000FDE  B80060     MUL.UU W0, #0x0, W0
000FE0  37FFFA     BRA leave
000FE2  D10081     LSR W1, W1
000FE4  D38000     RRC W0, W0
000FE6  E80204     INC W4, W4
000FE8  37FFEE     BRA noaddlsb
000FEA  780104     MOV W4, W2
000FEC  740189     IOR W8, W9, W3
000FEE  0701A1     RCALL __dnrmpackf
000FF0  70808A     IOR W1, W10, W1
000FF2  37FFF1     BRA leave
000FF4  0701F7     RCALL __typef
000FF6  780207     MOV W7, W4
000FF8  FD0100     EXCH W0, W2
000FFA  FD0181     EXCH W1, W3
000FFC  0701F3     RCALL __typef
000FFE  780287     MOV W7, W5
001000  720385     IOR W4, W5, W7
001002  A37807     BTST.Z W7, #7
001004  320004     BRA Z, checkforinf
001006  FD0100     EXCH W0, W2
001008  FD0181     EXCH W1, W3
00100A  070206     RCALL __propnanf
00100C  37FFE4     BRA leave
00100E  620385     AND W4, W5, W7
001010  A36807     BTST.Z W7, #6
001012  320008     BRA Z, chkxinf
001014  E1500B     CP W10, W11
001016  320003     BRA Z, retx
001018  2FFFF0     MOV #0xFFFF, W0
00101A  27FFF1     MOV #0x7FFF, W1
00101C  37FFDC     BRA leave
00101E  FD0100     EXCH W0, W2
001020  FD0181     EXCH W1, W3
001022  37FFD9     BRA leave
001024  A36804     BTST.Z W4, #6
001026  32FFD7     BRA Z, leave
001028  37FFFA     BRA retx
00102A  27FFF8     MOV #0x7FFF, W8
00102C  608388     AND W1, W8, W7
00102E  3A000B     BRA NZ, smallxdenorm
001030  E00000     CP0 W0
001032  3A0009     BRA NZ, smallxdenorm
001034  640383     AND W8, W3, W7
001036  738382     IOR W7, W2, W7
001038  320002     BRA Z, xandy0
00103A  BE0002     MOV.D W2, W0
00103C  37FFCC     BRA leave
00103E  E1500B     CP W10, W11
001040  3AFFCE     BRA NZ, return0
001042  BE0002     MOV.D W2, W0
001044  37FFC8     BRA leave
001046  200014     MOV #0x1, W4
001048  640081     AND W8, W1, W1
00104A  37FF3E     BRA xback
00104C  27FFF8     MOV #0x7FFF, W8
00104E  618388     AND W3, W8, W7
001050  3A0004     BRA NZ, smallydenorm
001052  E00002     CP0 W2
001054  3A0002     BRA NZ, smallydenorm
001056  78008C     MOV W12, W1
001058  37FFBE     BRA leave
00105A  200015     MOV #0x1, W5
00105C  640183     AND W8, W3, W3
00105E  37FF39     BRA yback
001060  27F801     MOV #0x7F80, W1
001062  200000     MOV #0x0, W0
001064  750081     IOR W10, W1, W1
001066  37FFB7     BRA leave
---  /home/xc16/release-builds/build_20230327/src/libm/src/umuldi3.s  -----------------------------------
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
000004  000B9A     NOP
000006  000B2E     NOP
000008  000B4A     NOP
00000A  000BD2     NOP
00000C  000BB6     NOP
00000E  000920     NOP
000010  000B66     NOP
000012  00091A     NOP
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
00001C  000920     NOP
00001E  000920     NOP
000020  000920     NOP
000022  000BF6     NOP
000024  000920     NOP
000026  000920     NOP
000028  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
00002E  000920     NOP
000030  000920     NOP
000032  000920     NOP
000034  000920     NOP
000036  000920     NOP
000038  000920     NOP
00003A  000920     NOP
00003C  000920     NOP
00003E  000920     NOP
000040  000920     NOP
000042  000920     NOP
---  /home/xc16/release-builds/build_20230327/src/libm/src/umodsi3.s  -----------------------------------
000E86  07FFEF     RCALL ___udivsi3
000E88  BE0004     MOV.D W4, W0
000E8A  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/udivsi3.s  -----------------------------------
000E66  B82260     MUL.UU W4, #0x0, W4
000E68  200206     MOV #0x20, W6
000E6A  D00000     SL W0, W0
000E6C  D28081     RLC W1, W1
000E6E  D28204     RLC W4, W4
000E70  D28285     RLC W5, W5
000E72  A00000     BSET W0, #0
000E74  520202     SUB W4, W2, W4
000E76  5A8283     SUBB W5, W3, W5
000E78  310003     BRA C, iterate
000E7A  420202     ADD W4, W2, W4
000E7C  4A8283     ADDC W5, W3, W5
000E7E  A10000     BCLR W0, #0
000E80  E90306     DEC W6, W6
000E82  3AFFF3     BRA NZ, nextbit
000E84  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/mulsi3.s  ------------------------------------
003346  B90A02     MUL.SU W1, W2, W4
003348  B91B00     MUL.SU W3, W0, W6
00334A  B80002     MUL.UU W0, W2, W0
00334C  420081     ADD W4, W1, W1
00334E  430081     ADD W6, W1, W1
003350  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/modsi3.s  ------------------------------------
000E48  781F81     MOV W1, [W15++]
000E4A  E00001     CP0 W1
000E4C  3D0002     BRA GE, modtestb
000E4E  100060     SUBR W0, #0x0, W0
000E50  1880E0     SUBBR W1, #0x0, W1
000E52  E00003     CP0 W3
000E54  3D0002     BRA GE, calcrem
000E56  110160     SUBR W2, #0x0, W2
000E58  1981E0     SUBBR W3, #0x0, W3
000E5A  070015     RCALL ___umodsi3
000E5C  E0004F     CP0 [--W15]
000E5E  3B0002     BRA NN, exitr
000E60  100060     SUBR W0, #0x0, W0
000E62  1880E0     SUBBR W1, #0x0, W1
000E64  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/funpack2.s  ----------------------------------
00172A  BE0400     MOV.D W0, W8
00172C  07FB78     RCALL __funpack
00172E  BE0300     MOV.D W0, W6
001730  BE0504     MOV.D W4, W10
001732  BE0002     MOV.D W2, W0
001734  07FB74     RCALL __funpack
001736  754F84     IOR.B W10, W4, [W15]
001738  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/funpack.s  -----------------------------------
000E1E  DE0AC7     LSR W1, #7, W5
000E20  B207F1     AND #0x7F, W1
000E22  B20FF5     AND #0xFF, W5
000E24  320008     BRA Z, zeroorsub
000E26  42CFE1     ADD.B W5, #0x1, [W15]
000E28  320002     BRA Z, nanorinf
000E2A  A07001     BSET W1, #7
000E2C  050024     RETLW #0x2, W4
000E2E  700F81     IOR W0, W1, [W15]
000E30  320001     BRA Z, infinite
000E32  050804     RETLW #0x80, W4
000E34  050044     RETLW #0x4, W4
000E36  700F81     IOR W0, W1, [W15]
000E38  3A0002     BRA NZ, subnormal
000E3A  050014     RETLW #0x1, W4
000E3C  E90285     DEC W5, W5
000E3E  400000     ADD W0, W0, W0
000E40  48C081     ADDC.B W1, W1, W1
000E42  3BFFFC     BRA NN, normalize
000E44  A07001     BSET W1, #7
000E46  050024     RETLW #0x2, W4
---  /home/xc16/release-builds/build_20230327/src/libm/src/fpack.s  -------------------------------------
000DD2  200081     MOV #0x8, W1
000DD4  558061     SUB W11, #0x1, W0
000DD6  3D000B     BRA GE, notsubnormal
000DD8  20000B     MOV #0x0, W11
000DDA  2FFE61     MOV #0xFFE6, W1
000DDC  E10001     CP W0, W1
000DDE  34001D     BRA LE, zerosig
000DE0  718182     IOR W3, W2, W3
000DE2  640161     AND W8, #0x1, W2
000DE4  D10489     LSR W9, W9
000DE6  D38408     RRC W8, W8
000DE8  E80000     INC W0, W0
000DEA  3AFFFA     BRA NZ, subnormal
000DEC  200071     MOV #0x7, W1
000DEE  640061     AND W8, #0x1, W0
000DF0  700003     IOR W0, W3, W0
000DF2  600002     AND W0, W2, W0
000DF4  320009     BRA Z, packupandgo
000DF6  440461     ADD W8, #0x1, W8
000DF8  4C84E0     ADDC W9, #0x0, W9
000DFA  A58809     BTST.Z W9, W1
000DFC  320005     BRA Z, packupandgo
000DFE  E8058B     INC W11, W11
000E00  E10868     CP W1, #8
000E02  3A0002     BRA NZ, packupandgo
000E04  D10489     LSR W9, W9
000E06  D38408     RRC W8, W8
000E08  200FF2     MOV #0xFF, W2
000E0A  E15802     CP W11, W2
000E0C  3D0005     BRA GE, overflow
000E0E  DD5DC7     SL W11, #7, W11
000E10  B207F9     AND #0x7F, W9
000E12  758089     IOR W11, W9, W1
000E14  780008     MOV W8, W0
000E16  060000     RETURN
000E18  27F80B     MOV #0x7F80, W11
000E1A  78008B     MOV W11, W1
000E1C  050000     RETLW #0x0, W0
---  /home/xc16/release-builds/build_20230327/src/libm/src/fne.s  ---------------------------------------
000DCE  200004     MOV #0x0, W4
000DD0  370491     BRA __fcompare
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatundisf.s  -------------------------------
000D70  BE9F88     MOV.D W8, [W15++]
000D72  BE9F8A     MOV.D W10, [W15++]
000D74  708200     IOR W1, W0, W4
000D76  710204     IOR W2, W4, W4
000D78  718204     IOR W3, W4, W4
000D7A  320026     BRA Z, return0
000D7C  BE0400     MOV.D W0, W8
000D7E  BE0002     MOV.D W2, W0
000D80  B81160     MUL.UU W2, #0x0, W2
000D82  20096B     MOV #0x96, W11
000D84  200295     MOV #0x29, W5
000D86  CF8201     FF1L W1, W4
000D88  39000A     BRA NC, fixshift
000D8A  B14105     SUB.B #0x10, W5
000D8C  CF8200     FF1L W0, W4
000D8E  390007     BRA NC, fixshift
000D90  B14105     SUB.B #0x10, W5
000D92  CF8209     FF1L W9, W4
000D94  390004     BRA NC, fixshift
000D96  B14105     SUB.B #0x10, W5
000D98  CF8208     FF1L W8, W4
000D9A  390001     BRA NC, fixshift
000D9C  B14105     SUB.B #0x10, W5
000D9E  524205     SUB.B W4, W5, W4
000DA0  320012     BRA Z, round
000DA2  3B000A     BRA NN, shiftleft
000DA4  718182     IOR W3, W2, W3
000DA6  640161     AND W8, #0x1, W2
000DA8  D10081     LSR W1, W1
000DAA  D38000     RRC W0, W0
000DAC  D38489     RRC W9, W9
000DAE  D38408     RRC W8, W8
000DB0  E8058B     INC W11, W11
000DB2  E84204     INC.B W4, W4
000DB4  3AFFF7     BRA NZ, shiftright
000DB6  370007     BRA round
000DB8  440408     ADD W8, W8, W8
000DBA  4C8489     ADDC W9, W9, W9
000DBC  480000     ADDC W0, W0, W0
000DBE  488081     ADDC W1, W1, W1
000DC0  E9058B     DEC W11, W11
000DC2  E94204     DEC.B W4, W4
000DC4  3AFFF9     BRA NZ, shiftleft
000DC6  070005     RCALL __fpack
000DC8  BE054F     MOV.D [--W15], W10
000DCA  BE044F     MOV.D [--W15], W8
000DCC  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatsisf.s  ---------------------------------
000D6A  DE894F     ASR W1, #15, W2
000D6C  780182     MOV W2, W3
000D6E  37FFED     BRA ___floatdisf
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatdisf.s  ---------------------------------
000D4A  781F88     MOV W8, [W15++]
000D4C  780403     MOV W3, W8
000D4E  E00003     CP0 W3
000D50  3D0007     BRA GE, notspecial
000D52  100060     SUBR W0, #0x0, W0
000D54  1880E0     SUBBR W1, #0x0, W1
000D56  190160     SUBBR W2, #0x0, W2
000D58  1981E0     SUBBR W3, #0x0, W3
000D5A  3B0002     BRA NN, notspecial
000D5C  2DF001     MOV #0xDF00, W1
000D5E  370003     BRA return0
000D60  070007     RCALL ___floatundisf
000D62  A7F008     BTSC W8, #15
000D64  A0F001     BSET W1, #15
000D66  78044F     MOV [--W15], W8
000D68  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/fixunssfsi.s  --------------------------------
000D14  BE0100     MOV.D W0, W2
000D16  070083     RCALL __funpack
000D18  A77004     BTSC W4, #7
000D1A  A1F003     BCLR W3, #15
000D1C  A3F803     BTST.Z W3, #15
000D1E  3A0013     BRA NZ, returnzero
000D20  B10965     SUB #0x96, W5
000D22  320010     BRA Z, exit
000D24  350009     BRA LT, shiftright
000D26  E12869     CP W5, #9
000D28  350002     BRA LT, shiftleft
000D2A  280001     MOV #0x8000, W1
000D2C  050000     RETLW #0x0, W0
000D2E  400000     ADD W0, W0, W0
000D30  488081     ADDC W1, W1, W1
000D32  E90285     DEC W5, W5
000D34  3AFFFC     BRA NZ, shiftleft
000D36  060000     RETURN
000D38  428FF8     ADD W5, #0x18, [W15]
000D3A  350005     BRA LT, returnzero
000D3C  D10081     LSR W1, W1
000D3E  D38000     RRC W0, W0
000D40  E80285     INC W5, W5
000D42  3AFFFC     BRA NZ, shiftrightloop
000D44  060000     RETURN
000D46  EB0080     CLR W1
000D48  050000     RETLW #0x0, W0
---  /home/xc16/release-builds/build_20230327/src/libm/src/fixsfsi.s  -----------------------------------
000CD2  BE0100     MOV.D W0, W2
000CD4  0700A4     RCALL __funpack
000CD6  A77004     BTSC W4, #7
000CD8  A1F003     BCLR W3, #15
000CDA  B10965     SUB #0x96, W5
000CDC  320016     BRA Z, setsign
000CDE  35000D     BRA LT, shiftright
000CE0  E12868     CP W5, #8
000CE2  350006     BRA LT, shiftleft
000CE4  2FFFF0     MOV #0xFFFF, W0
000CE6  27FFF1     MOV #0x7FFF, W1
000CE8  E00003     CP0 W3
000CEA  3B0013     BRA NN, exit
000CEC  280001     MOV #0x8000, W1
000CEE  050000     RETLW #0x0, W0
000CF0  400000     ADD W0, W0, W0
000CF2  488081     ADDC W1, W1, W1
000CF4  E90285     DEC W5, W5
000CF6  3AFFFC     BRA NZ, shiftleft
000CF8  370008     BRA setsign
000CFA  428FF8     ADD W5, #0x18, [W15]
000CFC  3C0002     BRA GT, shiftrightloop
000CFE  EB0080     CLR W1
000D00  050000     RETLW #0x0, W0
000D02  D10081     LSR W1, W1
000D04  D38000     RRC W0, W0
000D06  E80285     INC W5, W5
000D08  3AFFFC     BRA NZ, shiftrightloop
000D0A  E00003     CP0 W3
000D0C  3B0002     BRA NN, exit
000D0E  100060     SUBR W0, #0x0, W0
000D10  1880E0     SUBBR W1, #0x0, W1
000D12  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/fixsfdi.s  -----------------------------------
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
000004  000B9A     NOP
000006  000B2E     NOP
000008  000B4A     NOP
00000A  000BD2     NOP
00000C  000BB6     NOP
00000E  000920     NOP
000010  000B66     NOP
00000C  000BB6     NOP
00000E  000920     NOP
000010  000B66     NOP
000012  00091A     NOP
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
000012  00091A     NOP
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
00001C  000920     NOP
00001E  000920     NOP
000020  000920     NOP
00001C  000920     NOP
00001E  000920     NOP
000020  000920     NOP
000022  000BF6     NOP
000024  000920     NOP
000026  000920     NOP
000028  000920     NOP
00002A  000C36     NOP
000026  000920     NOP
000028  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
00002A  000C36     NOP
00002C  000920     NOP
00002E  000920     NOP
000030  000920     NOP
000032  000920     NOP
000034  000920     NOP
000036  000920     NOP
000032  000920     NOP
000034  000920     NOP
000036  000920     NOP
000038  000920     NOP
00003A  000920     NOP
00003C  000920     NOP
00003A  000920     NOP
00003C  000920     NOP
00003E  000920     NOP
000040  000920     NOP
000042  000920     NOP
00003C  000920     NOP
00003E  000920     NOP
000040  000920     NOP
000042  000920     NOP
000044  000C16     NOP
000042  000920     NOP
000044  000C16     NOP
000046  000920     NOP
000044  000C16     NOP
000046  000920     NOP
000048  000920     NOP
000046  000920     NOP
000048  000920     NOP
00004A  000920     NOP
00004C  000920     NOP
00004E  000920     NOP
00004A  000920     NOP
00004C  000920     NOP
00004E  000920     NOP
00004C  000920     NOP
00004E  000920     NOP
000050  000920     NOP
---  /home/xc16/release-builds/build_20230327/src/libm/src/fixdfsi.s  -----------------------------------
0032EE  FA0014     LNK #0x14
0032F0  BE9F88     MOV.D W8, [W15++]
0032F2  BE9F8A     MOV.D W10, [W15++]
0032F4  BE9F8C     MOV.D W12, [W15++]
0032F6  BE0400     MOV.D W0, W8
0032F8  BE0502     MOV.D W2, W10
0032FA  470068     ADD W14, #0x8, W0
0032FC  BE900A     MOV.D W10, [W0--]
0032FE  BE9008     MOV.D W8, [W0--]
003300  070249     RCALL __dunpack
003302  A77000     BTSC W0, #7
003304  A1F00B     BCLR W11, #15
003306  204330     MOV #0x433, W0
003308  90029E     MOV [W14+2], W5
00330A  528280     SUB W5, W0, W5
00330C  2FFEB0     MOV #0xFFEB, W0
00330E  E12800     CP W5, W0
003310  3D0011     BRA GE, overflow
003312  2FFCB0     MOV #0xFFCB, W0
003314  E12800     CP W5, W0
003316  340015     BRA LE, underflow
003318  90091E     MOV [W14+18], W2
00331A  90088E     MOV [W14+16], W1
00331C  90007E     MOV [W14+14], W0
00331E  B00105     ADD #0x10, W5
003320  D10102     LSR W2, W2
003322  D38081     RRC W1, W1
003324  D38000     RRC W0, W0
003326  E80285     INC W5, W5
003328  3AFFFB     BRA NZ, shiftrightloop
00332A  E0000B     CP0 W11
00332C  3B026E     BRA NN, __dunpack2exit
00332E  100060     SUBR W0, #0x0, W0
003330  1880E0     SUBBR W1, #0x0, W1
003332  37026B     BRA __dunpack2exit
003334  2FFFF0     MOV #0xFFFF, W0
003336  27FFF1     MOV #0x7FFF, W1
003338  E0000B     CP0 W11
00333A  3B0267     BRA NN, __dunpack2exit
00333C  280001     MOV #0x8000, W1
00333E  200000     MOV #0x0, W0
003340  370264     BRA __dunpack2exit
003342  B80060     MUL.UU W0, #0x0, W0
003344  370262     BRA __dunpack2exit
---  /home/xc16/release-builds/build_20230327/src/libm/src/fgtge.s  -------------------------------------
000CCE  2FFFF4     MOV #0xFFFF, W4
000CD0  370511     BRA __fcompare
---  /home/xc16/release-builds/build_20230327/src/libm/src/feqltle.s  -----------------------------------
000CCA  200014     MOV #0x1, W4
000CCC  370513     BRA __fcompare
---  /home/xc16/release-builds/build_20230327/src/libm/src/fcompare.s  ----------------------------------
0016F4  BE9F88     MOV.D W8, [W15++]
0016F6  BE9F8A     MOV.D W10, [W15++]
0016F8  781F84     MOV W4, [W15++]
0016FA  070017     RCALL __funpack2
0016FC  78004F     MOV [--W15], W0
0016FE  330011     BRA N, exit
001700  2FFFF0     MOV #0xFFFF, W0
001702  6C8F83     XOR W9, W3, [W15]
001704  3B0006     BRA NN, comparemag
001706  650504     AND W10, W4, W10
001708  A7000A     BTSC W10, #0
00170A  370008     BRA returnEqual
00170C  A6F009     BTSS W9, #15
00170E  200010     MOV #0x1, W0
001710  370008     BRA exit
001712  540F82     SUB W8, W2, [W15]
001714  5C8F83     SUBB W9, W3, [W15]
001716  390003     BRA NC, adjust
001718  200010     MOV #0x1, W0
00171A  3E0001     BRA GTU, adjust
00171C  200000     MOV #0x0, W0
00171E  A7F009     BTSC W9, #15
001720  EA0000     NEG W0, W0
001722  BE054F     MOV.D [--W15], W10
001724  BE044F     MOV.D [--W15], W8
001726  E00000     CP0 W0
001728  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/extendsfdf.s  --------------------------------
0032B0  780381     MOV W1, W7
0032B2  07EDB5     RCALL __funpack
0032B4  BE0100     MOV.D W0, W2
0032B6  B80060     MUL.UU W0, #0x0, W0
0032B8  A37804     BTST.Z W4, #7
0032BA  3A0013     BRA NZ, xIsNaN
0032BC  E12062     CP W4, #2
0032BE  3E0015     BRA GTU, xIsInf
0032C0  39000D     BRA NC, signoff
0032C2  D10183     LSR W3, W3
0032C4  D38102     RRC W2, W2
0032C6  D38081     RRC W1, W1
0032C8  D10183     LSR W3, W3
0032CA  D38102     RRC W2, W2
0032CC  D38081     RRC W1, W1
0032CE  D10183     LSR W3, W3
0032D0  D38102     RRC W2, W2
0032D2  D38081     RRC W1, W1
0032D4  B03805     ADD #0x380, W5
0032D6  DD2AC4     SL W5, #4, W5
0032D8  B200F3     AND #0xF, W3
0032DA  728183     IOR W5, W3, W3
0032DC  A7F007     BTSC W7, #15
0032DE  A0F003     BSET W3, #15
0032E0  060000     RETURN
0032E2  27FF83     MOV #0x7FF8, W3
0032E4  200002     MOV #0x0, W2
0032E6  B91061     MUL.SU W2, #0x1, W0
0032E8  37FFF9     BRA signoff
0032EA  27FF03     MOV #0x7FF0, W3
0032EC  37FFF7     BRA signoff
---  /home/xc16/release-builds/build_20230327/src/libm/src/dunpack2.s  ----------------------------------
0037E2  470468     ADD W14, #0x8, W8
0037E4  BE9402     MOV.D W2, [W8--]
0037E6  BE9400     MOV.D W0, [W8--]
0037E8  4704FC     ADD W14, #0x1C, W9
0037EA  BE9486     MOV.D W6, [W9--]
0037EC  BE9484     MOV.D W4, [W9--]
0037EE  780009     MOV W9, W0
0037F0  07FFD1     RCALL __dunpack
0037F2  780008     MOV W8, W0
0037F4  07FFCF     RCALL __dunpack
0037F6  780099     MOV [W9], W1
0037F8  704F81     IOR.B W0, W1, [W15]
0037FA  3B000B     BRA NN, exit
0037FC  BE0008     MOV.D W8, W0
0037FE  07000A     RCALL __dPropagateNaN
003800  B1004F     SUB #0x4, W15
003802  370003     BRA __dunpack2exit
003804  27FFF3     MOV #0x7FFF, W3
003806  2FFFF2     MOV #0xFFFF, W2
003808  B91061     MUL.SU W2, #0x1, W0
00380A  BE064F     MOV.D [--W15], W12
00380C  BE054F     MOV.D [--W15], W10
00380E  BE044F     MOV.D [--W15], W8
003810  FA8000     ULNK
003812  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/dunpack.s  -----------------------------------
003794  780080     MOV W0, W1
003796  BE0250     MOV.D [++W0], W4
003798  BE0350     MOV.D [++W0], W6
00379A  DE3944     LSR W7, #4, W2
00379C  B200F7     AND #0xF, W7
00379E  207FF3     MOV #0x7FF, W3
0037A0  610103     AND W2, W3, W2
0037A2  320009     BRA Z, zeroorsub
0037A4  E11802     CP W3, W2
0037A6  3A0016     BRA NZ, finitereturn
0037A8  720185     IOR W4, W5, W3
0037AA  730183     IOR W6, W3, W3
0037AC  738183     IOR W7, W3, W3
0037AE  200800     MOV #0x80, W0
0037B0  3A0015     BRA NZ, exit
0037B2  200040     MOV #0x4, W0
0037B4  370013     BRA exit
0037B6  720185     IOR W4, W5, W3
0037B8  730183     IOR W6, W3, W3
0037BA  738183     IOR W7, W3, W3
0037BC  3A0005     BRA NZ, subnormal
0037BE  BEA804     MOV.D W4, [++W0]
0037C0  BEA806     MOV.D W6, [++W0]
0037C2  200010     MOV #0x1, W0
0037C4  37000B     BRA exit
0037C6  E90102     DEC W2, W2
0037C8  420204     ADD W4, W4, W4
0037CA  4A8285     ADDC W5, W5, W5
0037CC  4B0306     ADDC W6, W6, W6
0037CE  4B8387     ADDC W7, W7, W7
0037D0  A34807     BTST.Z W7, #4
0037D2  32FFF9     BRA Z, normalize
0037D4  A04007     BSET W7, #4
0037D6  BEA804     MOV.D W4, [++W0]
0037D8  BEA806     MOV.D W6, [++W0]
0037DA  200020     MOV #0x2, W0
0037DC  980080     MOV W0, [W1+0]
0037DE  980092     MOV W2, [W1+2]
0037E0  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/dtype.s  -------------------------------------
0016D0  27FF05     MOV #0x7FF0, W5
0016D2  618205     AND W3, W5, W4
0016D4  320007     BRA Z, zeroorsub
0016D6  E12804     CP W5, W4
0016D8  320001     BRA Z, NaNorInf
0016DA  050024     RETLW #0x2, W4
0016DC  070006     RCALL checkfrac
0016DE  3A0001     BRA NZ, isNaN
0016E0  050044     RETLW #0x4, W4
0016E2  050804     RETLW #0x80, W4
0016E4  070002     RCALL checkfrac
0016E6  3AFFF9     BRA NZ, isFinite
0016E8  050014     RETLW #0x1, W4
0016EA  61826F     AND W3, #0xF, W4
0016EC  700281     IOR W0, W1, W5
0016EE  710285     IOR W2, W5, W5
0016F0  720285     IOR W4, W5, W5
0016F2  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/dpropagateNaN.s  -----------------------------
003814  4082E4     ADD W1, #0x4, W5
003816  A37810     BTST.Z [W0], #7
003818  320007     BRA Z, returnb
00381A  400264     ADD W0, #0x4, W4
00381C  A37811     BTST.Z [W1], #7
00381E  BE0034     MOV.D [W4++], W0
003820  BE0114     MOV.D [W4], W2
003822  320004     BRA Z, returnab
003824  A73003     BTSC W3, #3
003826  060000     RETURN
003828  BE0035     MOV.D [W5++], W0
00382A  BE0115     MOV.D [W5], W2
00382C  A03003     BSET W3, #3
00382E  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/divsi3.s  ------------------------------------
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
000004  000B9A     NOP
000006  000B2E     NOP
000008  000B4A     NOP
00000A  000BD2     NOP
00000C  000BB6     NOP
00000E  000920     NOP
000010  000B66     NOP
000012  00091A     NOP
000014  000920     NOP
000016  000920     NOP
000018  000920     NOP
00001A  000920     NOP
00001C  000920     NOP
---  /home/xc16/release-builds/build_20230327/src/libm/src/dgtge.s  -------------------------------------
000CC0  EB9F80     SETM [W15++]
000CC2  0704DD     RCALL __dcompare
000CC4  E9878F     DEC2 W15, W15
000CC6  E00000     CP0 W0
000CC8  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/deqltle.s  -----------------------------------
000CB6  D11F8F     LSR W15, [W15++]
000CB8  0704E2     RCALL __dcompare
000CBA  E9878F     DEC2 W15, W15
000CBC  E00000     CP0 W0
000CBE  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/dcompare.s  ----------------------------------
00167E  BE9F88     MOV.D W8, [W15++]
001680  BE9F8A     MOV.D W10, [W15++]
001682  BE9F8C     MOV.D W12, [W15++]
001684  BE0404     MOV.D W4, W8
001686  BE0506     MOV.D W6, W10
001688  BE9F80     MOV.D W0, [W15++]
00168A  BE9F82     MOV.D W2, [W15++]
00168C  070021     RCALL __dtype
00168E  780604     MOV W4, W12
001690  BE0008     MOV.D W8, W0
001692  BE010A     MOV.D W10, W2
001694  07001D     RCALL __dtype
001696  780684     MOV W4, W13
001698  BE034F     MOV.D [--W15], W6
00169A  BE024F     MOV.D [--W15], W4
00169C  764F8D     IOR.B W12, W13, [W15]
00169E  97B07F     MOV [W15-18], W0
0016A0  330013     BRA N, exit
0016A2  2FFFF0     MOV #0xFFFF, W0
0016A4  6B8F8B     XOR W7, W11, [W15]
0016A6  3B0006     BRA NN, comparemag
0016A8  66060D     AND W12, W13, W12
0016AA  A7000C     BTSC W12, #0
0016AC  37000A     BRA returnEqual
0016AE  A6F007     BTSS W7, #15
0016B0  200010     MOV #0x1, W0
0016B2  37000A     BRA exit
0016B4  520F88     SUB W4, W8, [W15]
0016B6  5A8F89     SUBB W5, W9, [W15]
0016B8  5B0F8A     SUBB W6, W10, [W15]
0016BA  5B8F8B     SUBB W7, W11, [W15]
0016BC  390003     BRA NC, adjust
0016BE  200010     MOV #0x1, W0
0016C0  3E0001     BRA GTU, adjust
0016C2  200000     MOV #0x0, W0
0016C4  A7F007     BTSC W7, #15
0016C6  EA0000     NEG W0, W0
0016C8  BE064F     MOV.D [--W15], W12
0016CA  BE054F     MOV.D [--W15], W10
0016CC  BE044F     MOV.D [--W15], W8
0016CE  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/fp_intrinsics/src/pic24/dpsubs.s  ---------------------
00366C  46068C     ADD W12, W12, W13
00366E  3A0002     BRA NZ, 0x3674
003670  A60000     BTSS W0, #0
003672  060000     RETURN
003674  480060     ADDC W0, #0x0, W0
003676  4880E0     ADDC W1, #0x0, W1
003678  490160     ADDC W2, #0x0, W2
00367A  4981E0     ADDC W3, #0x0, W3
00367C  A65003     BTSS W3, #5
00367E  060000     RETURN
003680  D10183     LSR W3, W3
003682  E80408     INC W8, W8
003684  060000     RETURN
003686  FD0200     EXCH W0, W4
003688  FD0281     EXCH W1, W5
00368A  FD0302     EXCH W2, W6
00368C  FD0383     EXCH W3, W7
00368E  FD0488     EXCH W8, W9
003690  FD058A     EXCH W10, W11
003692  060000     RETURN
003694  E14870     CP W9, #16
003696  39001A     BRA NC, 0x36CC
003698  20037D     MOV #0x37, W13
00369A  E1480D     CP W9, W13
00369C  39000A     BRA NC, 0x36B2
00369E  700581     IOR W0, W1, W11
0036A0  710683     IOR W2, W3, W13
0036A2  75858C     IOR W11, W12, W11
0036A4  75858D     IOR W11, W13, W11
0036A6  EB0600     CLR W12
0036A8  E7D81C     CPBEQ.W W11, W12, 0x36AC
0036AA  760661     IOR W12, #0x1, W12
0036AC  B80060     MUL.UU W0, #0x0, W0
0036AE  B81160     MUL.UU W2, #0x0, W2
0036B0  060000     RETURN
0036B2  E14870     CP W9, #16
0036B4  39000B     BRA NC, 0x36CC
0036B6  78058C     MOV W12, W11
0036B8  780600     MOV W0, W12
0036BA  780001     MOV W1, W0
0036BC  780082     MOV W2, W1
0036BE  780103     MOV W3, W2
0036C0  EB0180     CLR W3
0036C2  E7D813     CPBEQ.W W11, W3, 0x36C6
0036C4  760661     IOR W12, #0x1, W12
0036C6  5484F0     SUB W9, #0x10, W9
0036C8  3AFFF4     BRA NZ, 0x36B2
0036CA  060000     RETURN
0036CC  E16061     CP W12, #1
0036CE  AD480C     BSW.C W12, W9
0036D0  1485F0     SUBR W9, #0x10, W11
0036D2  DD068B     SL W0, W11, W13
0036D4  DE6609     LSR W12, W9, W12
0036D6  76060D     IOR W12, W13, W12
0036D8  DD0E8B     SL W1, W11, W13
0036DA  DE0009     LSR W0, W9, W0
0036DC  70000D     IOR W0, W13, W0
0036DE  DD168B     SL W2, W11, W13
0036E0  DE0889     LSR W1, W9, W1
0036E2  70808D     IOR W1, W13, W1
0036E4  DD1E8B     SL W3, W11, W13
0036E6  DE1109     LSR W2, W9, W2
0036E8  71010D     IOR W2, W13, W2
0036EA  DE1989     LSR W3, W9, W3
0036EC  060000     RETURN
0036EE  28000D     MOV #0x8000, W13
0036F0  207FFC     MOV #0x7FF, W12
0036F2  61850D     AND W3, W13, W10
0036F4  DE1C44     LSR W3, #4, W8
0036F6  6181EF     AND W3, #0xF, W3
0036F8  64040C     AND W8, W12, W8
0036FA  320001     BRA Z, 0x36FE
0036FC  A04003     BSET W3, #4
0036FE  63858D     AND W7, W13, W11
003700  DE3CC4     LSR W7, #4, W9
003702  6383EF     AND W7, #0xF, W7
003704  64848C     AND W9, W12, W9
003706  320001     BRA Z, 0x370A
003708  A04007     BSET W7, #4
00370A  E1400C     CP W8, W12
00370C  3A0006     BRA NZ, 0x371A
00370E  6186EF     AND W3, #0xF, W13
003710  768682     IOR W13, W2, W13
003712  768681     IOR W13, W1, W13
003714  768680     IOR W13, W0, W13
003716  320001     BRA Z, 0x371A
003718  370018     BRA 0x374A
00371A  E1480C     CP W9, W12
00371C  3A0007     BRA NZ, 0x372C
00371E  6386EF     AND W7, #0xF, W13
003720  768686     IOR W13, W6, W13
003722  768685     IOR W13, W5, W13
003724  768684     IOR W13, W4, W13
003726  320002     BRA Z, 0x372C
003728  07FFAE     RCALL __dxchg
00372A  37000F     BRA 0x374A
00372C  A34803     BTST.Z W3, #4
00372E  3A0005     BRA NZ, 0x373A
003730  700681     IOR W0, W1, W13
003732  768682     IOR W13, W2, W13
003734  768683     IOR W13, W3, W13
003736  320001     BRA Z, 0x373A
003738  E80408     INC W8, W8
00373A  A34807     BTST.Z W7, #4
00373C  3A0005     BRA NZ, 0x3748
00373E  720685     IOR W4, W5, W13
003740  768686     IOR W13, W6, W13
003742  768687     IOR W13, W7, W13
003744  320001     BRA Z, 0x3748
003746  E80489     INC W9, W9
003748  060000     RETURN
00374A  7804CF     MOV [--W15], W9
00374C  7805CF     MOV [--W15], W11
00374E  37001B     BRA __dpakex
003750  780200     MOV W0, W4
003752  780281     MOV W1, W5
003754  780302     MOV W2, W6
003756  780383     MOV W3, W7
003758  780488     MOV W8, W9
00375A  A7F00C     BTSC W12, #15
00375C  07FF87     RCALL drndne
00375E  207FFD     MOV #0x7FF, W13
003760  E1400D     CP W8, W13
003762  350004     BRA LT, 0x376C
003764  78040D     MOV W13, W8
003766  B80060     MUL.UU W0, #0x0, W0
003768  B81160     MUL.UU W2, #0x0, W2
00376A  37000D     BRA __dpakex
00376C  E00008     CP0 W8
00376E  3C000B     BRA GT, __dpakex
003770  780004     MOV W4, W0
003772  780085     MOV W5, W1
003774  780106     MOV W6, W2
003776  780187     MOV W7, W3
003778  1484E1     SUBR W9, #0x1, W9
00377A  07FF8C     RCALL __drshft
00377C  A7F00C     BTSC W12, #15
00377E  07FF76     RCALL drndne
003780  EB0400     CLR W8
003782  A74003     BTSC W3, #4
003784  E80408     INC W8, W8
003786  DD4444     SL W8, #4, W8
003788  61C56F     AND.B W3, #0xF, W10
00378A  750188     IOR W10, W8, W3
00378C  BE044F     MOV.D [--W15], W8
00378E  BE054F     MOV.D [--W15], W10
003790  BE064F     MOV.D [--W15], W12
003792  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/fp_intrinsics/src/pic24/dpmul.s  ----------------------
003552  BE9F8C     MOV.D W12, [W15++]
003554  BE9F8A     MOV.D W10, [W15++]
003556  BE9F88     MOV.D W8, [W15++]
003558  0700CA     RCALL __dupchk
00355A  6D050B     XOR W10, W11, W10
00355C  78058A     MOV W10, W11
00355E  E1400C     CP W8, W12
003560  3A0008     BRA NZ, 0x3572
003562  E00009     CP0 W9
003564  3A0082     BRA NZ, 0x366A
003566  A1F00A     BCLR W10, #15
003568  78040C     MOV W12, W8
00356A  2001F3     MOV #0x1F, W3
00356C  2FFFF2     MOV #0xFFFF, W2
00356E  B91061     MUL.SU W2, #0x1, W0
003570  37007C     BRA 0x366A
003572  E1480C     CP W9, W12
003574  3A0004     BRA NZ, 0x357E
003576  070087     RCALL __dxchg
003578  E00009     CP0 W9
00357A  3A0077     BRA NZ, 0x366A
00357C  37FFF4     BRA 0x3566
00357E  E00008     CP0 W8
003580  320074     BRA Z, 0x366A
003582  E00009     CP0 W9
003584  3A0002     BRA NZ, 0x358A
003586  07007F     RCALL __dxchg
003588  370070     BRA 0x366A
00358A  203FED     MOV #0x3FE, W13
00358C  54848D     SUB W9, W13, W9
00358E  440409     ADD W8, W9, W8
003590  781F8A     MOV W10, [W15++]
003592  781F88     MOV W8, [W15++]
003594  781F87     MOV W7, [W15++]
003596  781F86     MOV W6, [W15++]
003598  781F85     MOV W5, [W15++]
00359A  781F84     MOV W4, [W15++]
00359C  DD19CB     SL W3, #11, W3
00359E  DE15C5     LSR W2, #5, W11
0035A0  71858B     IOR W3, W11, W11
0035A2  DD114B     SL W2, #11, W2
0035A4  DE0D45     LSR W1, #5, W10
0035A6  71050A     IOR W2, W10, W10
0035A8  DD08CB     SL W1, #11, W1
0035AA  DE04C5     LSR W0, #5, W9
0035AC  708489     IOR W1, W9, W9
0035AE  DD044B     SL W0, #11, W8
0035B0  B84004     MUL.UU W8, W4, W0
0035B2  B84605     MUL.UU W8, W5, W12
0035B4  40808C     ADD W1, W12, W1
0035B6  4E8160     ADDC W13, #0x0, W2
0035B8  B84E04     MUL.UU W9, W4, W12
0035BA  40808C     ADD W1, W12, W1
0035BC  49010D     ADDC W2, W13, W2
0035BE  EB0180     CLR W3
0035C0  AD1803     BSW.C W3, W3
0035C2  B85604     MUL.UU W10, W4, W12
0035C4  41010C     ADD W2, W12, W2
0035C6  49818D     ADDC W3, W13, W3
0035C8  EB0200     CLR W4
0035CA  AD2004     BSW.C W4, W4
0035CC  B84606     MUL.UU W8, W6, W12
0035CE  41010C     ADD W2, W12, W2
0035D0  49818D     ADDC W3, W13, W3
0035D2  4A0260     ADDC W4, #0x0, W4
0035D4  B84E05     MUL.UU W9, W5, W12
0035D6  41010C     ADD W2, W12, W2
0035D8  49818D     ADDC W3, W13, W3
0035DA  4A0260     ADDC W4, #0x0, W4
0035DC  B85605     MUL.UU W10, W5, W12
0035DE  41818C     ADD W3, W12, W3
0035E0  4A020D     ADDC W4, W13, W4
0035E2  EB0280     CLR W5
0035E4  AD2805     BSW.C W5, W5
0035E6  B84607     MUL.UU W8, W7, W12
0035E8  41818C     ADD W3, W12, W3
0035EA  4A020D     ADDC W4, W13, W4
0035EC  4A82E0     ADDC W5, #0x0, W5
0035EE  B84E06     MUL.UU W9, W6, W12
0035F0  41818C     ADD W3, W12, W3
0035F2  4A020D     ADDC W4, W13, W4
0035F4  4A82E0     ADDC W5, #0x0, W5
0035F6  78064F     MOV [--W15], W12
0035F8  B85E0C     MUL.UU W11, W12, W12
0035FA  41818C     ADD W3, W12, W3
0035FC  4A020D     ADDC W4, W13, W4
0035FE  4A82E0     ADDC W5, #0x0, W5
003600  B85606     MUL.UU W10, W6, W12
003602  42020C     ADD W4, W12, W4
003604  4A828D     ADDC W5, W13, W5
003606  EB0300     CLR W6
003608  AD3006     BSW.C W6, W6
00360A  B84E07     MUL.UU W9, W7, W12
00360C  42020C     ADD W4, W12, W4
00360E  4A828D     ADDC W5, W13, W5
003610  4B0360     ADDC W6, #0x0, W6
003612  78064F     MOV [--W15], W12
003614  B85E0C     MUL.UU W11, W12, W12
003616  42020C     ADD W4, W12, W4
003618  4A828D     ADDC W5, W13, W5
00361A  4B0360     ADDC W6, #0x0, W6
00361C  B85607     MUL.UU W10, W7, W12
00361E  42828C     ADD W5, W12, W5
003620  4B030D     ADDC W6, W13, W6
003622  EB0380     CLR W7
003624  AD3807     BSW.C W7, W7
003626  78064F     MOV [--W15], W12
003628  B85E0C     MUL.UU W11, W12, W12
00362A  42828C     ADD W5, W12, W5
00362C  4B030D     ADDC W6, W13, W6
00362E  4B83E0     ADDC W7, #0x0, W7
003630  78064F     MOV [--W15], W12
003632  B85E0C     MUL.UU W11, W12, W12
003634  43030C     ADD W6, W12, W6
003636  4B838D     ADDC W7, W13, W7
003638  78044F     MOV [--W15], W8
00363A  78054F     MOV [--W15], W10
00363C  A34807     BTST.Z W7, #4
00363E  3A000A     BRA NZ, 0x3654
003640  400000     ADD W0, W0, W0
003642  488081     ADDC W1, W1, W1
003644  490102     ADDC W2, W2, W2
003646  498183     ADDC W3, W3, W3
003648  4A0204     ADDC W4, W4, W4
00364A  4A8285     ADDC W5, W5, W5
00364C  4B0306     ADDC W6, W6, W6
00364E  4B8387     ADDC W7, W7, W7
003650  E90408     DEC W8, W8
003652  37FFF4     BRA 0x363C
003654  780603     MOV W3, W12
003656  708080     IOR W1, W0, W1
003658  708082     IOR W1, W2, W1
00365A  320001     BRA Z, 0x365E
00365C  760661     IOR W12, #0x1, W12
00365E  780187     MOV W7, W3
003660  780106     MOV W6, W2
003662  780085     MOV W5, W1
003664  780004     MOV W4, W0
003666  780488     MOV W8, W9
003668  370078     BRA __dnsrnd
00366A  37008D     BRA __dpakex
---  /home/xc16/release-builds/build_20230327/src/fp_intrinsics/src/pic24/dpdiv.s  ----------------------
0033F4  BE9F8C     MOV.D W12, [W15++]
0033F6  BE9F8A     MOV.D W10, [W15++]
0033F8  BE9F88     MOV.D W8, [W15++]
0033FA  070179     RCALL __dupchk
0033FC  6D050B     XOR W10, W11, W10
0033FE  E14009     CP W8, W9
003400  3A000A     BRA NZ, 0x3416
003402  E00008     CP0 W8
003404  320002     BRA Z, 0x340A
003406  E1400C     CP W8, W12
003408  3A0006     BRA NZ, 0x3416
00340A  A1F00A     BCLR W10, #15
00340C  78040C     MOV W12, W8
00340E  2001F3     MOV #0x1F, W3
003410  2FFFF2     MOV #0xFFFF, W2
003412  B91061     MUL.SU W2, #0x1, W0
003414  37009D     BRA 0x3550
003416  E1400C     CP W8, W12
003418  32009B     BRA Z, 0x3550
00341A  E00008     CP0 W8
00341C  320099     BRA Z, 0x3550
00341E  E1480C     CP W9, W12
003420  3A0002     BRA NZ, 0x3426
003422  EB0400     CLR W8
003424  370003     BRA 0x342C
003426  E00009     CP0 W9
003428  3A0004     BRA NZ, 0x3432
00342A  78040C     MOV W12, W8
00342C  B80060     MUL.UU W0, #0x0, W0
00342E  B81160     MUL.UU W2, #0x0, W2
003430  37008F     BRA 0x3550
003432  A34803     BTST.Z W3, #4
003434  3A0006     BRA NZ, 0x3442
003436  400000     ADD W0, W0, W0
003438  488081     ADDC W1, W1, W1
00343A  490102     ADDC W2, W2, W2
00343C  498183     ADDC W3, W3, W3
00343E  E90408     DEC W8, W8
003440  37FFF8     BRA 0x3432
003442  A34807     BTST.Z W7, #4
003444  3A0006     BRA NZ, 0x3452
003446  420204     ADD W4, W4, W4
003448  4A8285     ADDC W5, W5, W5
00344A  4B0306     ADDC W6, W6, W6
00344C  4B8387     ADDC W7, W7, W7
00344E  E90489     DEC W9, W9
003450  37FFF8     BRA 0x3442
003452  203FFD     MOV #0x3FF, W13
003454  54848D     SUB W9, W13, W9
003456  540409     SUB W8, W9, W8
003458  781F8A     MOV W10, [W15++]
00345A  781F88     MOV W8, [W15++]
00345C  780400     MOV W0, W8
00345E  780481     MOV W1, W9
003460  780502     MOV W2, W10
003462  780583     MOV W3, W11
003464  B80060     MUL.UU W0, #0x0, W0
003466  B81160     MUL.UU W2, #0x0, W2
003468  20040D     MOV #0x40, W13
00346A  370005     BRA 0x3476
00346C  440408     ADD W8, W8, W8
00346E  4C8489     ADDC W9, W9, W9
003470  4D050A     ADDC W10, W10, W10
003472  4D858B     ADDC W11, W11, W11
003474  310008     BRA C, 0x3486
003476  540404     SUB W8, W4, W8
003478  5C8485     SUBB W9, W5, W9
00347A  5D0506     SUBB W10, W6, W10
00347C  5D8587     SUBB W11, W7, W11
00347E  D28183     RLC W3, W3
003480  D3068D     RRNC W13, W13
003482  3BFFF4     BRA NN, 0x346C
003484  370007     BRA 0x3494
003486  440404     ADD W8, W4, W8
003488  4C8485     ADDC W9, W5, W9
00348A  4D0506     ADDC W10, W6, W10
00348C  4D8587     ADDC W11, W7, W11
00348E  D28183     RLC W3, W3
003490  D3068D     RRNC W13, W13
003492  3BFFEC     BRA NN, 0x346C
003494  440408     ADD W8, W8, W8
003496  4C8489     ADDC W9, W9, W9
003498  4D050A     ADDC W10, W10, W10
00349A  4D858B     ADDC W11, W11, W11
00349C  310008     BRA C, 0x34AE
00349E  540404     SUB W8, W4, W8
0034A0  5C8485     SUBB W9, W5, W9
0034A2  5D0506     SUBB W10, W6, W10
0034A4  5D8587     SUBB W11, W7, W11
0034A6  D28102     RLC W2, W2
0034A8  D3068D     RRNC W13, W13
0034AA  3BFFF4     BRA NN, 0x3494
0034AC  370007     BRA 0x34BC
0034AE  440404     ADD W8, W4, W8
0034B0  4C8485     ADDC W9, W5, W9
0034B2  4D0506     ADDC W10, W6, W10
0034B4  4D8587     ADDC W11, W7, W11
0034B6  D28102     RLC W2, W2
0034B8  D3068D     RRNC W13, W13
0034BA  3BFFEC     BRA NN, 0x3494
0034BC  440408     ADD W8, W8, W8
0034BE  4C8489     ADDC W9, W9, W9
0034C0  4D050A     ADDC W10, W10, W10
0034C2  4D858B     ADDC W11, W11, W11
0034C4  310008     BRA C, 0x34D6
0034C6  540404     SUB W8, W4, W8
0034C8  5C8485     SUBB W9, W5, W9
0034CA  5D0506     SUBB W10, W6, W10
0034CC  5D8587     SUBB W11, W7, W11
0034CE  D28081     RLC W1, W1
0034D0  D3068D     RRNC W13, W13
0034D2  3BFFF4     BRA NN, 0x34BC
0034D4  370007     BRA 0x34E4
0034D6  440404     ADD W8, W4, W8
0034D8  4C8485     ADDC W9, W5, W9
0034DA  4D0506     ADDC W10, W6, W10
0034DC  4D8587     ADDC W11, W7, W11
0034DE  D28081     RLC W1, W1
0034E0  D3068D     RRNC W13, W13
0034E2  3BFFEC     BRA NN, 0x34BC
0034E4  440408     ADD W8, W8, W8
0034E6  4C8489     ADDC W9, W9, W9
0034E8  4D050A     ADDC W10, W10, W10
0034EA  4D858B     ADDC W11, W11, W11
0034EC  310008     BRA C, 0x34FE
0034EE  540404     SUB W8, W4, W8
0034F0  5C8485     SUBB W9, W5, W9
0034F2  5D0506     SUBB W10, W6, W10
0034F4  5D8587     SUBB W11, W7, W11
0034F6  D28000     RLC W0, W0
0034F8  D3068D     RRNC W13, W13
0034FA  3BFFF4     BRA NN, 0x34E4
0034FC  370007     BRA 0x350C
0034FE  440404     ADD W8, W4, W8
003500  4C8485     ADDC W9, W5, W9
003502  4D0506     ADDC W10, W6, W10
003504  4D8587     ADDC W11, W7, W11
003506  D28000     RLC W0, W0
003508  D3068D     RRNC W13, W13
00350A  3BFFEC     BRA NN, 0x34E4
00350C  E0000B     CP0 W11
00350E  3D0004     BRA GE, 0x3518
003510  440404     ADD W8, W4, W8
003512  4C8485     ADDC W9, W5, W9
003514  4D0506     ADDC W10, W6, W10
003516  4D8587     ADDC W11, W7, W11
003518  EB0600     CLR W12
00351A  D10183     LSR W3, W3
00351C  D38102     RRC W2, W2
00351E  D38081     RRC W1, W1
003520  D38000     RRC W0, W0
003522  D3860C     RRC W12, W12
003524  D10183     LSR W3, W3
003526  D38102     RRC W2, W2
003528  D38081     RRC W1, W1
00352A  D38000     RRC W0, W0
00352C  D3860C     RRC W12, W12
00352E  740489     IOR W8, W9, W9
003530  75058B     IOR W10, W11, W11
003532  74848B     IOR W9, W11, W9
003534  320001     BRA Z, 0x3538
003536  760661     IOR W12, #0x1, W12
003538  78044F     MOV [--W15], W8
00353A  78054F     MOV [--W15], W10
00353C  A34803     BTST.Z W3, #4
00353E  3A0007     BRA NZ, 0x354E
003540  46060C     ADD W12, W12, W12
003542  480000     ADDC W0, W0, W0
003544  488081     ADDC W1, W1, W1
003546  490102     ADDC W2, W2, W2
003548  498183     ADDC W3, W3, W3
00354A  E90408     DEC W8, W8
00354C  37FFF7     BRA 0x353C
00354E  370100     BRA __drndex
003550  37011A     BRA __dpakex
---  /home/xc16/release-builds/build_20230327/src/fp_intrinsics/src/pic24/dpadd.s  ----------------------
003352  BE9F8C     MOV.D W12, [W15++]
003354  BE9F8A     MOV.D W10, [W15++]
003356  BE9F88     MOV.D W8, [W15++]
003358  0701CA     RCALL __dupchk
00335A  A2F00B     BTG W11, #15
00335C  370004     BRA 0x3366
00335E  BE9F8C     MOV.D W12, [W15++]
003360  BE9F8A     MOV.D W10, [W15++]
003362  BE9F88     MOV.D W8, [W15++]
003364  0701C4     RCALL __dupchk
003366  E1480C     CP W9, W12
003368  3A000B     BRA NZ, 0x3380
00336A  E1400C     CP W8, W12
00336C  320002     BRA Z, 0x3372
00336E  07018B     RCALL __dxchg
003370  370040     BRA 0x33F2
003372  6D068B     XOR W10, W11, W13
003374  32003E     BRA Z, 0x33F2
003376  A1F00A     BCLR W10, #15
003378  2001F3     MOV #0x1F, W3
00337A  2FFFF2     MOV #0xFFFF, W2
00337C  B91061     MUL.SU W2, #0x1, W0
00337E  370039     BRA 0x33F2
003380  E1400C     CP W8, W12
003382  320037     BRA Z, 0x33F2
003384  E14009     CP W8, W9
003386  360001     BRA LEU, 0x338A
003388  07017E     RCALL __dxchg
00338A  6D858A     XOR W11, W10, W11
00338C  DE5DCF     LSR W11, #15, W11
00338E  75050B     IOR W10, W11, W10
003390  EB0600     CLR W12
003392  FD0488     EXCH W8, W9
003394  540489     SUB W8, W9, W9
003396  320001     BRA Z, 0x339A
003398  07017D     RCALL __drshft
00339A  E0040A     CP0.B W10
00339C  3A0011     BRA NZ, 0x33C0
00339E  E00008     CP0 W8
0033A0  320028     BRA Z, 0x33F2
0033A2  400004     ADD W0, W4, W0
0033A4  488085     ADDC W1, W5, W1
0033A6  490106     ADDC W2, W6, W2
0033A8  498187     ADDC W3, W7, W3
0033AA  A35803     BTST.Z W3, #5
0033AC  320018     BRA Z, 0x33DE
0033AE  D10183     LSR W3, W3
0033B0  D38102     RRC W2, W2
0033B2  D38081     RRC W1, W1
0033B4  D38000     RRC W0, W0
0033B6  D3860C     RRC W12, W12
0033B8  390001     BRA NC, 0x33BC
0033BA  760661     IOR W12, #0x1, W12
0033BC  E80408     INC W8, W8
0033BE  370018     BRA 0x33F0
0033C0  500004     SUB W0, W4, W0
0033C2  588085     SUBB W1, W5, W1
0033C4  590106     SUBB W2, W6, W2
0033C6  598187     SUBB W3, W7, W3
0033C8  310006     BRA C, 0x33D6
0033CA  A2F00A     BTG W10, #15
0033CC  EA060C     NEG W12, W12
0033CE  180060     SUBBR W0, #0x0, W0
0033D0  1880E0     SUBBR W1, #0x0, W1
0033D2  190160     SUBBR W2, #0x0, W2
0033D4  1981E0     SUBBR W3, #0x0, W3
0033D6  3A0003     BRA NZ, 0x33DE
0033D8  EB0400     CLR W8
0033DA  EB0500     CLR W10
0033DC  37000A     BRA 0x33F2
0033DE  A34803     BTST.Z W3, #4
0033E0  3A0007     BRA NZ, 0x33F0
0033E2  46060C     ADD W12, W12, W12
0033E4  480000     ADDC W0, W0, W0
0033E6  488081     ADDC W1, W1, W1
0033E8  490102     ADDC W2, W2, W2
0033EA  498183     ADDC W3, W3, W3
0033EC  E90408     DEC W8, W8
0033EE  37FFF7     BRA 0x33DE
0033F0  3701AF     BRA __drndex
0033F2  3701C9     BRA __dpakex
